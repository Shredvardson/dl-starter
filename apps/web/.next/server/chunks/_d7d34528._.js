module.exports = [
  65553,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEBUG_BUILD = 'undefined' == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__));
  },
  83247,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.GLOBAL_OBJ = globalThis));
  },
  32592,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.SDK_VERSION = '10.10.0'));
  },
  20434,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(32592),
      i = e.r(83247);
    function o(e) {
      let t = (e.__SENTRY__ = e.__SENTRY__ || {});
      return (
        (t.version = t.version || r.SDK_VERSION),
        (t[r.SDK_VERSION] = t[r.SDK_VERSION] || {})
      );
    }
    ((n.getGlobalSingleton = function (e, t, n = i.GLOBAL_OBJ) {
      let o = (n.__SENTRY__ = n.__SENTRY__ || {}),
        a = (o[r.SDK_VERSION] = o[r.SDK_VERSION] || {});
      return a[e] || (a[e] = t());
    }),
      (n.getMainCarrier = function () {
        return (o(i.GLOBAL_OBJ), i.GLOBAL_OBJ);
      }),
      (n.getSentryCarrier = o));
  },
  13500,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(20434),
      i = e.r(65553),
      o = e.r(83247),
      a = {};
    function s(e) {
      if (!('console' in o.GLOBAL_OBJ)) return e();
      let t = o.GLOBAL_OBJ.console,
        n = {},
        r = Object.keys(a);
      r.forEach((e) => {
        let r = a[e];
        ((n[e] = t[e]), (t[e] = r));
      });
      try {
        return e();
      } finally {
        r.forEach((e) => {
          t[e] = n[e];
        });
      }
    }
    function u() {
      return c().enabled;
    }
    function l(e, ...t) {
      i.DEBUG_BUILD &&
        u() &&
        s(() => {
          o.GLOBAL_OBJ.console[e](`Sentry Logger [${e}]:`, ...t);
        });
    }
    function c() {
      return i.DEBUG_BUILD
        ? r.getGlobalSingleton('loggerSettings', () => ({ enabled: !1 }))
        : { enabled: !1 };
    }
    ((n.CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace']),
      (n.consoleSandbox = s),
      (n.debug = {
        enable: function () {
          c().enabled = !0;
        },
        disable: function () {
          c().enabled = !1;
        },
        isEnabled: u,
        log: function (...e) {
          l('log', ...e);
        },
        warn: function (...e) {
          l('warn', ...e);
        },
        error: function (...e) {
          l('error', ...e);
        },
      }),
      (n.originalConsoleMethods = a));
  },
  87195,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = /\(error: (.*)\)/,
      i = /captureMessage|captureException/;
    function o(...e) {
      let t = e.sort((e, t) => e[0] - t[0]).map((e) => e[1]);
      return (e, n = 0, i = 0) => {
        let o = [],
          s = e.split('\n');
        for (let e = n; e < s.length; e++) {
          let n = s[e];
          n.length > 1024 && (n = n.slice(0, 1024));
          let a = r.test(n) ? n.replace(r, '$1') : n;
          if (!a.match(/\S*Error: /)) {
            for (let e of t) {
              let t = e(a);
              if (t) {
                o.push(t);
                break;
              }
            }
            if (o.length >= 50 + i) break;
          }
        }
        return a(o.slice(i));
      };
    }
    function a(e) {
      if (!e.length) return [];
      let t = Array.from(e);
      return (
        /sentryWrapped/.test(s(t).function || '') && t.pop(),
        t.reverse(),
        i.test(s(t).function || '') && (t.pop(), i.test(s(t).function || '') && t.pop()),
        t
          .slice(0, 50)
          .map((e) => ({
            ...e,
            filename: e.filename || s(t).filename,
            function: e.function || '?',
          }))
      );
    }
    function s(e) {
      return e[e.length - 1] || {};
    }
    let u = '<anonymous>';
    ((n.UNKNOWN_FUNCTION = '?'),
      (n.createStackParser = o),
      (n.getFramesFromEvent = function (e) {
        let t = e.exception;
        if (t) {
          let e = [];
          try {
            return (
              t.values.forEach((t) => {
                t.stacktrace.frames && e.push(...t.stacktrace.frames);
              }),
              e
            );
          } catch {}
        }
      }),
      (n.getFunctionName = function (e) {
        try {
          if (!e || 'function' != typeof e) return u;
          return e.name || u;
        } catch {
          return u;
        }
      }),
      (n.stackParserFromStackParserOptions = function (e) {
        return Array.isArray(e) ? o(...e) : e;
      }),
      (n.stripSentryFramesAndReverse = a));
  },
  32801,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(87195),
      a = {},
      s = {};
    ((n.addHandler = function (e, t) {
      ((a[e] = a[e] || []), a[e].push(t));
    }),
      (n.maybeInstrument = function (e, t) {
        if (!s[e]) {
          s[e] = !0;
          try {
            t();
          } catch (t) {
            r.DEBUG_BUILD && i.debug.error(`Error while instrumenting ${e}`, t);
          }
        }
      }),
      (n.resetInstrumentationHandlers = function () {
        Object.keys(a).forEach((e) => {
          a[e] = void 0;
        });
      }),
      (n.triggerHandlers = function (e, t) {
        let n = e && a[e];
        if (n)
          for (let a of n)
            try {
              a(t);
            } catch (t) {
              r.DEBUG_BUILD &&
                i.debug.error(
                  `Error while triggering instrumentation handler.
Type: ${e}
Name: ${o.getFunctionName(a)}
Error:`,
                  t
                );
            }
      }));
  },
  59937,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(83247),
      i = e.r(32801),
      o = null;
    function a() {
      ((o = r.GLOBAL_OBJ.onerror),
        (r.GLOBAL_OBJ.onerror = function (e, t, n, r, a) {
          return (
            i.triggerHandlers('error', { column: r, error: a, line: n, msg: e, url: t }),
            !!o && o.apply(this, arguments)
          );
        }),
        (r.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0));
    }
    n.addGlobalErrorInstrumentationHandler = function (e) {
      let t = 'error';
      (i.addHandler(t, e), i.maybeInstrument(t, a));
    };
  },
  15591,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(83247),
      i = e.r(32801),
      o = null;
    function a() {
      ((o = r.GLOBAL_OBJ.onunhandledrejection),
        (r.GLOBAL_OBJ.onunhandledrejection = function (e) {
          return (i.triggerHandlers('unhandledrejection', e), !o || o.apply(this, arguments));
        }),
        (r.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0));
    }
    n.addGlobalUnhandledRejectionInstrumentationHandler = function (e) {
      let t = 'unhandledrejection';
      (i.addHandler(t, e), i.maybeInstrument(t, a));
    };
  },
  2802,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = Object.prototype.toString;
    function i(e, t) {
      return r.call(e) === `[object ${t}]`;
    }
    function o(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        '__sentry_template_string__' in e &&
        '__sentry_template_values__' in e
      );
    }
    function a(e) {
      return i(e, 'Object');
    }
    function s(e, t) {
      try {
        return e instanceof t;
      } catch {
        return !1;
      }
    }
    ((n.isDOMError = function (e) {
      return i(e, 'DOMError');
    }),
      (n.isDOMException = function (e) {
        return i(e, 'DOMException');
      }),
      (n.isElement = function (e) {
        return 'undefined' != typeof Element && s(e, Element);
      }),
      (n.isError = function (e) {
        switch (r.call(e)) {
          case '[object Error]':
          case '[object Exception]':
          case '[object DOMException]':
          case '[object WebAssembly.Exception]':
            return !0;
          default:
            return s(e, Error);
        }
      }),
      (n.isErrorEvent = function (e) {
        return i(e, 'ErrorEvent');
      }),
      (n.isEvent = function (e) {
        return 'undefined' != typeof Event && s(e, Event);
      }),
      (n.isInstanceOf = s),
      (n.isParameterizedString = o),
      (n.isPlainObject = a),
      (n.isPrimitive = function (e) {
        return null === e || o(e) || ('object' != typeof e && 'function' != typeof e);
      }),
      (n.isRegExp = function (e) {
        return i(e, 'RegExp');
      }),
      (n.isRequest = function (e) {
        return 'undefined' != typeof Request && s(e, Request);
      }),
      (n.isString = function (e) {
        return i(e, 'String');
      }),
      (n.isSyntheticEvent = function (e) {
        return a(e) && 'nativeEvent' in e && 'preventDefault' in e && 'stopPropagation' in e;
      }),
      (n.isThenable = function (e) {
        return !!(e?.then && 'function' == typeof e.then);
      }),
      (n.isVueViewModel = function (e) {
        return !!('object' == typeof e && null !== e && (e.__isVue || e._isVue));
      }));
  },
  24211,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802),
      i = e.r(83247).GLOBAL_OBJ;
    ((n.getComponentName = function (e) {
      if (!i.HTMLElement) return null;
      let t = e;
      for (let e = 0; e < 5 && t; e++) {
        if (t instanceof HTMLElement) {
          if (t.dataset.sentryComponent) return t.dataset.sentryComponent;
          if (t.dataset.sentryElement) return t.dataset.sentryElement;
        }
        t = t.parentNode;
      }
      return null;
    }),
      (n.getLocationHref = function () {
        try {
          return i.document.location.href;
        } catch {
          return '';
        }
      }),
      (n.htmlTreeAsString = function (e, t = {}) {
        if (!e) return '<unknown>';
        try {
          let n,
            o = e,
            a = [],
            s = 0,
            u = 0,
            l = Array.isArray(t) ? t : t.keyAttrs,
            c = (!Array.isArray(t) && t.maxStringLength) || 80;
          for (
            ;
            o &&
            s++ < 5 &&
            ((n = (function (e, t) {
              let n = [];
              if (!e?.tagName) return '';
              if (i.HTMLElement && e instanceof HTMLElement && e.dataset) {
                if (e.dataset.sentryComponent) return e.dataset.sentryComponent;
                if (e.dataset.sentryElement) return e.dataset.sentryElement;
              }
              n.push(e.tagName.toLowerCase());
              let o = t?.length
                ? t.filter((t) => e.getAttribute(t)).map((t) => [t, e.getAttribute(t)])
                : null;
              if (o?.length)
                o.forEach((e) => {
                  n.push(`[${e[0]}="${e[1]}"]`);
                });
              else {
                e.id && n.push(`#${e.id}`);
                let t = e.className;
                if (t && r.isString(t)) for (let e of t.split(/\s+/)) n.push(`.${e}`);
              }
              for (let t of ['aria-label', 'type', 'name', 'title', 'alt']) {
                let r = e.getAttribute(t);
                r && n.push(`[${t}="${r}"]`);
              }
              return n.join('');
            })(o, l)),
            'html' !== n && (!(s > 1) || !(u + 3 * a.length + n.length >= c)));

          )
            (a.push(n), (u += n.length), (o = o.parentNode));
          return a.reverse().join(' > ');
        } catch {
          return '<unknown>';
        }
      }));
  },
  22111,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802);
    function i(e, t, n = !1) {
      return (
        !!r.isString(e) &&
        (r.isRegExp(t) ? t.test(e) : !!r.isString(t) && (n ? e === t : e.includes(t)))
      );
    }
    ((n.isMatchingPattern = i),
      (n.safeJoin = function (e, t) {
        if (!Array.isArray(e)) return '';
        let n = [];
        for (let t = 0; t < e.length; t++) {
          let i = e[t];
          try {
            r.isVueViewModel(i) ? n.push('[VueViewModel]') : n.push(String(i));
          } catch {
            n.push('[value cannot be serialized]');
          }
        }
        return n.join(t);
      }),
      (n.snipLine = function (e, t) {
        let n = e,
          r = n.length;
        if (r <= 150) return n;
        t > r && (t = r);
        let i = Math.max(t - 60, 0);
        i < 5 && (i = 0);
        let o = Math.min(i + 140, r);
        return (
          o > r - 5 && (o = r),
          o === r && (i = Math.max(o - 140, 0)),
          (n = n.slice(i, o)),
          i > 0 && (n = `'{snip} ${n}`),
          o < r && (n += ' {snip}'),
          n
        );
      }),
      (n.stringMatchesSomePattern = function (e, t = [], n = !1) {
        return t.some((t) => i(e, t, n));
      }),
      (n.truncate = function (e, t = 0) {
        return 'string' != typeof e || 0 === t || e.length <= t ? e : `${e.slice(0, t)}...`;
      }));
  },
  63236,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(24211),
      o = e.r(13500),
      a = e.r(2802),
      s = e.r(22111);
    function u(e, t, n) {
      try {
        Object.defineProperty(e, t, { value: n, writable: !0, configurable: !0 });
      } catch {
        r.DEBUG_BUILD && o.debug.log(`Failed to add non-enumerable property "${t}" to object`, e);
      }
    }
    function l(e, t) {
      try {
        let n = t.prototype || {};
        ((e.prototype = t.prototype = n), u(e, '__sentry_original__', t));
      } catch {}
    }
    function c(e) {
      if (a.isError(e)) return { message: e.message, name: e.name, stack: e.stack, ...p(e) };
      if (!a.isEvent(e)) return e;
      {
        let t = { type: e.type, target: d(e.target), currentTarget: d(e.currentTarget), ...p(e) };
        return (
          'undefined' != typeof CustomEvent &&
            a.isInstanceOf(e, CustomEvent) &&
            (t.detail = e.detail),
          t
        );
      }
    }
    function d(e) {
      try {
        return a.isElement(e) ? i.htmlTreeAsString(e) : Object.prototype.toString.call(e);
      } catch {
        return '<unknown>';
      }
    }
    function p(e) {
      if ('object' != typeof e || null === e) return {};
      {
        let t = {};
        for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
        return t;
      }
    }
    ((n.addNonEnumerableProperty = u),
      (n.convertToPlainObject = c),
      (n.dropUndefinedKeys = function (e) {
        return (function e(t, n) {
          if (null === t || 'object' != typeof t) return t;
          let r = n.get(t);
          if (void 0 !== r) return r;
          if (Array.isArray(t)) {
            let r = [];
            return (
              n.set(t, r),
              t.forEach((t) => {
                r.push(e(t, n));
              }),
              r
            );
          }
          if (
            (function (e) {
              let t = e.constructor;
              return t === Object || void 0 === t;
            })(t)
          ) {
            let r = {};
            return (
              n.set(t, r),
              Object.keys(t).forEach((i) => {
                let o = t[i];
                void 0 !== o && (r[i] = e(o, n));
              }),
              r
            );
          }
          return t;
        })(e, new Map());
      }),
      (n.extractExceptionKeysForMessage = function (e, t = 40) {
        let n = Object.keys(c(e));
        n.sort();
        let r = n[0];
        if (!r) return '[object has no keys]';
        if (r.length >= t) return s.truncate(r, t);
        for (let e = n.length; e > 0; e--) {
          let r = n.slice(0, e).join(', ');
          if (!(r.length > t)) {
            if (e === n.length) return r;
            return s.truncate(r, t);
          }
        }
        return '';
      }),
      (n.fill = function (e, t, n) {
        if (!(t in e)) return;
        let i = e[t];
        if ('function' != typeof i) return;
        let a = n(i);
        'function' == typeof a && l(a, i);
        try {
          e[t] = a;
        } catch {
          r.DEBUG_BUILD && o.debug.log(`Failed to replace method "${t}" in object`, e);
        }
      }),
      (n.getOriginalFunction = function (e) {
        return e.__sentry_original__;
      }),
      (n.markFunctionWrapped = l),
      (n.objectify = function (e) {
        let t;
        switch (!0) {
          case void 0 == e:
            t = new String(e);
            break;
          case 'symbol' == typeof e || 'bigint' == typeof e:
            t = Object(e);
            break;
          case a.isPrimitive(e):
            t = new e.constructor(e);
            break;
          default:
            t = e;
        }
        return t;
      }));
  },
  21919,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(63236),
      i = e.r(22111),
      o = e.r(83247);
    function a(e) {
      return e.exception?.values?.[0];
    }
    let s =
      /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    function u(e) {
      return parseInt(e || '', 10);
    }
    ((n.addContextToFrame = function (e, t, n = 5) {
      if (void 0 === t.lineno) return;
      let r = e.length,
        o = Math.max(Math.min(r - 1, t.lineno - 1), 0);
      t.pre_context = e.slice(Math.max(0, o - n), o).map((e) => i.snipLine(e, 0));
      let a = Math.min(r - 1, o);
      ((t.context_line = i.snipLine(e[a], t.colno || 0)),
        (t.post_context = e.slice(Math.min(o + 1, r), o + 1 + n).map((e) => i.snipLine(e, 0))));
    }),
      (n.addExceptionMechanism = function (e, t) {
        let n = a(e);
        if (!n) return;
        let r = n.mechanism;
        if (((n.mechanism = { type: 'generic', handled: !0, ...r, ...t }), t && 'data' in t)) {
          let e = { ...r?.data, ...t.data };
          n.mechanism.data = e;
        }
      }),
      (n.addExceptionTypeValue = function (e, t, n) {
        let r = (e.exception = e.exception || {}),
          i = (r.values = r.values || []),
          o = (i[0] = i[0] || {});
        (o.value || (o.value = t || ''), o.type || (o.type = n || 'Error'));
      }),
      (n.checkOrSetAlreadyCaught = function (e) {
        if (
          (function (e) {
            try {
              return e.__sentry_captured__;
            } catch {}
          })(e)
        )
          return !0;
        try {
          r.addNonEnumerableProperty(e, '__sentry_captured__', !0);
        } catch {}
        return !1;
      }),
      (n.getEventDescription = function (e) {
        let { message: t, event_id: n } = e;
        if (t) return t;
        let r = a(e);
        return r
          ? r.type && r.value
            ? `${r.type}: ${r.value}`
            : r.type || r.value || n || '<unknown>'
          : n || '<unknown>';
      }),
      (n.parseSemver = function (e) {
        let t = e.match(s) || [],
          n = u(t[1]),
          r = u(t[2]),
          i = u(t[3]);
        return {
          buildmetadata: t[5],
          major: isNaN(n) ? void 0 : n,
          minor: isNaN(r) ? void 0 : r,
          patch: isNaN(i) ? void 0 : i,
          prerelease: t[4],
        };
      }),
      (n.uuid4 = function (
        e = (function () {
          let e = o.GLOBAL_OBJ;
          return e.crypto || e.msCrypto;
        })()
      ) {
        let t = () => 16 * Math.random();
        try {
          if (e?.randomUUID) return e.randomUUID().replace(/-/g, '');
          e?.getRandomValues &&
            (t = () => {
              let t = new Uint8Array(1);
              return (e.getRandomValues(t), t[0]);
            });
        } catch {}
        return '10000000100040008000100000000000'.replace(/[018]/g, (e) =>
          (e ^ ((15 & t()) >> (e / 4))).toString(16)
        );
      }));
  },
  28685,
  (e, t, n) => {
    let r, i;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let o = e.r(83247);
    function a() {
      return Date.now() / 1e3;
    }
    ((n.browserPerformanceTimeOrigin = function () {
      return (
        i ||
          (i = (function () {
            let { performance: e } = o.GLOBAL_OBJ;
            if (!e?.now) return [void 0, 'none'];
            let t = e.now(),
              n = Date.now(),
              r = e.timeOrigin ? Math.abs(e.timeOrigin + t - n) : 36e5,
              i = e.timing?.navigationStart,
              a = 'number' == typeof i ? Math.abs(i + t - n) : 36e5;
            if (r < 36e5 || a < 36e5)
              if (r <= a) return [e.timeOrigin, 'timeOrigin'];
              else return [i, 'navigationStart'];
            return [n, 'dateNow'];
          })()),
        i[0]
      );
    }),
      (n.dateTimestampInSeconds = a),
      (n.timestampInSeconds = function () {
        return (
          r ??
          (r = (function () {
            let { performance: e } = o.GLOBAL_OBJ;
            if (!e?.now || !e.timeOrigin) return a;
            let t = e.timeOrigin;
            return () => (t + e.now()) / 1e3;
          })())
        )();
      }));
  },
  54596,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(21919),
      i = e.r(28685);
    function o(e, t = {}) {
      if (
        (t.user &&
          (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address),
          e.did || t.did || (e.did = t.user.id || t.user.email || t.user.username)),
        (e.timestamp = t.timestamp || i.timestampInSeconds()),
        t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism),
        t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
        t.sid && (e.sid = 32 === t.sid.length ? t.sid : r.uuid4()),
        void 0 !== t.init && (e.init = t.init),
        !e.did && t.did && (e.did = `${t.did}`),
        'number' == typeof t.started && (e.started = t.started),
        e.ignoreDuration)
      )
        e.duration = void 0;
      else if ('number' == typeof t.duration) e.duration = t.duration;
      else {
        let t = e.timestamp - e.started;
        e.duration = t >= 0 ? t : 0;
      }
      (t.release && (e.release = t.release),
        t.environment && (e.environment = t.environment),
        !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
        !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
        'number' == typeof t.errors && (e.errors = t.errors),
        t.status && (e.status = t.status));
    }
    ((n.closeSession = function (e, t) {
      let n = {};
      (t ? (n = { status: t }) : 'ok' === e.status && (n = { status: 'exited' }), o(e, n));
    }),
      (n.makeSession = function (e) {
        let t = i.timestampInSeconds(),
          n = {
            sid: r.uuid4(),
            init: !0,
            timestamp: t,
            started: t,
            duration: 0,
            status: 'ok',
            errors: 0,
            ignoreDuration: !1,
            toJSON: () => {
              var e;
              return (
                (e = n),
                {
                  sid: `${e.sid}`,
                  init: e.init,
                  started: new Date(1e3 * e.started).toISOString(),
                  timestamp: new Date(1e3 * e.timestamp).toISOString(),
                  status: e.status,
                  errors: e.errors,
                  did: 'number' == typeof e.did || 'string' == typeof e.did ? `${e.did}` : void 0,
                  duration: e.duration,
                  abnormal_mechanism: e.abnormal_mechanism,
                  attrs: {
                    release: e.release,
                    environment: e.environment,
                    ip_address: e.ipAddress,
                    user_agent: e.userAgent,
                  },
                }
              );
            },
          };
        return (e && o(n, e), n);
      }),
      (n.updateSession = o));
  },
  53182,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.merge = function e(t, n, r = 2) {
        if (!n || 'object' != typeof n || r <= 0) return n;
        if (t && 0 === Object.keys(n).length) return t;
        let i = { ...t };
        for (let t in n)
          Object.prototype.hasOwnProperty.call(n, t) && (i[t] = e(i[t], n[t], r - 1));
        return i;
      }));
  },
  99712,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(21919);
    ((n.generateSpanId = function () {
      return r.uuid4().substring(16);
    }),
      (n.generateTraceId = function () {
        return r.uuid4();
      }));
  },
  59814,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(63236),
      i = '_sentrySpan';
    ((n._getSpanForScope = function (e) {
      return e[i];
    }),
      (n._setSpanForScope = function (e, t) {
        t ? r.addNonEnumerableProperty(e, i, t) : delete e[i];
      }));
  },
  32515,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(54596),
      o = e.r(13500),
      a = e.r(2802),
      s = e.r(53182),
      u = e.r(21919),
      l = e.r(99712),
      c = e.r(59814),
      d = e.r(22111),
      p = e.r(28685);
    class _ {
      constructor() {
        ((this._notifyingListeners = !1),
          (this._scopeListeners = []),
          (this._eventProcessors = []),
          (this._breadcrumbs = []),
          (this._attachments = []),
          (this._user = {}),
          (this._tags = {}),
          (this._extra = {}),
          (this._contexts = {}),
          (this._sdkProcessingMetadata = {}),
          (this._propagationContext = { traceId: l.generateTraceId(), sampleRand: Math.random() }));
      }
      clone() {
        let e = new _();
        return (
          (e._breadcrumbs = [...this._breadcrumbs]),
          (e._tags = { ...this._tags }),
          (e._extra = { ...this._extra }),
          (e._contexts = { ...this._contexts }),
          this._contexts.flags &&
            (e._contexts.flags = { values: [...this._contexts.flags.values] }),
          (e._user = this._user),
          (e._level = this._level),
          (e._session = this._session),
          (e._transactionName = this._transactionName),
          (e._fingerprint = this._fingerprint),
          (e._eventProcessors = [...this._eventProcessors]),
          (e._attachments = [...this._attachments]),
          (e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
          (e._propagationContext = { ...this._propagationContext }),
          (e._client = this._client),
          (e._lastEventId = this._lastEventId),
          c._setSpanForScope(e, c._getSpanForScope(this)),
          e
        );
      }
      setClient(e) {
        this._client = e;
      }
      setLastEventId(e) {
        this._lastEventId = e;
      }
      getClient() {
        return this._client;
      }
      lastEventId() {
        return this._lastEventId;
      }
      addScopeListener(e) {
        this._scopeListeners.push(e);
      }
      addEventProcessor(e) {
        return (this._eventProcessors.push(e), this);
      }
      setUser(e) {
        return (
          (this._user = e || { email: void 0, id: void 0, ip_address: void 0, username: void 0 }),
          this._session && i.updateSession(this._session, { user: e }),
          this._notifyScopeListeners(),
          this
        );
      }
      getUser() {
        return this._user;
      }
      setTags(e) {
        return ((this._tags = { ...this._tags, ...e }), this._notifyScopeListeners(), this);
      }
      setTag(e, t) {
        return ((this._tags = { ...this._tags, [e]: t }), this._notifyScopeListeners(), this);
      }
      setExtras(e) {
        return ((this._extra = { ...this._extra, ...e }), this._notifyScopeListeners(), this);
      }
      setExtra(e, t) {
        return ((this._extra = { ...this._extra, [e]: t }), this._notifyScopeListeners(), this);
      }
      setFingerprint(e) {
        return ((this._fingerprint = e), this._notifyScopeListeners(), this);
      }
      setLevel(e) {
        return ((this._level = e), this._notifyScopeListeners(), this);
      }
      setTransactionName(e) {
        return ((this._transactionName = e), this._notifyScopeListeners(), this);
      }
      setContext(e, t) {
        return (
          null === t ? delete this._contexts[e] : (this._contexts[e] = t),
          this._notifyScopeListeners(),
          this
        );
      }
      setSession(e) {
        return (e ? (this._session = e) : delete this._session, this._notifyScopeListeners(), this);
      }
      getSession() {
        return this._session;
      }
      update(e) {
        if (!e) return this;
        let t = 'function' == typeof e ? e(this) : e,
          {
            tags: n,
            extra: r,
            user: i,
            contexts: o,
            level: s,
            fingerprint: u = [],
            propagationContext: l,
          } = (t instanceof _ ? t.getScopeData() : a.isPlainObject(t) ? e : void 0) || {};
        return (
          (this._tags = { ...this._tags, ...n }),
          (this._extra = { ...this._extra, ...r }),
          (this._contexts = { ...this._contexts, ...o }),
          i && Object.keys(i).length && (this._user = i),
          s && (this._level = s),
          u.length && (this._fingerprint = u),
          l && (this._propagationContext = l),
          this
        );
      }
      clear() {
        return (
          (this._breadcrumbs = []),
          (this._tags = {}),
          (this._extra = {}),
          (this._user = {}),
          (this._contexts = {}),
          (this._level = void 0),
          (this._transactionName = void 0),
          (this._fingerprint = void 0),
          (this._session = void 0),
          c._setSpanForScope(this, void 0),
          (this._attachments = []),
          this.setPropagationContext({ traceId: l.generateTraceId(), sampleRand: Math.random() }),
          this._notifyScopeListeners(),
          this
        );
      }
      addBreadcrumb(e, t) {
        let n = 'number' == typeof t ? t : 100;
        if (n <= 0) return this;
        let r = {
          timestamp: p.dateTimestampInSeconds(),
          ...e,
          message: e.message ? d.truncate(e.message, 2048) : e.message,
        };
        return (
          this._breadcrumbs.push(r),
          this._breadcrumbs.length > n &&
            ((this._breadcrumbs = this._breadcrumbs.slice(-n)),
            this._client?.recordDroppedEvent('buffer_overflow', 'log_item')),
          this._notifyScopeListeners(),
          this
        );
      }
      getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1];
      }
      clearBreadcrumbs() {
        return ((this._breadcrumbs = []), this._notifyScopeListeners(), this);
      }
      addAttachment(e) {
        return (this._attachments.push(e), this);
      }
      clearAttachments() {
        return ((this._attachments = []), this);
      }
      getScopeData() {
        return {
          breadcrumbs: this._breadcrumbs,
          attachments: this._attachments,
          contexts: this._contexts,
          tags: this._tags,
          extra: this._extra,
          user: this._user,
          level: this._level,
          fingerprint: this._fingerprint || [],
          eventProcessors: this._eventProcessors,
          propagationContext: this._propagationContext,
          sdkProcessingMetadata: this._sdkProcessingMetadata,
          transactionName: this._transactionName,
          span: c._getSpanForScope(this),
        };
      }
      setSDKProcessingMetadata(e) {
        return ((this._sdkProcessingMetadata = s.merge(this._sdkProcessingMetadata, e, 2)), this);
      }
      setPropagationContext(e) {
        return ((this._propagationContext = e), this);
      }
      getPropagationContext() {
        return this._propagationContext;
      }
      captureException(e, t) {
        let n = t?.event_id || u.uuid4();
        if (!this._client)
          return (
            r.DEBUG_BUILD &&
              o.debug.warn('No client configured on scope - will not capture exception!'),
            n
          );
        let i = Error('Sentry syntheticException');
        return (
          this._client.captureException(
            e,
            { originalException: e, syntheticException: i, ...t, event_id: n },
            this
          ),
          n
        );
      }
      captureMessage(e, t, n) {
        let i = n?.event_id || u.uuid4();
        if (!this._client)
          return (
            r.DEBUG_BUILD &&
              o.debug.warn('No client configured on scope - will not capture message!'),
            i
          );
        let a = Error(e);
        return (
          this._client.captureMessage(
            e,
            t,
            { originalException: e, syntheticException: a, ...n, event_id: i },
            this
          ),
          i
        );
      }
      captureEvent(e, t) {
        let n = t?.event_id || u.uuid4();
        return (
          this._client
            ? this._client.captureEvent(e, { ...t, event_id: n }, this)
            : r.DEBUG_BUILD &&
              o.debug.warn('No client configured on scope - will not capture event!'),
          n
        );
      }
      _notifyScopeListeners() {
        this._notifyingListeners ||
          ((this._notifyingListeners = !0),
          this._scopeListeners.forEach((e) => {
            e(this);
          }),
          (this._notifyingListeners = !1));
      }
    }
    n.Scope = _;
  },
  7716,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(20434),
      i = e.r(32515);
    ((n.getDefaultCurrentScope = function () {
      return r.getGlobalSingleton('defaultCurrentScope', () => new i.Scope());
    }),
      (n.getDefaultIsolationScope = function () {
        return r.getGlobalSingleton('defaultIsolationScope', () => new i.Scope());
      }));
  },
  56570,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(7716),
      i = e.r(32515),
      o = e.r(2802),
      a = e.r(20434);
    class s {
      constructor(e, t) {
        let n, r;
        ((n = e || new i.Scope()),
          (r = t || new i.Scope()),
          (this._stack = [{ scope: n }]),
          (this._isolationScope = r));
      }
      withScope(e) {
        let t,
          n = this._pushScope();
        try {
          t = e(n);
        } catch (e) {
          throw (this._popScope(), e);
        }
        return o.isThenable(t)
          ? t.then(
              (e) => (this._popScope(), e),
              (e) => {
                throw (this._popScope(), e);
              }
            )
          : (this._popScope(), t);
      }
      getClient() {
        return this.getStackTop().client;
      }
      getScope() {
        return this.getStackTop().scope;
      }
      getIsolationScope() {
        return this._isolationScope;
      }
      getStackTop() {
        return this._stack[this._stack.length - 1];
      }
      _pushScope() {
        let e = this.getScope().clone();
        return (this._stack.push({ client: this.getClient(), scope: e }), e);
      }
      _popScope() {
        return !(this._stack.length <= 1) && !!this._stack.pop();
      }
    }
    function u() {
      let e = a.getMainCarrier(),
        t = a.getSentryCarrier(e);
      return (t.stack = t.stack || new s(r.getDefaultCurrentScope(), r.getDefaultIsolationScope()));
    }
    function l(e) {
      return u().withScope(e);
    }
    function c(e, t) {
      let n = u();
      return n.withScope(() => ((n.getStackTop().scope = e), t(e)));
    }
    function d(e) {
      return u().withScope(() => e(u().getIsolationScope()));
    }
    ((n.AsyncContextStack = s),
      (n.getStackAsyncContextStrategy = function () {
        return {
          withIsolationScope: d,
          withScope: l,
          withSetScope: c,
          withSetIsolationScope: (e, t) => d(t),
          getCurrentScope: () => u().getScope(),
          getIsolationScope: () => u().getIsolationScope(),
        };
      }));
  },
  23196,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(20434),
      i = e.r(56570);
    ((n.getAsyncContextStrategy = function (e) {
      let t = r.getSentryCarrier(e);
      return t.acs ? t.acs : i.getStackAsyncContextStrategy();
    }),
      (n.setAsyncContextStrategy = function (e) {
        let t = r.getMainCarrier();
        r.getSentryCarrier(t).acs = e;
      }));
  },
  6336,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23196),
      i = e.r(20434),
      o = e.r(32515),
      a = e.r(99712);
    function s() {
      let e = i.getMainCarrier();
      return r.getAsyncContextStrategy(e).getCurrentScope();
    }
    ((n.getClient = function () {
      return s().getClient();
    }),
      (n.getCurrentScope = s),
      (n.getGlobalScope = function () {
        return i.getGlobalSingleton('globalScope', () => new o.Scope());
      }),
      (n.getIsolationScope = function () {
        let e = i.getMainCarrier();
        return r.getAsyncContextStrategy(e).getIsolationScope();
      }),
      (n.getTraceContextFromScope = function (e) {
        let { traceId: t, parentSpanId: n, propagationSpanId: r } = e.getPropagationContext(),
          i = { trace_id: t, span_id: r || a.generateSpanId() };
        return (n && (i.parent_span_id = n), i);
      }),
      (n.withIsolationScope = function (...e) {
        let t = i.getMainCarrier(),
          n = r.getAsyncContextStrategy(t);
        if (2 === e.length) {
          let [t, r] = e;
          return t ? n.withSetIsolationScope(t, r) : n.withIsolationScope(r);
        }
        return n.withIsolationScope(e[0]);
      }),
      (n.withScope = function (...e) {
        let t = i.getMainCarrier(),
          n = r.getAsyncContextStrategy(t);
        if (2 === e.length) {
          let [t, r] = e;
          return t ? n.withSetScope(t, r) : n.withScope(r);
        }
        return n.withScope(e[0]);
      }));
  },
  13801,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit'),
      (n.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size'),
      (n.SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key'),
      (n.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time'),
      (n.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method'),
      (n.SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE =
        'sentry.previous_trace_sample_rate'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate'),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source'),
      (n.SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full'),
      (n.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type'));
  },
  72517,
  (e, t, n) => {
    function r(e) {
      if (e < 400 && e >= 100) return { code: 1 };
      if (e >= 400 && e < 500)
        switch (e) {
          case 401:
            return { code: 2, message: 'unauthenticated' };
          case 403:
            return { code: 2, message: 'permission_denied' };
          case 404:
            return { code: 2, message: 'not_found' };
          case 409:
            return { code: 2, message: 'already_exists' };
          case 413:
            return { code: 2, message: 'failed_precondition' };
          case 429:
            return { code: 2, message: 'resource_exhausted' };
          case 499:
            return { code: 2, message: 'cancelled' };
          default:
            return { code: 2, message: 'invalid_argument' };
        }
      if (e >= 500 && e < 600)
        switch (e) {
          case 501:
            return { code: 2, message: 'unimplemented' };
          case 503:
            return { code: 2, message: 'unavailable' };
          case 504:
            return { code: 2, message: 'deadline_exceeded' };
          default:
            return { code: 2, message: 'internal_error' };
        }
      return { code: 2, message: 'unknown_error' };
    }
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.SPAN_STATUS_ERROR = 2),
      (n.SPAN_STATUS_OK = 1),
      (n.SPAN_STATUS_UNSET = 0),
      (n.getSpanStatusFromHttpCode = r),
      (n.setHttpStatus = function (e, t) {
        e.setAttribute('http.response.status_code', t);
        let n = r(t);
        'unknown_error' !== n.message && e.setStatus(n);
      }));
  },
  82335,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(63236),
      i = '_sentryScope',
      o = '_sentryIsolationScope';
    ((n.getCapturedScopesOnSpan = function (e) {
      return { scope: e[i], isolationScope: e[o] };
    }),
      (n.setCapturedScopesOnSpan = function (e, t, n) {
        e && (r.addNonEnumerableProperty(e, o, n), r.addNonEnumerableProperty(e, i, t));
      }));
  },
  8612,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(2802),
      a = 'sentry-',
      s = /^sentry-/;
    function u(e) {
      if (e && (o.isString(e) || Array.isArray(e)))
        return Array.isArray(e)
          ? e.reduce(
              (e, t) => (
                Object.entries(l(t)).forEach(([t, n]) => {
                  e[t] = n;
                }),
                e
              ),
              {}
            )
          : l(e);
    }
    function l(e) {
      return e
        .split(',')
        .map((e) =>
          e.split('=').map((e) => {
            try {
              return decodeURIComponent(e.trim());
            } catch {
              return;
            }
          })
        )
        .reduce((e, [t, n]) => (t && n && (e[t] = n), e), {});
    }
    function c(e) {
      if (0 !== Object.keys(e).length)
        return Object.entries(e).reduce((e, [t, n], o) => {
          let a = `${encodeURIComponent(t)}=${encodeURIComponent(n)}`,
            s = 0 === o ? a : `${e},${a}`;
          return s.length > 8192
            ? (r.DEBUG_BUILD &&
                i.debug.warn(
                  `Not adding key: ${t} with val: ${n} to baggage header due to exceeding baggage size limits.`
                ),
              e)
            : s;
        }, '');
    }
    ((n.MAX_BAGGAGE_STRING_LENGTH = 8192),
      (n.SENTRY_BAGGAGE_KEY_PREFIX = a),
      (n.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = s),
      (n.baggageHeaderToDynamicSamplingContext = function (e) {
        let t = u(e);
        if (!t) return;
        let n = Object.entries(t).reduce(
          (e, [t, n]) => (t.match(s) && (e[t.slice(a.length)] = n), e),
          {}
        );
        return Object.keys(n).length > 0 ? n : void 0;
      }),
      (n.dynamicSamplingContextToSentryBaggageHeader = function (e) {
        if (e) return c(Object.entries(e).reduce((e, [t, n]) => (n && (e[`${a}${t}`] = n), e), {}));
      }),
      (n.objectToBaggageHeader = c),
      (n.parseBaggageHeader = u));
  },
  87033,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = /^o(\d+)\./,
      a = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    function s(e) {
      let t = a.exec(e);
      if (!t)
        return void i.consoleSandbox(() => {
          console.error(`Invalid Sentry Dsn: ${e}`);
        });
      let [n, r, o = '', s = '', l = '', c = ''] = t.slice(1),
        d = '',
        p = c,
        _ = p.split('/');
      if ((_.length > 1 && ((d = _.slice(0, -1).join('/')), (p = _.pop())), p)) {
        let e = p.match(/^\d+/);
        e && (p = e[0]);
      }
      return u({ host: s, pass: o, path: d, projectId: p, port: l, protocol: n, publicKey: r });
    }
    function u(e) {
      return {
        protocol: e.protocol,
        publicKey: e.publicKey || '',
        pass: e.pass || '',
        host: e.host,
        port: e.port || '',
        path: e.path || '',
        projectId: e.projectId,
      };
    }
    function l(e) {
      let t = e.match(o);
      return t?.[1];
    }
    ((n.dsnFromString = s),
      (n.dsnToString = function (e, t = !1) {
        let { host: n, path: r, pass: i, port: o, projectId: a, protocol: s, publicKey: u } = e;
        return `${s}://${u}${t && i ? `:${i}` : ''}@${n}${o ? `:${o}` : ''}/${r ? `${r}/` : r}${a}`;
      }),
      (n.extractOrgIdFromClient = function (e) {
        let t,
          n = e.getOptions(),
          { host: r } = e.getDsn() || {};
        return (n.orgId ? (t = String(n.orgId)) : r && (t = l(r)), t);
      }),
      (n.extractOrgIdFromDsnHost = l),
      (n.makeDsn = function (e) {
        let t = 'string' == typeof e ? s(e) : u(e);
        if (
          t &&
          (function (e) {
            if (!r.DEBUG_BUILD) return !0;
            let { port: t, projectId: n, protocol: o } = e;
            return (
              !['protocol', 'publicKey', 'host', 'projectId'].find(
                (t) => !e[t] && (i.debug.error(`Invalid Sentry Dsn: ${t} missing`), !0)
              ) &&
              (n.match(/^\d+$/)
                ? 'http' !== o && 'https' !== o
                  ? (i.debug.error(`Invalid Sentry Dsn: Invalid protocol ${o}`), !1)
                  : !(t && isNaN(parseInt(t, 10))) ||
                    (i.debug.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1)
                : (i.debug.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1))
            );
          })(t)
        )
          return t;
      }));
  },
  45018,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.parseSampleRate = function (e) {
        if ('boolean' == typeof e) return Number(e);
        let t = 'string' == typeof e ? parseFloat(e) : e;
        if (!('number' != typeof t || isNaN(t)) && !(t < 0) && !(t > 1)) return t;
      }));
  },
  26270,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13500),
      i = e.r(8612),
      o = e.r(87033),
      a = e.r(45018),
      s = e.r(99712),
      u = RegExp('^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$');
    function l(e) {
      let t;
      if (!e) return;
      let n = e.match(u);
      if (n)
        return (
          '1' === n[3] ? (t = !0) : '0' === n[3] && (t = !1),
          { traceId: n[1], parentSampled: t, parentSpanId: n[2] }
        );
    }
    ((n.TRACEPARENT_REGEXP = u),
      (n.extractTraceparentData = l),
      (n.generateSentryTraceHeader = function (e = s.generateTraceId(), t = s.generateSpanId(), n) {
        let r = '';
        return (void 0 !== n && (r = n ? '-1' : '-0'), `${e}-${t}${r}`);
      }),
      (n.propagationContextFromHeaders = function (e, t) {
        let n = l(e),
          r = i.baggageHeaderToDynamicSamplingContext(t);
        if (!n?.traceId) return { traceId: s.generateTraceId(), sampleRand: Math.random() };
        let o = (function (e, t) {
          let n = a.parseSampleRate(t?.sample_rand);
          if (void 0 !== n) return n;
          let r = a.parseSampleRate(t?.sample_rate);
          return r && e?.parentSampled !== void 0
            ? e.parentSampled
              ? Math.random() * r
              : r + Math.random() * (1 - r)
            : Math.random();
        })(n, r);
        r && (r.sample_rand = o.toString());
        let { traceId: u, parentSpanId: c, parentSampled: d } = n;
        return { traceId: u, parentSpanId: c, sampled: d, dsc: r || {}, sampleRand: o };
      }),
      (n.shouldContinueTrace = function (e, t) {
        let n = o.extractOrgIdFromClient(e);
        return t && n && t !== n
          ? (r.debug.log(
              `Won't continue trace because org IDs don't match (incoming baggage: ${t}, SDK options: ${n})`
            ),
            !1)
          : !e.getOptions().strictTraceContinuation ||
              ((!t || !!n) && (!!t || !n)) ||
              (r.debug.log(
                `Starting a new trace because strict trace continuation is enabled but one org ID is missing (incoming baggage: ${t}, Sentry client: ${n})`
              ),
              !1);
      }));
  },
  24205,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23196),
      i = e.r(20434),
      o = e.r(6336),
      a = e.r(13801),
      s = e.r(72517),
      u = e.r(82335),
      l = e.r(63236),
      c = e.r(99712),
      d = e.r(28685),
      p = e.r(26270),
      _ = e.r(13500),
      S = e.r(59814),
      E = !1;
    function T(e) {
      return e && e.length > 0
        ? e.map(({ context: { spanId: e, traceId: t, traceFlags: n, ...r }, attributes: i }) => ({
            span_id: e,
            trace_id: t,
            sampled: 1 === n,
            attributes: i,
            ...r,
          }))
        : void 0;
    }
    function m(e) {
      return 'number' == typeof e
        ? g(e)
        : Array.isArray(e)
          ? e[0] + e[1] / 1e9
          : e instanceof Date
            ? g(e.getTime())
            : d.timestampInSeconds();
    }
    function g(e) {
      return e > 0x2540be3ff ? e / 1e3 : e;
    }
    function f(e) {
      var t;
      if ('function' == typeof e.getSpanJSON) return e.getSpanJSON();
      let { spanId: n, traceId: r } = e.spanContext();
      if ((t = e).attributes && t.startTime && t.name && t.endTime && t.status) {
        let { attributes: t, startTime: i, name: o, endTime: s, status: u, links: l } = e;
        return {
          span_id: n,
          trace_id: r,
          data: t,
          description: o,
          parent_span_id:
            'parentSpanId' in e
              ? e.parentSpanId
              : 'parentSpanContext' in e
                ? e.parentSpanContext?.spanId
                : void 0,
          start_timestamp: m(i),
          timestamp: m(s) || void 0,
          status: A(u),
          op: t[a.SEMANTIC_ATTRIBUTE_SENTRY_OP],
          origin: t[a.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
          links: T(l),
        };
      }
      return { span_id: n, trace_id: r, start_timestamp: 0, data: {} };
    }
    function h(e) {
      let { traceFlags: t } = e.spanContext();
      return 1 === t;
    }
    function A(e) {
      if (e && e.code !== s.SPAN_STATUS_UNSET)
        return e.code === s.SPAN_STATUS_OK ? 'ok' : e.message || 'unknown_error';
    }
    let R = '_sentryChildSpans',
      y = '_sentryRootSpan';
    ((n.TRACE_FLAG_NONE = 0),
      (n.TRACE_FLAG_SAMPLED = 1),
      (n.addChildSpanToSpan = function (e, t) {
        let n = e[y] || e;
        (l.addNonEnumerableProperty(t, y, n),
          e[R] ? e[R].add(t) : l.addNonEnumerableProperty(e, R, new Set([t])));
      }),
      (n.convertSpanLinksForEnvelope = T),
      (n.getActiveSpan = function () {
        let e = i.getMainCarrier(),
          t = r.getAsyncContextStrategy(e);
        return t.getActiveSpan ? t.getActiveSpan() : S._getSpanForScope(o.getCurrentScope());
      }),
      (n.getRootSpan = function (e) {
        return e[y] || e;
      }),
      (n.getSpanDescendants = function (e) {
        let t = new Set();
        return (
          !(function e(n) {
            if (!t.has(n) && h(n)) for (let r of (t.add(n), n[R] ? Array.from(n[R]) : [])) e(r);
          })(e),
          Array.from(t)
        );
      }),
      (n.getStatusMessage = A),
      (n.removeChildSpanFromSpan = function (e, t) {
        e[R] && e[R].delete(t);
      }),
      (n.showSpanDropWarning = function () {
        E ||
          (_.consoleSandbox(() => {
            console.warn(
              '[Sentry] Returning null from `beforeSendSpan` is disallowed. To drop certain spans, configure the respective integrations directly.'
            );
          }),
          (E = !0));
      }),
      (n.spanIsSampled = h),
      (n.spanTimeInputToSeconds = m),
      (n.spanToJSON = f),
      (n.spanToTraceContext = function (e) {
        let { spanId: t, traceId: n, isRemote: r } = e.spanContext(),
          i = r ? t : f(e).parent_span_id,
          o = u.getCapturedScopesOnSpan(e).scope;
        return {
          parent_span_id: i,
          span_id: r ? o?.getPropagationContext().propagationSpanId || c.generateSpanId() : t,
          trace_id: n,
        };
      }),
      (n.spanToTraceHeader = function (e) {
        let { traceId: t, spanId: n } = e.spanContext(),
          r = h(e);
        return p.generateSentryTraceHeader(t, n, r);
      }),
      (n.spanToTransactionTraceContext = function (e) {
        let { spanId: t, traceId: n } = e.spanContext(),
          { data: r, op: i, parent_span_id: o, status: a, origin: s, links: u } = f(e);
        return {
          parent_span_id: o,
          span_id: t,
          trace_id: n,
          data: r,
          op: i,
          status: a,
          origin: s,
          links: u,
        };
      }),
      (n.updateSpanName = function (e, t) {
        (e.updateName(t),
          e.setAttributes({
            [a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',
            [a.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME]: t,
          }));
      }));
  },
  91630,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(59937),
      o = e.r(15591),
      a = e.r(13500),
      s = e.r(24205),
      u = e.r(72517),
      l = !1;
    n.registerSpanErrorInstrumentation = function () {
      l ||
        ((e.tag = 'sentry_tracingErrorCallback'),
        (l = !0),
        i.addGlobalErrorInstrumentationHandler(e),
        o.addGlobalUnhandledRejectionInstrumentationHandler(e));
      function e() {
        let e = s.getActiveSpan(),
          t = e && s.getRootSpan(e);
        if (t) {
          let e = 'internal_error';
          (r.DEBUG_BUILD && a.debug.log(`[Tracing] Root span: ${e} -> Global error occurred`),
            t.setStatus({ code: u.SPAN_STATUS_ERROR, message: e }));
        }
      }
    };
  },
  9338,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336);
    n.hasSpansEnabled = function (e) {
      if ('boolean' == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) return !1;
      let t = e || r.getClient()?.getOptions();
      return !!t && (null != t.tracesSampleRate || !!t.tracesSampler);
    };
  },
  23363,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEFAULT_ENVIRONMENT = 'production'));
  },
  22599,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23363),
      i = e.r(6336),
      o = e.r(13801),
      a = e.r(8612),
      s = e.r(87033),
      u = e.r(9338),
      l = e.r(63236),
      c = e.r(24205),
      d = e.r(82335),
      p = '_frozenDsc';
    function _(e, t) {
      let n = t.getOptions(),
        { publicKey: i } = t.getDsn() || {},
        o = {
          environment: n.environment || r.DEFAULT_ENVIRONMENT,
          release: n.release,
          public_key: i,
          trace_id: e,
          org_id: s.extractOrgIdFromClient(t),
        };
      return (t.emit('createDsc', o), o);
    }
    function S(e) {
      let t = i.getClient();
      if (!t) return {};
      let n = c.getRootSpan(e),
        r = c.spanToJSON(n),
        s = r.data,
        l = n.spanContext().traceState,
        S =
          l?.get('sentry.sample_rate') ??
          s[o.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ??
          s[o.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE];
      function E(e) {
        return (('number' == typeof S || 'string' == typeof S) && (e.sample_rate = `${S}`), e);
      }
      let T = n[p];
      if (T) return E(T);
      let m = l?.get('sentry.dsc'),
        g = m && a.baggageHeaderToDynamicSamplingContext(m);
      if (g) return E(g);
      let f = _(e.spanContext().traceId, t),
        h = s[o.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
        A = r.description;
      return (
        'url' !== h && A && (f.transaction = A),
        u.hasSpansEnabled() &&
          ((f.sampled = String(c.spanIsSampled(n))),
          (f.sample_rand =
            l?.get('sentry.sample_rand') ??
            d.getCapturedScopesOnSpan(n).scope?.getPropagationContext().sampleRand.toString())),
        E(f),
        t.emit('createDsc', f, n),
        f
      );
    }
    ((n.freezeDscOnSpan = function (e, t) {
      l.addNonEnumerableProperty(e, p, t);
    }),
      (n.getDynamicSamplingContextFromClient = _),
      (n.getDynamicSamplingContextFromScope = function (e, t) {
        let n = t.getPropagationContext();
        return n.dsc || _(n.traceId, e);
      }),
      (n.getDynamicSamplingContextFromSpan = S),
      (n.spanToBaggageHeader = function (e) {
        let t = S(e);
        return a.dynamicSamplingContextToSentryBaggageHeader(t);
      }));
  },
  29946,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(99712),
      i = e.r(24205);
    n.SentryNonRecordingSpan = class {
      constructor(e = {}) {
        ((this._traceId = e.traceId || r.generateTraceId()),
          (this._spanId = e.spanId || r.generateSpanId()));
      }
      spanContext() {
        return { spanId: this._spanId, traceId: this._traceId, traceFlags: i.TRACE_FLAG_NONE };
      }
      end(e) {}
      setAttribute(e, t) {
        return this;
      }
      setAttributes(e) {
        return this;
      }
      setStatus(e) {
        return this;
      }
      updateName(e) {
        return this;
      }
      isRecording() {
        return !1;
      }
      addEvent(e, t, n) {
        return this;
      }
      addLink(e) {
        return this;
      }
      addLinks(e) {
        return this;
      }
      recordException(e, t) {}
    };
  },
  97548,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802),
      i = e.r(63236),
      o = e.r(87195);
    function a(t, n = 100, s = Infinity) {
      try {
        return (function t(
          n,
          a,
          s = Infinity,
          u = Infinity,
          l = (function () {
            let e = new WeakSet();
            return [
              function (t) {
                return !!e.has(t) || (e.add(t), !1);
              },
              function (t) {
                e.delete(t);
              },
            ];
          })()
        ) {
          let [c, d] = l;
          if (
            null == a ||
            ['boolean', 'string'].includes(typeof a) ||
            ('number' == typeof a && Number.isFinite(a))
          )
            return a;
          let p = (function (t, n) {
            try {
              if ('domain' === t && n && 'object' == typeof n && n._events) return '[Domain]';
              if ('domainEmitter' === t) return '[DomainEmitter]';
              if (n === e.g) return '[Global]';
              if ('undefined' != typeof document && n === document) return '[Document]';
              if (r.isVueViewModel(n)) return '[VueViewModel]';
              if (r.isSyntheticEvent(n)) return '[SyntheticEvent]';
              if ('number' == typeof n && !Number.isFinite(n)) return `[${n}]`;
              if ('function' == typeof n) return `[Function: ${o.getFunctionName(n)}]`;
              if ('symbol' == typeof n) return `[${String(n)}]`;
              if ('bigint' == typeof n) return `[BigInt: ${String(n)}]`;
              let i = (function (e) {
                let t = Object.getPrototypeOf(e);
                return t?.constructor ? t.constructor.name : 'null prototype';
              })(n);
              if (/^HTML(\w*)Element$/.test(i)) return `[HTMLElement: ${i}]`;
              return `[object ${i}]`;
            } catch (e) {
              return `**non-serializable** (${e})`;
            }
          })(n, a);
          if (!p.startsWith('[object ')) return p;
          if (a.__sentry_skip_normalization__) return a;
          let _ =
            'number' == typeof a.__sentry_override_normalization_depth__
              ? a.__sentry_override_normalization_depth__
              : s;
          if (0 === _) return p.replace('object ', '');
          if (c(a)) return '[Circular ~]';
          if (a && 'function' == typeof a.toJSON)
            try {
              let e = a.toJSON();
              return t('', e, _ - 1, u, l);
            } catch {}
          let S = Array.isArray(a) ? [] : {},
            E = 0,
            T = i.convertToPlainObject(a);
          for (let e in T) {
            if (!Object.prototype.hasOwnProperty.call(T, e)) continue;
            if (E >= u) {
              S[e] = '[MaxProperties ~]';
              break;
            }
            let n = T[e];
            ((S[e] = t(e, n, _ - 1, u, l)), E++);
          }
          return (d(a), S);
        })('', t, n, s);
      } catch (e) {
        return { ERROR: `**non-serializable** (${e})` };
      }
    }
    ((n.normalize = a),
      (n.normalizeToSize = function e(t, n = 3, r = 102400) {
        let i = a(t, n);
        return ~-encodeURI(JSON.stringify(i)).split(/%..|./).length > r ? e(t, n - 1, r) : i;
      }),
      (n.normalizeUrlToBase = function (e, t) {
        let n = t.replace(/\\/g, '/').replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'),
          r = e;
        try {
          r = decodeURI(e);
        } catch {}
        return r
          .replace(/\\/g, '/')
          .replace(/webpack:\/?/g, '')
          .replace(RegExp(`(file://)?/*${n}/*`, 'ig'), 'app:///');
      }));
  },
  46274,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(20434),
      i = e.r(87033),
      o = e.r(97548),
      a = e.r(83247);
    function s(e, t) {
      for (let n of e[1]) {
        let e = n[0].type;
        if (t(n, e)) return !0;
      }
      return !1;
    }
    function u(e) {
      let t = r.getSentryCarrier(a.GLOBAL_OBJ);
      return t.encodePolyfill ? t.encodePolyfill(e) : new TextEncoder().encode(e);
    }
    let l = {
      session: 'session',
      sessions: 'session',
      attachment: 'attachment',
      transaction: 'transaction',
      event: 'error',
      client_report: 'internal',
      user_report: 'default',
      profile: 'profile',
      profile_chunk: 'profile',
      replay_event: 'replay',
      replay_recording: 'replay',
      check_in: 'monitor',
      feedback: 'feedback',
      span: 'span',
      raw_security: 'security',
      log: 'log_item',
    };
    ((n.addItemToEnvelope = function (e, t) {
      let [n, r] = e;
      return [n, [...r, t]];
    }),
      (n.createAttachmentEnvelopeItem = function (e) {
        let t = 'string' == typeof e.data ? u(e.data) : e.data;
        return [
          {
            type: 'attachment',
            length: t.length,
            filename: e.filename,
            content_type: e.contentType,
            attachment_type: e.attachmentType,
          },
          t,
        ];
      }),
      (n.createEnvelope = function (e, t = []) {
        return [e, t];
      }),
      (n.createEventEnvelopeHeaders = function (e, t, n, r) {
        let o = e.sdkProcessingMetadata?.dynamicSamplingContext;
        return {
          event_id: e.event_id,
          sent_at: new Date().toISOString(),
          ...(t && { sdk: t }),
          ...(!!n && r && { dsn: i.dsnToString(r) }),
          ...(o && { trace: o }),
        };
      }),
      (n.createSpanEnvelopeItem = function (e) {
        return [{ type: 'span' }, e];
      }),
      (n.envelopeContainsItemType = function (e, t) {
        return s(e, (e, n) => t.includes(n));
      }),
      (n.envelopeItemTypeToDataCategory = function (e) {
        return l[e];
      }),
      (n.forEachEnvelopeItem = s),
      (n.getSdkMetadataForEnvelopeHeader = function (e) {
        if (!e?.sdk) return;
        let { name: t, version: n } = e.sdk;
        return { name: t, version: n };
      }),
      (n.parseEnvelope = function (e) {
        let t = 'string' == typeof e ? u(e) : e;
        function n(e) {
          let n = t.subarray(0, e);
          return ((t = t.subarray(e + 1)), n);
        }
        function i() {
          let e = t.indexOf(10);
          return (
            e < 0 && (e = t.length),
            JSON.parse(
              (function (e) {
                let t = r.getSentryCarrier(a.GLOBAL_OBJ);
                return t.decodePolyfill ? t.decodePolyfill(e) : new TextDecoder().decode(e);
              })(n(e))
            )
          );
        }
        let o = i(),
          s = [];
        for (; t.length; ) {
          let e = i(),
            t = 'number' == typeof e.length ? e.length : void 0;
          s.push([e, t ? n(t) : i()]);
        }
        return [o, s];
      }),
      (n.serializeEnvelope = function (e) {
        let [t, n] = e,
          r = JSON.stringify(t);
        function i(e) {
          'string' == typeof r
            ? (r = 'string' == typeof e ? r + e : [u(r), e])
            : r.push('string' == typeof e ? u(e) : e);
        }
        for (let e of n) {
          let [t, n] = e;
          if (
            (i(`
${JSON.stringify(t)}
`),
            'string' == typeof n || n instanceof Uint8Array)
          )
            i(n);
          else {
            let e;
            try {
              e = JSON.stringify(n);
            } catch {
              e = JSON.stringify(o.normalize(n));
            }
            i(e);
          }
        }
        return 'string' == typeof r
          ? r
          : (function (e) {
              let t = new Uint8Array(e.reduce((e, t) => e + t.length, 0)),
                n = 0;
              for (let r of e) (t.set(r, n), (n += r.length));
              return t;
            })(r);
      }));
  },
  78719,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(22111);
    ((n.reparentChildSpans = function (e, t) {
      let n = t.parent_span_id,
        r = t.span_id;
      if (n) for (let t of e) t.parent_span_id === r && (t.parent_span_id = n);
    }),
      (n.shouldIgnoreSpan = function (e, t) {
        if (!t?.length || !e.description) return !1;
        for (let i of t) {
          var n;
          if ('string' == typeof (n = i) || n instanceof RegExp) {
            if (r.isMatchingPattern(e.description, i)) return !0;
            continue;
          }
          if (!i.name && !i.op) continue;
          let t = !i.name || r.isMatchingPattern(e.description, i.name),
            o = !i.op || (e.op && r.isMatchingPattern(e.op, i.op));
          if (t && o) return !0;
        }
        return !1;
      }));
  },
  66400,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(22599),
      i = e.r(87033),
      o = e.r(46274),
      a = e.r(78719),
      s = e.r(24205);
    function u(e, t) {
      if (!t) return e;
      let n = e.sdk || {};
      return (
        (e.sdk = {
          ...n,
          name: n.name || t.name,
          version: n.version || t.version,
          integrations: [...(e.sdk?.integrations || []), ...(t.integrations || [])],
          packages: [...(e.sdk?.packages || []), ...(t.packages || [])],
          settings: e.sdk?.settings || t.settings ? { ...e.sdk?.settings, ...t.settings } : void 0,
        }),
        e
      );
    }
    ((n._enhanceEventWithSdkInfo = u),
      (n.createEventEnvelope = function (e, t, n, r) {
        let i = o.getSdkMetadataForEnvelopeHeader(n),
          a = e.type && 'replay_event' !== e.type ? e.type : 'event';
        u(e, n?.sdk);
        let s = o.createEventEnvelopeHeaders(e, i, r, t);
        delete e.sdkProcessingMetadata;
        let l = [{ type: a }, e];
        return o.createEnvelope(s, [l]);
      }),
      (n.createSessionEnvelope = function (e, t, n, r) {
        let a = o.getSdkMetadataForEnvelopeHeader(n),
          s = {
            sent_at: new Date().toISOString(),
            ...(a && { sdk: a }),
            ...(!!r && t && { dsn: i.dsnToString(t) }),
          },
          u = 'aggregates' in e ? [{ type: 'sessions' }, e] : [{ type: 'session' }, e.toJSON()];
        return o.createEnvelope(s, [u]);
      }),
      (n.createSpanEnvelope = function (e, t) {
        let n = r.getDynamicSamplingContextFromSpan(e[0]),
          u = t?.getDsn(),
          l = t?.getOptions().tunnel,
          c = {
            sent_at: new Date().toISOString(),
            ...(!!n.trace_id && !!n.public_key && { trace: n }),
            ...(!!l && u && { dsn: i.dsnToString(u) }),
          },
          { beforeSendSpan: d, ignoreSpans: p } = t?.getOptions() || {},
          _ = p?.length ? e.filter((e) => !a.shouldIgnoreSpan(s.spanToJSON(e), p)) : e,
          S = e.length - _.length;
        S && t?.recordDroppedEvent('before_send', 'span', S);
        let E = d
            ? (e) => {
                let t = s.spanToJSON(e),
                  n = d(t);
                return n || (s.showSpanDropWarning(), t);
              }
            : s.spanToJSON,
          T = [];
        for (let e of _) {
          let t = E(e);
          t && T.push(o.createSpanEnvelopeItem(t));
        }
        return o.createEnvelope(c, T);
      }));
  },
  1769,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(24205);
    ((n.logSpanEnd = function (e) {
      if (!r.DEBUG_BUILD) return;
      let { description: t = '< unknown name >', op: n = '< unknown op >' } = o.spanToJSON(e),
        { spanId: a } = e.spanContext(),
        s = o.getRootSpan(e) === e,
        u = `[Tracing] Finishing "${n}" ${s ? 'root ' : ''}span "${t}" with ID ${a}`;
      i.debug.log(u);
    }),
      (n.logSpanStart = function (e) {
        if (!r.DEBUG_BUILD) return;
        let {
            description: t = '< unknown name >',
            op: n = '< unknown op >',
            parent_span_id: a,
          } = o.spanToJSON(e),
          { spanId: s } = e.spanContext(),
          u = o.spanIsSampled(e),
          l = o.getRootSpan(e),
          c = l === e,
          d = `[Tracing] Starting ${u ? 'sampled' : 'unsampled'} ${c ? 'root ' : ''}span`,
          p = [`op: ${n}`, `name: ${t}`, `ID: ${s}`];
        if ((a && p.push(`parent ID: ${a}`), !c)) {
          let { op: e, description: t } = o.spanToJSON(l);
          (p.push(`root ID: ${l.spanContext().spanId}`),
            e && p.push(`root op: ${e}`),
            t && p.push(`root description: ${t}`));
        }
        i.debug.log(`${d}
  ${p.join('\n  ')}`);
      }));
  },
  22353,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13801),
      o = e.r(13500),
      a = e.r(24205);
    ((n.setMeasurement = function (e, t, n, s = a.getActiveSpan()) {
      let u = s && a.getRootSpan(s);
      u &&
        (r.DEBUG_BUILD &&
          o.debug.log(`[Measurement] Setting measurement on root span: ${e} = ${t} ${n}`),
        u.addEvent(e, {
          [i.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE]: t,
          [i.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT]: n,
        }));
    }),
      (n.timedEventsToMeasurements = function (e) {
        if (!e || 0 === e.length) return;
        let t = {};
        return (
          e.forEach((e) => {
            let n = e.attributes || {},
              r = n[i.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT],
              o = n[i.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE];
            'string' == typeof r && 'number' == typeof o && (t[e.name] = { value: o, unit: r });
          }),
          t
        );
      }));
  },
  75803,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(66400),
      a = e.r(13801),
      s = e.r(13500),
      u = e.r(99712),
      l = e.r(24205),
      c = e.r(28685),
      d = e.r(22599),
      p = e.r(1769),
      _ = e.r(22353),
      S = e.r(82335);
    class E {
      constructor(e = {}) {
        ((this._traceId = e.traceId || u.generateTraceId()),
          (this._spanId = e.spanId || u.generateSpanId()),
          (this._startTime = e.startTimestamp || c.timestampInSeconds()),
          (this._links = e.links),
          (this._attributes = {}),
          this.setAttributes({
            [a.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'manual',
            [a.SEMANTIC_ATTRIBUTE_SENTRY_OP]: e.op,
            ...e.attributes,
          }),
          (this._name = e.name),
          e.parentSpanId && (this._parentSpanId = e.parentSpanId),
          'sampled' in e && (this._sampled = e.sampled),
          e.endTimestamp && (this._endTime = e.endTimestamp),
          (this._events = []),
          (this._isStandaloneSpan = e.isStandalone),
          this._endTime && this._onSpanEnded());
      }
      addLink(e) {
        return (this._links ? this._links.push(e) : (this._links = [e]), this);
      }
      addLinks(e) {
        return (this._links ? this._links.push(...e) : (this._links = e), this);
      }
      recordException(e, t) {}
      spanContext() {
        let { _spanId: e, _traceId: t, _sampled: n } = this;
        return { spanId: e, traceId: t, traceFlags: n ? l.TRACE_FLAG_SAMPLED : l.TRACE_FLAG_NONE };
      }
      setAttribute(e, t) {
        return (void 0 === t ? delete this._attributes[e] : (this._attributes[e] = t), this);
      }
      setAttributes(e) {
        return (Object.keys(e).forEach((t) => this.setAttribute(t, e[t])), this);
      }
      updateStartTime(e) {
        this._startTime = l.spanTimeInputToSeconds(e);
      }
      setStatus(e) {
        return ((this._status = e), this);
      }
      updateName(e) {
        return (
          (this._name = e),
          this.setAttribute(a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'custom'),
          this
        );
      }
      end(e) {
        this._endTime ||
          ((this._endTime = l.spanTimeInputToSeconds(e)), p.logSpanEnd(this), this._onSpanEnded());
      }
      getSpanJSON() {
        return {
          data: this._attributes,
          description: this._name,
          op: this._attributes[a.SEMANTIC_ATTRIBUTE_SENTRY_OP],
          parent_span_id: this._parentSpanId,
          span_id: this._spanId,
          start_timestamp: this._startTime,
          status: l.getStatusMessage(this._status),
          timestamp: this._endTime,
          trace_id: this._traceId,
          origin: this._attributes[a.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
          profile_id: this._attributes[a.SEMANTIC_ATTRIBUTE_PROFILE_ID],
          exclusive_time: this._attributes[a.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
          measurements: _.timedEventsToMeasurements(this._events),
          is_segment: (this._isStandaloneSpan && l.getRootSpan(this) === this) || void 0,
          segment_id: this._isStandaloneSpan ? l.getRootSpan(this).spanContext().spanId : void 0,
          links: l.convertSpanLinksForEnvelope(this._links),
        };
      }
      isRecording() {
        return !this._endTime && !!this._sampled;
      }
      addEvent(e, t, n) {
        i.DEBUG_BUILD && s.debug.log('[Tracing] Adding an event to span:', e);
        let r = T(t) ? t : n || c.timestampInSeconds(),
          o = T(t) ? {} : t || {},
          a = { name: e, time: l.spanTimeInputToSeconds(r), attributes: o };
        return (this._events.push(a), this);
      }
      isStandaloneSpan() {
        return !!this._isStandaloneSpan;
      }
      _onSpanEnded() {
        let e = r.getClient();
        if (
          (e && e.emit('spanEnd', this), !(this._isStandaloneSpan || this === l.getRootSpan(this)))
        )
          return;
        if (this._isStandaloneSpan)
          return void (this._sampled
            ? (function (e) {
                let t = r.getClient();
                if (!t) return;
                let n = e[1];
                if (!n || 0 === n.length) return t.recordDroppedEvent('before_send', 'span');
                t.sendEnvelope(e);
              })(o.createSpanEnvelope([this], e))
            : (i.DEBUG_BUILD &&
                s.debug.log(
                  '[Tracing] Discarding standalone span because its trace was not chosen to be sampled.'
                ),
              e && e.recordDroppedEvent('sample_rate', 'span')));
        let t = this._convertSpanToTransaction();
        t && (S.getCapturedScopesOnSpan(this).scope || r.getCurrentScope()).captureEvent(t);
      }
      _convertSpanToTransaction() {
        if (!m(l.spanToJSON(this))) return;
        this._name ||
          (i.DEBUG_BUILD &&
            s.debug.warn('Transaction has no name, falling back to `<unlabeled transaction>`.'),
          (this._name = '<unlabeled transaction>'));
        let { scope: e, isolationScope: t } = S.getCapturedScopesOnSpan(this),
          n = e?.getScopeData().sdkProcessingMetadata?.normalizedRequest;
        if (!0 !== this._sampled) return;
        let r = l
            .getSpanDescendants(this)
            .filter((e) => {
              var t;
              return e !== this && !((t = e) instanceof E && t.isStandaloneSpan());
            })
            .map((e) => l.spanToJSON(e))
            .filter(m),
          o = this._attributes[a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
        (delete this._attributes[a.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME],
          r.forEach((e) => {
            delete e.data[a.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
          }));
        let u = {
            contexts: { trace: l.spanToTransactionTraceContext(this) },
            spans:
              r.length > 1e3
                ? r.sort((e, t) => e.start_timestamp - t.start_timestamp).slice(0, 1e3)
                : r,
            start_timestamp: this._startTime,
            timestamp: this._endTime,
            transaction: this._name,
            type: 'transaction',
            sdkProcessingMetadata: {
              capturedSpanScope: e,
              capturedSpanIsolationScope: t,
              dynamicSamplingContext: d.getDynamicSamplingContextFromSpan(this),
            },
            request: n,
            ...(o && { transaction_info: { source: o } }),
          },
          c = _.timedEventsToMeasurements(this._events);
        return (
          c &&
            Object.keys(c).length &&
            (i.DEBUG_BUILD &&
              s.debug.log(
                '[Measurements] Adding measurements to transaction event',
                JSON.stringify(c, void 0, 2)
              ),
            (u.measurements = c)),
          u
        );
      }
    }
    function T(e) {
      return (e && 'number' == typeof e) || e instanceof Date || Array.isArray(e);
    }
    function m(e) {
      return !!e.start_timestamp && !!e.timestamp && !!e.span_id && !!e.trace_id;
    }
    n.SentrySpan = E;
  },
  30307,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802);
    n.handleCallbackErrors = function (e, t, n = () => {}) {
      var i, o, a;
      let s;
      try {
        s = e();
      } catch (e) {
        throw (t(e), n(), e);
      }
      return (
        (i = s),
        (o = t),
        (a = n),
        r.isThenable(i)
          ? i.then(
              (e) => (a(), e),
              (e) => {
                throw (o(e), a(), e);
              }
            )
          : (a(), i)
      );
    };
  },
  57785,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(9338),
      a = e.r(45018);
    n.sampleSpan = function (e, t, n) {
      let s, u;
      if (!o.hasSpansEnabled(e)) return [!1];
      'function' == typeof e.tracesSampler
        ? ((s = e.tracesSampler({
            ...t,
            inheritOrSampleWith: (e) =>
              'number' == typeof t.parentSampleRate
                ? t.parentSampleRate
                : 'boolean' == typeof t.parentSampled
                  ? Number(t.parentSampled)
                  : e,
          })),
          (u = !0))
        : void 0 !== t.parentSampled
          ? (s = t.parentSampled)
          : void 0 !== e.tracesSampleRate && ((s = e.tracesSampleRate), (u = !0));
      let l = a.parseSampleRate(s);
      if (void 0 === l)
        return (
          r.DEBUG_BUILD &&
            i.debug.warn(
              `[Tracing] Discarding root span because of invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(s)} of type ${JSON.stringify(typeof s)}.`
            ),
          [!1]
        );
      if (!l)
        return (
          r.DEBUG_BUILD &&
            i.debug.log(
              `[Tracing] Discarding transaction because ${'function' == typeof e.tracesSampler ? 'tracesSampler returned 0 or false' : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'}`
            ),
          [!1, l, u]
        );
      let c = n < l;
      return (
        !c &&
          r.DEBUG_BUILD &&
          i.debug.log(
            `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(s)})`
          ),
        [c, l, u]
      );
    };
  },
  66744,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23196),
      i = e.r(20434),
      o = e.r(6336),
      a = e.r(65553),
      s = e.r(13801),
      u = e.r(8612),
      l = e.r(13500),
      c = e.r(30307),
      d = e.r(9338),
      p = e.r(45018),
      _ = e.r(99712),
      S = e.r(59814),
      E = e.r(24205),
      T = e.r(26270),
      m = e.r(22599),
      g = e.r(1769),
      f = e.r(57785),
      h = e.r(29946),
      A = e.r(75803),
      R = e.r(72517),
      y = e.r(82335),
      I = '__SENTRY_SUPPRESS_TRACING__';
    function b(e, t) {
      let n = C();
      return n.withActiveSpan
        ? n.withActiveSpan(e, t)
        : o.withScope((n) => (S._setSpanForScope(n, e || void 0), t(n)));
    }
    function N(e) {
      return o.withScope(
        (t) => (
          t.setPropagationContext({ traceId: _.generateTraceId(), sampleRand: Math.random() }),
          a.DEBUG_BUILD &&
            l.debug.log(`Starting a new trace with id ${t.getPropagationContext().traceId}`),
          b(null, e)
        )
      );
    }
    function O({ parentSpan: e, spanArguments: t, forceTransaction: n, scope: r }) {
      let i;
      if (!d.hasSpansEnabled()) {
        let r = new h.SentryNonRecordingSpan();
        if (n || !e) {
          let e = {
            sampled: 'false',
            sample_rate: '0',
            transaction: t.name,
            ...m.getDynamicSamplingContextFromSpan(r),
          };
          m.freezeDscOnSpan(r, e);
        }
        return r;
      }
      let a = o.getIsolationScope();
      if (e && !n)
        ((i = (function (e, t, n) {
          let { spanId: r, traceId: i } = e.spanContext(),
            a = !t.getScopeData().sdkProcessingMetadata[I] && E.spanIsSampled(e),
            s = a
              ? new A.SentrySpan({ ...n, parentSpanId: r, traceId: i, sampled: a })
              : new h.SentryNonRecordingSpan({ traceId: i });
          E.addChildSpanToSpan(e, s);
          let u = o.getClient();
          return (u && (u.emit('spanStart', s), n.endTimestamp && u.emit('spanEnd', s)), s);
        })(e, r, t)),
          E.addChildSpanToSpan(e, i));
      else if (e) {
        let n = m.getDynamicSamplingContextFromSpan(e),
          { traceId: o, spanId: a } = e.spanContext(),
          s = E.spanIsSampled(e);
        ((i = P({ traceId: o, parentSpanId: a, ...t }, r, s)), m.freezeDscOnSpan(i, n));
      } else {
        let {
          traceId: e,
          dsc: n,
          parentSpanId: o,
          sampled: s,
        } = { ...a.getPropagationContext(), ...r.getPropagationContext() };
        ((i = P({ traceId: e, parentSpanId: o, ...t }, r, s)), n && m.freezeDscOnSpan(i, n));
      }
      return (g.logSpanStart(i), y.setCapturedScopesOnSpan(i, r, a), i);
    }
    function v(e) {
      let t = { isStandalone: (e.experimental || {}).standalone, ...e };
      if (e.startTime) {
        let n = { ...t };
        return ((n.startTimestamp = E.spanTimeInputToSeconds(e.startTime)), delete n.startTime, n);
      }
      return t;
    }
    function C() {
      let e = i.getMainCarrier();
      return r.getAsyncContextStrategy(e);
    }
    function P(e, t, n) {
      let r = o.getClient(),
        i = r?.getOptions() || {},
        { name: u = '' } = e,
        c = { spanAttributes: { ...e.attributes }, spanName: u, parentSampled: n };
      r?.emit('beforeSampling', c, { decision: !1 });
      let d = c.parentSampled ?? n,
        _ = c.spanAttributes,
        S = t.getPropagationContext(),
        [E, T, m] = t.getScopeData().sdkProcessingMetadata[I]
          ? [!1]
          : f.sampleSpan(
              i,
              {
                name: u,
                parentSampled: d,
                attributes: _,
                parentSampleRate: p.parseSampleRate(S.dsc?.sample_rate),
              },
              S.sampleRand
            ),
        g = new A.SentrySpan({
          ...e,
          attributes: {
            [s.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',
            [s.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: void 0 !== T && m ? T : void 0,
            ..._,
          },
          sampled: E,
        });
      return (
        !E &&
          r &&
          (a.DEBUG_BUILD &&
            l.debug.log(
              '[Tracing] Discarding root span because its trace was not chosen to be sampled.'
            ),
          r.recordDroppedEvent('sample_rate', 'transaction')),
        r && r.emit('spanStart', g),
        g
      );
    }
    function M(e, t) {
      if (t) return t;
      if (null === t) return;
      let n = S._getSpanForScope(e);
      if (!n) return;
      let r = o.getClient();
      return (r ? r.getOptions() : {}).parentSpanIsAlwaysRootSpan ? E.getRootSpan(n) : n;
    }
    function L(e) {
      return void 0 !== e ? (t) => b(e, t) : (e) => e();
    }
    ((n.continueTrace = (e, t) => {
      let n = i.getMainCarrier(),
        a = r.getAsyncContextStrategy(n);
      if (a.continueTrace) return a.continueTrace(e, t);
      let { sentryTrace: s, baggage: l } = e,
        c = o.getClient(),
        d = u.baggageHeaderToDynamicSamplingContext(l);
      return c && !T.shouldContinueTrace(c, d?.org_id)
        ? N(t)
        : o.withScope((e) => {
            let n = T.propagationContextFromHeaders(s, l);
            return (e.setPropagationContext(n), t());
          });
    }),
      (n.startInactiveSpan = function (e) {
        let t = C();
        if (t.startInactiveSpan) return t.startInactiveSpan(e);
        let n = v(e),
          { forceTransaction: r, parentSpan: i } = e;
        return (
          e.scope ? (t) => o.withScope(e.scope, t) : void 0 !== i ? (e) => b(i, e) : (e) => e()
        )(() => {
          let t = o.getCurrentScope(),
            a = M(t, i);
          return e.onlyIfParent && !a
            ? new h.SentryNonRecordingSpan()
            : O({ parentSpan: a, spanArguments: n, forceTransaction: r, scope: t });
        });
      }),
      (n.startNewTrace = N),
      (n.startSpan = function (e, t) {
        let n = C();
        if (n.startSpan) return n.startSpan(e, t);
        let r = v(e),
          { forceTransaction: i, parentSpan: a, scope: s } = e,
          u = s?.clone();
        return o.withScope(u, () =>
          L(a)(() => {
            let n = o.getCurrentScope(),
              s = M(n, a),
              u =
                e.onlyIfParent && !s
                  ? new h.SentryNonRecordingSpan()
                  : O({ parentSpan: s, spanArguments: r, forceTransaction: i, scope: n });
            return (
              S._setSpanForScope(n, u),
              c.handleCallbackErrors(
                () => t(u),
                () => {
                  let { status: e } = E.spanToJSON(u);
                  u.isRecording() &&
                    (!e || 'ok' === e) &&
                    u.setStatus({ code: R.SPAN_STATUS_ERROR, message: 'internal_error' });
                },
                () => {
                  u.end();
                }
              )
            );
          })
        );
      }),
      (n.startSpanManual = function (e, t) {
        let n = C();
        if (n.startSpanManual) return n.startSpanManual(e, t);
        let r = v(e),
          { forceTransaction: i, parentSpan: a, scope: s } = e,
          u = s?.clone();
        return o.withScope(u, () =>
          L(a)(() => {
            let n = o.getCurrentScope(),
              s = M(n, a),
              u =
                e.onlyIfParent && !s
                  ? new h.SentryNonRecordingSpan()
                  : O({ parentSpan: s, spanArguments: r, forceTransaction: i, scope: n });
            return (
              S._setSpanForScope(n, u),
              c.handleCallbackErrors(
                () => t(u, () => u.end()),
                () => {
                  let { status: e } = E.spanToJSON(u);
                  u.isRecording() &&
                    (!e || 'ok' === e) &&
                    u.setStatus({ code: R.SPAN_STATUS_ERROR, message: 'internal_error' });
                }
              )
            );
          })
        );
      }),
      (n.suppressTracing = function (e) {
        let t = C();
        return t.suppressTracing
          ? t.suppressTracing(e)
          : o.withScope((t) => {
              t.setSDKProcessingMetadata({ [I]: !0 });
              let n = e();
              return (t.setSDKProcessingMetadata({ [I]: void 0 }), n);
            });
      }),
      (n.withActiveSpan = b));
  },
  58597,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(13801),
      a = e.r(13500),
      s = e.r(9338),
      u = e.r(59814),
      l = e.r(24205),
      c = e.r(28685),
      d = e.r(22599),
      p = e.r(29946),
      _ = e.r(75803),
      S = e.r(72517),
      E = e.r(66744),
      T = { idleTimeout: 1e3, finalTimeout: 3e4, childSpanTimeout: 15e3 };
    ((n.TRACING_DEFAULTS = T),
      (n.startIdleSpan = function (e, t = {}) {
        let n,
          m = new Map(),
          g = !1,
          f = 'externalFinish',
          h = !t.disableAutoFinish,
          A = [],
          {
            idleTimeout: R = T.idleTimeout,
            finalTimeout: y = T.finalTimeout,
            childSpanTimeout: I = T.childSpanTimeout,
            beforeSpanEnd: b,
          } = t,
          N = r.getClient();
        if (!N || !s.hasSpansEnabled()) {
          let e = new p.SentryNonRecordingSpan(),
            t = { sample_rate: '0', sampled: 'false', ...d.getDynamicSamplingContextFromSpan(e) };
          return (d.freezeDscOnSpan(e, t), e);
        }
        let O = r.getCurrentScope(),
          v = l.getActiveSpan(),
          C = (function (e) {
            let t = E.startInactiveSpan(e);
            return (
              u._setSpanForScope(r.getCurrentScope(), t),
              i.DEBUG_BUILD && a.debug.log('[Tracing] Started span is an idle span'),
              t
            );
          })(e);
        function P() {
          n && (clearTimeout(n), (n = void 0));
        }
        function M(e) {
          (P(),
            (n = setTimeout(() => {
              !g && 0 === m.size && h && ((f = 'idleTimeout'), C.end(e));
            }, R)));
        }
        function L(e) {
          n = setTimeout(() => {
            !g && h && ((f = 'heartbeatFailed'), C.end(e));
          }, I);
        }
        function U(e) {
          ((g = !0), m.clear(), A.forEach((e) => e()), u._setSpanForScope(O, v));
          let t = l.spanToJSON(C),
            { start_timestamp: n } = t;
          if (!n) return;
          (t.data[o.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON] ||
            C.setAttribute(o.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, f),
            a.debug.log(`[Tracing] Idle span "${t.op}" finished`));
          let r = l.getSpanDescendants(C).filter((e) => e !== C),
            s = 0;
          (r.forEach((t) => {
            t.isRecording() &&
              (t.setStatus({ code: S.SPAN_STATUS_ERROR, message: 'cancelled' }),
              t.end(e),
              i.DEBUG_BUILD &&
                a.debug.log(
                  '[Tracing] Cancelling span since span ended early',
                  JSON.stringify(t, void 0, 2)
                ));
            let { timestamp: n = 0, start_timestamp: r = 0 } = l.spanToJSON(t),
              o = r <= e,
              u = n - r <= (y + R) / 1e3;
            if (i.DEBUG_BUILD) {
              let e = JSON.stringify(t, void 0, 2);
              o
                ? u ||
                  a.debug.log(
                    '[Tracing] Discarding span since it finished after idle span final timeout',
                    e
                  )
                : a.debug.log(
                    '[Tracing] Discarding span since it happened after idle span was finished',
                    e
                  );
            }
            (!u || !o) && (l.removeChildSpanFromSpan(C, t), s++);
          }),
            s > 0 && C.setAttribute('sentry.idle_span_discarded_spans', s));
        }
        return (
          (C.end = new Proxy(C.end, {
            apply(e, t, n) {
              if ((b && b(C), t instanceof p.SentryNonRecordingSpan)) return;
              let [r, ...i] = n,
                o = r || c.timestampInSeconds(),
                a = l.spanTimeInputToSeconds(o),
                s = l.getSpanDescendants(C).filter((e) => e !== C);
              if (!s.length) return (U(a), Reflect.apply(e, t, [a, ...i]));
              let u = s.map((e) => l.spanToJSON(e).timestamp).filter((e) => !!e),
                d = u.length ? Math.max(...u) : void 0,
                _ = l.spanToJSON(C).start_timestamp,
                S = Math.min(
                  _ ? _ + y / 1e3 : 1 / 0,
                  Math.max(_ || -1 / 0, Math.min(a, d || 1 / 0))
                );
              return (U(S), Reflect.apply(e, t, [S, ...i]));
            },
          })),
          A.push(
            N.on('spanStart', (e) => {
              var t;
              !(
                g ||
                e === C ||
                l.spanToJSON(e).timestamp ||
                (e instanceof _.SentrySpan && e.isStandaloneSpan())
              ) &&
                l.getSpanDescendants(C).includes(e) &&
                ((t = e.spanContext().spanId),
                P(),
                m.set(t, !0),
                L(c.timestampInSeconds() + I / 1e3));
            })
          ),
          A.push(
            N.on('spanEnd', (e) => {
              if (!g) {
                var t;
                ((t = e.spanContext().spanId),
                  m.has(t) && m.delete(t),
                  0 === m.size && M(c.timestampInSeconds() + R / 1e3));
              }
            })
          ),
          A.push(
            N.on('idleSpanEnableAutoFinish', (e) => {
              e === C && ((h = !0), M(), m.size && L());
            })
          ),
          t.disableAutoFinish || M(),
          setTimeout(() => {
            g ||
              (C.setStatus({ code: S.SPAN_STATUS_ERROR, message: 'deadline_exceeded' }),
              (f = 'finalTimeout'),
              C.end());
          }, y),
          C
        );
      }));
  },
  63652,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802);
    class i {
      constructor(e) {
        ((this._state = 0), (this._handlers = []), this._runExecutor(e));
      }
      then(e, t) {
        return new i((n, r) => {
          (this._handlers.push([
            !1,
            (t) => {
              if (e)
                try {
                  n(e(t));
                } catch (e) {
                  r(e);
                }
              else n(t);
            },
            (e) => {
              if (t)
                try {
                  n(t(e));
                } catch (e) {
                  r(e);
                }
              else r(e);
            },
          ]),
            this._executeHandlers());
        });
      }
      catch(e) {
        return this.then((e) => e, e);
      }
      finally(e) {
        return new i((t, n) => {
          let r, i;
          return this.then(
            (t) => {
              ((i = !1), (r = t), e && e());
            },
            (t) => {
              ((i = !0), (r = t), e && e());
            }
          ).then(() => {
            if (i) return void n(r);
            t(r);
          });
        });
      }
      _executeHandlers() {
        if (0 === this._state) return;
        let e = this._handlers.slice();
        ((this._handlers = []),
          e.forEach((e) => {
            e[0] ||
              (1 === this._state && e[1](this._value),
              2 === this._state && e[2](this._value),
              (e[0] = !0));
          }));
      }
      _runExecutor(e) {
        let t = (e, t) => {
            if (0 === this._state) {
              if (r.isThenable(t)) return void t.then(n, i);
              ((this._state = e), (this._value = t), this._executeHandlers());
            }
          },
          n = (e) => {
            t(1, e);
          },
          i = (e) => {
            t(2, e);
          };
        try {
          e(n, i);
        } catch (e) {
          i(e);
        }
      }
    }
    ((n.SyncPromise = i),
      (n.rejectedSyncPromise = function (e) {
        return new i((t, n) => {
          n(e);
        });
      }),
      (n.resolvedSyncPromise = function (e) {
        return new i((t) => {
          t(e);
        });
      }));
  },
  10083,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(2802),
      a = e.r(63652);
    n.notifyEventProcessors = function e(t, n, s, u = 0) {
      return new a.SyncPromise((a, l) => {
        let c = t[u];
        if (null === n || 'function' != typeof c) a(n);
        else {
          let d = c({ ...n }, s);
          (r.DEBUG_BUILD &&
            c.id &&
            null === d &&
            i.debug.log(`Event processor "${c.id}" dropped event`),
            o.isThenable(d)
              ? d.then((n) => e(t, n, s, u + 1).then(a)).then(null, l)
              : e(t, d, s, u + 1)
                  .then(a)
                  .then(null, l));
        }
      });
    };
  },
  97935,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(22599),
      i = e.r(53182),
      o = e.r(24205);
    function a(e, t, n) {
      e[t] = i.merge(e[t], n, 1);
    }
    ((n.applyScopeDataToEvent = function (e, t) {
      var n, i, a, s;
      let { fingerprint: u, span: l, breadcrumbs: c, sdkProcessingMetadata: d } = t;
      ((function (e, t) {
        let { extra: n, tags: r, user: i, contexts: o, level: a, transactionName: s } = t;
        (Object.keys(n).length && (e.extra = { ...n, ...e.extra }),
          Object.keys(r).length && (e.tags = { ...r, ...e.tags }),
          Object.keys(i).length && (e.user = { ...i, ...e.user }),
          Object.keys(o).length && (e.contexts = { ...o, ...e.contexts }),
          a && (e.level = a),
          s && 'transaction' !== e.type && (e.transaction = s));
      })(e, t),
        l &&
          (function (e, t) {
            ((e.contexts = { trace: o.spanToTraceContext(t), ...e.contexts }),
              (e.sdkProcessingMetadata = {
                dynamicSamplingContext: r.getDynamicSamplingContextFromSpan(t),
                ...e.sdkProcessingMetadata,
              }));
            let n = o.getRootSpan(t),
              i = o.spanToJSON(n).description;
            i && !e.transaction && 'transaction' === e.type && (e.transaction = i);
          })(e, l),
        (n = e),
        (i = u),
        (n.fingerprint = n.fingerprint
          ? Array.isArray(n.fingerprint)
            ? n.fingerprint
            : [n.fingerprint]
          : []),
        i && (n.fingerprint = n.fingerprint.concat(i)),
        n.fingerprint.length || delete n.fingerprint,
        (function (e, t) {
          let n = [...(e.breadcrumbs || []), ...t];
          e.breadcrumbs = n.length ? n : void 0;
        })(e, c),
        (a = e),
        (s = d),
        (a.sdkProcessingMetadata = { ...a.sdkProcessingMetadata, ...s }));
    }),
      (n.mergeAndOverwriteScopeData = a),
      (n.mergeScopeData = function (e, t) {
        let {
          extra: n,
          tags: r,
          user: o,
          contexts: s,
          level: u,
          sdkProcessingMetadata: l,
          breadcrumbs: c,
          fingerprint: d,
          eventProcessors: p,
          attachments: _,
          propagationContext: S,
          transactionName: E,
          span: T,
        } = t;
        (a(e, 'extra', n),
          a(e, 'tags', r),
          a(e, 'user', o),
          a(e, 'contexts', s),
          (e.sdkProcessingMetadata = i.merge(e.sdkProcessingMetadata, l, 2)),
          u && (e.level = u),
          E && (e.transactionName = E),
          T && (e.span = T),
          c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]),
          d.length && (e.fingerprint = [...e.fingerprint, ...d]),
          p.length && (e.eventProcessors = [...e.eventProcessors, ...p]),
          _.length && (e.attachments = [...e.attachments, ..._]),
          (e.propagationContext = { ...e.propagationContext, ...S }));
      }));
  },
  69718,
  (e, t, n) => {
    let r, i, o;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let a = e.r(83247);
    function s(e) {
      let t = a.GLOBAL_OBJ._sentryDebugIds;
      if (!t) return {};
      let n = Object.keys(t);
      return o && n.length === i
        ? o
        : ((i = n.length),
          (o = n.reduce((n, i) => {
            r || (r = {});
            let o = r[i];
            if (o) n[o[0]] = o[1];
            else {
              let o = e(i);
              for (let e = o.length - 1; e >= 0; e--) {
                let a = o[e],
                  s = a?.filename,
                  u = t[i];
                if (s && u) {
                  ((n[s] = u), (r[i] = [s, u]));
                  break;
                }
              }
            }
            return n;
          }, {})));
    }
    ((n.getDebugImagesForResources = function (e, t) {
      let n = s(e);
      if (!n) return [];
      let r = [];
      for (let e of t) e && n[e] && r.push({ type: 'sourcemap', code_file: e, debug_id: n[e] });
      return r;
    }),
      (n.getFilenameToDebugIdMap = s));
  },
  47333,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23363),
      i = e.r(6336),
      o = e.r(10083),
      a = e.r(32515),
      s = e.r(97935),
      u = e.r(69718),
      l = e.r(21919),
      c = e.r(97548),
      d = e.r(22111),
      p = e.r(28685);
    function _(e, t) {
      let { environment: n, release: i, dist: o, maxValueLength: a = 250 } = t;
      ((e.environment = e.environment || n || r.DEFAULT_ENVIRONMENT),
        !e.release && i && (e.release = i),
        !e.dist && o && (e.dist = o));
      let s = e.request;
      s?.url && (s.url = d.truncate(s.url, a));
    }
    function S(e, t) {
      let n = u.getFilenameToDebugIdMap(t);
      e.exception?.values?.forEach((e) => {
        e.stacktrace?.frames?.forEach((e) => {
          e.filename && (e.debug_id = n[e.filename]);
        });
      });
    }
    function E(e) {
      let t = {};
      if (
        (e.exception?.values?.forEach((e) => {
          e.stacktrace?.frames?.forEach((e) => {
            e.debug_id &&
              (e.abs_path
                ? (t[e.abs_path] = e.debug_id)
                : e.filename && (t[e.filename] = e.debug_id),
              delete e.debug_id);
          });
        }),
        0 === Object.keys(t).length)
      )
        return;
      ((e.debug_meta = e.debug_meta || {}), (e.debug_meta.images = e.debug_meta.images || []));
      let n = e.debug_meta.images;
      Object.entries(t).forEach(([e, t]) => {
        n.push({ type: 'sourcemap', code_file: e, debug_id: t });
      });
    }
    let T = ['user', 'level', 'extra', 'contexts', 'tags', 'fingerprint', 'propagationContext'];
    ((n.applyClientOptions = _),
      (n.applyDebugIds = S),
      (n.applyDebugMeta = E),
      (n.parseEventHintOrCaptureContext = function (e) {
        if (e) {
          var t;
          return (t = e) instanceof a.Scope ||
            'function' == typeof t ||
            Object.keys(e).some((e) => T.includes(e))
            ? { captureContext: e }
            : e;
        }
      }),
      (n.prepareEvent = function (e, t, n, r, u, d) {
        var T, m;
        let { normalizeDepth: g = 3, normalizeMaxBreadth: f = 1e3 } = e,
          h = {
            ...t,
            event_id: t.event_id || n.event_id || l.uuid4(),
            timestamp: t.timestamp || p.dateTimestampInSeconds(),
          },
          A = n.integrations || e.integrations.map((e) => e.name);
        (_(h, e),
          (T = h),
          (m = A).length > 0 &&
            ((T.sdk = T.sdk || {}), (T.sdk.integrations = [...(T.sdk.integrations || []), ...m])),
          u && u.emit('applyFrameMetadata', t),
          void 0 === t.type && S(h, e.stackParser));
        let R = (function (e, t) {
          if (!t) return e;
          let n = e ? e.clone() : new a.Scope();
          return (n.update(t), n);
        })(r, n.captureContext);
        n.mechanism && l.addExceptionMechanism(h, n.mechanism);
        let y = u ? u.getEventProcessors() : [],
          I = i.getGlobalScope().getScopeData();
        if (d) {
          let e = d.getScopeData();
          s.mergeScopeData(I, e);
        }
        if (R) {
          let e = R.getScopeData();
          s.mergeScopeData(I, e);
        }
        let b = [...(n.attachments || []), ...I.attachments];
        (b.length && (n.attachments = b), s.applyScopeDataToEvent(h, I));
        let N = [...y, ...I.eventProcessors];
        return o.notifyEventProcessors(N, h, n).then((e) =>
          (e && E(e), 'number' == typeof g && g > 0)
            ? (function (e, t, n) {
                if (!e) return null;
                let r = {
                  ...e,
                  ...(e.breadcrumbs && {
                    breadcrumbs: e.breadcrumbs.map((e) => ({
                      ...e,
                      ...(e.data && { data: c.normalize(e.data, t, n) }),
                    })),
                  }),
                  ...(e.user && { user: c.normalize(e.user, t, n) }),
                  ...(e.contexts && { contexts: c.normalize(e.contexts, t, n) }),
                  ...(e.extra && { extra: c.normalize(e.extra, t, n) }),
                };
                return (
                  e.contexts?.trace &&
                    r.contexts &&
                    ((r.contexts.trace = e.contexts.trace),
                    e.contexts.trace.data &&
                      (r.contexts.trace.data = c.normalize(e.contexts.trace.data, t, n))),
                  e.spans &&
                    (r.spans = e.spans.map((e) => ({
                      ...e,
                      ...(e.data && { data: c.normalize(e.data, t, n) }),
                    }))),
                  e.contexts?.flags &&
                    r.contexts &&
                    (r.contexts.flags = c.normalize(e.contexts.flags, 3, n)),
                  r
                );
              })(e, g, f)
            : e
        );
      }));
  },
  55842,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(54596),
      a = e.r(13500),
      s = e.r(2802),
      u = e.r(21919),
      l = e.r(47333),
      c = e.r(28685),
      d = e.r(83247);
    function p(e, t) {
      let n = r.getCurrentScope(),
        o = r.getClient();
      if (o)
        if (o.captureCheckIn) return o.captureCheckIn(e, t, n);
        else
          i.DEBUG_BUILD &&
            a.debug.warn('Cannot capture check-in. Client does not support sending check-ins.');
      else i.DEBUG_BUILD && a.debug.warn('Cannot capture check-in. No client defined.');
      return u.uuid4();
    }
    async function _(e) {
      let t = r.getClient();
      return t
        ? t.flush(e)
        : (i.DEBUG_BUILD && a.debug.warn('Cannot flush events. No client defined.'),
          Promise.resolve(!1));
    }
    async function S(e) {
      let t = r.getClient();
      return t
        ? t.close(e)
        : (i.DEBUG_BUILD && a.debug.warn('Cannot flush events and disable SDK. No client defined.'),
          Promise.resolve(!1));
    }
    function E() {
      let e = r.getIsolationScope(),
        t = r.getCurrentScope().getSession() || e.getSession();
      (t && o.closeSession(t), T(), e.setSession());
    }
    function T() {
      let e = r.getIsolationScope(),
        t = r.getClient(),
        n = e.getSession();
      n && t && t.captureSession(n);
    }
    ((n.addEventProcessor = function (e) {
      r.getIsolationScope().addEventProcessor(e);
    }),
      (n.captureCheckIn = p),
      (n.captureEvent = function (e, t) {
        return r.getCurrentScope().captureEvent(e, t);
      }),
      (n.captureException = function (e, t) {
        return r.getCurrentScope().captureException(e, l.parseEventHintOrCaptureContext(t));
      }),
      (n.captureMessage = function (e, t) {
        let n = 'string' == typeof t ? t : void 0,
          i = 'string' != typeof t ? { captureContext: t } : void 0;
        return r.getCurrentScope().captureMessage(e, n, i);
      }),
      (n.captureSession = function (e = !1) {
        if (e) return void E();
        T();
      }),
      (n.close = S),
      (n.endSession = E),
      (n.flush = _),
      (n.isEnabled = function () {
        let e = r.getClient();
        return e?.getOptions().enabled !== !1 && !!e?.getTransport();
      }),
      (n.isInitialized = function () {
        return !!r.getClient();
      }),
      (n.lastEventId = function () {
        return r.getIsolationScope().lastEventId();
      }),
      (n.setContext = function (e, t) {
        r.getIsolationScope().setContext(e, t);
      }),
      (n.setExtra = function (e, t) {
        r.getIsolationScope().setExtra(e, t);
      }),
      (n.setExtras = function (e) {
        r.getIsolationScope().setExtras(e);
      }),
      (n.setTag = function (e, t) {
        r.getIsolationScope().setTag(e, t);
      }),
      (n.setTags = function (e) {
        r.getIsolationScope().setTags(e);
      }),
      (n.setUser = function (e) {
        r.getIsolationScope().setUser(e);
      }),
      (n.startSession = function (e) {
        let t = r.getIsolationScope(),
          n = r.getCurrentScope(),
          { userAgent: i } = d.GLOBAL_OBJ.navigator || {},
          a = o.makeSession({ user: n.getUser() || t.getUser(), ...(i && { userAgent: i }), ...e }),
          s = t.getSession();
        return (
          s?.status === 'ok' && o.updateSession(s, { status: 'exited' }),
          E(),
          t.setSession(a),
          a
        );
      }),
      (n.withMonitor = function (e, t, n) {
        let i = p({ monitorSlug: e, status: 'in_progress' }, n),
          o = c.timestampInSeconds();
        function a(t) {
          p({ monitorSlug: e, status: t, checkInId: i, duration: c.timestampInSeconds() - o });
        }
        return r.withIsolationScope(() => {
          let e;
          try {
            e = t();
          } catch (e) {
            throw (a('error'), e);
          }
          return s.isThenable(e)
            ? e.then(
                (e) => (a('ok'), e),
                (e) => {
                  throw (a('error'), e);
                }
              )
            : (a('ok'), e);
        });
      }));
  },
  81435,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(87033);
    function i(e) {
      let t = e.protocol ? `${e.protocol}:` : '',
        n = e.port ? `:${e.port}` : '';
      return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ''}/api/`;
    }
    ((n.getEnvelopeEndpointWithUrlEncodedAuth = function (e, t, n) {
      return (
        t ||
        `${i(e)}${e.projectId}/envelope/?${(function (e, t) {
          let n = { sentry_version: '7' };
          return (
            e.publicKey && (n.sentry_key = e.publicKey),
            t && (n.sentry_client = `${t.name}/${t.version}`),
            new URLSearchParams(n).toString()
          );
        })(e, n)}`
      );
    }),
      (n.getReportDialogEndpoint = function (e, t) {
        let n = r.makeDsn(e);
        if (!n) return '';
        let o = `${i(n)}embed/error-page/`,
          a = `dsn=${r.dsnToString(n)}`;
        for (let e in t)
          if ('dsn' !== e && 'onClose' !== e)
            if ('user' === e) {
              let e = t.user;
              if (!e) continue;
              (e.name && (a += `&name=${encodeURIComponent(e.name)}`),
                e.email && (a += `&email=${encodeURIComponent(e.email)}`));
            } else a += `&${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`;
        return `${o}?${a}`;
      }));
  },
  39059,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(13500),
      a = [];
    function s(e, t, n) {
      if (n[t.name]) {
        i.DEBUG_BUILD &&
          o.debug.log(`Integration skipped because it was already installed: ${t.name}`);
        return;
      }
      if (
        ((n[t.name] = t),
        -1 === a.indexOf(t.name) &&
          'function' == typeof t.setupOnce &&
          (t.setupOnce(), a.push(t.name)),
        t.setup && 'function' == typeof t.setup && t.setup(e),
        'function' == typeof t.preprocessEvent)
      ) {
        let n = t.preprocessEvent.bind(t);
        e.on('preprocessEvent', (t, r) => n(t, r, e));
      }
      if ('function' == typeof t.processEvent) {
        let n = t.processEvent.bind(t),
          r = Object.assign((t, r) => n(t, r, e), { id: t.name });
        e.addEventProcessor(r);
      }
      i.DEBUG_BUILD && o.debug.log(`Integration installed: ${t.name}`);
    }
    ((n.addIntegration = function (e) {
      let t = r.getClient();
      if (!t) {
        i.DEBUG_BUILD &&
          o.debug.warn(`Cannot add integration "${e.name}" because no SDK Client is available.`);
        return;
      }
      t.addIntegration(e);
    }),
      (n.afterSetupIntegrations = function (e, t) {
        for (let n of t) n?.afterAllSetup && n.afterAllSetup(e);
      }),
      (n.defineIntegration = function (e) {
        return e;
      }),
      (n.getIntegrationsToSetup = function (e) {
        let t,
          n = e.defaultIntegrations || [],
          r = e.integrations;
        if (
          (n.forEach((e) => {
            e.isDefaultInstance = !0;
          }),
          Array.isArray(r))
        )
          t = [...n, ...r];
        else if ('function' == typeof r) {
          let e = r(n);
          t = Array.isArray(e) ? e : [e];
        } else t = n;
        let i = {};
        return (
          t.forEach((e) => {
            let { name: t } = e,
              n = i[t];
            (n && !n.isDefaultInstance && e.isDefaultInstance) || (i[t] = e);
          }),
          Object.values(i)
        );
      }),
      (n.installedIntegrations = a),
      (n.setupIntegration = s),
      (n.setupIntegrations = function (e, t) {
        let n = {};
        return (
          t.forEach((t) => {
            t && s(e, t, n);
          }),
          n
        );
      }));
  },
  6583,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(46274),
      i = e.r(28685);
    n.createClientReportEnvelope = function (e, t, n) {
      let o = [
        { type: 'client_report' },
        { timestamp: n || i.dateTimestampInSeconds(), discarded_events: e },
      ];
      return r.createEnvelope(t ? { dsn: t } : {}, [o]);
    };
  },
  60610,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.getPossibleEventMessages = function (e) {
        let t = [];
        e.message && t.push(e.message);
        try {
          let n = e.exception.values[e.exception.values.length - 1];
          n?.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`));
        } catch {}
        return t;
      }));
  },
  27538,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13801);
    ((n.convertSpanJsonToTransactionEvent = function (e) {
      return {
        type: 'transaction',
        timestamp: e.timestamp,
        start_timestamp: e.start_timestamp,
        transaction: e.description,
        contexts: {
          trace: {
            trace_id: e.trace_id,
            span_id: e.span_id,
            parent_span_id: e.parent_span_id,
            op: e.op,
            status: e.status,
            origin: e.origin,
            data: {
              ...e.data,
              ...(e.profile_id && { [r.SEMANTIC_ATTRIBUTE_PROFILE_ID]: e.profile_id }),
              ...(e.exclusive_time && { [r.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: e.exclusive_time }),
            },
          },
        },
        measurements: e.measurements,
      };
    }),
      (n.convertTransactionEventToSpanJson = function (e) {
        let {
          trace_id: t,
          parent_span_id: n,
          span_id: i,
          status: o,
          origin: a,
          data: s,
          op: u,
        } = e.contexts?.trace ?? {};
        return {
          data: s ?? {},
          description: e.transaction,
          op: u,
          parent_span_id: n,
          span_id: i ?? '',
          start_timestamp: e.start_timestamp ?? 0,
          status: o,
          timestamp: e.timestamp,
          trace_id: t ?? '',
          origin: a,
          profile_id: s?.[r.SEMANTIC_ATTRIBUTE_PROFILE_ID],
          exclusive_time: s?.[r.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
          measurements: e.measurements,
          is_segment: !0,
        };
      }));
  },
  83666,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(81435),
      i = e.r(23363),
      o = e.r(6336),
      a = e.r(65553),
      s = e.r(66400),
      u = e.r(39059),
      l = e.r(54596),
      c = e.r(22599),
      d = e.r(6583),
      p = e.r(13500),
      _ = e.r(87033),
      S = e.r(46274),
      E = e.r(60610),
      T = e.r(2802),
      m = e.r(53182),
      g = e.r(21919),
      f = e.r(45018),
      h = e.r(47333),
      A = e.r(78719),
      R = e.r(24205),
      y = e.r(63652),
      I = e.r(27538),
      b = "Not capturing exception because it's already been captured.",
      N = 'Discarded session because of missing or non-string release',
      O = Symbol.for('SentryInternalError'),
      v = Symbol.for('SentryDoNotSendEventError');
    function C(e) {
      return { message: e, [O]: !0 };
    }
    function P(e) {
      return { message: e, [v]: !0 };
    }
    function M(e) {
      return !!e && 'object' == typeof e && O in e;
    }
    function L(e) {
      return !!e && 'object' == typeof e && v in e;
    }
    function U(e) {
      return void 0 === e.type;
    }
    function D(e) {
      return 'transaction' === e.type;
    }
    ((n.Client = class {
      constructor(e) {
        if (
          ((this._options = e),
          (this._integrations = {}),
          (this._numProcessing = 0),
          (this._outcomes = {}),
          (this._hooks = {}),
          (this._eventProcessors = []),
          e.dsn
            ? (this._dsn = _.makeDsn(e.dsn))
            : a.DEBUG_BUILD && p.debug.warn('No DSN provided, client will not send events.'),
          this._dsn)
        ) {
          let t = r.getEnvelopeEndpointWithUrlEncodedAuth(
            this._dsn,
            e.tunnel,
            e._metadata ? e._metadata.sdk : void 0
          );
          this._transport = e.transport({
            tunnel: this._options.tunnel,
            recordDroppedEvent: this.recordDroppedEvent.bind(this),
            ...e.transportOptions,
            url: t,
          });
        }
      }
      captureException(e, t, n) {
        let r = g.uuid4();
        if (g.checkOrSetAlreadyCaught(e)) return (a.DEBUG_BUILD && p.debug.log(b), r);
        let i = { event_id: r, ...t };
        return (
          this._process(this.eventFromException(e, i).then((e) => this._captureEvent(e, i, n))),
          i.event_id
        );
      }
      captureMessage(e, t, n, r) {
        let i = { event_id: g.uuid4(), ...n },
          o = T.isParameterizedString(e) ? e : String(e),
          a = T.isPrimitive(e) ? this.eventFromMessage(o, t, i) : this.eventFromException(e, i);
        return (this._process(a.then((e) => this._captureEvent(e, i, r))), i.event_id);
      }
      captureEvent(e, t, n) {
        let r = g.uuid4();
        if (t?.originalException && g.checkOrSetAlreadyCaught(t.originalException))
          return (a.DEBUG_BUILD && p.debug.log(b), r);
        let i = { event_id: r, ...t },
          o = e.sdkProcessingMetadata || {},
          s = o.capturedSpanScope,
          u = o.capturedSpanIsolationScope;
        return (this._process(this._captureEvent(e, i, s || n, u)), i.event_id);
      }
      captureSession(e) {
        (this.sendSession(e), l.updateSession(e, { init: !1 }));
      }
      getDsn() {
        return this._dsn;
      }
      getOptions() {
        return this._options;
      }
      getSdkMetadata() {
        return this._options._metadata;
      }
      getTransport() {
        return this._transport;
      }
      flush(e) {
        let t = this._transport;
        return t
          ? (this.emit('flush'),
            this._isClientDoneProcessing(e).then((n) => t.flush(e).then((e) => n && e)))
          : y.resolvedSyncPromise(!0);
      }
      close(e) {
        return this.flush(e).then((e) => ((this.getOptions().enabled = !1), this.emit('close'), e));
      }
      getEventProcessors() {
        return this._eventProcessors;
      }
      addEventProcessor(e) {
        this._eventProcessors.push(e);
      }
      init() {
        (this._isEnabled() ||
          this._options.integrations.some(({ name: e }) => e.startsWith('Spotlight'))) &&
          this._setupIntegrations();
      }
      getIntegrationByName(e) {
        return this._integrations[e];
      }
      addIntegration(e) {
        let t = this._integrations[e.name];
        (u.setupIntegration(this, e, this._integrations), t || u.afterSetupIntegrations(this, [e]));
      }
      sendEvent(e, t = {}) {
        this.emit('beforeSendEvent', e, t);
        let n = s.createEventEnvelope(e, this._dsn, this._options._metadata, this._options.tunnel);
        for (let e of t.attachments || [])
          n = S.addItemToEnvelope(n, S.createAttachmentEnvelopeItem(e));
        let r = this.sendEnvelope(n);
        r && r.then((t) => this.emit('afterSendEvent', e, t), null);
      }
      sendSession(e) {
        let { release: t, environment: n = i.DEFAULT_ENVIRONMENT } = this._options;
        if ('aggregates' in e) {
          let r = e.attrs || {};
          if (!r.release && !t) {
            a.DEBUG_BUILD && p.debug.warn(N);
            return;
          }
          ((r.release = r.release || t), (r.environment = r.environment || n), (e.attrs = r));
        } else {
          if (!e.release && !t) {
            a.DEBUG_BUILD && p.debug.warn(N);
            return;
          }
          ((e.release = e.release || t), (e.environment = e.environment || n));
        }
        this.emit('beforeSendSession', e);
        let r = s.createSessionEnvelope(
          e,
          this._dsn,
          this._options._metadata,
          this._options.tunnel
        );
        this.sendEnvelope(r);
      }
      recordDroppedEvent(e, t, n = 1) {
        if (this._options.sendClientReports) {
          let r = `${e}:${t}`;
          (a.DEBUG_BUILD && p.debug.log(`Recording outcome: "${r}"${n > 1 ? ` (${n} times)` : ''}`),
            (this._outcomes[r] = (this._outcomes[r] || 0) + n));
        }
      }
      on(e, t) {
        let n = (this._hooks[e] = this._hooks[e] || []);
        return (
          n.push(t),
          () => {
            let e = n.indexOf(t);
            e > -1 && n.splice(e, 1);
          }
        );
      }
      emit(e, ...t) {
        let n = this._hooks[e];
        n && n.forEach((e) => e(...t));
      }
      sendEnvelope(e) {
        return (this.emit('beforeEnvelope', e), this._isEnabled() && this._transport)
          ? this._transport
              .send(e)
              .then(
                null,
                (e) => (a.DEBUG_BUILD && p.debug.error('Error while sending envelope:', e), e)
              )
          : (a.DEBUG_BUILD && p.debug.error('Transport disabled'), y.resolvedSyncPromise({}));
      }
      _setupIntegrations() {
        let { integrations: e } = this._options;
        ((this._integrations = u.setupIntegrations(this, e)), u.afterSetupIntegrations(this, e));
      }
      _updateSessionFromEvent(e, t) {
        let n = 'fatal' === t.level,
          r = !1,
          i = t.exception?.values;
        if (i)
          for (let e of ((r = !0), i)) {
            let t = e.mechanism;
            if (t?.handled === !1) {
              n = !0;
              break;
            }
          }
        let o = 'ok' === e.status;
        ((o && 0 === e.errors) || (o && n)) &&
          (l.updateSession(e, {
            ...(n && { status: 'crashed' }),
            errors: e.errors || Number(r || n),
          }),
          this.captureSession(e));
      }
      _isClientDoneProcessing(e) {
        return new y.SyncPromise((t) => {
          let n = 0,
            r = setInterval(() => {
              0 == this._numProcessing
                ? (clearInterval(r), t(!0))
                : ((n += 1), e && n >= e && (clearInterval(r), t(!1)));
            }, 1);
        });
      }
      _isEnabled() {
        return !1 !== this.getOptions().enabled && void 0 !== this._transport;
      }
      _prepareEvent(e, t, n, r) {
        let i = this.getOptions(),
          a = Object.keys(this._integrations);
        return (
          !t.integrations && a?.length && (t.integrations = a),
          this.emit('preprocessEvent', e, t),
          e.type || r.setLastEventId(e.event_id || t.event_id),
          h
            .prepareEvent(i, e, t, n, this, r)
            .then(
              (e) => (
                null === e ||
                  (this.emit('postprocessEvent', e, t),
                  (e.contexts = { trace: o.getTraceContextFromScope(n), ...e.contexts }),
                  (e.sdkProcessingMetadata = {
                    dynamicSamplingContext: c.getDynamicSamplingContextFromScope(this, n),
                    ...e.sdkProcessingMetadata,
                  })),
                e
              )
            )
        );
      }
      _captureEvent(e, t = {}, n = o.getCurrentScope(), r = o.getIsolationScope()) {
        return (
          a.DEBUG_BUILD &&
            U(e) &&
            p.debug.log(
              `Captured error event \`${E.getPossibleEventMessages(e)[0] || '<unknown>'}\``
            ),
          this._processEvent(e, t, n, r).then(
            (e) => e.event_id,
            (e) => {
              a.DEBUG_BUILD &&
                (L(e) ? p.debug.log(e.message) : M(e) ? p.debug.warn(e.message) : p.debug.warn(e));
            }
          )
        );
      }
      _processEvent(e, t, n, r) {
        let i = this.getOptions(),
          { sampleRate: o } = i,
          a = D(e),
          s = U(e),
          u = e.type || 'error',
          l = `before send for type \`${u}\``,
          c = void 0 === o ? void 0 : f.parseSampleRate(o);
        if (s && 'number' == typeof c && Math.random() > c)
          return (
            this.recordDroppedEvent('sample_rate', 'error'),
            y.rejectedSyncPromise(
              P(
                `Discarding event because it's not included in the random sample (sampling rate = ${o})`
              )
            )
          );
        let d = 'replay_event' === u ? 'replay' : u;
        return this._prepareEvent(e, t, n, r)
          .then((e) => {
            if (null === e)
              throw (
                this.recordDroppedEvent('event_processor', d),
                P('An event processor returned `null`, will not send event.')
              );
            return t.data && !0 === t.data.__sentry__
              ? e
              : (function (e, t) {
                  let n = `${t} must return \`null\` or a valid event.`;
                  if (T.isThenable(e))
                    return e.then(
                      (e) => {
                        if (!T.isPlainObject(e) && null !== e) throw C(n);
                        return e;
                      },
                      (e) => {
                        throw C(`${t} rejected with ${e}`);
                      }
                    );
                  if (!T.isPlainObject(e) && null !== e) throw C(n);
                  return e;
                })(
                  (function (e, t, n, r) {
                    let {
                        beforeSend: i,
                        beforeSendTransaction: o,
                        beforeSendSpan: a,
                        ignoreSpans: s,
                      } = t,
                      u = n;
                    if (U(u) && i) return i(u, r);
                    if (D(u)) {
                      if (a || s) {
                        let t = I.convertTransactionEventToSpanJson(u);
                        if (s?.length && A.shouldIgnoreSpan(t, s)) return null;
                        if (a) {
                          let e = a(t);
                          e
                            ? (u = m.merge(n, I.convertSpanJsonToTransactionEvent(e)))
                            : R.showSpanDropWarning();
                        }
                        if (u.spans) {
                          let t = [],
                            n = u.spans;
                          for (let e of n) {
                            if (s?.length && A.shouldIgnoreSpan(e, s)) {
                              A.reparentChildSpans(n, e);
                              continue;
                            }
                            if (a) {
                              let n = a(e);
                              n ? t.push(n) : (R.showSpanDropWarning(), t.push(e));
                            } else t.push(e);
                          }
                          let r = u.spans.length - t.length;
                          (r && e.recordDroppedEvent('before_send', 'span', r), (u.spans = t));
                        }
                      }
                      if (o) {
                        if (u.spans) {
                          let e = u.spans.length;
                          u.sdkProcessingMetadata = {
                            ...n.sdkProcessingMetadata,
                            spanCountBeforeProcessing: e,
                          };
                        }
                        return o(u, r);
                      }
                    }
                    return u;
                  })(this, i, e, t),
                  l
                );
          })
          .then((i) => {
            if (null === i) {
              if ((this.recordDroppedEvent('before_send', d), a)) {
                let t = 1 + (e.spans || []).length;
                this.recordDroppedEvent('before_send', 'span', t);
              }
              throw P(`${l} returned \`null\`, will not send event.`);
            }
            let o = n.getSession() || r.getSession();
            if ((s && o && this._updateSessionFromEvent(o, i), a)) {
              let e =
                (i.sdkProcessingMetadata?.spanCountBeforeProcessing || 0) -
                (i.spans ? i.spans.length : 0);
              e > 0 && this.recordDroppedEvent('before_send', 'span', e);
            }
            let u = i.transaction_info;
            return (
              a &&
                u &&
                i.transaction !== e.transaction &&
                (i.transaction_info = { ...u, source: 'custom' }),
              this.sendEvent(i, t),
              i
            );
          })
          .then(null, (e) => {
            if (L(e) || M(e)) throw e;
            throw (
              this.captureException(e, {
                mechanism: { handled: !1, type: 'internal' },
                data: { __sentry__: !0 },
                originalException: e,
              }),
              C(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${e}`)
            );
          });
      }
      _process(e) {
        (this._numProcessing++,
          e.then(
            (e) => (this._numProcessing--, e),
            (e) => (this._numProcessing--, e)
          ));
      }
      _clearOutcomes() {
        let e = this._outcomes;
        return (
          (this._outcomes = {}),
          Object.entries(e).map(([e, t]) => {
            let [n, r] = e.split(':');
            return { reason: n, category: r, quantity: t };
          })
        );
      }
      _flushOutcomes() {
        a.DEBUG_BUILD && p.debug.log('Flushing outcomes...');
        let e = this._clearOutcomes();
        if (0 === e.length) {
          a.DEBUG_BUILD && p.debug.log('No outcomes to send');
          return;
        }
        if (!this._dsn) {
          a.DEBUG_BUILD && p.debug.log('No dsn provided, will not send outcomes');
          return;
        }
        a.DEBUG_BUILD && p.debug.log('Sending outcomes:', e);
        let t = d.createClientReportEnvelope(e, this._options.tunnel && _.dsnToString(this._dsn));
        this.sendEnvelope(t);
      }
    }),
      (n._getTraceInfoFromScope = function (e, t) {
        return t
          ? o.withScope(t, () => {
              let n = R.getActiveSpan(),
                r = n ? R.spanToTraceContext(n) : o.getTraceContextFromScope(t);
              return [
                n
                  ? c.getDynamicSamplingContextFromSpan(n)
                  : c.getDynamicSamplingContextFromScope(e, t),
                r,
              ];
            })
          : [void 0, void 0];
      }));
  },
  30201,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(87033),
      i = e.r(46274);
    n.createCheckInEnvelope = function (e, t, n, o, a) {
      let s = { sent_at: new Date().toISOString() };
      (n?.sdk && (s.sdk = { name: n.sdk.name, version: n.sdk.version }),
        o && a && (s.dsn = r.dsnToString(a)),
        t && (s.trace = t));
      let u = [{ type: 'check_in' }, e];
      return i.createEnvelope(s, [u]);
    };
  },
  17798,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.SEVERITY_TEXT_TO_SEVERITY_NUMBER = {
        trace: 1,
        debug: 5,
        info: 9,
        warn: 13,
        error: 17,
        fatal: 21,
      }));
  },
  68111,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(87033),
      i = e.r(46274);
    function o(e) {
      return [
        {
          type: 'log',
          item_count: e.length,
          content_type: 'application/vnd.sentry.items.log+json',
        },
        { items: e },
      ];
    }
    ((n.createLogContainerEnvelopeItem = o),
      (n.createLogEnvelope = function (e, t, n, a) {
        let s = {};
        return (
          t?.sdk && (s.sdk = { name: t.sdk.name, version: t.sdk.version }),
          n && a && (s.dsn = r.dsnToString(a)),
          i.createEnvelope(s, [o(e)])
        );
      }));
  },
  10241,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(20434),
      i = e.r(83666),
      o = e.r(6336),
      a = e.r(65553),
      s = e.r(97935),
      u = e.r(13500),
      l = e.r(2802),
      c = e.r(59814),
      d = e.r(28685),
      p = e.r(17798),
      _ = e.r(68111);
    function S(e) {
      switch (typeof e) {
        case 'number':
          if (Number.isInteger(e)) return { value: e, type: 'integer' };
          return { value: e, type: 'double' };
        case 'boolean':
          return { value: e, type: 'boolean' };
        case 'string':
          return { value: e, type: 'string' };
        default: {
          let t = '';
          try {
            t = JSON.stringify(e) ?? '';
          } catch {}
          return { value: t, type: 'string' };
        }
      }
    }
    function E(e, t, n, r = !0) {
      n && (!e[t] || r) && (e[t] = n);
    }
    function T(e, t) {
      let n = f(),
        r = g(e);
      void 0 === r ? n.set(e, [t]) : (n.set(e, [...r, t]), r.length >= 100 && m(e, r));
    }
    function m(e, t) {
      let n = t ?? g(e) ?? [];
      if (0 === n.length) return;
      let r = e.getOptions(),
        i = _.createLogEnvelope(n, r._metadata, r.tunnel, e.getDsn());
      (f().set(e, []), e.emit('flushLogs'), e.sendEnvelope(i));
    }
    function g(e) {
      return f().get(e);
    }
    function f() {
      return r.getGlobalSingleton('clientToLogBufferMap', () => new WeakMap());
    }
    ((n._INTERNAL_captureLog = function (e, t = o.getClient(), n = o.getCurrentScope(), r = T) {
      if (!t) {
        a.DEBUG_BUILD && u.debug.warn('No client available to capture log.');
        return;
      }
      let { release: _, environment: m, enableLogs: g = !1, beforeSendLog: f } = t.getOptions();
      if (!g) {
        a.DEBUG_BUILD && u.debug.warn('logging option not enabled, log will not be captured.');
        return;
      }
      let [, h] = i._getTraceInfoFromScope(t, n),
        A = { ...e.attributes },
        {
          user: { id: R, email: y, username: I },
        } = (function (e) {
          let t = o.getGlobalScope().getScopeData();
          return (
            s.mergeScopeData(t, o.getIsolationScope().getScopeData()),
            s.mergeScopeData(t, e.getScopeData()),
            t
          );
        })(n);
      (E(A, 'user.id', R, !1),
        E(A, 'user.email', y, !1),
        E(A, 'user.name', I, !1),
        E(A, 'sentry.release', _),
        E(A, 'sentry.environment', m));
      let { name: b, version: N } = t.getSdkMetadata()?.sdk ?? {};
      (E(A, 'sentry.sdk.name', b), E(A, 'sentry.sdk.version', N));
      let O = e.message;
      if (l.isParameterizedString(O)) {
        let { __sentry_template_string__: e, __sentry_template_values__: t = [] } = O;
        (t?.length && (A['sentry.message.template'] = e),
          t.forEach((e, t) => {
            A[`sentry.message.parameter.${t}`] = e;
          }));
      }
      let v = c._getSpanForScope(n);
      E(A, 'sentry.trace.parent_span_id', v?.spanContext().spanId);
      let C = { ...e, attributes: A };
      t.emit('beforeCaptureLog', C);
      let P = f ? u.consoleSandbox(() => f(C)) : C;
      if (!P) {
        (t.recordDroppedEvent('before_send', 'log_item', 1),
          a.DEBUG_BUILD && u.debug.warn('beforeSendLog returned null, log will not be captured.'));
        return;
      }
      let { level: M, message: L, attributes: U = {}, severityNumber: D } = P;
      (r(t, {
        timestamp: d.timestampInSeconds(),
        level: M,
        body: L,
        trace_id: h?.trace_id,
        severity_number: D ?? p.SEVERITY_TEXT_TO_SEVERITY_NUMBER[M],
        attributes: Object.keys(U).reduce((e, t) => ((e[t] = S(U[t])), e), {}),
      }),
        t.emit('afterCaptureLog', P));
    }),
      (n._INTERNAL_captureSerializedLog = T),
      (n._INTERNAL_flushLogsBuffer = m),
      (n._INTERNAL_getLogBuffer = g),
      (n.logAttributeToSerializedLogAttribute = S));
  },
  30158,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802),
      i = e.r(21919),
      o = e.r(97548),
      a = e.r(63236);
    function s(e, t) {
      return e(t.stack || '', 1);
    }
    function u(e, t) {
      let n = { type: t.name || t.constructor.name, value: t.message },
        r = s(e, t);
      return (r.length && (n.stacktrace = { frames: r }), n);
    }
    ((n.eventFromMessage = function (e, t, n = 'info', o, a) {
      let u = { event_id: o?.event_id, level: n };
      if (a && o?.syntheticException) {
        let n = s(e, o.syntheticException);
        n.length &&
          ((u.exception = { values: [{ value: t, stacktrace: { frames: n } }] }),
          i.addExceptionMechanism(u, { synthetic: !0 }));
      }
      if (r.isParameterizedString(t)) {
        let { __sentry_template_string__: e, __sentry_template_values__: n } = t;
        return ((u.logentry = { message: e, params: n }), u);
      }
      return ((u.message = t), u);
    }),
      (n.eventFromUnknownInput = function (e, t, n, s) {
        let l = (s?.data && s.data.mechanism) || { handled: !0, type: 'generic' },
          [c, d] = (function (e, t, n, i) {
            if (r.isError(n)) return [n, void 0];
            if (((t.synthetic = !0), r.isPlainObject(n))) {
              let t = e?.getOptions().normalizeDepth,
                s = { __serialized__: o.normalizeToSize(n, t) },
                u = (function (e) {
                  for (let t in e)
                    if (Object.prototype.hasOwnProperty.call(e, t)) {
                      let n = e[t];
                      if (n instanceof Error) return n;
                    }
                })(n);
              if (u) return [u, s];
              let l = (function (e) {
                  if ('name' in e && 'string' == typeof e.name) {
                    let t = `'${e.name}' captured as exception`;
                    return (
                      'message' in e &&
                        'string' == typeof e.message &&
                        (t += ` with message '${e.message}'`),
                      t
                    );
                  }
                  if ('message' in e && 'string' == typeof e.message) return e.message;
                  let t = a.extractExceptionKeysForMessage(e);
                  if (r.isErrorEvent(e))
                    return `Event \`ErrorEvent\` captured as exception with message \`${e.message}\``;
                  let n = (function (e) {
                    try {
                      let t = Object.getPrototypeOf(e);
                      return t ? t.constructor.name : void 0;
                    } catch {}
                  })(e);
                  return `${n && 'Object' !== n ? `'${n}'` : 'Object'} captured as exception with keys: ${t}`;
                })(n),
                c = i?.syntheticException || Error(l);
              return ((c.message = l), [c, s]);
            }
            let s = i?.syntheticException || Error(n);
            return ((s.message = `${n}`), [s, void 0]);
          })(e, l, n, s),
          p = { exception: { values: [u(t, c)] } };
        return (
          d && (p.extra = d),
          i.addExceptionTypeValue(p, void 0, void 0),
          i.addExceptionMechanism(p, l),
          { ...p, event_id: s?.event_id }
        );
      }),
      (n.exceptionFromError = u),
      (n.parseStackFrames = s));
  },
  21571,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(30201),
      i = e.r(83666),
      o = e.r(6336),
      a = e.r(65553),
      s = e.r(10241),
      u = e.r(91630),
      l = e.r(2802),
      c = e.r(13500),
      d = e.r(21919),
      p = e.r(30158),
      _ = e.r(63652);
    class S extends i.Client {
      constructor(e) {
        if (
          (u.registerSpanErrorInstrumentation(),
          super(e),
          (this._logWeight = 0),
          this._options.enableLogs)
        ) {
          let e = this;
          (e.on('flushLogs', () => {
            ((e._logWeight = 0), clearTimeout(e._logFlushIdleTimeout));
          }),
            e.on('afterCaptureLog', (t) => {
              ((e._logWeight += (function (e) {
                let t = 0;
                return (
                  e.message && (t += 2 * e.message.length),
                  e.attributes &&
                    Object.values(e.attributes).forEach((e) => {
                      Array.isArray(e)
                        ? (t += e.length * T(e[0]))
                        : l.isPrimitive(e)
                          ? (t += T(e))
                          : (t += 100);
                    }),
                  t
                );
              })(t)),
                e._logWeight >= 8e5
                  ? s._INTERNAL_flushLogsBuffer(e)
                  : (e._logFlushIdleTimeout = setTimeout(() => {
                      s._INTERNAL_flushLogsBuffer(e);
                    }, 5e3)));
            }),
            e.on('flush', () => {
              s._INTERNAL_flushLogsBuffer(e);
            }));
        }
      }
      eventFromException(e, t) {
        let n = p.eventFromUnknownInput(this, this._options.stackParser, e, t);
        return ((n.level = 'error'), _.resolvedSyncPromise(n));
      }
      eventFromMessage(e, t = 'info', n) {
        return _.resolvedSyncPromise(
          p.eventFromMessage(this._options.stackParser, e, t, n, this._options.attachStacktrace)
        );
      }
      captureException(e, t, n) {
        return (E(t), super.captureException(e, t, n));
      }
      captureEvent(e, t, n) {
        return (
          !e.type && e.exception?.values && e.exception.values.length > 0 && E(t),
          super.captureEvent(e, t, n)
        );
      }
      captureCheckIn(e, t, n) {
        let o = 'checkInId' in e && e.checkInId ? e.checkInId : d.uuid4();
        if (!this._isEnabled())
          return (a.DEBUG_BUILD && c.debug.warn('SDK not enabled, will not capture check-in.'), o);
        let { release: s, environment: u, tunnel: l } = this.getOptions(),
          p = {
            check_in_id: o,
            monitor_slug: e.monitorSlug,
            status: e.status,
            release: s,
            environment: u,
          };
        ('duration' in e && (p.duration = e.duration),
          t &&
            (p.monitor_config = {
              schedule: t.schedule,
              checkin_margin: t.checkinMargin,
              max_runtime: t.maxRuntime,
              timezone: t.timezone,
              failure_issue_threshold: t.failureIssueThreshold,
              recovery_threshold: t.recoveryThreshold,
            }));
        let [_, S] = i._getTraceInfoFromScope(this, n);
        S && (p.contexts = { trace: S });
        let E = r.createCheckInEnvelope(p, _, this.getSdkMetadata(), l, this.getDsn());
        return (
          a.DEBUG_BUILD && c.debug.log('Sending checkin:', e.monitorSlug, e.status),
          this.sendEnvelope(E),
          o
        );
      }
      _prepareEvent(e, t, n, r) {
        return (
          this._options.platform && (e.platform = e.platform || this._options.platform),
          this._options.runtime &&
            (e.contexts = { ...e.contexts, runtime: e.contexts?.runtime || this._options.runtime }),
          this._options.serverName && (e.server_name = e.server_name || this._options.serverName),
          super._prepareEvent(e, t, n, r)
        );
      }
    }
    function E(e) {
      let t = o.getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;
      if (t) {
        let n = e?.mechanism?.handled ?? !0;
        n && 'crashed' !== t.status ? (t.status = 'errored') : n || (t.status = 'crashed');
      }
    }
    function T(e) {
      return 'string' == typeof e
        ? 2 * e.length
        : 'number' == typeof e
          ? 8
          : 4 * ('boolean' == typeof e);
    }
    n.ServerRuntimeClient = S;
  },
  2396,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(13500);
    function a(e) {
      r.getCurrentScope().setClient(e);
    }
    ((n.initAndBind = function (e, t) {
      (!0 === t.debug &&
        (i.DEBUG_BUILD
          ? o.debug.enable()
          : o.consoleSandbox(() => {
              console.warn(
                '[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.'
              );
            })),
        r.getCurrentScope().update(t.initialScope));
      let n = new e(t);
      return (a(n), n.init(), n);
    }),
      (n.setCurrentClient = a));
  },
  90736,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(63652),
      i = Symbol.for('SentryBufferFullError');
    ((n.SENTRY_BUFFER_FULL_ERROR = i),
      (n.makePromiseBuffer = function (e) {
        let t = [];
        function n(e) {
          return t.splice(t.indexOf(e), 1)[0] || Promise.resolve(void 0);
        }
        return {
          $: t,
          add: function (o) {
            if (!(void 0 === e || t.length < e)) return r.rejectedSyncPromise(i);
            let a = o();
            return (
              -1 === t.indexOf(a) && t.push(a),
              a.then(() => n(a)).then(null, () => n(a).then(null, () => {})),
              a
            );
          },
          drain: function (e) {
            return new r.SyncPromise((n, i) => {
              let o = t.length;
              if (!o) return n(!0);
              let a = setTimeout(() => {
                e && e > 0 && n(!1);
              }, e);
              t.forEach((e) => {
                r.resolvedSyncPromise(e).then(() => {
                  --o || (clearTimeout(a), n(!0));
                }, i);
              });
            });
          },
        };
      }));
  },
  11918,
  (e, t, n) => {
    function r(e, t = Date.now()) {
      let n = parseInt(`${e}`, 10);
      if (!isNaN(n)) return 1e3 * n;
      let i = Date.parse(`${e}`);
      return isNaN(i) ? 6e4 : i - t;
    }
    function i(e, t) {
      return e[t] || e.all || 0;
    }
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEFAULT_RETRY_AFTER = 6e4),
      (n.disabledUntil = i),
      (n.isRateLimited = function (e, t, n = Date.now()) {
        return i(e, t) > n;
      }),
      (n.parseRetryAfterHeader = r),
      (n.updateRateLimits = function (e, { statusCode: t, headers: n }, i = Date.now()) {
        let o = { ...e },
          a = n?.['x-sentry-rate-limits'],
          s = n?.['retry-after'];
        if (a)
          for (let e of a.trim().split(',')) {
            let [t, n, , , r] = e.split(':', 5),
              a = parseInt(t, 10),
              s = (isNaN(a) ? 60 : a) * 1e3;
            if (n)
              for (let e of n.split(';'))
                'metric_bucket' === e
                  ? (!r || r.split(';').includes('custom')) && (o[e] = i + s)
                  : (o[e] = i + s);
            else o.all = i + s;
          }
        else s ? (o.all = i + r(s, i)) : 429 === t && (o.all = i + 6e4);
        return o;
      }));
  },
  48476,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(46274),
      a = e.r(90736),
      s = e.r(11918),
      u = e.r(63652);
    ((n.DEFAULT_TRANSPORT_BUFFER_SIZE = 64),
      (n.createTransport = function (e, t, n = a.makePromiseBuffer(e.bufferSize || 64)) {
        let l = {};
        return {
          send: function (c) {
            let d = [];
            if (
              (o.forEachEnvelopeItem(c, (t, n) => {
                let r = o.envelopeItemTypeToDataCategory(n);
                s.isRateLimited(l, r) ? e.recordDroppedEvent('ratelimit_backoff', r) : d.push(t);
              }),
              0 === d.length)
            )
              return u.resolvedSyncPromise({});
            let p = o.createEnvelope(c[0], d),
              _ = (t) => {
                o.forEachEnvelopeItem(p, (n, r) => {
                  e.recordDroppedEvent(t, o.envelopeItemTypeToDataCategory(r));
                });
              };
            return n
              .add(() =>
                t({ body: o.serializeEnvelope(p) }).then(
                  (e) => (
                    void 0 !== e.statusCode &&
                      (e.statusCode < 200 || e.statusCode >= 300) &&
                      r.DEBUG_BUILD &&
                      i.debug.warn(
                        `Sentry responded with status code ${e.statusCode} to sent event.`
                      ),
                    (l = s.updateRateLimits(l, e)),
                    e
                  ),
                  (e) => {
                    throw (
                      _('network_error'),
                      r.DEBUG_BUILD &&
                        i.debug.error('Encountered error running transport request:', e),
                      e
                    );
                  }
                )
              )
              .then(
                (e) => e,
                (e) => {
                  if (e === a.SENTRY_BUFFER_FULL_ERROR)
                    return (
                      r.DEBUG_BUILD &&
                        i.debug.error('Skipped sending event because buffer is full.'),
                      _('queue_overflow'),
                      u.resolvedSyncPromise({})
                    );
                  throw e;
                }
              );
          },
          flush: (e) => n.drain(e),
        };
      }));
  },
  38242,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(46274),
      a = e.r(11918);
    ((n.MIN_DELAY = 100),
      (n.START_DELAY = 5e3),
      (n.makeOfflineTransport = function (e) {
        function t(...e) {
          r.DEBUG_BUILD && i.debug.log('[Offline]:', ...e);
        }
        return (n) => {
          let r,
            i = e(n);
          if (!n.createStore) throw Error('No `createStore` function was provided');
          let s = n.createStore(n),
            u = 5e3;
          function l(e) {
            (r && clearTimeout(r),
              'number' !=
                typeof (r = setTimeout(async () => {
                  r = void 0;
                  let e = await s.shift();
                  e &&
                    (t('Attempting to send previously queued event'),
                    (e[0].sent_at = new Date().toISOString()),
                    d(e, !0).catch((e) => {
                      t('Failed to retry sending', e);
                    }));
                }, e)) &&
                r.unref &&
                r.unref());
          }
          function c() {
            r || (l(u), (u = Math.min(2 * u, 36e5)));
          }
          async function d(e, r = !1) {
            if (!r && o.envelopeContainsItemType(e, ['replay_event', 'replay_recording']))
              return (await s.push(e), l(100), {});
            try {
              if (n.shouldSend && (await n.shouldSend(e)) === !1)
                throw Error('Envelope not sent because `shouldSend` callback returned false');
              let t = await i.send(e),
                r = 100;
              if (t) {
                if (t.headers?.['retry-after'])
                  r = a.parseRetryAfterHeader(t.headers['retry-after']);
                else if (t.headers?.['x-sentry-rate-limits']) r = 6e4;
                else if ((t.statusCode || 0) >= 400) return t;
              }
              return (l(r), (u = 5e3), t);
            } catch (i) {
              var p;
              if (
                await ((p = u),
                !o.envelopeContainsItemType(e, ['client_report']) &&
                  (!n.shouldStore || n.shouldStore(e, i, p)))
              )
                return (
                  r ? await s.unshift(e) : await s.push(e),
                  c(),
                  t('Error sending. Event queued.', i),
                  {}
                );
              throw i;
            }
          }
          return (
            n.flushAtStartup && c(),
            { send: d, flush: (e) => (void 0 === e && ((u = 5e3), l(100)), i.flush(e)) }
          );
        };
      }));
  },
  38769,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(81435),
      i = e.r(87033),
      o = e.r(46274);
    function a(e, t) {
      let n;
      return (
        o.forEachEnvelopeItem(
          e,
          (e, r) => (t.includes(r) && (n = Array.isArray(e) ? e[1] : void 0), !!n)
        ),
        n
      );
    }
    ((n.eventFromEnvelope = a),
      (n.makeMultiplexedTransport = function (e, t) {
        return (n) => {
          let s = e(n),
            u = new Map();
          function l(t, o) {
            let s = o ? `${t}:${o}` : t,
              l = u.get(s);
            if (!l) {
              let c = i.dsnFromString(t);
              if (!c) return;
              let d = r.getEnvelopeEndpointWithUrlEncodedAuth(c, n.tunnel);
              ((l = o
                ? ((t) => {
                    let n = e(t);
                    return {
                      ...n,
                      send: async (e) => {
                        let t = a(e, ['event', 'transaction', 'profile', 'replay_event']);
                        return (t && (t.release = o), n.send(e));
                      },
                    };
                  })({ ...n, url: d })
                : e({ ...n, url: d })),
                u.set(s, l));
            }
            return [t, l];
          }
          return {
            send: async function (e) {
              let n = t({
                  envelope: e,
                  getEvent: function (t) {
                    return a(e, t?.length ? t : ['event']);
                  },
                })
                  .map((e) => ('string' == typeof e ? l(e, void 0) : l(e.dsn, e.release)))
                  .filter((e) => !!e),
                r = n.length ? n : [['', s]];
              return (
                await Promise.all(
                  r.map(([t, n]) => n.send(o.createEnvelope(t ? { ...e[0], dsn: t } : e[0], e[1])))
                )
              )[0];
            },
            flush: async function (e) {
              let t = [...u.values(), s];
              return (await Promise.all(t.map((t) => t.flush(e)))).every((e) => e);
            },
          };
        };
      }));
  },
  16097,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13801);
    function i(e) {
      return 'isRelative' in e;
    }
    function o(e) {
      if (i(e)) return e.pathname;
      let t = new URL(e);
      return (
        (t.search = ''),
        (t.hash = ''),
        ['80', '443'].includes(t.port) && (t.port = ''),
        t.password && (t.password = '%filtered%'),
        t.username && (t.username = '%filtered%'),
        t.toString()
      );
    }
    ((n.getHttpSpanDetailsFromUrlObject = function (e, t, n, a, s) {
      let u = {
        [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: n,
        [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',
      };
      return (
        s &&
          ((u['server' === t ? 'http.route' : 'url.template'] = s),
          (u[r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route')),
        a?.method && (u[r.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD] = a.method.toUpperCase()),
        e &&
          (e.search && (u['url.query'] = e.search),
          e.hash && (u['url.fragment'] = e.hash),
          e.pathname &&
            ((u['url.path'] = e.pathname),
            '/' === e.pathname && (u[r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route')),
          !i(e) &&
            ((u[r.SEMANTIC_ATTRIBUTE_URL_FULL] = e.href),
            e.port && (u['url.port'] = e.port),
            e.protocol && (u['url.scheme'] = e.protocol),
            e.hostname && (u['server' === t ? 'server.address' : 'url.domain'] = e.hostname))),
        [
          (function (e, t, n, r) {
            let i = n?.method?.toUpperCase() ?? 'GET',
              a = r || (e ? ('client' === t ? o(e) : e.pathname) : '/');
            return `${i} ${a}`;
          })(e, t, a, s),
          u,
        ]
      );
    }),
      (n.getSanitizedUrlString = function (e) {
        let { protocol: t, host: n, path: r } = e,
          i =
            n
              ?.replace(/^.*@/, '[filtered]:[filtered]@')
              .replace(/(:80)$/, '')
              .replace(/(:443)$/, '') || '';
        return `${t ? `${t}://` : ''}${i}${r}`;
      }),
      (n.getSanitizedUrlStringFromUrlObject = o),
      (n.isURLObjectRelative = i),
      (n.parseStringToURLObject = function (e, t) {
        let n = 0 >= e.indexOf('://') && 0 !== e.indexOf('//'),
          r = t ?? (n ? 'thismessage:/' : void 0);
        try {
          if ('canParse' in URL && !URL.canParse(e, r)) return;
          let t = new URL(e, r);
          if (n) return { isRelative: n, pathname: t.pathname, search: t.search, hash: t.hash };
          return t;
        } catch {}
      }),
      (n.parseUrl = function (e) {
        if (!e) return {};
        let t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
        if (!t) return {};
        let n = t[6] || '',
          r = t[8] || '';
        return {
          host: t[4],
          path: t[5],
          protocol: t[2],
          search: n,
          hash: r,
          relative: t[5] + n + r,
        };
      }),
      (n.stripUrlQueryAndFragment = function (e) {
        return e.split(/[?#]/, 1)[0];
      }));
  },
  72740,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(16097);
    function i(e) {
      return '/' === e[e.length - 1] ? e.slice(0, -1) : e;
    }
    n.isSentryRequestUrl = function (e, t) {
      var n, o;
      let a = t?.getDsn(),
        s = t?.getOptions().tunnel;
      return (
        (function (e, t) {
          let n = r.parseStringToURLObject(e);
          return (
            !(!n || r.isURLObjectRelative(n)) &&
            !!t &&
            n.host.includes(t.host) &&
            /(^|&|\?)sentry_key=/.test(n.search)
          );
        })(e, a) || ((n = e), !!(o = s) && i(n) === i(o))
      );
    };
  },
  97589,
  (e, t, n) => {
    function r(e, ...t) {
      let n = new String(String.raw(e, ...t));
      return (
        (n.__sentry_template_string__ = e.join('\0').replace(/%/g, '%%').replace(/\0/g, '%s')),
        (n.__sentry_template_values__ = t),
        n
      );
    }
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.fmt = r),
      (n.parameterize = r));
  },
  48790,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.addAutoIpAddressToSession = function (e) {
        'aggregates' in e
          ? e.attrs?.ip_address === void 0 && (e.attrs = { ...e.attrs, ip_address: '{{auto}}' })
          : void 0 === e.ipAddress && (e.ipAddress = '{{auto}}');
      }),
      (n.addAutoIpAddressToUser = function (e) {
        e.user?.ip_address === void 0 && (e.user = { ...e.user, ip_address: '{{auto}}' });
      }));
  },
  88313,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(32592);
    n.applySdkMetadata = function (e, t, n = [t], i = 'npm') {
      let o = e._metadata || {};
      (o.sdk ||
        (o.sdk = {
          name: `sentry.javascript.${t}`,
          packages: n.map((e) => ({ name: `${i}:@sentry/${e}`, version: r.SDK_VERSION })),
          version: r.SDK_VERSION,
        }),
        (e._metadata = o));
    };
  },
  25086,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23196),
      i = e.r(20434),
      o = e.r(6336),
      a = e.r(55842),
      s = e.r(13500),
      u = e.r(24205),
      l = e.r(22599),
      c = e.r(8612),
      d = e.r(26270);
    function p(e) {
      let { traceId: t, parentSpanId: n, parentSampled: r } = d.extractTraceparentData(e) || {};
      if (t && n) return `00-${t}-${n}-${r ? '01' : '00'}`;
    }
    ((n._sentryTraceToTraceParentHeader = p),
      (n.getTraceData = function (e = {}) {
        let t = e.client || o.getClient();
        if (!a.isEnabled() || !t) return {};
        let n = i.getMainCarrier(),
          _ = r.getAsyncContextStrategy(n);
        if (_.getTraceData) return _.getTraceData(e);
        let S = e.scope || o.getCurrentScope(),
          E = e.span || u.getActiveSpan(),
          T = E
            ? u.spanToTraceHeader(E)
            : (function (e) {
                let { traceId: t, sampled: n, propagationSpanId: r } = e.getPropagationContext();
                return d.generateSentryTraceHeader(t, r, n);
              })(S),
          m = E
            ? l.getDynamicSamplingContextFromSpan(E)
            : l.getDynamicSamplingContextFromScope(t, S),
          g = c.dynamicSamplingContextToSentryBaggageHeader(m);
        if (!d.TRACEPARENT_REGEXP.test(T))
          return (s.debug.warn('Invalid sentry-trace data. Cannot generate trace data'), {});
        let f = { 'sentry-trace': T, baggage: g };
        if (e.propagateTraceparent) {
          let e = p(T);
          e && (f.traceparent = e);
        }
        return f;
      }));
  },
  97121,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(25086);
    n.getTraceMetaTags = function (e) {
      return Object.entries(e || r.getTraceData())
        .map(([e, t]) => `<meta name="${e}" content="${t}"/>`)
        .join('\n');
    };
  },
  45143,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.debounce = function (e, t, n) {
        let r,
          i,
          o,
          a = n?.maxWait ? Math.max(n.maxWait, t) : 0,
          s = n?.setTimeoutImpl || setTimeout;
        function u() {
          return (l(), (r = e()));
        }
        function l() {
          (void 0 !== i && clearTimeout(i), void 0 !== o && clearTimeout(o), (i = o = void 0));
        }
        function c() {
          return (i && clearTimeout(i), (i = s(u, t)), a && void 0 === o && (o = s(u, a)), r);
        }
        return (
          (c.cancel = l),
          (c.flush = function () {
            return void 0 !== i || void 0 !== o ? u() : r;
          }),
          c
        );
      }));
  },
  82619,
  (e, t, n) => {
    function r(e) {
      let t = {};
      try {
        e.forEach((e, n) => {
          'string' == typeof e && (t[n] = e);
        });
      } catch {}
      return t;
    }
    function i(e) {
      let t = Object.create(null);
      try {
        Object.entries(e).forEach(([e, n]) => {
          'string' == typeof n && (t[e] = n);
        });
      } catch {}
      return t;
    }
    function o(e) {
      if (e)
        try {
          let t = new URL(e, 'http://s.io').search.slice(1);
          return t.length ? t : void 0;
        } catch {
          return;
        }
    }
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.extractQueryParamsFromUrl = o),
      (n.headersToDict = i),
      (n.httpRequestToRequestData = function (e) {
        let t = e.headers || {},
          n =
            ('string' == typeof t['x-forwarded-host'] ? t['x-forwarded-host'] : void 0) ||
            ('string' == typeof t.host ? t.host : void 0),
          r =
            ('string' == typeof t['x-forwarded-proto'] ? t['x-forwarded-proto'] : void 0) ||
            e.protocol ||
            (e.socket?.encrypted ? 'https' : 'http'),
          a = e.url || '',
          s = (function ({ url: e, protocol: t, host: n }) {
            return e?.startsWith('http') ? e : e && n ? `${t}://${n}${e}` : void 0;
          })({ url: a, host: n, protocol: r }),
          u = e.body || void 0,
          l = e.cookies;
        return { url: s, method: e.method, query_string: o(a), headers: i(t), cookies: l, data: u };
      }),
      (n.winterCGHeadersToDict = r),
      (n.winterCGRequestToRequestData = function (e) {
        let t = r(e.headers);
        return { method: e.method, url: e.url, query_string: o(e.url), headers: t };
      }));
  },
  53152,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(13500),
      o = e.r(28685);
    n.addBreadcrumb = function (e, t) {
      let n = r.getClient(),
        a = r.getIsolationScope();
      if (!n) return;
      let { beforeBreadcrumb: s = null, maxBreadcrumbs: u = 100 } = n.getOptions();
      if (u <= 0) return;
      let l = { timestamp: o.dateTimestampInSeconds(), ...e },
        c = s ? i.consoleSandbox(() => s(l, t)) : l;
      null !== c && (n.emit && n.emit('beforeAddBreadcrumb', c, t), a.addBreadcrumb(c, u));
    };
  },
  46773,
  (e, t, n) => {
    let r;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let i = e.r(6336),
      o = e.r(39059),
      a = e.r(63236),
      s = new WeakMap();
    n.functionToStringIntegration = o.defineIntegration(() => ({
      name: 'FunctionToString',
      setupOnce() {
        r = Function.prototype.toString;
        try {
          Function.prototype.toString = function (...e) {
            let t = a.getOriginalFunction(this),
              n = s.has(i.getClient()) && void 0 !== t ? t : this;
            return r.apply(n, e);
          };
        } catch {}
      },
      setup(e) {
        s.set(e, !0);
      },
    }));
  },
  26884,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(39059),
      o = e.r(13500),
      a = e.r(60610),
      s = e.r(21919),
      u = e.r(22111),
      l = [
        /^Script error\.?$/,
        /^Javascript error: Script error\.? on line 0$/,
        /^ResizeObserver loop completed with undelivered notifications.$/,
        /^Cannot redefine property: googletag$/,
        /^Can't find variable: gmo$/,
        /^undefined is not an object \(evaluating 'a\.[A-Z]'\)$/,
        'can\'t redefine non-configurable property "solana"',
        "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
        "Can't find variable: _AutofillCallbackHandler",
        /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/,
        /^Java exception was raised during method invocation$/,
      ],
      c = i.defineIntegration((e = {}) => {
        let t;
        return {
          name: 'EventFilters',
          setup(n) {
            t = p(e, n.getOptions());
          },
          processEvent: (n, i, l) => (
            t || (t = p(e, l.getOptions())),
            !(function (e, t) {
              if (e.type) {
                if (
                  'transaction' === e.type &&
                  (function (e, t) {
                    if (!t?.length) return !1;
                    let n = e.transaction;
                    return !!n && u.stringMatchesSomePattern(n, t);
                  })(e, t.ignoreTransactions)
                )
                  return (
                    r.DEBUG_BUILD &&
                      o.debug
                        .warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${s.getEventDescription(e)}`),
                    !0
                  );
              } else {
                var n, i, l;
                if (
                  ((n = e),
                  (i = t.ignoreErrors),
                  i?.length &&
                    a.getPossibleEventMessages(n).some((e) => u.stringMatchesSomePattern(e, i)))
                )
                  return (
                    r.DEBUG_BUILD &&
                      o.debug.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${s.getEventDescription(e)}`),
                    !0
                  );
                if (
                  ((l = e),
                  l.exception?.values?.length &&
                    !l.message &&
                    !l.exception.values.some(
                      (e) => e.stacktrace || (e.type && 'Error' !== e.type) || e.value
                    ))
                )
                  return (
                    r.DEBUG_BUILD &&
                      o.debug
                        .warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${s.getEventDescription(e)}`),
                    !0
                  );
                if (
                  (function (e, t) {
                    if (!t?.length) return !1;
                    let n = _(e);
                    return !!n && u.stringMatchesSomePattern(n, t);
                  })(e, t.denyUrls)
                )
                  return (
                    r.DEBUG_BUILD &&
                      o.debug.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${s.getEventDescription(e)}.
Url: ${_(e)}`),
                    !0
                  );
                if (
                  !(function (e, t) {
                    if (!t?.length) return !0;
                    let n = _(e);
                    return !n || u.stringMatchesSomePattern(n, t);
                  })(e, t.allowUrls)
                )
                  return (
                    r.DEBUG_BUILD &&
                      o.debug.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${s.getEventDescription(e)}.
Url: ${_(e)}`),
                    !0
                  );
              }
              return !1;
            })(n, t)
              ? n
              : null
          ),
        };
      }),
      d = i.defineIntegration((e = {}) => ({ ...c(e), name: 'InboundFilters' }));
    function p(e = {}, t = {}) {
      return {
        allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
        denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
        ignoreErrors: [
          ...(e.ignoreErrors || []),
          ...(t.ignoreErrors || []),
          ...(e.disableErrorDefaults ? [] : l),
        ],
        ignoreTransactions: [...(e.ignoreTransactions || []), ...(t.ignoreTransactions || [])],
      };
    }
    function _(e) {
      try {
        let t = [...(e.exception?.values ?? [])]
            .reverse()
            .find((e) => e.mechanism?.parent_id === void 0 && e.stacktrace?.frames?.length),
          n = t?.stacktrace?.frames;
        return n
          ? (function (e = []) {
              for (let t = e.length - 1; t >= 0; t--) {
                let n = e[t];
                if (n && '<anonymous>' !== n.filename && '[native code]' !== n.filename)
                  return n.filename || null;
              }
              return null;
            })(n)
          : null;
      } catch {
        return (
          r.DEBUG_BUILD &&
            o.debug.error(`Cannot extract url for event ${s.getEventDescription(e)}`),
          null
        );
      }
    }
    ((n.eventFiltersIntegration = c), (n.inboundFiltersIntegration = d));
  },
  57896,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802);
    function i(e, t) {
      ((e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
        (e.mechanism = {
          ...e.mechanism,
          ...('AggregateError' === e.type && { is_exception_group: !0 }),
          exception_id: t,
        }));
    }
    function o(e, t, n, r) {
      ((e.mechanism = e.mechanism || { type: 'generic', handled: !0 }),
        (e.mechanism = {
          ...e.mechanism,
          type: 'chained',
          source: t,
          exception_id: n,
          parent_id: r,
        }));
    }
    n.applyAggregateErrorsToEvent = function (e, t, n, a, s, u) {
      if (!s.exception?.values || !u || !r.isInstanceOf(u.originalException, Error)) return;
      let l =
        s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
      l &&
        (s.exception.values = (function e(t, n, a, s, u, l, c, d) {
          if (l.length >= a + 1) return l;
          let p = [...l];
          if (r.isInstanceOf(s[u], Error)) {
            i(c, d);
            let r = t(n, s[u]),
              l = p.length;
            (o(r, u, l, d), (p = e(t, n, a, s[u], u, [r, ...p], r, l)));
          }
          return (
            Array.isArray(s.errors) &&
              s.errors.forEach((s, l) => {
                if (r.isInstanceOf(s, Error)) {
                  i(c, d);
                  let r = t(n, s),
                    _ = p.length;
                  (o(r, `errors[${l}]`, _, d), (p = e(t, n, a, s, u, [r, ...p], r, _)));
                }
              }),
            p
          );
        })(e, t, a, u.originalException, n, s.exception.values, l, 0));
    };
  },
  82133,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(57896),
      o = e.r(30158);
    n.linkedErrorsIntegration = r.defineIntegration((e = {}) => {
      let t = e.limit || 5,
        n = e.key || 'cause';
      return {
        name: 'LinkedErrors',
        preprocessEvent(e, r, a) {
          let s = a.getOptions();
          i.applyAggregateErrorsToEvent(o.exceptionFromError, s.stackParser, n, t, e, r);
        },
      };
    });
  },
  75869,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(83247),
      i = new Map(),
      o = new Set();
    function a(e, t) {
      if (r.GLOBAL_OBJ._sentryModuleMetadata)
        for (let t of Object.keys(r.GLOBAL_OBJ._sentryModuleMetadata)) {
          let n = r.GLOBAL_OBJ._sentryModuleMetadata[t];
          if (!o.has(t)) {
            for (let r of (o.add(t), e(t).reverse()))
              if (r.filename) {
                i.set(r.filename, n);
                break;
              }
          }
        }
      return i.get(t);
    }
    ((n.addMetadataToStackFrames = function (e, t) {
      try {
        t.exception.values.forEach((t) => {
          if (t.stacktrace)
            for (let n of t.stacktrace.frames || []) {
              if (!n.filename || n.module_metadata) continue;
              let t = a(e, n.filename);
              t && (n.module_metadata = t);
            }
        });
      } catch {}
    }),
      (n.getMetadataForUrl = a),
      (n.stripMetadataFromStackFrames = function (e) {
        try {
          e.exception.values.forEach((e) => {
            if (e.stacktrace) for (let t of e.stacktrace.frames || []) delete t.module_metadata;
          });
        } catch {}
      }));
  },
  22540,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(75869),
      o = e.r(46274);
    n.moduleMetadataIntegration = r.defineIntegration(() => ({
      name: 'ModuleMetadata',
      setup(e) {
        (e.on('beforeEnvelope', (e) => {
          o.forEachEnvelopeItem(e, (e, t) => {
            if ('event' === t) {
              let t = Array.isArray(e) ? e[1] : void 0;
              t && (i.stripMetadataFromStackFrames(t), (e[1] = t));
            }
          });
        }),
          e.on('applyFrameMetadata', (t) => {
            if (t.type) return;
            let n = e.getOptions().stackParser;
            i.addMetadataToStackFrames(n, t);
          }));
      },
    }));
  },
  60797,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.parseCookie = function (e) {
        let t = {},
          n = 0;
        for (; n < e.length; ) {
          let r = e.indexOf('=', n);
          if (-1 === r) break;
          let i = e.indexOf(';', n);
          if (-1 === i) i = e.length;
          else if (i < r) {
            n = e.lastIndexOf(';', r - 1) + 1;
            continue;
          }
          let o = e.slice(n, r).trim();
          if (void 0 === t[o]) {
            let n = e.slice(r + 1, i).trim();
            34 === n.charCodeAt(0) && (n = n.slice(1, -1));
            try {
              t[o] = -1 !== n.indexOf('%') ? decodeURIComponent(n) : n;
            } catch {
              t[o] = n;
            }
          }
          n = i + 1;
        }
        return t;
      }));
  },
  87084,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = [
      'X-Client-IP',
      'X-Forwarded-For',
      'Fly-Client-IP',
      'CF-Connecting-IP',
      'Fastly-Client-Ip',
      'True-Client-Ip',
      'X-Real-IP',
      'X-Cluster-Client-IP',
      'X-Forwarded',
      'Forwarded-For',
      'Forwarded',
      'X-Vercel-Forwarded-For',
    ];
    ((n.getClientIPAddress = function (e) {
      return (
        r
          .map((t) => {
            let n = e[t],
              r = Array.isArray(n) ? n.join(';') : n;
            return 'Forwarded' === t
              ? (function (e) {
                  if (!e) return null;
                  for (let t of e.split(';')) if (t.startsWith('for=')) return t.slice(4);
                  return null;
                })(r)
              : r?.split(',').map((e) => e.trim());
          })
          .reduce((e, t) => (t ? e.concat(t) : e), [])
          .find((e) => {
            var t;
            return (
              null !== e &&
              ((t = e),
              /(?:^(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}$)|(?:^(?:(?:[a-fA-F\d]{1,4}:){7}(?:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|:[a-fA-F\d]{1,4}|:)|(?:[a-fA-F\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,2}|:)|(?:[a-fA-F\d]{1,4}:){4}(?:(?::[a-fA-F\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,3}|:)|(?:[a-fA-F\d]{1,4}:){3}(?:(?::[a-fA-F\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,4}|:)|(?:[a-fA-F\d]{1,4}:){2}(?:(?::[a-fA-F\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,5}|:)|(?:[a-fA-F\d]{1,4}:){1}(?:(?::[a-fA-F\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)(?:\\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)){3}|(?::[a-fA-F\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/.test(
                t
              ))
            );
          }) || null
      );
    }),
      (n.ipHeaderNames = r));
  },
  28496,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(60797),
      o = e.r(87084),
      a = { cookies: !0, data: !0, headers: !0, query_string: !0, url: !0 };
    n.requestDataIntegration = r.defineIntegration((e = {}) => {
      let t = { ...a, ...e.include };
      return {
        name: 'RequestData',
        processEvent(e, n, r) {
          let { sdkProcessingMetadata: a = {} } = e,
            { normalizedRequest: s, ipAddress: u } = a,
            l = { ...t, ip: t.ip ?? r.getOptions().sendDefaultPii };
          return (
            s &&
              (function (e, t, n, r) {
                if (
                  ((e.request = {
                    ...e.request,
                    ...(function (e, t) {
                      let n = {},
                        r = { ...e.headers };
                      return (
                        t.headers &&
                          ((n.headers = r),
                          t.cookies || delete r.cookie,
                          t.ip ||
                            o.ipHeaderNames.forEach((e) => {
                              delete r[e];
                            })),
                        (n.method = e.method),
                        t.url && (n.url = e.url),
                        t.cookies &&
                          (n.cookies =
                            e.cookies || (r?.cookie ? i.parseCookie(r.cookie) : void 0) || {}),
                        t.query_string && (n.query_string = e.query_string),
                        t.data && (n.data = e.data),
                        n
                      );
                    })(t, r),
                  }),
                  r.ip)
                ) {
                  let r = (t.headers && o.getClientIPAddress(t.headers)) || n.ipAddress;
                  r && (e.user = { ...e.user, ip_address: r });
                }
              })(e, s, { ipAddress: u }, l),
            e
          );
        },
      };
    });
  },
  10045,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13500),
      i = e.r(63236),
      o = e.r(83247),
      a = e.r(32801);
    function s() {
      'console' in o.GLOBAL_OBJ &&
        r.CONSOLE_LEVELS.forEach(function (e) {
          e in o.GLOBAL_OBJ.console &&
            i.fill(o.GLOBAL_OBJ.console, e, function (t) {
              return (
                (r.originalConsoleMethods[e] = t),
                function (...t) {
                  a.triggerHandlers('console', { args: t, level: e });
                  let n = r.originalConsoleMethods[e];
                  n?.apply(o.GLOBAL_OBJ.console, t);
                }
              );
            });
        });
    }
    n.addConsoleInstrumentationHandler = function (e) {
      let t = 'console';
      (a.addHandler(t, e), a.maybeInstrument(t, s));
    };
  },
  61302,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.severityLevelFromString = function (e) {
        return 'warn' === e
          ? 'warning'
          : ['fatal', 'error', 'warning', 'log', 'info', 'debug'].includes(e)
            ? e
            : 'log';
      }));
  },
  65849,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(55842),
      o = e.r(10045),
      a = e.r(39059),
      s = e.r(13500),
      u = e.r(21919),
      l = e.r(61302),
      c = e.r(22111),
      d = e.r(83247);
    n.captureConsoleIntegration = a.defineIntegration((e = {}) => {
      let t = e.levels || s.CONSOLE_LEVELS,
        n = e.handled ?? !0;
      return {
        name: 'CaptureConsole',
        setup(e) {
          'console' in d.GLOBAL_OBJ &&
            o.addConsoleInstrumentationHandler(({ args: o, level: a }) => {
              r.getClient() === e &&
                t.includes(a) &&
                (function (e, t, n) {
                  let o = { level: l.severityLevelFromString(t), extra: { arguments: e } };
                  r.withScope((r) => {
                    if (
                      (r.addEventProcessor(
                        (e) => (
                          (e.logger = 'console'),
                          u.addExceptionMechanism(e, { handled: n, type: 'console' }),
                          e
                        )
                      ),
                      'assert' === t)
                    ) {
                      if (!e[0]) {
                        let t = `Assertion failed: ${c.safeJoin(e.slice(1), ' ') || 'console.assert'}`;
                        (r.setExtra('arguments', e.slice(1)), i.captureMessage(t, o));
                      }
                      return;
                    }
                    let a = e.find((e) => e instanceof Error);
                    if (a) return void i.captureException(a, o);
                    let s = c.safeJoin(e, ' ');
                    i.captureMessage(s, o);
                  });
                })(o, a, n);
            });
        },
      };
    });
  },
  39169,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(39059),
      o = e.r(13500),
      a = e.r(87195),
      s = i.defineIntegration(() => {
        let e;
        return {
          name: 'Dedupe',
          processEvent(t) {
            if (t.type) return t;
            try {
              if (u(t, e))
                return (
                  r.DEBUG_BUILD &&
                    o.debug.warn(
                      'Event dropped due to being a duplicate of previously captured event.'
                    ),
                  null
                );
            } catch {}
            return (e = t);
          },
        };
      });
    function u(e, t) {
      return (
        !!t &&
        !!(
          (function (e, t) {
            let n = e.message,
              r = t.message;
            return (
              (!!n || !!r) && (!n || !!r) && (!!n || !r) && n === r && !!c(e, t) && !!l(e, t) && !0
            );
          })(e, t) ||
          (function (e, t) {
            let n = d(t),
              r = d(e);
            return !!n && !!r && n.type === r.type && n.value === r.value && !!c(e, t) && !!l(e, t);
          })(e, t)
        )
      );
    }
    function l(e, t) {
      let n = a.getFramesFromEvent(e),
        r = a.getFramesFromEvent(t);
      if (!n && !r) return !0;
      if ((n && !r) || (!n && r) || r.length !== n.length) return !1;
      for (let e = 0; e < r.length; e++) {
        let t = r[e],
          i = n[e];
        if (
          t.filename !== i.filename ||
          t.lineno !== i.lineno ||
          t.colno !== i.colno ||
          t.function !== i.function
        )
          return !1;
      }
      return !0;
    }
    function c(e, t) {
      let n = e.fingerprint,
        r = t.fingerprint;
      if (!n && !r) return !0;
      if ((n && !r) || (!n && r)) return !1;
      try {
        return n.join('') === r.join('');
      } catch {
        return !1;
      }
    }
    function d(e) {
      return e.exception?.values?.[0];
    }
    ((n._shouldDropEvent = u), (n.dedupeIntegration = s));
  },
  66243,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(39059),
      o = e.r(13500),
      a = e.r(2802),
      s = e.r(97548),
      u = e.r(63236),
      l = e.r(22111);
    n.extraErrorDataIntegration = i.defineIntegration((e = {}) => {
      let { depth: t = 3, captureErrorCause: n = !0 } = e;
      return {
        name: 'ExtraErrorData',
        processEvent(e, i, c) {
          let { maxValueLength: d = 250 } = c.getOptions();
          return (function (e, t = {}, n, i, c) {
            if (!t.originalException || !a.isError(t.originalException)) return e;
            let d = t.originalException.name || t.originalException.constructor.name,
              p = (function e(t, n, i) {
                try {
                  let r = [
                      'name',
                      'message',
                      'stack',
                      'line',
                      'column',
                      'fileName',
                      'lineNumber',
                      'columnNumber',
                      'toJSON',
                    ],
                    o = {};
                  for (let e of Object.keys(t)) {
                    if (-1 !== r.indexOf(e)) continue;
                    let n = t[e];
                    o[e] = a.isError(n) || 'string' == typeof n ? l.truncate(`${n}`, i) : n;
                  }
                  if (
                    (n &&
                      void 0 !== t.cause &&
                      (a.isError(t.cause)
                        ? (o.cause = {
                            [t.cause.name || t.cause.constructor.name]: e(t.cause, !1, i),
                          })
                        : (o.cause = t.cause)),
                    'function' == typeof t.toJSON)
                  ) {
                    let e = t.toJSON();
                    for (let t of Object.keys(e)) {
                      let n = e[t];
                      o[t] = a.isError(n) ? n.toString() : n;
                    }
                  }
                  return o;
                } catch (e) {
                  r.DEBUG_BUILD &&
                    o.debug.error('Unable to extract extra data from the Error object:', e);
                }
                return null;
              })(t.originalException, i, c);
            if (p) {
              let t = { ...e.contexts },
                r = s.normalize(p, n);
              return (
                a.isPlainObject(r) &&
                  (u.addNonEnumerableProperty(r, '__sentry_skip_normalization__', !0), (t[d] = r)),
                { ...e, contexts: t }
              );
            }
            return e;
          })(e, i, t, n, d);
        },
      };
    });
  },
  91995,
  (e, t, n) => {
    function r(e, t) {
      let n = 0;
      for (let t = e.length - 1; t >= 0; t--) {
        let r = e[t];
        '.' === r
          ? e.splice(t, 1)
          : '..' === r
            ? (e.splice(t, 1), n++)
            : n && (e.splice(t, 1), n--);
      }
      if (t) for (; n--; ) e.unshift('..');
      return e;
    }
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let i = /^(\S+:\\|\/?)([\s\S]*?)((?:\.{1,2}|[^/\\]+?|)(\.[^./\\]*|))(?:[/\\]*)$/;
    function o(e) {
      let t = e.length > 1024 ? `<truncated>${e.slice(-1024)}` : e,
        n = i.exec(t);
      return n ? n.slice(1) : [];
    }
    function a(...e) {
      let t = '',
        n = !1;
      for (let r = e.length - 1; r >= -1 && !n; r--) {
        let i = r >= 0 ? e[r] : '/';
        i && ((t = `${i}/${t}`), (n = '/' === i.charAt(0)));
      }
      return (
        (t = r(
          t.split('/').filter((e) => !!e),
          !n
        ).join('/')),
        (n ? '/' : '') + t || '.'
      );
    }
    function s(e) {
      let t = 0;
      for (; t < e.length && '' === e[t]; t++);
      let n = e.length - 1;
      for (; n >= 0 && '' === e[n]; n--);
      return t > n ? [] : e.slice(t, n - t + 1);
    }
    function u(e) {
      let t = l(e),
        n = '/' === e.slice(-1),
        i = r(
          e.split('/').filter((e) => !!e),
          !t
        ).join('/');
      return (i || t || (i = '.'), i && n && (i += '/'), (t ? '/' : '') + i);
    }
    function l(e) {
      return '/' === e.charAt(0);
    }
    ((n.basename = function (e, t) {
      let n = o(e)[2] || '';
      return (t && n.slice(-1 * t.length) === t && (n = n.slice(0, n.length - t.length)), n);
    }),
      (n.dirname = function (e) {
        let t = o(e),
          n = t[0] || '',
          r = t[1];
        return n || r ? (r && (r = r.slice(0, r.length - 1)), n + r) : '.';
      }),
      (n.isAbsolute = l),
      (n.join = function (...e) {
        return u(e.join('/'));
      }),
      (n.normalizePath = u),
      (n.relative = function (e, t) {
        ((e = a(e).slice(1)), (t = a(t).slice(1)));
        let n = s(e.split('/')),
          r = s(t.split('/')),
          i = Math.min(n.length, r.length),
          o = i;
        for (let e = 0; e < i; e++)
          if (n[e] !== r[e]) {
            o = e;
            break;
          }
        let u = [];
        for (let e = o; e < n.length; e++) u.push('..');
        return (u = u.concat(r.slice(o))).join('/');
      }),
      (n.resolve = a));
  },
  71998,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(91995),
      o = e.r(83247),
      a = r.defineIntegration((e = {}) => {
        let t = e.root,
          n = e.prefix || 'app:///',
          r = 'window' in o.GLOBAL_OBJ && !!o.GLOBAL_OBJ.window,
          i = e.iteratee || s({ isBrowser: r, root: t, prefix: n });
        return {
          name: 'RewriteFrames',
          processEvent(e) {
            let t = e;
            return (
              e.exception &&
                Array.isArray(e.exception.values) &&
                (t = (function (e) {
                  try {
                    return {
                      ...e,
                      exception: {
                        ...e.exception,
                        values: e.exception.values.map((e) => {
                          var t;
                          return {
                            ...e,
                            ...(e.stacktrace && {
                              stacktrace: {
                                ...(t = e.stacktrace),
                                frames: t?.frames?.map((e) => i(e)),
                              },
                            }),
                          };
                        }),
                      },
                    };
                  } catch {
                    return e;
                  }
                })(t)),
              t
            );
          },
        };
      });
    function s({ isBrowser: e, root: t, prefix: n }) {
      return (r) => {
        if (!r.filename) return r;
        let o =
            /^[a-zA-Z]:\\/.test(r.filename) ||
            (r.filename.includes('\\') && !r.filename.includes('/')),
          a = /^\//.test(r.filename);
        if (e) {
          if (t) {
            let e = r.filename;
            0 === e.indexOf(t) && (r.filename = e.replace(t, n));
          }
        } else if (o || a) {
          let e = o ? r.filename.replace(/^[a-zA-Z]:/, '').replace(/\\/g, '/') : r.filename,
            a = t ? i.relative(t, e) : i.basename(e);
          r.filename = `${n}${a}`;
        }
        return r;
      };
    }
    ((n.generateIteratee = s), (n.rewriteFramesIntegration = a));
  },
  98348,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(53152),
      i = e.r(65553),
      o = e.r(55842),
      a = e.r(39059),
      s = e.r(13801),
      u = e.r(13500),
      l = e.r(21919),
      c = e.r(2802),
      d = e.r(72517),
      p = e.r(66744),
      _ = [
        'reauthenticate',
        'signInAnonymously',
        'signInWithOAuth',
        'signInWithIdToken',
        'signInWithOtp',
        'signInWithPassword',
        'signInWithSSO',
        'signOut',
        'signUp',
        'verifyOtp',
      ],
      S = [
        'createUser',
        'deleteUser',
        'listUsers',
        'getUserById',
        'updateUserById',
        'inviteUserByEmail',
      ],
      E = {
        eq: 'eq',
        neq: 'neq',
        gt: 'gt',
        gte: 'gte',
        lt: 'lt',
        lte: 'lte',
        like: 'like',
        'like(all)': 'likeAllOf',
        'like(any)': 'likeAnyOf',
        ilike: 'ilike',
        'ilike(all)': 'ilikeAllOf',
        'ilike(any)': 'ilikeAnyOf',
        is: 'is',
        in: 'in',
        cs: 'contains',
        cd: 'containedBy',
        sr: 'rangeGt',
        nxl: 'rangeGte',
        sl: 'rangeLt',
        nxr: 'rangeLte',
        adj: 'rangeAdjacent',
        ov: 'overlaps',
        fts: '',
        plfts: 'plain',
        phfts: 'phrase',
        wfts: 'websearch',
        not: 'not',
      },
      T = ['select', 'insert', 'upsert', 'update', 'delete'];
    function m(e) {
      try {
        e.__SENTRY_INSTRUMENTED__ = !0;
      } catch {}
    }
    function g(e) {
      try {
        return e.__SENTRY_INSTRUMENTED__;
      } catch {
        return !1;
      }
    }
    function f(e, t = {}) {
      switch (e) {
        case 'GET':
          return 'select';
        case 'POST':
          if (t.Prefer?.includes('resolution=')) return 'upsert';
          return 'insert';
        case 'PATCH':
          return 'update';
        case 'DELETE':
          return 'delete';
        default:
          return '<unknown-op>';
      }
    }
    function h(e, t) {
      let n;
      if ('' === t || '*' === t) return 'select(*)';
      if ('select' === e) return `select(${t})`;
      if ('or' === e || e.endsWith('.or')) return `${e}${t}`;
      let [r, ...i] = t.split('.');
      return (
        (n = r?.startsWith('fts')
          ? 'textSearch'
          : r?.startsWith('plfts')
            ? 'textSearch[plain]'
            : r?.startsWith('phfts')
              ? 'textSearch[phrase]'
              : r?.startsWith('wfts')
                ? 'textSearch[websearch]'
                : (r && E[r]) || 'filter'),
        `${n}(${e}, ${i.join('.')})`
      );
    }
    function A(e, t = !1) {
      return new Proxy(e, {
        apply: (n, r, i) =>
          p.startSpan(
            {
              name: `auth ${t ? '(admin) ' : ''}${e.name}`,
              attributes: {
                [s.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',
                [s.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',
                'db.system': 'postgresql',
                'db.operation': `auth.${t ? 'admin.' : ''}${e.name}`,
              },
            },
            (e) =>
              Reflect.apply(n, r, i)
                .then(
                  (t) => (
                    t && 'object' == typeof t && 'error' in t && t.error
                      ? (e.setStatus({ code: d.SPAN_STATUS_ERROR }),
                        o.captureException(t.error, {
                          mechanism: { handled: !1, type: 'auto.db.supabase.auth' },
                        }))
                      : e.setStatus({ code: d.SPAN_STATUS_OK }),
                    e.end(),
                    t
                  )
                )
                .catch((t) => {
                  throw (
                    e.setStatus({ code: d.SPAN_STATUS_ERROR }),
                    e.end(),
                    o.captureException(t, {
                      mechanism: { handled: !1, type: 'auto.db.supabase.auth' },
                    }),
                    t
                  );
                })
                .then(...i)
          ),
      });
    }
    let R = (e) => {
        if (!e) {
          i.DEBUG_BUILD &&
            u.debug.warn(
              'Supabase integration was not installed because no Supabase client was provided.'
            );
          return;
        }
        (!(function (e) {
          g(e.prototype.from) ||
            ((e.prototype.from = new Proxy(e.prototype.from, {
              apply(e, t, n) {
                let a = Reflect.apply(e, t, n);
                return (
                  (function (e) {
                    for (let t of T)
                      g(e.prototype[t]) ||
                        ((e.prototype[t] = new Proxy(e.prototype[t], {
                          apply(e, n, a) {
                            let _ = Reflect.apply(e, n, a),
                              S = _.constructor;
                            return (
                              i.DEBUG_BUILD &&
                                u.debug.log(
                                  `Instrumenting ${t} operation's PostgRESTFilterBuilder`
                                ),
                              g(S.prototype.then) ||
                                ((S.prototype.then = new Proxy(S.prototype.then, {
                                  apply(e, t, n) {
                                    let i = f(t.method, t.headers);
                                    if (
                                      !T.includes(i) ||
                                      !t?.url?.pathname ||
                                      'string' != typeof t.url.pathname
                                    )
                                      return Reflect.apply(e, t, n);
                                    let a = t.url.pathname.split('/'),
                                      u = a.length > 0 ? a[a.length - 1] : '',
                                      _ = [];
                                    for (let [e, n] of t.url.searchParams.entries())
                                      _.push(h(e, n));
                                    let S = Object.create(null);
                                    if (c.isPlainObject(t.body))
                                      for (let [e, n] of Object.entries(t.body)) S[e] = n;
                                    let E = `${'select' === i ? '' : `${i}${S ? '(...) ' : ''}`}${_.join(' ')} from(${u})`,
                                      m = {
                                        'db.table': u,
                                        'db.schema': t.schema,
                                        'db.url': t.url.origin,
                                        'db.sdk': t.headers['X-Client-Info'],
                                        'db.system': 'postgresql',
                                        'db.operation': i,
                                        [s.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.db.supabase',
                                        [s.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'db',
                                      };
                                    return (
                                      _.length && (m['db.query'] = _),
                                      Object.keys(S).length && (m['db.body'] = S),
                                      p.startSpan({ name: E, attributes: m }, (a) =>
                                        Reflect.apply(e, t, [])
                                          .then(
                                            (e) => {
                                              if (
                                                (a &&
                                                  (e &&
                                                    'object' == typeof e &&
                                                    'status' in e &&
                                                    d.setHttpStatus(a, e.status || 500),
                                                  a.end()),
                                                e.error)
                                              ) {
                                                let t = Error(e.error.message);
                                                (e.error.code && (t.code = e.error.code),
                                                  e.error.details && (t.details = e.error.details));
                                                let n = {};
                                                (_.length && (n.query = _),
                                                  Object.keys(S).length && (n.body = S),
                                                  o.captureException(
                                                    t,
                                                    (e) => (
                                                      e.addEventProcessor(
                                                        (e) => (
                                                          l.addExceptionMechanism(e, {
                                                            handled: !1,
                                                            type: 'auto.db.supabase.postgres',
                                                          }),
                                                          e
                                                        )
                                                      ),
                                                      e.setContext('supabase', n),
                                                      e
                                                    )
                                                  ));
                                              }
                                              let t = {
                                                  type: 'supabase',
                                                  category: `db.${i}`,
                                                  message: E,
                                                },
                                                n = {};
                                              return (
                                                _.length && (n.query = _),
                                                Object.keys(S).length && (n.body = S),
                                                Object.keys(n).length && (t.data = n),
                                                r.addBreadcrumb(t),
                                                e
                                              );
                                            },
                                            (e) => {
                                              throw (a && (d.setHttpStatus(a, 500), a.end()), e);
                                            }
                                          )
                                          .then(...n)
                                      )
                                    );
                                  },
                                })),
                                m(S.prototype.then)),
                              _
                            );
                          },
                        })),
                        m(e.prototype[t]));
                  })(a.constructor),
                  a
                );
              },
            })),
            m(e.prototype.from));
        })(e.constructor === Function ? e : e.constructor),
          (function (e) {
            let t = e.auth;
            if (!(!t || g(e.auth))) {
              for (let n of _) {
                let r = t[n];
                r && 'function' == typeof e.auth[n] && (e.auth[n] = A(r));
              }
              for (let n of S) {
                let r = t.admin[n];
                r && 'function' == typeof e.auth.admin[n] && (e.auth.admin[n] = A(r, !0));
              }
              m(e.auth);
            }
          })(e));
      },
      y = a.defineIntegration((e) => {
        let t;
        return (
          (t = e.supabaseClient),
          {
            setupOnce() {
              R(t);
            },
            name: 'Supabase',
          }
        );
      });
    ((n.DB_OPERATIONS_TO_INSTRUMENT = T),
      (n.FILTER_MAPPINGS = E),
      (n.extractOperation = f),
      (n.instrumentSupabaseClient = R),
      (n.supabaseIntegration = y),
      (n.translateFiltersIntoMethods = h));
  },
  41094,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(2802),
      o = e.r(22111);
    function a(e) {
      return {
        ...e,
        path: 'path' in e && Array.isArray(e.path) ? e.path.join('.') : void 0,
        keys: 'keys' in e ? JSON.stringify(e.keys) : void 0,
        unionErrors: 'unionErrors' in e ? JSON.stringify(e.unionErrors) : void 0,
      };
    }
    function s(e) {
      return e.map((e) => ('number' == typeof e ? '<array>' : e)).join('.');
    }
    function u(e) {
      let t = new Set();
      for (let n of e.issues) {
        let e = s(n.path);
        e.length > 0 && t.add(e);
      }
      let n = Array.from(t);
      if (0 === n.length) {
        let t = 'variable';
        if (e.issues.length > 0) {
          let n = e.issues[0];
          void 0 !== n && 'expected' in n && 'string' == typeof n.expected && (t = n.expected);
        }
        return `Failed to validate ${t}`;
      }
      return `Failed to validate keys: ${o.truncate(n.join(', '), 100)}`;
    }
    function l(e, t = !1, n, r) {
      var o;
      if (
        !n.exception?.values ||
        !r.originalException ||
        ((o = r.originalException),
        !(i.isError(o) && 'ZodError' === o.name && Array.isArray(o.issues))) ||
        0 === r.originalException.issues.length
      )
        return n;
      try {
        let i = (t ? r.originalException.issues : r.originalException.issues.slice(0, e)).map(a);
        return (
          t &&
            (Array.isArray(r.attachments) || (r.attachments = []),
            r.attachments.push({
              filename: 'zod_issues.json',
              data: JSON.stringify({ issues: i }),
            })),
          {
            ...n,
            exception: {
              ...n.exception,
              values: [
                { ...n.exception.values[0], value: u(r.originalException) },
                ...n.exception.values.slice(1),
              ],
            },
            extra: { ...n.extra, 'zoderror.issues': i.slice(0, e) },
          }
        );
      } catch (e) {
        return {
          ...n,
          extra: {
            ...n.extra,
            'zoderrors sentry integration parse error': {
              message:
                'an exception was thrown while processing ZodError within applyZodErrorsToEvent()',
              error:
                e instanceof Error
                  ? `${e.name}: ${e.message}
${e.stack}`
                  : 'unknown',
            },
          },
        };
      }
    }
    let c = r.defineIntegration((e = {}) => {
      let t = e.limit ?? 10;
      return { name: 'ZodErrors', processEvent: (n, r) => l(t, e.saveZodIssuesAsAttachment, n, r) };
    });
    ((n.applyZodErrorsToEvent = l),
      (n.flattenIssue = a),
      (n.flattenIssuePath = s),
      (n.formatIssueMessage = u),
      (n.zodErrorsIntegration = c));
  },
  98720,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(75869),
      o = e.r(46274),
      a = e.r(87195),
      s = r.defineIntegration((e) => ({
        name: 'ThirdPartyErrorsFilter',
        setup(e) {
          (e.on('beforeEnvelope', (e) => {
            o.forEachEnvelopeItem(e, (e, t) => {
              if ('event' === t) {
                let t = Array.isArray(e) ? e[1] : void 0;
                t && (i.stripMetadataFromStackFrames(t), (e[1] = t));
              }
            });
          }),
            e.on('applyFrameMetadata', (t) => {
              if (t.type) return;
              let n = e.getOptions().stackParser;
              i.addMetadataToStackFrames(n, t);
            }));
        },
        processEvent(t) {
          let n = (function (e) {
            let t = a.getFramesFromEvent(e);
            if (t)
              return t
                .filter((e) => !!e.filename)
                .map((e) =>
                  e.module_metadata
                    ? Object.keys(e.module_metadata)
                        .filter((e) => e.startsWith(u))
                        .map((e) => e.slice(u.length))
                    : []
                );
          })(t);
          if (
            n &&
            n[
              'drop-error-if-contains-third-party-frames' === e.behaviour ||
              'apply-tag-if-contains-third-party-frames' === e.behaviour
                ? 'some'
                : 'every'
            ]((t) => !t.some((t) => e.filterKeys.includes(t)))
          ) {
            if (
              'drop-error-if-contains-third-party-frames' === e.behaviour ||
              'drop-error-if-exclusively-contains-third-party-frames' === e.behaviour
            )
              return null;
            t.tags = { ...t.tags, third_party_code: !0 };
          }
          return t;
        },
      })),
      u = '_sentryBundlerPluginAppKey:';
    n.thirdPartyErrorFilterIntegration = s;
  },
  82063,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(53152),
      i = e.r(6336),
      o = e.r(10045),
      a = e.r(39059),
      s = e.r(13500),
      u = e.r(61302),
      l = e.r(22111),
      c = e.r(83247),
      d = a.defineIntegration((e = {}) => {
        let t = new Set(e.levels || s.CONSOLE_LEVELS);
        return {
          name: 'Console',
          setup(e) {
            o.addConsoleInstrumentationHandler(({ args: n, level: r }) => {
              i.getClient() === e && t.has(r) && p(r, n);
            });
          },
        };
      });
    function p(e, t) {
      let n = {
        category: 'console',
        data: { arguments: t, logger: 'console' },
        level: u.severityLevelFromString(e),
        message: _(t),
      };
      if ('assert' === e)
        if (!1 !== t[0]) return;
        else {
          let e = t.slice(1);
          ((n.message = e.length > 0 ? `Assertion failed: ${_(e)}` : 'Assertion failed'),
            (n.data.arguments = e));
        }
      r.addBreadcrumb(n, { input: t, level: e });
    }
    function _(e) {
      return 'util' in c.GLOBAL_OBJ && 'function' == typeof c.GLOBAL_OBJ.util.format
        ? c.GLOBAL_OBJ.util.format(...e)
        : l.safeJoin(e, ' ');
    }
    ((n.addConsoleBreadcrumb = p), (n.consoleIntegration = d));
  },
  81130,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(13500),
      a = e.r(24205),
      s = 'flag.evaluation.';
    function u(e, t, n, r) {
      if ('boolean' != typeof n) return;
      if (e.length > r) {
        i.DEBUG_BUILD &&
          o.debug.error(
            `[Feature Flags] insertToFlagBuffer called on a buffer larger than maxSize=${r}`
          );
        return;
      }
      let a = e.findIndex((e) => e.flag === t);
      (-1 !== a && e.splice(a, 1), e.length === r && e.shift(), e.push({ flag: t, result: n }));
    }
    ((n._INTERNAL_FLAG_BUFFER_SIZE = 100),
      (n._INTERNAL_MAX_FLAGS_PER_SPAN = 10),
      (n._INTERNAL_addFeatureFlagToActiveSpan = function (e, t, n = 10) {
        if ('boolean' != typeof t) return;
        let r = a.getActiveSpan();
        if (!r) return;
        let i = a.spanToJSON(r).data;
        if (`${s}${e}` in i) return void r.setAttribute(`${s}${e}`, t);
        Object.keys(i).filter((e) => e.startsWith(s)).length < n && r.setAttribute(`${s}${e}`, t);
      }),
      (n._INTERNAL_copyFlagsFromScopeToEvent = function (e) {
        let t = r.getCurrentScope().getScopeData().contexts.flags,
          n = t ? t.values : [];
        return (
          n.length &&
            (void 0 === e.contexts && (e.contexts = {}), (e.contexts.flags = { values: [...n] })),
          e
        );
      }),
      (n._INTERNAL_insertFlagToScope = function (e, t, n = 100) {
        let i = r.getCurrentScope().getScopeData().contexts;
        (i.flags || (i.flags = { values: [] }), u(i.flags.values, e, t, n));
      }),
      (n._INTERNAL_insertToFlagBuffer = u));
  },
  6355,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(39059),
      i = e.r(81130);
    n.featureFlagsIntegration = r.defineIntegration(() => ({
      name: 'FeatureFlags',
      processEvent: (e, t, n) => i._INTERNAL_copyFlagsFromScopeToEvent(e),
      addFeatureFlag(e, t) {
        (i._INTERNAL_insertFlagToScope(e, t), i._INTERNAL_addFeatureFlagToActiveSpan(e, t));
      },
    }));
  },
  26129,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(13500);
    function a(e) {
      return (
        !!e &&
        void 0 !== e._profiler &&
        'function' == typeof e._profiler.start &&
        'function' == typeof e._profiler.stop
      );
    }
    n.profiler = {
      startProfiler: function () {
        let e = r.getClient();
        if (!e) {
          i.DEBUG_BUILD && o.debug.warn('No Sentry client available, profiling is not started');
          return;
        }
        let t = e.getIntegrationByName('ProfilingIntegration');
        if (!t) {
          i.DEBUG_BUILD && o.debug.warn('ProfilingIntegration is not available');
          return;
        }
        if (!a(t)) {
          i.DEBUG_BUILD && o.debug.warn('Profiler is not available on profiling integration.');
          return;
        }
        t._profiler.start();
      },
      stopProfiler: function () {
        let e = r.getClient();
        if (!e) {
          i.DEBUG_BUILD && o.debug.warn('No Sentry client available, profiling is not started');
          return;
        }
        let t = e.getIntegrationByName('ProfilingIntegration');
        if (!t) {
          i.DEBUG_BUILD && o.debug.warn('ProfilingIntegration is not available');
          return;
        }
        if (!a(t)) {
          i.DEBUG_BUILD && o.debug.warn('Profiler is not available on profiling integration.');
          return;
        }
        t._profiler.stop();
      },
    };
  },
  79892,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(13801),
      o = e.r(24205),
      a = e.r(72517),
      s = e.r(2802),
      u = e.r(9338),
      l = e.r(8612),
      c = e.r(29946),
      d = e.r(66744),
      p = e.r(25086),
      _ = e.r(16097);
    function S(e, t, n, r) {
      var i;
      let o = p.getTraceData({ span: n, propagateTraceparent: r }),
        a = o['sentry-trace'],
        u = o.baggage,
        l = o.traceparent;
      if (!a) return;
      let c = t.headers || (s.isRequest(e) ? e.headers : void 0);
      if (!c) return { ...o };
      if (((i = c), 'undefined' != typeof Headers && s.isInstanceOf(i, Headers))) {
        let e = new Headers(c);
        if (
          (e.get('sentry-trace') || e.set('sentry-trace', a),
          r && l && !e.get('traceparent') && e.set('traceparent', l),
          u)
        ) {
          let t = e.get('baggage');
          t ? E(t) || e.set('baggage', `${t},${u}`) : e.set('baggage', u);
        }
        return e;
      }
      if (Array.isArray(c)) {
        let e = [...c];
        (c.find((e) => 'sentry-trace' === e[0]) || e.push(['sentry-trace', a]),
          r && l && !c.find((e) => 'traceparent' === e[0]) && e.push(['traceparent', l]));
        let t = c.find((e) => 'baggage' === e[0] && E(e[1]));
        return (u && !t && e.push(['baggage', u]), e);
      }
      {
        let e = 'sentry-trace' in c ? c['sentry-trace'] : void 0,
          t = 'traceparent' in c ? c.traceparent : void 0,
          n = 'baggage' in c ? c.baggage : void 0,
          i = n ? (Array.isArray(n) ? [...n] : [n]) : [],
          o = n && (Array.isArray(n) ? n.find((e) => E(e)) : E(n));
        u && !o && i.push(u);
        let s = { ...c, 'sentry-trace': e ?? a, baggage: i.length > 0 ? i.join(',') : void 0 };
        return (r && l && !t && (s.traceparent = l), s);
      }
    }
    function E(e) {
      return e.split(',').some((e) => e.trim().startsWith(l.SENTRY_BAGGAGE_KEY_PREFIX));
    }
    ((n._addTracingHeadersToFetchRequest = S),
      (n.instrumentFetchRequest = function (e, t, n, s, l) {
        if (!e.fetchData) return;
        let { method: p, url: E } = e.fetchData,
          T = u.hasSpansEnabled() && t(E);
        if (e.endTimestamp && T) {
          let t = e.fetchData.__span;
          if (!t) return;
          let n = s[t];
          n &&
            ((function (e, t) {
              if (t.response) {
                a.setHttpStatus(e, t.response.status);
                let n = t.response?.headers?.get('content-length');
                if (n) {
                  let t = parseInt(n);
                  t > 0 && e.setAttribute('http.response_content_length', t);
                }
              } else
                t.error && e.setStatus({ code: a.SPAN_STATUS_ERROR, message: 'internal_error' });
              e.end();
            })(n, e),
            delete s[t]);
          return;
        }
        let { spanOrigin: m = 'auto.http.browser', propagateTraceparent: g = !1 } =
            'object' == typeof l ? l : { spanOrigin: l },
          f = !!o.getActiveSpan(),
          h =
            T && f
              ? d.startInactiveSpan(
                  (function (e, t, n) {
                    let r = _.parseStringToURLObject(e);
                    return {
                      name: r ? `${t} ${_.getSanitizedUrlStringFromUrlObject(r)}` : t,
                      attributes: (function (e, t, n, r) {
                        let o = {
                          url: e,
                          type: 'fetch',
                          'http.method': n,
                          [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: r,
                          [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',
                        };
                        return (
                          t &&
                            (_.isURLObjectRelative(t) ||
                              ((o['http.url'] = t.href), (o['server.address'] = t.host)),
                            t.search && (o['http.query'] = t.search),
                            t.hash && (o['http.fragment'] = t.hash)),
                          o
                        );
                      })(e, r, t, n),
                    };
                  })(E, p, m)
                )
              : new c.SentryNonRecordingSpan();
        if (
          ((e.fetchData.__span = h.spanContext().spanId),
          (s[h.spanContext().spanId] = h),
          n(e.fetchData.url))
        ) {
          let t = e.args[0],
            n = e.args[1] || {},
            r = S(t, n, u.hasSpansEnabled() && f ? h : void 0, g);
          r && ((e.args[1] = n), (n.headers = r));
        }
        let A = r.getClient();
        if (A) {
          let t = {
            input: e.args,
            response: e.response,
            startTimestamp: e.startTimestamp,
            endTimestamp: e.endTimestamp,
          };
          A.emit('beforeOutgoingRequestSpan', h, t);
        }
        return h;
      }));
  },
  51266,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(55842),
      o = e.r(13801),
      a = e.r(63236),
      s = e.r(97548),
      u = e.r(66744),
      l = { mechanism: { handled: !1, data: { function: 'trpcMiddleware' } } };
    n.trpcMiddleware = function (e = {}) {
      return async function (t) {
        let { path: n, type: c, next: d, rawInput: p, getRawInput: _ } = t,
          S = r.getClient(),
          E = S?.getOptions(),
          T = { procedure_path: n, procedure_type: c };
        if (
          (a.addNonEnumerableProperty(
            T,
            '__sentry_override_normalization_depth__',
            1 + (E?.normalizeDepth ?? 5)
          ),
          (void 0 !== e.attachRpcInput ? e.attachRpcInput : E?.sendDefaultPii) &&
            (void 0 !== p && (T.input = s.normalize(p)), void 0 !== _ && 'function' == typeof _))
        )
          try {
            let e = await _();
            T.input = s.normalize(e);
          } catch {}
        return r.withIsolationScope(
          (t) => (
            t.setContext('trpc', T),
            u.startSpanManual(
              {
                name: `trpc/${n}`,
                op: 'rpc.server',
                attributes: {
                  [o.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                  [o.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc',
                },
                forceTransaction: !!e.forceTransaction,
              },
              async (e) => {
                try {
                  let t = await d();
                  return (
                    'object' == typeof t &&
                      null !== t &&
                      'ok' in t &&
                      !t.ok &&
                      'error' in t &&
                      i.captureException(t.error, l),
                    e.end(),
                    t
                  );
                } catch (t) {
                  throw (i.captureException(t, l), e.end(), t);
                }
              }
            )
          )
        );
      };
    };
  },
  95958,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(55842),
      o = e.r(24205),
      a = e.r(72517);
    n.captureError = function (e, t, n) {
      try {
        if (!r.getClient()) return;
        let s = o.getActiveSpan();
        (s?.isRecording() && s.setStatus({ code: a.SPAN_STATUS_ERROR, message: 'internal_error' }),
          i.captureException(e, {
            mechanism: {
              type: 'mcp_server',
              handled: !1,
              data: { error_type: t || 'handler_execution', ...n },
            },
          }));
      } catch {}
    };
  },
  23213,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(63236),
      a = e.r(95958);
    function s(e, t) {
      o.fill(
        e,
        t,
        (e) =>
          function (n, ...o) {
            var a, s, l;
            let c = o[o.length - 1];
            if ('function' != typeof c) return e.call(this, n, ...o);
            let d =
              ((a = c),
              (s = t),
              (l = n),
              function (...e) {
                try {
                  return u.call(this, a, s, l, e);
                } catch (t) {
                  return (
                    r.DEBUG_BUILD && i.debug.warn('MCP handler wrapping failed:', t),
                    a.apply(this, e)
                  );
                }
              });
            return e.call(this, n, ...o.slice(0, -1), d);
          }
      );
    }
    function u(e, t, n, r) {
      try {
        let i = e.apply(this, r);
        if (i && 'object' == typeof i && 'function' == typeof i.then)
          return Promise.resolve(i).catch((e) => {
            throw (l(e, t, n), e);
          });
        return i;
      } catch (e) {
        throw (l(e, t, n), e);
      }
    }
    function l(e, t, n) {
      try {
        let r = {};
        'tool' === t
          ? ((r.tool_name = n),
            'ProtocolValidationError' === e.name ||
            e.message.includes('validation') ||
            e.message.includes('protocol')
              ? a.captureError(e, 'validation', r)
              : 'ServerTimeoutError' === e.name ||
                  e.message.includes('timed out') ||
                  e.message.includes('timeout')
                ? a.captureError(e, 'timeout', r)
                : a.captureError(e, 'tool_execution', r))
          : 'resource' === t
            ? ((r.resource_uri = n), a.captureError(e, 'resource_execution', r))
            : 'prompt' === t && ((r.prompt_name = n), a.captureError(e, 'prompt_execution', r));
      } catch (e) {}
    }
    function c(e) {
      s(e, 'tool');
    }
    function d(e) {
      s(e, 'resource');
    }
    function p(e) {
      s(e, 'prompt');
    }
    ((n.wrapAllMCPHandlers = function (e) {
      (c(e), d(e), p(e));
    }),
      (n.wrapPromptHandlers = p),
      (n.wrapResourceHandlers = d),
      (n.wrapToolHandlers = c));
  },
  13907,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.CLIENT_ADDRESS_ATTRIBUTE = 'client.address'),
      (n.CLIENT_PORT_ATTRIBUTE = 'client.port'),
      (n.MCP_FUNCTION_ORIGIN_VALUE = 'auto.function.mcp_server'),
      (n.MCP_LOGGING_DATA_TYPE_ATTRIBUTE = 'mcp.logging.data_type'),
      (n.MCP_LOGGING_LEVEL_ATTRIBUTE = 'mcp.logging.level'),
      (n.MCP_LOGGING_LOGGER_ATTRIBUTE = 'mcp.logging.logger'),
      (n.MCP_LOGGING_MESSAGE_ATTRIBUTE = 'mcp.logging.message'),
      (n.MCP_METHOD_NAME_ATTRIBUTE = 'mcp.method.name'),
      (n.MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE = 'mcp.notification.client_to_server'),
      (n.MCP_NOTIFICATION_ORIGIN_VALUE = 'auto.mcp.notification'),
      (n.MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE = 'mcp.notification.server_to_client'),
      (n.MCP_PROMPT_NAME_ATTRIBUTE = 'mcp.prompt.name'),
      (n.MCP_PROMPT_RESULT_DESCRIPTION_ATTRIBUTE = 'mcp.prompt.result.description'),
      (n.MCP_PROMPT_RESULT_MESSAGE_CONTENT_ATTRIBUTE = 'mcp.prompt.result.message_content'),
      (n.MCP_PROMPT_RESULT_MESSAGE_COUNT_ATTRIBUTE = 'mcp.prompt.result.message_count'),
      (n.MCP_PROMPT_RESULT_PREFIX = 'mcp.prompt.result'),
      (n.MCP_PROTOCOL_VERSION_ATTRIBUTE = 'mcp.protocol.version'),
      (n.MCP_REQUEST_ARGUMENT = 'mcp.request.argument'),
      (n.MCP_REQUEST_ID_ATTRIBUTE = 'mcp.request.id'),
      (n.MCP_RESOURCE_URI_ATTRIBUTE = 'mcp.resource.uri'),
      (n.MCP_ROUTE_SOURCE_VALUE = 'route'),
      (n.MCP_SERVER_NAME_ATTRIBUTE = 'mcp.server.name'),
      (n.MCP_SERVER_OP_VALUE = 'mcp.server'),
      (n.MCP_SERVER_TITLE_ATTRIBUTE = 'mcp.server.title'),
      (n.MCP_SERVER_VERSION_ATTRIBUTE = 'mcp.server.version'),
      (n.MCP_SESSION_ID_ATTRIBUTE = 'mcp.session.id'),
      (n.MCP_TOOL_NAME_ATTRIBUTE = 'mcp.tool.name'),
      (n.MCP_TOOL_RESULT_CONTENT_ATTRIBUTE = 'mcp.tool.result.content'),
      (n.MCP_TOOL_RESULT_CONTENT_COUNT_ATTRIBUTE = 'mcp.tool.result.content_count'),
      (n.MCP_TOOL_RESULT_IS_ERROR_ATTRIBUTE = 'mcp.tool.result.is_error'),
      (n.MCP_TOOL_RESULT_PREFIX = 'mcp.tool.result'),
      (n.MCP_TRANSPORT_ATTRIBUTE = 'mcp.transport'),
      (n.NETWORK_PROTOCOL_VERSION_ATTRIBUTE = 'network.protocol.version'),
      (n.NETWORK_TRANSPORT_ATTRIBUTE = 'network.transport'));
  },
  44121,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13907),
      i = new Set([
        r.CLIENT_ADDRESS_ATTRIBUTE,
        r.CLIENT_PORT_ATTRIBUTE,
        r.MCP_LOGGING_MESSAGE_ATTRIBUTE,
        r.MCP_PROMPT_RESULT_DESCRIPTION_ATTRIBUTE,
        r.MCP_PROMPT_RESULT_MESSAGE_CONTENT_ATTRIBUTE,
        r.MCP_RESOURCE_URI_ATTRIBUTE,
        r.MCP_TOOL_RESULT_CONTENT_ATTRIBUTE,
      ]);
    n.filterMcpPiiFromSpanData = function (e, t) {
      return t
        ? e
        : Object.entries(e).reduce(
            (e, [t, n]) => (
              i.has(t) ||
                t.startsWith(`${r.MCP_REQUEST_ARGUMENT}.`) ||
                ((t.startsWith(`${r.MCP_TOOL_RESULT_PREFIX}.`) ||
                  t.startsWith(`${r.MCP_PROMPT_RESULT_PREFIX}.`)) &&
                  !t.endsWith('_count') &&
                  !t.endsWith('_error') &&
                  !t.endsWith('.is_error')) ||
                (e[t] = n),
              e
            ),
            {}
          );
    };
  },
  4402,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500);
    ((n.isJsonRpcNotification = function (e) {
      return (
        'object' == typeof e &&
        null !== e &&
        'jsonrpc' in e &&
        '2.0' === e.jsonrpc &&
        'method' in e &&
        !('id' in e)
      );
    }),
      (n.isJsonRpcRequest = function (e) {
        return (
          'object' == typeof e &&
          null !== e &&
          'jsonrpc' in e &&
          '2.0' === e.jsonrpc &&
          'method' in e &&
          'id' in e
        );
      }),
      (n.isJsonRpcResponse = function (e) {
        return (
          'object' == typeof e &&
          null !== e &&
          'jsonrpc' in e &&
          '2.0' === e.jsonrpc &&
          'id' in e &&
          ('result' in e || 'error' in e)
        );
      }),
      (n.isValidContentItem = function (e) {
        return null != e && 'object' == typeof e;
      }),
      (n.validateMcpServerInstance = function (e) {
        return (
          ('object' == typeof e &&
            null !== e &&
            'resource' in e &&
            'tool' in e &&
            'prompt' in e &&
            'connect' in e) ||
          (r.DEBUG_BUILD && i.debug.warn('Did not patch MCP server. Interface is incompatible.'),
          !1)
        );
      }));
  },
  70609,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13907),
      i = e.r(4402);
    ((n.extractPromptResultAttributes = function (e) {
      let t = {};
      if (!i.isValidContentItem(e)) return t;
      if (
        ('string' == typeof e.description &&
          (t[r.MCP_PROMPT_RESULT_DESCRIPTION_ATTRIBUTE] = e.description),
        Array.isArray(e.messages))
      ) {
        t[r.MCP_PROMPT_RESULT_MESSAGE_COUNT_ATTRIBUTE] = e.messages.length;
        let a = e.messages;
        for (let [e, r] of a.entries()) {
          var n, o;
          if (!i.isValidContentItem(r)) continue;
          let s = 1 === a.length ? 'mcp.prompt.result' : `mcp.prompt.result.${e}`;
          if (
            ((n = 'role'),
            'string' == typeof (o = r.role) &&
              (t[1 === a.length ? `${s}.message_${n}` : `${s}.${n}`] = o),
            i.isValidContentItem(r.content))
          ) {
            let e = r.content;
            'string' == typeof e.text &&
              (t[1 === a.length ? `${s}.message_content` : `${s}.content`] = e.text);
          }
        }
      }
      return t;
    }),
      (n.extractToolResultAttributes = function (e) {
        if (!i.isValidContentItem(e)) return {};
        let t = Array.isArray(e.content)
          ? (function (e) {
              let t = { [r.MCP_TOOL_RESULT_CONTENT_COUNT_ATTRIBUTE]: e.length };
              for (let [n, r] of e.entries()) {
                if (!i.isValidContentItem(r)) continue;
                let o = 1 === e.length ? 'mcp.tool.result' : `mcp.tool.result.${n}`,
                  a = (e, n) => {
                    'string' == typeof n && (t[`${o}.${e}`] = n);
                  };
                (a('content_type', r.type),
                  a('mime_type', r.mimeType),
                  a('uri', r.uri),
                  a('name', r.name),
                  'string' == typeof r.text && (t[`${o}.content`] = r.text),
                  'string' == typeof r.data && (t[`${o}.data_size`] = r.data.length));
                let s = r.resource;
                i.isValidContentItem(s) &&
                  (a('resource_uri', s.uri), a('resource_mime_type', s.mimeType));
              }
              return t;
            })(e.content)
          : {};
        return (
          'boolean' == typeof e.isError && (t[r.MCP_TOOL_RESULT_IS_ERROR_ATTRIBUTE] = e.isError),
          t
        );
      }));
  },
  483,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(72517),
      o = e.r(44121),
      a = e.r(70609),
      s = new WeakMap();
    function u(e) {
      let t = s.get(e);
      return (t || ((t = new Map()), s.set(e, t)), t);
    }
    ((n.cleanupPendingSpansForTransport = function (e) {
      let t = s.get(e);
      if (t) {
        for (let [, e] of t)
          (e.span.setStatus({ code: i.SPAN_STATUS_ERROR, message: 'cancelled' }), e.span.end());
        t.clear();
      }
    }),
      (n.completeSpanWithResults = function (e, t, n) {
        let i = u(e),
          s = i.get(t);
        if (s) {
          let { span: e, method: u } = s;
          if ('tools/call' === u) {
            let t = a.extractToolResultAttributes(n),
              i = r.getClient(),
              s = !!i?.getOptions().sendDefaultPii,
              u = o.filterMcpPiiFromSpanData(t, s);
            e.setAttributes(u);
          } else if ('prompts/get' === u) {
            let t = a.extractPromptResultAttributes(n),
              i = r.getClient(),
              s = !!i?.getOptions().sendDefaultPii,
              u = o.filterMcpPiiFromSpanData(t, s);
            e.setAttributes(u);
          }
          (e.end(), i.delete(t));
        }
      }),
      (n.storeSpanForRequest = function (e, t, n, r) {
        u(e).set(t, { span: n, method: r, startTime: Date.now() });
      }));
  },
  45398,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = new WeakMap();
    ((n.cleanupSessionDataForTransport = function (e) {
      r.delete(e);
    }),
      (n.getClientInfoForTransport = function (e) {
        return r.get(e)?.clientInfo;
      }),
      (n.getProtocolVersionForTransport = function (e) {
        return r.get(e)?.protocolVersion;
      }),
      (n.getSessionDataForTransport = function (e) {
        return r.get(e);
      }),
      (n.storeSessionDataForTransport = function (e, t) {
        e.sessionId && r.set(e, t);
      }),
      (n.updateSessionDataForTransport = function (e, t) {
        if (e.sessionId) {
          let n = r.get(e) || {};
          r.set(e, { ...n, ...t });
        }
      }));
  },
  53761,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13907),
      i = e.r(45398),
      o = e.r(4402);
    function a(e) {
      let t = {};
      return (
        o.isValidContentItem(e) &&
          ('string' == typeof e.name && (t.name = e.name),
          'string' == typeof e.title && (t.title = e.title),
          'string' == typeof e.version && (t.version = e.version)),
        t
      );
    }
    function s(e) {
      let t = i.getClientInfoForTransport(e),
        n = {};
      return (
        t?.name && (n['mcp.client.name'] = t.name),
        t?.title && (n['mcp.client.title'] = t.title),
        t?.version && (n['mcp.client.version'] = t.version),
        n
      );
    }
    function u(e) {
      let t = i.getSessionDataForTransport(e)?.serverInfo,
        n = {};
      return (
        t?.name && (n[r.MCP_SERVER_NAME_ATTRIBUTE] = t.name),
        t?.title && (n[r.MCP_SERVER_TITLE_ATTRIBUTE] = t.title),
        t?.version && (n[r.MCP_SERVER_VERSION_ATTRIBUTE] = t.version),
        n
      );
    }
    function l(e) {
      return {
        address:
          e?.requestInfo?.remoteAddress ||
          e?.clientAddress ||
          e?.request?.ip ||
          e?.request?.connection?.remoteAddress,
        port: e?.requestInfo?.remotePort || e?.clientPort || e?.request?.connection?.remotePort,
      };
    }
    function c(e) {
      if (!e?.constructor) return { mcpTransport: 'unknown', networkTransport: 'unknown' };
      let t = 'string' == typeof e.constructor?.name ? e.constructor.name : 'unknown',
        n = 'unknown',
        r = t.toLowerCase();
      return (
        r.includes('stdio')
          ? (n = 'pipe')
          : (r.includes('http') || r.includes('sse')) && (n = 'tcp'),
        { mcpTransport: t, networkTransport: n }
      );
    }
    ((n.buildTransportAttributes = function (e, t) {
      let n = e && 'sessionId' in e ? e.sessionId : void 0,
        o = t ? l(t) : {},
        { mcpTransport: a, networkTransport: d } = c(e),
        p = s(e),
        _ = u(e),
        S = i.getProtocolVersionForTransport(e);
      return {
        ...(n && { [r.MCP_SESSION_ID_ATTRIBUTE]: n }),
        ...(o.address && { [r.CLIENT_ADDRESS_ATTRIBUTE]: o.address }),
        ...(o.port && { [r.CLIENT_PORT_ATTRIBUTE]: o.port }),
        [r.MCP_TRANSPORT_ATTRIBUTE]: a,
        [r.NETWORK_TRANSPORT_ATTRIBUTE]: d,
        [r.NETWORK_PROTOCOL_VERSION_ATTRIBUTE]: '2.0',
        ...(S && { [r.MCP_PROTOCOL_VERSION_ATTRIBUTE]: S }),
        ...p,
        ..._,
      };
    }),
      (n.extractClientInfo = l),
      (n.extractSessionDataFromInitializeRequest = function (e) {
        let t = {};
        return (
          o.isValidContentItem(e.params) &&
            ('string' == typeof e.params.protocolVersion &&
              (t.protocolVersion = e.params.protocolVersion),
            e.params.clientInfo && (t.clientInfo = a(e.params.clientInfo))),
          t
        );
      }),
      (n.extractSessionDataFromInitializeResponse = function (e) {
        let t = {};
        return (
          o.isValidContentItem(e) &&
            ('string' == typeof e.protocolVersion && (t.protocolVersion = e.protocolVersion),
            e.serverInfo && (t.serverInfo = a(e.serverInfo))),
          t
        );
      }),
      (n.getClientAttributes = s),
      (n.getServerAttributes = u),
      (n.getTransportTypes = c));
  },
  91049,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13907),
      i = {
        'tools/call': {
          targetField: 'name',
          targetAttribute: r.MCP_TOOL_NAME_ATTRIBUTE,
          captureArguments: !0,
          argumentsField: 'arguments',
        },
        'resources/read': {
          targetField: 'uri',
          targetAttribute: r.MCP_RESOURCE_URI_ATTRIBUTE,
          captureUri: !0,
        },
        'resources/subscribe': {
          targetField: 'uri',
          targetAttribute: r.MCP_RESOURCE_URI_ATTRIBUTE,
        },
        'resources/unsubscribe': {
          targetField: 'uri',
          targetAttribute: r.MCP_RESOURCE_URI_ATTRIBUTE,
        },
        'prompts/get': {
          targetField: 'name',
          targetAttribute: r.MCP_PROMPT_NAME_ATTRIBUTE,
          captureName: !0,
          captureArguments: !0,
          argumentsField: 'arguments',
        },
      };
    ((n.extractTargetInfo = function (e, t) {
      let n = i[e];
      if (!n) return { attributes: {} };
      let r = n.targetField && 'string' == typeof t?.[n.targetField] ? t[n.targetField] : void 0;
      return { target: r, attributes: r && n.targetAttribute ? { [n.targetAttribute]: r } : {} };
    }),
      (n.getRequestArguments = function (e, t) {
        let n = {},
          o = i[e];
        if (!o) return n;
        if (o.captureArguments && o.argumentsField && t?.[o.argumentsField]) {
          let e = t[o.argumentsField];
          if ('object' == typeof e && null !== e)
            for (let [t, i] of Object.entries(e))
              n[`${r.MCP_REQUEST_ARGUMENT}.${t.toLowerCase()}`] = JSON.stringify(i);
        }
        return (
          o.captureUri && t?.uri && (n[`${r.MCP_REQUEST_ARGUMENT}.uri`] = JSON.stringify(t.uri)),
          o.captureName &&
            t?.name &&
            (n[`${r.MCP_REQUEST_ARGUMENT}.name`] = JSON.stringify(t.name)),
          n
        );
      }));
  },
  41344,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(16097),
      i = e.r(13907),
      o = e.r(91049);
    function a(e, t) {
      let n = {};
      switch (e) {
        case 'notifications/cancelled':
          (t?.requestId && (n['mcp.cancelled.request_id'] = String(t.requestId)),
            t?.reason && (n['mcp.cancelled.reason'] = String(t.reason)));
          break;
        case 'notifications/message':
          (t?.level && (n[i.MCP_LOGGING_LEVEL_ATTRIBUTE] = String(t.level)),
            t?.logger && (n[i.MCP_LOGGING_LOGGER_ATTRIBUTE] = String(t.logger)),
            t?.data !== void 0 &&
              ((n[i.MCP_LOGGING_DATA_TYPE_ATTRIBUTE] = typeof t.data),
              'string' == typeof t.data
                ? (n[i.MCP_LOGGING_MESSAGE_ATTRIBUTE] = t.data)
                : (n[i.MCP_LOGGING_MESSAGE_ATTRIBUTE] = JSON.stringify(t.data))));
          break;
        case 'notifications/progress':
          (t?.progressToken && (n['mcp.progress.token'] = String(t.progressToken)),
            'number' == typeof t?.progress && (n['mcp.progress.current'] = t.progress),
            'number' == typeof t?.total &&
              ((n['mcp.progress.total'] = t.total),
              'number' == typeof t?.progress &&
                (n['mcp.progress.percentage'] = (t.progress / t.total) * 100)),
            t?.message && (n['mcp.progress.message'] = String(t.message)));
          break;
        case 'notifications/resources/updated':
          if (t?.uri) {
            n[i.MCP_RESOURCE_URI_ATTRIBUTE] = String(t.uri);
            let e = r.parseStringToURLObject(String(t.uri));
            e &&
              !r.isURLObjectRelative(e) &&
              (n['mcp.resource.protocol'] = e.protocol.replace(':', ''));
          }
          break;
        case 'notifications/initialized':
          ((n['mcp.lifecycle.phase'] = 'initialization_complete'), (n['mcp.protocol.ready'] = 1));
      }
      return n;
    }
    ((n.buildTypeSpecificAttributes = function (e, t, n) {
      if ('request' === e) {
        let e = o.extractTargetInfo(t.method, n || {});
        return {
          ...(void 0 !== t.id && { [i.MCP_REQUEST_ID_ATTRIBUTE]: String(t.id) }),
          ...e.attributes,
          ...o.getRequestArguments(t.method, n || {}),
        };
      }
      return a(t.method, n || {});
    }),
      (n.getNotificationAttributes = a));
  },
  19845,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(13801),
      o = e.r(66744),
      a = e.r(41344),
      s = e.r(13907),
      u = e.r(91049),
      l = e.r(44121),
      c = e.r(53761);
    function d(e, t) {
      return t ? `${e} ${t}` : e;
    }
    function p(e) {
      let t, n;
      switch (e) {
        case 'request':
          ((t = s.MCP_SERVER_OP_VALUE), (n = s.MCP_FUNCTION_ORIGIN_VALUE));
          break;
        case 'notification-incoming':
          ((t = s.MCP_NOTIFICATION_CLIENT_TO_SERVER_OP_VALUE),
            (n = s.MCP_NOTIFICATION_ORIGIN_VALUE));
          break;
        case 'notification-outgoing':
          ((t = s.MCP_NOTIFICATION_SERVER_TO_CLIENT_OP_VALUE),
            (n = s.MCP_NOTIFICATION_ORIGIN_VALUE));
      }
      return {
        [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: t,
        [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: n,
        [i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: s.MCP_ROUTE_SOURCE_VALUE,
      };
    }
    function _(e) {
      let t,
        { type: n, message: i, transport: _, extra: S, callback: E } = e,
        { method: T } = i,
        m = i.params;
      if ('request' === n) {
        let e = u.extractTargetInfo(T, m || {});
        t = d(T, e.target);
      } else t = T;
      let g = {
          ...c.buildTransportAttributes(_, S),
          [s.MCP_METHOD_NAME_ATTRIBUTE]: T,
          ...a.buildTypeSpecificAttributes(n, i, m),
          ...p(n),
        },
        f = r.getClient(),
        h = !!f?.getOptions().sendDefaultPii,
        A = l.filterMcpPiiFromSpanData(g, h);
      return o.startSpan({ name: t, forceTransaction: !0, attributes: A }, E);
    }
    ((n.buildMcpServerSpanConfig = function (e, t, n) {
      let { method: i } = e,
        o = e.params,
        _ = u.extractTargetInfo(i, o || {}),
        S = d(i, _.target),
        E = {
          ...c.buildTransportAttributes(t, n),
          [s.MCP_METHOD_NAME_ATTRIBUTE]: i,
          ...a.buildTypeSpecificAttributes('request', e, o),
          ...p('request'),
        },
        T = r.getClient(),
        m = !!T?.getOptions().sendDefaultPii,
        g = l.filterMcpPiiFromSpanData(E, m);
      return { name: S, op: s.MCP_SERVER_OP_VALUE, forceTransaction: !0, attributes: g };
    }),
      (n.createMcpNotificationSpan = function (e, t, n, r) {
        return _({
          type: 'notification-incoming',
          message: e,
          transport: t,
          extra: n,
          callback: r,
        });
      }),
      (n.createMcpOutgoingNotificationSpan = function (e, t, n) {
        return _({ type: 'notification-outgoing', message: e, transport: t, callback: n });
      }));
  },
  84121,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(63236),
      o = e.r(66744),
      a = e.r(483),
      s = e.r(95958),
      u = e.r(53761),
      l = e.r(45398),
      c = e.r(19845),
      d = e.r(4402);
    ((n.wrapTransportError = function (e) {
      e.onerror &&
        i.fill(
          e,
          'onerror',
          (e) =>
            function (t) {
              return (
                (function (e) {
                  try {
                    s.captureError(e, 'transport');
                  } catch {}
                })(t),
                e.call(this, t)
              );
            }
        );
    }),
      (n.wrapTransportOnClose = function (e) {
        e.onclose &&
          i.fill(
            e,
            'onclose',
            (e) =>
              function (...t) {
                return (
                  a.cleanupPendingSpansForTransport(this),
                  l.cleanupSessionDataForTransport(this),
                  e.call(this, ...t)
                );
              }
          );
      }),
      (n.wrapTransportOnMessage = function (e) {
        e.onmessage &&
          i.fill(
            e,
            'onmessage',
            (e) =>
              function (t, n) {
                if (d.isJsonRpcRequest(t)) {
                  if ('initialize' === t.method)
                    try {
                      let e = u.extractSessionDataFromInitializeRequest(t);
                      l.storeSessionDataForTransport(this, e);
                    } catch {}
                  let i = r.getIsolationScope().clone();
                  return r.withIsolationScope(i, () => {
                    let r = c.buildMcpServerSpanConfig(t, this, n),
                      i = o.startInactiveSpan(r);
                    return (
                      a.storeSpanForRequest(this, t.id, i, t.method),
                      o.withActiveSpan(i, () => e.call(this, t, n))
                    );
                  });
                }
                return d.isJsonRpcNotification(t)
                  ? c.createMcpNotificationSpan(t, this, n, () => e.call(this, t, n))
                  : e.call(this, t, n);
              }
          );
      }),
      (n.wrapTransportSend = function (e) {
        e.send &&
          i.fill(
            e,
            'send',
            (e) =>
              async function (...t) {
                let [n] = t;
                if (d.isJsonRpcNotification(n))
                  return c.createMcpOutgoingNotificationSpan(n, this, () => e.call(this, ...t));
                if (d.isJsonRpcResponse(n) && null !== n.id && void 0 !== n.id) {
                  if (
                    (n.error &&
                      (function (e) {
                        try {
                          if (
                            e &&
                            'object' == typeof e &&
                            'code' in e &&
                            'message' in e &&
                            (-32603 === e.code || (e.code >= -32099 && e.code <= -32e3))
                          ) {
                            let t = Error(e.message);
                            ((t.name = `JsonRpcError_${e.code}`), s.captureError(t, 'protocol'));
                          }
                        } catch {}
                      })(n.error),
                    d.isValidContentItem(n.result) &&
                      (n.result.protocolVersion || n.result.serverInfo))
                  )
                    try {
                      let e = u.extractSessionDataFromInitializeResponse(n.result);
                      l.updateSessionDataForTransport(this, e);
                    } catch {}
                  a.completeSpanWithResults(this, n.id, n.result);
                }
                return e.call(this, ...t);
              }
          );
      }));
  },
  89580,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(63236),
      i = e.r(23213),
      o = e.r(84121),
      a = e.r(4402),
      s = new WeakSet();
    n.wrapMcpServerWithSentry = function (e) {
      return (
        s.has(e) ||
          !a.validateMcpServerInstance(e) ||
          (r.fill(
            e,
            'connect',
            (e) =>
              async function (t, ...n) {
                let r = await e.call(this, t, ...n);
                return (
                  o.wrapTransportOnMessage(t),
                  o.wrapTransportSend(t),
                  o.wrapTransportOnClose(t),
                  o.wrapTransportError(t),
                  r
                );
              }
          ),
          i.wrapAllMCPHandlers(e),
          s.add(e)),
        e
      );
    };
  },
  22106,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336);
    n.captureFeedback = function (e, t = {}, n = r.getCurrentScope()) {
      let { message: i, name: o, email: a, url: s, source: u, associatedEventId: l, tags: c } = e,
        d = {
          contexts: {
            feedback: {
              contact_email: a,
              name: o,
              message: i,
              url: s,
              source: u,
              associated_event_id: l,
            },
          },
          type: 'feedback',
          level: 'info',
          tags: c,
        },
        p = n?.getClient() || r.getClient();
      return (p && p.emit('beforeSendFeedback', d, t), n.captureEvent(d, t));
    };
  },
  13128,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(65553),
      o = e.r(10045),
      a = e.r(39059),
      s = e.r(13801),
      u = e.r(13500),
      l = e.r(2802),
      c = e.r(97548),
      d = e.r(83247),
      p = e.r(10241),
      _ = { [s.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.console.logging' };
    function S(e, t, n) {
      var r, i, o;
      return 'util' in d.GLOBAL_OBJ && 'function' == typeof d.GLOBAL_OBJ.util.format
        ? d.GLOBAL_OBJ.util.format(...e)
        : ((r = e),
          (i = t),
          (o = n),
          r
            .map((e) => (l.isPrimitive(e) ? String(e) : JSON.stringify(c.normalize(e, i, o))))
            .join(' '));
    }
    n.consoleLoggingIntegration = a.defineIntegration((e = {}) => {
      let t = e.levels || u.CONSOLE_LEVELS;
      return {
        name: 'ConsoleLogs',
        setup(e) {
          let {
            enableLogs: n,
            normalizeDepth: a = 3,
            normalizeMaxBreadth: s = 1e3,
          } = e.getOptions();
          if (!n) {
            i.DEBUG_BUILD &&
              u.debug.warn('`enableLogs` is not enabled, ConsoleLogs integration disabled');
            return;
          }
          o.addConsoleInstrumentationHandler(({ args: n, level: i }) => {
            if (r.getClient() !== e || !t.includes(i)) return;
            if ('assert' === i) {
              if (!n[0]) {
                let e = n.slice(1),
                  t = e.length > 0 ? `Assertion failed: ${S(e, a, s)}` : 'Assertion failed';
                p._INTERNAL_captureLog({ level: 'error', message: t, attributes: _ });
              }
              return;
            }
            let o = 'log' === i;
            p._INTERNAL_captureLog({
              level: o ? 'info' : i,
              message: S(n, a, s),
              severityNumber: o ? 10 : void 0,
              attributes: _,
            });
          });
        },
      };
    });
  },
  75224,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.toolCallSpanMap = new Map()));
  },
  50217,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE = 'anthropic.response.timestamp'),
      (n.GEN_AI_OPERATION_NAME_ATTRIBUTE = 'gen_ai.operation.name'),
      (n.GEN_AI_PROMPT_ATTRIBUTE = 'gen_ai.prompt'),
      (n.GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE = 'gen_ai.request.available_tools'),
      (n.GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE = 'gen_ai.request.frequency_penalty'),
      (n.GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE = 'gen_ai.request.max_tokens'),
      (n.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE = 'gen_ai.request.messages'),
      (n.GEN_AI_REQUEST_MODEL_ATTRIBUTE = 'gen_ai.request.model'),
      (n.GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE = 'gen_ai.request.presence_penalty'),
      (n.GEN_AI_REQUEST_STREAM_ATTRIBUTE = 'gen_ai.request.stream'),
      (n.GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE = 'gen_ai.request.temperature'),
      (n.GEN_AI_REQUEST_TOP_K_ATTRIBUTE = 'gen_ai.request.top_k'),
      (n.GEN_AI_REQUEST_TOP_P_ATTRIBUTE = 'gen_ai.request.top_p'),
      (n.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE = 'gen_ai.response.finish_reasons'),
      (n.GEN_AI_RESPONSE_ID_ATTRIBUTE = 'gen_ai.response.id'),
      (n.GEN_AI_RESPONSE_MODEL_ATTRIBUTE = 'gen_ai.response.model'),
      (n.GEN_AI_RESPONSE_STREAMING_ATTRIBUTE = 'gen_ai.response.streaming'),
      (n.GEN_AI_RESPONSE_TEXT_ATTRIBUTE = 'gen_ai.response.text'),
      (n.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE = 'gen_ai.response.tool_calls'),
      (n.GEN_AI_SYSTEM_ATTRIBUTE = 'gen_ai.system'),
      (n.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.input_tokens'),
      (n.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.output_tokens'),
      (n.GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE = 'gen_ai.usage.total_tokens'),
      (n.OPENAI_OPERATIONS = { CHAT: 'chat', RESPONSES: 'responses' }),
      (n.OPENAI_RESPONSE_ID_ATTRIBUTE = 'openai.response.id'),
      (n.OPENAI_RESPONSE_MODEL_ATTRIBUTE = 'openai.response.model'),
      (n.OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE = 'openai.response.timestamp'),
      (n.OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE = 'openai.usage.completion_tokens'),
      (n.OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE = 'openai.usage.prompt_tokens'));
  },
  67e3,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(50217),
      i = e.r(75224);
    ((n._INTERNAL_cleanupToolCallSpan = function (e) {
      i.toolCallSpanMap.delete(e);
    }),
      (n._INTERNAL_getSpanForToolCallId = function (e) {
        return i.toolCallSpanMap.get(e);
      }),
      (n.accumulateTokensForParent = function (e, t) {
        let n = e.parent_span_id;
        if (!n) return;
        let i = e.data[r.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE],
          o = e.data[r.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE];
        if ('number' == typeof i || 'number' == typeof o) {
          let e = t.get(n) || { inputTokens: 0, outputTokens: 0 };
          ('number' == typeof i && (e.inputTokens += i),
            'number' == typeof o && (e.outputTokens += o),
            t.set(n, e));
        }
      }),
      (n.applyAccumulatedTokens = function (e, t) {
        let n = t.get(e.span_id);
        n &&
          e.data &&
          (n.inputTokens > 0 && (e.data[r.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] = n.inputTokens),
          n.outputTokens > 0 && (e.data[r.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] = n.outputTokens),
          (n.inputTokens > 0 || n.outputTokens > 0) &&
            (e.data['gen_ai.usage.total_tokens'] = n.inputTokens + n.outputTokens));
      }));
  },
  34889,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.AI_MODEL_ID_ATTRIBUTE = 'ai.model.id'),
      (n.AI_MODEL_PROVIDER_ATTRIBUTE = 'ai.model.provider'),
      (n.AI_PROMPT_ATTRIBUTE = 'ai.prompt'),
      (n.AI_PROMPT_MESSAGES_ATTRIBUTE = 'ai.prompt.messages'),
      (n.AI_PROMPT_TOOLS_ATTRIBUTE = 'ai.prompt.tools'),
      (n.AI_RESPONSE_OBJECT_ATTRIBUTE = 'ai.response.object'),
      (n.AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE = 'ai.response.providerMetadata'),
      (n.AI_RESPONSE_TEXT_ATTRIBUTE = 'ai.response.text'),
      (n.AI_RESPONSE_TOOL_CALLS_ATTRIBUTE = 'ai.response.toolCalls'),
      (n.AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE = 'ai.telemetry.functionId'),
      (n.AI_TOOL_CALL_ARGS_ATTRIBUTE = 'ai.toolCall.args'),
      (n.AI_TOOL_CALL_ID_ATTRIBUTE = 'ai.toolCall.id'),
      (n.AI_TOOL_CALL_NAME_ATTRIBUTE = 'ai.toolCall.name'),
      (n.AI_TOOL_CALL_RESULT_ATTRIBUTE = 'ai.toolCall.result'),
      (n.AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE = 'ai.usage.completionTokens'),
      (n.AI_USAGE_PROMPT_TOKENS_ATTRIBUTE = 'ai.usage.promptTokens'),
      (n.GEN_AI_RESPONSE_MODEL_ATTRIBUTE = 'gen_ai.response.model'),
      (n.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.input_tokens'),
      (n.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE = 'gen_ai.usage.output_tokens'));
  },
  70161,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(13801),
      i = e.r(24205),
      o = e.r(75224),
      a = e.r(67e3),
      s = e.r(34889);
    function u(e, t) {
      e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, t);
    }
    function l(e) {
      let { data: t, description: n } = i.spanToJSON(e);
      if (!n) return;
      if (t[s.AI_TOOL_CALL_NAME_ATTRIBUTE] && t[s.AI_TOOL_CALL_ID_ATTRIBUTE] && 'ai.toolCall' === n)
        return void (function (e, t) {
          (u(e, 'auto.vercelai.otel'),
            e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.execute_tool'),
            d(t, s.AI_TOOL_CALL_NAME_ATTRIBUTE, 'gen_ai.tool.name'),
            d(t, s.AI_TOOL_CALL_ID_ATTRIBUTE, 'gen_ai.tool.call.id'));
          let n = t['gen_ai.tool.call.id'];
          ('string' == typeof n && o.toolCallSpanMap.set(n, e),
            t['gen_ai.tool.type'] || e.setAttribute('gen_ai.tool.type', 'function'));
          let i = t['gen_ai.tool.name'];
          i && e.updateName(`execute_tool ${i}`);
        })(e, t);
      let a = t[s.AI_MODEL_ID_ATTRIBUTE],
        l = t[s.AI_MODEL_PROVIDER_ATTRIBUTE];
      'string' == typeof a &&
        'string' == typeof l &&
        a &&
        l &&
        (function (e, t, n) {
          u(e, 'auto.vercelai.otel');
          let i = t.replace('ai.', '');
          (e.setAttribute('ai.pipeline.name', i), e.updateName(i));
          let o = n[s.AI_TELEMETRY_FUNCTION_ID_ATTRIBUTE];
          if (
            (o &&
              'string' == typeof o &&
              t.split('.').length - 1 == 1 &&
              (e.updateName(`${i} ${o}`), e.setAttribute('gen_ai.function_id', o)),
            n[s.AI_PROMPT_ATTRIBUTE] && e.setAttribute('gen_ai.prompt', n[s.AI_PROMPT_ATTRIBUTE]),
            n[s.AI_MODEL_ID_ATTRIBUTE] &&
              !n[s.GEN_AI_RESPONSE_MODEL_ATTRIBUTE] &&
              e.setAttribute(s.GEN_AI_RESPONSE_MODEL_ATTRIBUTE, n[s.AI_MODEL_ID_ATTRIBUTE]),
            e.setAttribute('ai.streaming', t.includes('stream')),
            'ai.generateText' === t)
          )
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.generateText.doGenerate' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_text'),
              e.updateName(`generate_text ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          if ('ai.streamText' === t)
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.streamText.doStream' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_text'),
              e.updateName(`stream_text ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          if ('ai.generateObject' === t)
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.generateObject.doGenerate' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.generate_object'),
              e.updateName(`generate_object ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          if ('ai.streamObject' === t)
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.streamObject.doStream' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.stream_object'),
              e.updateName(`stream_object ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          if ('ai.embed' === t)
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.embed.doEmbed' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed'),
              e.updateName(`embed ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          if ('ai.embedMany' === t)
            return e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.invoke_agent');
          if ('ai.embedMany.doEmbed' === t) {
            (e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'gen_ai.embed_many'),
              e.updateName(`embed_many ${n[s.AI_MODEL_ID_ATTRIBUTE]}`));
            return;
          }
          t.startsWith('ai.stream') && e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'ai.run');
        })(e, n, t);
    }
    function c(e) {
      if ('transaction' === e.type && e.spans) {
        let t = new Map();
        for (let n of e.spans)
          ((function (e) {
            let { data: t, origin: n } = e;
            if ('auto.vercelai.otel' === n)
              for (let e of (d(
                t,
                s.AI_USAGE_COMPLETION_TOKENS_ATTRIBUTE,
                s.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE
              ),
              d(t, s.AI_USAGE_PROMPT_TOKENS_ATTRIBUTE, s.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE),
              'number' == typeof t[s.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] &&
                'number' == typeof t[s.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] &&
                (t['gen_ai.usage.total_tokens'] =
                  t[s.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] +
                  t[s.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]),
              d(t, s.AI_PROMPT_MESSAGES_ATTRIBUTE, 'gen_ai.request.messages'),
              d(t, s.AI_RESPONSE_TEXT_ATTRIBUTE, 'gen_ai.response.text'),
              d(t, s.AI_RESPONSE_TOOL_CALLS_ATTRIBUTE, 'gen_ai.response.tool_calls'),
              d(t, s.AI_RESPONSE_OBJECT_ATTRIBUTE, 'gen_ai.response.object'),
              d(t, s.AI_PROMPT_TOOLS_ATTRIBUTE, 'gen_ai.request.available_tools'),
              d(t, s.AI_TOOL_CALL_ARGS_ATTRIBUTE, 'gen_ai.tool.input'),
              d(t, s.AI_TOOL_CALL_RESULT_ATTRIBUTE, 'gen_ai.tool.output'),
              (function (e) {
                let t = e[s.AI_RESPONSE_PROVIDER_METADATA_ATTRIBUTE];
                if (t)
                  try {
                    let n = JSON.parse(t);
                    (n.openai &&
                      (p(e, 'gen_ai.usage.input_tokens.cached', n.openai.cachedPromptTokens),
                      p(e, 'gen_ai.usage.output_tokens.reasoning', n.openai.reasoningTokens),
                      p(
                        e,
                        'gen_ai.usage.output_tokens.prediction_accepted',
                        n.openai.acceptedPredictionTokens
                      ),
                      p(
                        e,
                        'gen_ai.usage.output_tokens.prediction_rejected',
                        n.openai.rejectedPredictionTokens
                      ),
                      p(e, 'gen_ai.conversation.id', n.openai.responseId)),
                      n.anthropic &&
                        (p(e, 'gen_ai.usage.input_tokens.cached', n.anthropic.cacheReadInputTokens),
                        p(
                          e,
                          'gen_ai.usage.input_tokens.cache_write',
                          n.anthropic.cacheCreationInputTokens
                        )),
                      n.bedrock?.usage &&
                        (p(
                          e,
                          'gen_ai.usage.input_tokens.cached',
                          n.bedrock.usage.cacheReadInputTokens
                        ),
                        p(
                          e,
                          'gen_ai.usage.input_tokens.cache_write',
                          n.bedrock.usage.cacheWriteInputTokens
                        )),
                      n.deepseek &&
                        (p(e, 'gen_ai.usage.input_tokens.cached', n.deepseek.promptCacheHitTokens),
                        p(
                          e,
                          'gen_ai.usage.input_tokens.cache_miss',
                          n.deepseek.promptCacheMissTokens
                        )));
                  } catch {}
              })(t),
              Object.keys(t)))
                e.startsWith('ai.') && d(t, e, `vercel.${e}`);
          })(n),
            a.accumulateTokensForParent(n, t));
        for (let n of e.spans) 'gen_ai.invoke_agent' === n.op && a.applyAccumulatedTokens(n, t);
        let n = e.contexts?.trace;
        n && 'gen_ai.invoke_agent' === n.op && a.applyAccumulatedTokens(n, t);
      }
      return e;
    }
    function d(e, t, n) {
      null != e[t] && ((e[n] = e[t]), delete e[t]);
    }
    function p(e, t, n) {
      null != n && (e[t] = n);
    }
    n.addVercelAiProcessors = function (e) {
      (e.on('spanStart', l),
        e.addEventProcessor(Object.assign(c, { id: 'VercelAiEventProcessor' })));
    };
  },
  45404,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = [
        'response.output_item.added',
        'response.function_call_arguments.delta',
        'response.function_call_arguments.done',
        'response.output_item.done',
      ],
      i = [
        'response.created',
        'response.in_progress',
        'response.failed',
        'response.completed',
        'response.incomplete',
        'response.queued',
        'response.output_text.delta',
        ...r,
      ];
    ((n.INSTRUMENTED_METHODS = ['responses.create', 'chat.completions.create']),
      (n.OPENAI_INTEGRATION_NAME = 'OpenAI'),
      (n.RESPONSES_TOOL_CALL_EVENT_TYPES = r),
      (n.RESPONSE_EVENT_TYPES = i));
  },
  36080,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(50217),
      i = e.r(45404);
    function o(e) {
      return e.includes('chat.completions')
        ? r.OPENAI_OPERATIONS.CHAT
        : e.includes('responses')
          ? r.OPENAI_OPERATIONS.RESPONSES
          : e.split('.').pop() || 'unknown';
    }
    ((n.buildMethodPath = function (e, t) {
      return e ? `${e}.${t}` : t;
    }),
      (n.getOperationName = o),
      (n.getSpanOperation = function (e) {
        return `gen_ai.${o(e)}`;
      }),
      (n.isChatCompletionChunk = function (e) {
        return (
          null !== e &&
          'object' == typeof e &&
          'object' in e &&
          'chat.completion.chunk' === e.object
        );
      }),
      (n.isChatCompletionResponse = function (e) {
        return (
          null !== e && 'object' == typeof e && 'object' in e && 'chat.completion' === e.object
        );
      }),
      (n.isResponsesApiResponse = function (e) {
        return null !== e && 'object' == typeof e && 'object' in e && 'response' === e.object;
      }),
      (n.isResponsesApiStreamEvent = function (e) {
        return (
          null !== e &&
          'object' == typeof e &&
          'type' in e &&
          'string' == typeof e.type &&
          e.type.startsWith('response.')
        );
      }),
      (n.setCommonResponseAttributes = function (e, t, n, i) {
        (e.setAttributes({
          [r.OPENAI_RESPONSE_ID_ATTRIBUTE]: t,
          [r.GEN_AI_RESPONSE_ID_ATTRIBUTE]: t,
        }),
          e.setAttributes({
            [r.OPENAI_RESPONSE_MODEL_ATTRIBUTE]: n,
            [r.GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: n,
          }),
          e.setAttributes({
            [r.OPENAI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(1e3 * i).toISOString(),
          }));
      }),
      (n.setTokenUsageAttributes = function (e, t, n, i) {
        (void 0 !== t &&
          e.setAttributes({
            [r.OPENAI_USAGE_PROMPT_TOKENS_ATTRIBUTE]: t,
            [r.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: t,
          }),
          void 0 !== n &&
            e.setAttributes({
              [r.OPENAI_USAGE_COMPLETION_TOKENS_ATTRIBUTE]: n,
              [r.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: n,
            }),
          void 0 !== i && e.setAttributes({ [r.GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: i }));
      }),
      (n.shouldInstrument = function (e) {
        return i.INSTRUMENTED_METHODS.includes(e);
      }));
  },
  51607,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(55842),
      i = e.r(72517),
      o = e.r(50217),
      a = e.r(45404),
      s = e.r(36080);
    n.instrumentStream = async function* (e, t, n) {
      let u = {
        eventTypes: [],
        responseTexts: [],
        finishReasons: [],
        responseId: '',
        responseModel: '',
        responseTimestamp: 0,
        promptTokens: void 0,
        completionTokens: void 0,
        totalTokens: void 0,
        chatCompletionToolCalls: {},
        responsesApiToolCalls: [],
      };
      try {
        for await (let o of e) {
          if (s.isChatCompletionChunk(o))
            for (let e of ((u.responseId = o.id ?? u.responseId),
            (u.responseModel = o.model ?? u.responseModel),
            (u.responseTimestamp = o.created ?? u.responseTimestamp),
            o.usage &&
              ((u.promptTokens = o.usage.prompt_tokens),
              (u.completionTokens = o.usage.completion_tokens),
              (u.totalTokens = o.usage.total_tokens)),
            o.choices ?? []))
              (n &&
                (e.delta?.content && u.responseTexts.push(e.delta.content),
                e.delta?.tool_calls &&
                  (function (e, t) {
                    for (let n of e) {
                      let e = n.index;
                      if (void 0 !== e && n.function)
                        if (e in t.chatCompletionToolCalls) {
                          let r = t.chatCompletionToolCalls[e];
                          n.function.arguments &&
                            r?.function &&
                            (r.function.arguments += n.function.arguments);
                        } else
                          t.chatCompletionToolCalls[e] = {
                            ...n,
                            function: {
                              name: n.function.name,
                              arguments: n.function.arguments || '',
                            },
                          };
                    }
                  })(e.delta.tool_calls, u)),
                e.finish_reason && u.finishReasons.push(e.finish_reason));
          else
            s.isResponsesApiStreamEvent(o) &&
              (function (e, t, n, o) {
                if (!(e && 'object' == typeof e)) return t.eventTypes.push('unknown:non-object');
                if (e instanceof Error) {
                  (o.setStatus({ code: i.SPAN_STATUS_ERROR, message: 'internal_error' }),
                    r.captureException(e, { mechanism: { handled: !1 } }));
                  return;
                }
                if ('type' in e) {
                  if (!a.RESPONSE_EVENT_TYPES.includes(e.type)) return t.eventTypes.push(e.type);
                  if (
                    n &&
                    ('response.output_item.done' === e.type &&
                      'item' in e &&
                      t.responsesApiToolCalls.push(e.item),
                    'response.output_text.delta' === e.type && 'delta' in e && e.delta)
                  )
                    return t.responseTexts.push(e.delta);
                  if ('response' in e) {
                    let { response: r } = e;
                    ((t.responseId = r.id ?? t.responseId),
                      (t.responseModel = r.model ?? t.responseModel),
                      (t.responseTimestamp = r.created_at ?? t.responseTimestamp),
                      r.usage &&
                        ((t.promptTokens = r.usage.input_tokens),
                        (t.completionTokens = r.usage.output_tokens),
                        (t.totalTokens = r.usage.total_tokens)),
                      r.status && t.finishReasons.push(r.status),
                      n && r.output_text && t.responseTexts.push(r.output_text));
                  }
                }
              })(o, u, n, t);
          yield o;
        }
      } finally {
        (s.setCommonResponseAttributes(t, u.responseId, u.responseModel, u.responseTimestamp),
          s.setTokenUsageAttributes(t, u.promptTokens, u.completionTokens, u.totalTokens),
          t.setAttributes({ [o.GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: !0 }),
          u.finishReasons.length &&
            t.setAttributes({
              [o.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(u.finishReasons),
            }),
          n &&
            u.responseTexts.length &&
            t.setAttributes({ [o.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: u.responseTexts.join('') }));
        let e = [...Object.values(u.chatCompletionToolCalls), ...u.responsesApiToolCalls];
        (e.length > 0 &&
          t.setAttributes({ [o.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(e) }),
          t.end());
      }
    };
  },
  74565,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(55842),
      o = e.r(13801),
      a = e.r(72517),
      s = e.r(66744),
      u = e.r(50217),
      l = e.r(45404),
      c = e.r(51607),
      d = e.r(36080);
    function p(e, t) {
      ('messages' in t &&
        e.setAttributes({ [u.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(t.messages) }),
        'input' in t &&
          e.setAttributes({ [u.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(t.input) }));
    }
    n.instrumentOpenAiClient = function (e, t) {
      return (function e(t, n = '', _) {
        return new Proxy(t, {
          get(t, S) {
            let E = t[S],
              T = d.buildMethodPath(n, String(S));
            if ('function' == typeof E && d.shouldInstrument(T))
              return async function (...e) {
                let n =
                    _ ||
                    (function () {
                      let e = r.getCurrentScope().getClient(),
                        t = e?.getIntegrationByName(l.OPENAI_INTEGRATION_NAME),
                        n = !!t && !!e?.getOptions().sendDefaultPii;
                      return {
                        recordInputs: t?.options?.recordInputs ?? n,
                        recordOutputs: t?.options?.recordOutputs ?? n,
                      };
                    })(),
                  S = (function (e, t) {
                    let n = {
                      [u.GEN_AI_SYSTEM_ATTRIBUTE]: 'openai',
                      [u.GEN_AI_OPERATION_NAME_ATTRIBUTE]: d.getOperationName(t),
                      [o.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.openai',
                    };
                    if (e.length > 0 && 'object' == typeof e[0] && null !== e[0]) {
                      let t = e[0],
                        r = [
                          ...(Array.isArray(t.tools) ? t.tools : []),
                          ...(t.web_search_options && 'object' == typeof t.web_search_options
                            ? [{ type: 'web_search_options', ...t.web_search_options }]
                            : []),
                        ];
                      r.length > 0 &&
                        (n[u.GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(r));
                    }
                    if (e.length > 0 && 'object' == typeof e[0] && null !== e[0]) {
                      let t = e[0];
                      ((n[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = t.model ?? 'unknown'),
                        'temperature' in t &&
                          (n[u.GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = t.temperature),
                        'top_p' in t && (n[u.GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = t.top_p),
                        'frequency_penalty' in t &&
                          (n[u.GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = t.frequency_penalty),
                        'presence_penalty' in t &&
                          (n[u.GEN_AI_REQUEST_PRESENCE_PENALTY_ATTRIBUTE] = t.presence_penalty),
                        'stream' in t && (n[u.GEN_AI_REQUEST_STREAM_ATTRIBUTE] = t.stream));
                    } else n[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown';
                    return n;
                  })(e, T),
                  m = S[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] || 'unknown',
                  g = d.getOperationName(T),
                  f = e[0];
                return f && 'object' == typeof f && !0 === f.stream
                  ? s.startSpanManual(
                      {
                        name: `${g} ${m} stream-response`,
                        op: d.getSpanOperation(T),
                        attributes: S,
                      },
                      async (r) => {
                        try {
                          n.recordInputs && e[0] && 'object' == typeof e[0] && p(r, e[0]);
                          let i = await E.apply(t, e);
                          return c.instrumentStream(i, r, n.recordOutputs ?? !1);
                        } catch (e) {
                          throw (
                            r.setStatus({ code: a.SPAN_STATUS_ERROR, message: 'internal_error' }),
                            i.captureException(e, { mechanism: { handled: !1 } }),
                            r.end(),
                            e
                          );
                        }
                      }
                    )
                  : s.startSpan(
                      { name: `${g} ${m}`, op: d.getSpanOperation(T), attributes: S },
                      async (r) => {
                        try {
                          n.recordInputs && e[0] && 'object' == typeof e[0] && p(r, e[0]);
                          let i = await E.apply(t, e);
                          return (
                            !(function (e, t, n) {
                              if (t && 'object' == typeof t) {
                                if (d.isChatCompletionResponse(t)) {
                                  if (
                                    (d.setCommonResponseAttributes(e, t.id, t.model, t.created),
                                    t.usage &&
                                      d.setTokenUsageAttributes(
                                        e,
                                        t.usage.prompt_tokens,
                                        t.usage.completion_tokens,
                                        t.usage.total_tokens
                                      ),
                                    Array.isArray(t.choices))
                                  ) {
                                    let r = t.choices
                                      .map((e) => e.finish_reason)
                                      .filter((e) => null !== e);
                                    if (
                                      (r.length > 0 &&
                                        e.setAttributes({
                                          [u.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]:
                                            JSON.stringify(r),
                                        }),
                                      n)
                                    ) {
                                      let n = t.choices
                                        .map((e) => e.message?.tool_calls)
                                        .filter((e) => Array.isArray(e) && e.length > 0)
                                        .flat();
                                      n.length > 0 &&
                                        e.setAttributes({
                                          [u.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]:
                                            JSON.stringify(n),
                                        });
                                    }
                                  }
                                  if (n && t.choices?.length) {
                                    let n = t.choices.map((e) => e.message?.content || '');
                                    e.setAttributes({
                                      [u.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(n),
                                    });
                                  }
                                } else if (d.isResponsesApiResponse(t)) {
                                  if (
                                    (d.setCommonResponseAttributes(e, t.id, t.model, t.created_at),
                                    t.status &&
                                      e.setAttributes({
                                        [u.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]:
                                          JSON.stringify([t.status]),
                                      }),
                                    t.usage &&
                                      d.setTokenUsageAttributes(
                                        e,
                                        t.usage.input_tokens,
                                        t.usage.output_tokens,
                                        t.usage.total_tokens
                                      ),
                                    n && Array.isArray(t.output) && t.output.length > 0)
                                  ) {
                                    let n = t.output.filter(
                                      (e) =>
                                        'object' == typeof e &&
                                        null !== e &&
                                        'function_call' === e.type
                                    );
                                    n.length > 0 &&
                                      e.setAttributes({
                                        [u.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(n),
                                      });
                                  }
                                  n &&
                                    t.output_text &&
                                    e.setAttributes({
                                      [u.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: t.output_text,
                                    });
                                }
                              }
                            })(r, i, n.recordOutputs),
                            i
                          );
                        } catch (e) {
                          throw (i.captureException(e), e);
                        }
                      }
                    );
              };
            return 'function' == typeof E ? E.bind(t) : E && 'object' == typeof E ? e(E, T, _) : E;
          },
        });
      })(e, '', t);
    };
  },
  76992,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(50217);
    function i(e) {
      return e.includes('messages')
        ? 'messages'
        : e.includes('completions')
          ? 'completions'
          : e.includes('models')
            ? 'models'
            : e.split('.').pop() || 'unknown';
    }
    ((n.buildMethodPath = function (e, t) {
      return e ? `${e}.${t}` : t;
    }),
      (n.getFinalOperationName = i),
      (n.getSpanOperation = function (e) {
        return `gen_ai.${i(e)}`;
      }),
      (n.setTokenUsageAttributes = function (e, t, n, i, o) {
        (void 0 !== t && e.setAttributes({ [r.GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE]: t }),
          void 0 !== n && e.setAttributes({ [r.GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE]: n }),
          (void 0 !== t || void 0 !== n || void 0 !== i || void 0 !== o) &&
            e.setAttributes({
              [r.GEN_AI_USAGE_TOTAL_TOKENS_ATTRIBUTE]: (t ?? 0) + (n ?? 0) + (i ?? 0) + (o ?? 0),
            }));
      }));
  },
  32695,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.ANTHROPIC_AI_INSTRUMENTED_METHODS = [
        'messages.create',
        'messages.stream',
        'messages.countTokens',
        'models.get',
        'completions.create',
        'models.retrieve',
        'beta.messages.create',
      ]),
      (n.ANTHROPIC_AI_INTEGRATION_NAME = 'Anthropic_AI'));
  },
  4828,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(55842),
      i = e.r(72517),
      o = e.r(50217),
      a = e.r(76992);
    n.instrumentStream = async function* (e, t, n) {
      let s = {
        responseTexts: [],
        finishReasons: [],
        responseId: '',
        responseModel: '',
        promptTokens: void 0,
        completionTokens: void 0,
        cacheCreationInputTokens: void 0,
        cacheReadInputTokens: void 0,
        toolCalls: [],
        activeToolBlocks: {},
      };
      try {
        for await (let o of e)
          (!(function (e, t, n, o) {
            if (
              e &&
              'object' == typeof e &&
              !(function (e, t) {
                if ('type' in e && 'string' == typeof e.type && 'error' === e.type) {
                  let n = e.error?.message ?? 'internal_error';
                  return (
                    t.setStatus({ code: i.SPAN_STATUS_ERROR, message: n }),
                    r.captureException(Error(`anthropic_stream_error: ${n}`), {
                      mechanism: {
                        handled: !1,
                        type: 'auto.ai.anthropic',
                        data: { function: 'anthropic_stream_error' },
                      },
                      data: { function: 'anthropic_stream_error' },
                    }),
                    !0
                  );
                }
                return !1;
              })(e, o)
            ) {
              if (
                ('message_delta' === e.type &&
                  e.usage &&
                  'output_tokens' in e.usage &&
                  'number' == typeof e.usage.output_tokens &&
                  (t.completionTokens = e.usage.output_tokens),
                e.message)
              ) {
                let n = e.message;
                (n.id && (t.responseId = n.id),
                  n.model && (t.responseModel = n.model),
                  n.stop_reason && t.finishReasons.push(n.stop_reason),
                  n.usage &&
                    ('number' == typeof n.usage.input_tokens &&
                      (t.promptTokens = n.usage.input_tokens),
                    'number' == typeof n.usage.cache_creation_input_tokens &&
                      (t.cacheCreationInputTokens = n.usage.cache_creation_input_tokens),
                    'number' == typeof n.usage.cache_read_input_tokens &&
                      (t.cacheReadInputTokens = n.usage.cache_read_input_tokens)));
              }
              'content_block_start' === e.type &&
                'number' == typeof e.index &&
                e.content_block &&
                ('tool_use' === e.content_block.type ||
                  'server_tool_use' === e.content_block.type) &&
                (t.activeToolBlocks[e.index] = {
                  id: e.content_block.id,
                  name: e.content_block.name,
                  inputJsonParts: [],
                });
              if ('content_block_delta' === e.type && e.delta) {
                if (
                  'number' == typeof e.index &&
                  'partial_json' in e.delta &&
                  'string' == typeof e.delta.partial_json
                ) {
                  let n = t.activeToolBlocks[e.index];
                  n && n.inputJsonParts.push(e.delta.partial_json);
                }
                n && 'string' == typeof e.delta.text && t.responseTexts.push(e.delta.text);
              }
              !(function (e, t) {
                let n;
                if ('content_block_stop' !== e.type || 'number' != typeof e.index) return;
                let r = t.activeToolBlocks[e.index];
                if (!r) return;
                let i = r.inputJsonParts.join('');
                try {
                  n = i ? JSON.parse(i) : {};
                } catch {
                  n = { __unparsed: i };
                }
                (t.toolCalls.push({ type: 'tool_use', id: r.id, name: r.name, input: n }),
                  delete t.activeToolBlocks[e.index]);
              })(e, t);
            }
          })(o, s, n, t),
            yield o);
      } finally {
        (s.responseId && t.setAttributes({ [o.GEN_AI_RESPONSE_ID_ATTRIBUTE]: s.responseId }),
          s.responseModel &&
            t.setAttributes({ [o.GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: s.responseModel }),
          a.setTokenUsageAttributes(
            t,
            s.promptTokens,
            s.completionTokens,
            s.cacheCreationInputTokens,
            s.cacheReadInputTokens
          ),
          t.setAttributes({ [o.GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: !0 }),
          s.finishReasons.length > 0 &&
            t.setAttributes({
              [o.GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(s.finishReasons),
            }),
          n &&
            s.responseTexts.length > 0 &&
            t.setAttributes({ [o.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: s.responseTexts.join('') }),
          n &&
            s.toolCalls.length > 0 &&
            t.setAttributes({
              [o.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(s.toolCalls),
            }),
          t.end());
      }
    };
  },
  79140,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(32695);
    n.shouldInstrument = function (e) {
      return r.ANTHROPIC_AI_INSTRUMENTED_METHODS.includes(e);
    };
  },
  47155,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(6336),
      i = e.r(55842),
      o = e.r(13801),
      a = e.r(72517),
      s = e.r(66744),
      u = e.r(50217),
      l = e.r(76992),
      c = e.r(32695),
      d = e.r(4828),
      p = e.r(79140);
    function _(e, t) {
      ('messages' in t &&
        e.setAttributes({ [u.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(t.messages) }),
        'input' in t &&
          e.setAttributes({ [u.GEN_AI_REQUEST_MESSAGES_ATTRIBUTE]: JSON.stringify(t.input) }),
        'prompt' in t &&
          e.setAttributes({ [u.GEN_AI_PROMPT_ATTRIBUTE]: JSON.stringify(t.prompt) }));
    }
    n.instrumentAnthropicAiClient = function (e, t) {
      return (function e(t, n = '', S) {
        return new Proxy(t, {
          get(t, E) {
            let T = t[E],
              m = l.buildMethodPath(n, String(E));
            if ('function' == typeof T && p.shouldInstrument(m))
              return async function (...e) {
                let n =
                    S ||
                    (function () {
                      let e = r.getCurrentScope().getClient(),
                        t = e?.getIntegrationByName(c.ANTHROPIC_AI_INTEGRATION_NAME),
                        n = !!t && !!e?.getOptions().sendDefaultPii;
                      return {
                        recordInputs: t?.options?.recordInputs ?? n,
                        recordOutputs: t?.options?.recordOutputs ?? n,
                      };
                    })(),
                  p = (function (e, t) {
                    let n = {
                      [u.GEN_AI_SYSTEM_ATTRIBUTE]: 'anthropic',
                      [u.GEN_AI_OPERATION_NAME_ATTRIBUTE]: l.getFinalOperationName(t),
                      [o.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ai.anthropic',
                    };
                    if (e.length > 0 && 'object' == typeof e[0] && null !== e[0]) {
                      let t = e[0];
                      (t.tools &&
                        Array.isArray(t.tools) &&
                        (n[u.GEN_AI_REQUEST_AVAILABLE_TOOLS_ATTRIBUTE] = JSON.stringify(t.tools)),
                        (n[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = t.model ?? 'unknown'),
                        'temperature' in t &&
                          (n[u.GEN_AI_REQUEST_TEMPERATURE_ATTRIBUTE] = t.temperature),
                        'top_p' in t && (n[u.GEN_AI_REQUEST_TOP_P_ATTRIBUTE] = t.top_p),
                        'stream' in t && (n[u.GEN_AI_REQUEST_STREAM_ATTRIBUTE] = t.stream),
                        'top_k' in t && (n[u.GEN_AI_REQUEST_TOP_K_ATTRIBUTE] = t.top_k),
                        'frequency_penalty' in t &&
                          (n[u.GEN_AI_REQUEST_FREQUENCY_PENALTY_ATTRIBUTE] = t.frequency_penalty),
                        'max_tokens' in t &&
                          (n[u.GEN_AI_REQUEST_MAX_TOKENS_ATTRIBUTE] = t.max_tokens));
                    } else
                      'models.retrieve' === t || 'models.get' === t
                        ? (n[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = e[0])
                        : (n[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] = 'unknown');
                    return n;
                  })(e, m),
                  E = p[u.GEN_AI_REQUEST_MODEL_ATTRIBUTE] ?? 'unknown',
                  g = l.getFinalOperationName(m),
                  f = 'object' == typeof e[0] ? e[0] : void 0,
                  h = !!f?.stream,
                  A = 'messages.stream' === m;
                return h || A
                  ? s.startSpanManual(
                      {
                        name: `${g} ${E} stream-response`,
                        op: l.getSpanOperation(m),
                        attributes: p,
                      },
                      async (r) => {
                        try {
                          n.recordInputs && f && _(r, f);
                          let i = await T.apply(t, e);
                          return d.instrumentStream(i, r, n.recordOutputs ?? !1);
                        } catch (e) {
                          throw (
                            r.setStatus({ code: a.SPAN_STATUS_ERROR, message: 'internal_error' }),
                            i.captureException(e, {
                              mechanism: {
                                handled: !1,
                                type: 'auto.ai.anthropic',
                                data: { function: m },
                              },
                            }),
                            r.end(),
                            e
                          );
                        }
                      }
                    )
                  : s.startSpan(
                      { name: `${g} ${E}`, op: l.getSpanOperation(m), attributes: p },
                      async (r) => {
                        try {
                          n.recordInputs && e[0] && 'object' == typeof e[0] && _(r, e[0]);
                          let i = await T.apply(t, e);
                          var o = n.recordOutputs;
                          if (i && 'object' == typeof i) {
                            if (o) {
                              if ('content' in i && Array.isArray(i.content)) {
                                r.setAttributes({
                                  [u.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: i.content
                                    .map((e) => e.text)
                                    .filter((e) => !!e)
                                    .join(''),
                                });
                                let e = [];
                                for (let t of i.content)
                                  ('tool_use' === t.type || 'server_tool_use' === t.type) &&
                                    e.push(t);
                                e.length > 0 &&
                                  r.setAttributes({
                                    [u.GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(e),
                                  });
                              }
                              ('completion' in i &&
                                r.setAttributes({
                                  [u.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: i.completion,
                                }),
                                'input_tokens' in i &&
                                  r.setAttributes({
                                    [u.GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: JSON.stringify(
                                      i.input_tokens
                                    ),
                                  }));
                            }
                            (r.setAttributes({ [u.GEN_AI_RESPONSE_ID_ATTRIBUTE]: i.id }),
                              r.setAttributes({ [u.GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: i.model }),
                              'created' in i &&
                                'number' == typeof i.created &&
                                r.setAttributes({
                                  [u.ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(
                                    1e3 * i.created
                                  ).toISOString(),
                                }),
                              'created_at' in i &&
                                'number' == typeof i.created_at &&
                                r.setAttributes({
                                  [u.ANTHROPIC_AI_RESPONSE_TIMESTAMP_ATTRIBUTE]: new Date(
                                    1e3 * i.created_at
                                  ).toISOString(),
                                }),
                              i.usage &&
                                l.setTokenUsageAttributes(
                                  r,
                                  i.usage.input_tokens,
                                  i.usage.output_tokens,
                                  i.usage.cache_creation_input_tokens,
                                  i.usage.cache_read_input_tokens
                                ));
                          }
                          return i;
                        } catch (e) {
                          throw (
                            i.captureException(e, {
                              mechanism: {
                                handled: !1,
                                type: 'auto.ai.anthropic',
                                data: { function: m },
                              },
                            }),
                            e
                          );
                        }
                      }
                    );
              };
            return 'function' == typeof T ? T.bind(t) : T && 'object' == typeof T ? e(T, m, S) : T;
          },
        });
      })(e, '', t);
    };
  },
  16444,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.getBreadcrumbLogLevelFromHttpStatusCode = function (e) {
        if (void 0 !== e) return e >= 400 && e < 500 ? 'warning' : e >= 500 ? 'error' : void 0;
      }));
  },
  52734,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.SentryError = class extends Error {
        constructor(e, t = 'warn') {
          (super(e), (this.message = e), (this.logLevel = t));
        }
      }));
  },
  76237,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(65553),
      i = e.r(13500),
      o = e.r(83247).GLOBAL_OBJ;
    function a() {
      if (!('fetch' in o)) return !1;
      try {
        return (new Headers(), new Request('http://www.example.com'), new Response(), !0);
      } catch {
        return !1;
      }
    }
    function s(e) {
      return e && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString());
    }
    ((n.isNativeFunction = s),
      (n.supportsDOMError = function () {
        try {
          return (new DOMError(''), !0);
        } catch {
          return !1;
        }
      }),
      (n.supportsDOMException = function () {
        try {
          return (new DOMException(''), !0);
        } catch {
          return !1;
        }
      }),
      (n.supportsErrorEvent = function () {
        try {
          return (new ErrorEvent(''), !0);
        } catch {
          return !1;
        }
      }),
      (n.supportsFetch = a),
      (n.supportsHistory = function () {
        return 'history' in o && !!o.history;
      }),
      (n.supportsNativeFetch = function () {
        if ('string' == typeof EdgeRuntime) return !0;
        if (!a()) return !1;
        if (s(o.fetch)) return !0;
        let e = !1,
          t = o.document;
        if (t && 'function' == typeof t.createElement)
          try {
            let n = t.createElement('iframe');
            ((n.hidden = !0),
              t.head.appendChild(n),
              n.contentWindow?.fetch && (e = s(n.contentWindow.fetch)),
              t.head.removeChild(n));
          } catch (e) {
            r.DEBUG_BUILD &&
              i.debug.warn(
                'Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ',
                e
              );
          }
        return e;
      }),
      (n.supportsReferrerPolicy = function () {
        if (!a()) return !1;
        try {
          return (new Request('_', { referrerPolicy: 'origin' }), !0);
        } catch {
          return !1;
        }
      }),
      (n.supportsReportingObserver = function () {
        return 'ReportingObserver' in o;
      }));
  },
  72068,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2802),
      i = e.r(63236),
      o = e.r(76237),
      a = e.r(28685),
      s = e.r(83247),
      u = e.r(32801);
    function l(e, t = !1) {
      (!t || o.supportsNativeFetch()) &&
        i.fill(s.GLOBAL_OBJ, 'fetch', function (t) {
          return function (...n) {
            let o = Error(),
              { method: l, url: c } = S(n),
              d = {
                args: n,
                fetchData: { method: l, url: c },
                startTimestamp: 1e3 * a.timestampInSeconds(),
                virtualError: o,
                headers: (function (e) {
                  let [t, n] = e;
                  try {
                    if ('object' == typeof n && null !== n && 'headers' in n && n.headers)
                      return new Headers(n.headers);
                    if (r.isRequest(t)) return new Headers(t.headers);
                  } catch {}
                })(n),
              };
            return (
              e || u.triggerHandlers('fetch', { ...d }),
              t.apply(s.GLOBAL_OBJ, n).then(
                async (t) => (
                  e
                    ? e(t)
                    : u.triggerHandlers('fetch', {
                        ...d,
                        endTimestamp: 1e3 * a.timestampInSeconds(),
                        response: t,
                      }),
                  t
                ),
                (e) => {
                  if (
                    (u.triggerHandlers('fetch', {
                      ...d,
                      endTimestamp: 1e3 * a.timestampInSeconds(),
                      error: e,
                    }),
                    r.isError(e) &&
                      void 0 === e.stack &&
                      ((e.stack = o.stack), i.addNonEnumerableProperty(e, 'framesToPop', 1)),
                    e instanceof TypeError &&
                      ('Failed to fetch' === e.message ||
                        'Load failed' === e.message ||
                        'NetworkError when attempting to fetch resource.' === e.message))
                  )
                    try {
                      let t = new URL(d.fetchData.url);
                      e.message = `${e.message} (${t.host})`;
                    } catch {}
                  throw e;
                }
              )
            );
          };
        });
    }
    async function c(e, t) {
      if (e?.body) {
        let n = e.body,
          r = n.getReader(),
          i = setTimeout(() => {
            n.cancel().then(null, () => {});
          }, 9e4),
          o = !0;
        for (; o; ) {
          let e;
          try {
            e = setTimeout(() => {
              n.cancel().then(null, () => {});
            }, 5e3);
            let { done: i } = await r.read();
            (clearTimeout(e), i && (t(), (o = !1)));
          } catch {
            o = !1;
          } finally {
            clearTimeout(e);
          }
        }
        (clearTimeout(i), r.releaseLock(), n.cancel().then(null, () => {}));
      }
    }
    function d(e) {
      let t;
      try {
        t = e.clone();
      } catch {
        return;
      }
      c(t, () => {
        u.triggerHandlers('fetch-body-resolved', {
          endTimestamp: 1e3 * a.timestampInSeconds(),
          response: e,
        });
      });
    }
    function p(e, t) {
      return !!e && 'object' == typeof e && !!e[t];
    }
    function _(e) {
      return 'string' == typeof e
        ? e
        : e
          ? p(e, 'url')
            ? e.url
            : e.toString
              ? e.toString()
              : ''
          : '';
    }
    function S(e) {
      if (0 === e.length) return { method: 'GET', url: '' };
      if (2 === e.length) {
        let [t, n] = e;
        return { url: _(t), method: p(n, 'method') ? String(n.method).toUpperCase() : 'GET' };
      }
      let t = e[0];
      return { url: _(t), method: p(t, 'method') ? String(t.method).toUpperCase() : 'GET' };
    }
    ((n.addFetchEndInstrumentationHandler = function (e) {
      let t = 'fetch-body-resolved';
      (u.addHandler(t, e), u.maybeInstrument(t, () => l(d)));
    }),
      (n.addFetchInstrumentationHandler = function (e, t) {
        let n = 'fetch';
        (u.addHandler(n, e), u.maybeInstrument(n, () => l(void 0, t)));
      }),
      (n.parseFetchArgs = S));
  },
  41318,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.getSDKSource = function () {
        return 'npm';
      }),
      (n.isBrowserBundle = function () {
        return 'undefined' != typeof __SENTRY_BROWSER_BUNDLE__ && !!__SENTRY_BROWSER_BUNDLE__;
      }));
  },
  49261,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(41318);
    function i(e, t) {
      return e.require(t);
    }
    ((n.isNodeEnv = function () {
      return (
        !r.isBrowserBundle() &&
        '[object process]' ===
          Object.prototype.toString.call('undefined' != typeof process ? process : 0)
      );
    }),
      (n.loadModule = function (e, n = t) {
        let r;
        try {
          r = i(n, e);
        } catch {}
        if (!r)
          try {
            let { cwd: t } = i(n, 'process');
            r = i(n, `${t()}/node_modules/${e}`);
          } catch {}
        return r;
      }));
  },
  88439,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      e.r(49261),
      e.r(83247),
      (n.isBrowser = function () {
        return !1;
      }));
  },
  88192,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(87195);
    function i(e, t = !1) {
      return (
        !(
          t ||
          (e &&
            !e.startsWith('/') &&
            !e.match(/^[A-Z]:/) &&
            !e.startsWith('.') &&
            !e.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
        ) &&
        void 0 !== e &&
        !e.includes('node_modules/')
      );
    }
    function o(e) {
      let t = /^\s*[-]{4,}$/,
        n = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/,
        o = /at (?:async )?(.+?) \(data:(.*?),/;
      return (s) => {
        let u = s.match(o);
        if (u) return { filename: `<data:${u[2]}>`, function: u[1] };
        let l = s.match(n);
        if (l) {
          let t, n, o, s, u;
          if (l[1]) {
            let e = (o = l[1]).lastIndexOf('.');
            if (('.' === o[e - 1] && e--, e > 0)) {
              ((t = o.slice(0, e)), (n = o.slice(e + 1)));
              let r = t.indexOf('.Module');
              r > 0 && ((o = o.slice(r + 1)), (t = t.slice(0, r)));
            }
            s = void 0;
          }
          (n && ((s = t), (u = n)),
            '<anonymous>' === n && ((u = void 0), (o = void 0)),
            void 0 === o && ((u = u || r.UNKNOWN_FUNCTION), (o = s ? `${s}.${u}` : u)));
          let c = l[2]?.startsWith('file://') ? l[2].slice(7) : l[2],
            d = 'native' === l[5];
          return (
            c?.match(/\/[A-Z]:/) && (c = c.slice(1)),
            c || !l[5] || d || (c = l[5]),
            {
              filename: c ? decodeURI(c) : void 0,
              module: e ? e(c) : void 0,
              function: o,
              lineno: a(l[3]),
              colno: a(l[4]),
              in_app: i(c || '', d),
            }
          );
        }
        if (s.match(t)) return { filename: s };
      };
    }
    function a(e) {
      return parseInt(e || '', 10) || void 0;
    }
    ((n.filenameIsInApp = i),
      (n.node = o),
      (n.nodeStackLineParser = function (e) {
        return [90, o(e)];
      }));
  },
  59883,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(88192),
      i = e.r(87195);
    ((n.callFrameToStackFrame = function (e, t, n) {
      let o = t ? t.replace(/^file:\/\//, '') : void 0,
        a = e.location.columnNumber ? e.location.columnNumber + 1 : void 0,
        s = e.location.lineNumber ? e.location.lineNumber + 1 : void 0;
      return {
        filename: o,
        module: n(o),
        function: e.functionName || i.UNKNOWN_FUNCTION,
        colno: a,
        lineno: s,
        in_app: o ? r.filenameIsInApp(o) : void 0,
      };
    }),
      (n.watchdogTimer = function (e, t, n, r) {
        let i = e(),
          o = !1,
          a = !0;
        return (
          setInterval(() => {
            let e = i.getTimeMs();
            (!1 === o && e > t + n && ((o = !0), a && r()), e < t + n && (o = !1));
          }, 20),
          {
            poll: () => {
              i.reset();
            },
            enabled: (e) => {
              a = e;
            },
          }
        );
      }));
  },
  275,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.LRUMap = class {
        constructor(e) {
          ((this._maxSize = e), (this._cache = new Map()));
        }
        get size() {
          return this._cache.size;
        }
        get(e) {
          let t = this._cache.get(e);
          if (void 0 !== t) return (this._cache.delete(e), this._cache.set(e, t), t);
        }
        set(e, t) {
          (this._cache.size >= this._maxSize && this._cache.delete(this._cache.keys().next().value),
            this._cache.set(e, t));
        }
        remove(e) {
          let t = this._cache.get(e);
          return (t && this._cache.delete(e), t);
        }
        clear() {
          this._cache.clear();
        }
        keys() {
          return Array.from(this._cache.keys());
        }
        values() {
          let e = [];
          return (this._cache.forEach((t) => e.push(t)), e);
        }
      }));
  },
  60477,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(83247);
    n.vercelWaitUntil = function (e) {
      let t = r.GLOBAL_OBJ[Symbol.for('@vercel/request-context')],
        n = t?.get?.();
      n?.waitUntil && n.waitUntil(e);
    };
  },
  62610,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(55842),
      i = e.r(13500),
      o = e.r(60477),
      a = e.r(83247);
    async function s(e) {
      try {
        (i.debug.log('Flushing events...'), await r.flush(e), i.debug.log('Done flushing events'));
      } catch (e) {
        i.debug.log('Error while flushing events:\n', e);
      }
    }
    n.flushIfServerless = async function (e = {}) {
      let { timeout: t = 2e3 } = e;
      return 'cloudflareWaitUntil' in e && 'function' == typeof e?.cloudflareWaitUntil
        ? void e.cloudflareWaitUntil(s(t))
        : 'cloudflareCtx' in e && 'function' == typeof e.cloudflareCtx?.waitUntil
          ? void e.cloudflareCtx.waitUntil(s(t))
          : a.GLOBAL_OBJ[Symbol.for('@vercel/request-context')]
            ? void o.vercelWaitUntil(s(t))
            : 'undefined' == typeof process
              ? void 0
              : void (
                  (process.env.FUNCTIONS_WORKER_RUNTIME ||
                    process.env.LAMBDA_TASK_ROOT ||
                    process.env.K_SERVICE ||
                    process.env.CF_PAGES ||
                    process.env.VERCEL ||
                    process.env.NETLIFY) &&
                  (await s(t))
                );
    };
  },
  11816,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.escapeStringForRegex = function (e) {
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
      }));
  },
  48009,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(91630),
      i = e.r(82335),
      o = e.r(58597),
      a = e.r(75803),
      s = e.r(29946),
      u = e.r(72517),
      l = e.r(66744),
      c = e.r(22599),
      d = e.r(22353),
      p = e.r(57785),
      _ = e.r(1769),
      S = e.r(13801),
      E = e.r(66400),
      T = e.r(55842),
      m = e.r(6336),
      g = e.r(7716),
      f = e.r(23196),
      h = e.r(20434),
      A = e.r(54596),
      R = e.r(32515),
      y = e.r(10083),
      I = e.r(81435),
      b = e.r(83666),
      N = e.r(21571),
      O = e.r(2396),
      v = e.r(48476),
      C = e.r(38242),
      P = e.r(38769),
      M = e.r(39059),
      L = e.r(97935),
      U = e.r(47333),
      D = e.r(30201),
      x = e.r(9338),
      w = e.r(72740),
      k = e.r(30307),
      G = e.r(97589),
      V = e.r(48790),
      $ = e.r(24205),
      B = e.r(45018),
      H = e.r(88313),
      j = e.r(25086),
      F = e.r(97121),
      Z = e.r(45143),
      Y = e.r(82619),
      W = e.r(23363),
      K = e.r(53152),
      z = e.r(46773),
      X = e.r(26884),
      J = e.r(82133),
      Q = e.r(22540),
      q = e.r(28496),
      ee = e.r(65849),
      et = e.r(39169),
      en = e.r(66243),
      er = e.r(71998),
      ei = e.r(98348),
      eo = e.r(41094),
      ea = e.r(98720),
      es = e.r(82063),
      eu = e.r(6355),
      el = e.r(26129),
      ec = e.r(79892),
      ed = e.r(51266),
      ep = e.r(89580),
      e_ = e.r(22106),
      eS = e.r(10241),
      eE = e.r(13128),
      eT = e.r(70161),
      em = e.r(67e3),
      eg = e.r(74565),
      ef = e.r(45404),
      eh = e.r(47155),
      eA = e.r(32695),
      eR = e.r(81130),
      ey = e.r(57896),
      eI = e.r(16444),
      eb = e.r(24211),
      eN = e.r(87033),
      eO = e.r(52734),
      ev = e.r(83247),
      eC = e.r(10045),
      eP = e.r(72068),
      eM = e.r(59937),
      eL = e.r(15591),
      eU = e.r(32801),
      eD = e.r(2802),
      ex = e.r(88439),
      ew = e.r(13500),
      ek = e.r(21919),
      eG = e.r(49261),
      eV = e.r(97548),
      e$ = e.r(63236),
      eB = e.r(91995),
      eH = e.r(90736),
      ej = e.r(61302),
      eF = e.r(87195),
      eZ = e.r(88192),
      eY = e.r(22111),
      eW = e.r(76237),
      eK = e.r(63652),
      ez = e.r(28685),
      eX = e.r(26270),
      eJ = e.r(41318),
      eQ = e.r(46274),
      eq = e.r(6583),
      e0 = e.r(11918),
      e1 = e.r(8612),
      e2 = e.r(16097),
      e5 = e.r(30158),
      e4 = e.r(59883),
      e9 = e.r(275),
      e3 = e.r(99712),
      e6 = e.r(60477),
      e7 = e.r(62610),
      e8 = e.r(32592),
      te = e.r(69718),
      tt = e.r(11816);
    ((n.registerSpanErrorInstrumentation = r.registerSpanErrorInstrumentation),
      (n.getCapturedScopesOnSpan = i.getCapturedScopesOnSpan),
      (n.setCapturedScopesOnSpan = i.setCapturedScopesOnSpan),
      (n.TRACING_DEFAULTS = o.TRACING_DEFAULTS),
      (n.startIdleSpan = o.startIdleSpan),
      (n.SentrySpan = a.SentrySpan),
      (n.SentryNonRecordingSpan = s.SentryNonRecordingSpan),
      (n.SPAN_STATUS_ERROR = u.SPAN_STATUS_ERROR),
      (n.SPAN_STATUS_OK = u.SPAN_STATUS_OK),
      (n.SPAN_STATUS_UNSET = u.SPAN_STATUS_UNSET),
      (n.getSpanStatusFromHttpCode = u.getSpanStatusFromHttpCode),
      (n.setHttpStatus = u.setHttpStatus),
      (n.continueTrace = l.continueTrace),
      (n.startInactiveSpan = l.startInactiveSpan),
      (n.startNewTrace = l.startNewTrace),
      (n.startSpan = l.startSpan),
      (n.startSpanManual = l.startSpanManual),
      (n.suppressTracing = l.suppressTracing),
      (n.withActiveSpan = l.withActiveSpan),
      (n.getDynamicSamplingContextFromClient = c.getDynamicSamplingContextFromClient),
      (n.getDynamicSamplingContextFromScope = c.getDynamicSamplingContextFromScope),
      (n.getDynamicSamplingContextFromSpan = c.getDynamicSamplingContextFromSpan),
      (n.spanToBaggageHeader = c.spanToBaggageHeader),
      (n.setMeasurement = d.setMeasurement),
      (n.timedEventsToMeasurements = d.timedEventsToMeasurements),
      (n.sampleSpan = p.sampleSpan),
      (n.logSpanEnd = _.logSpanEnd),
      (n.logSpanStart = _.logSpanStart),
      (n.SEMANTIC_ATTRIBUTE_CACHE_HIT = S.SEMANTIC_ATTRIBUTE_CACHE_HIT),
      (n.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = S.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE),
      (n.SEMANTIC_ATTRIBUTE_CACHE_KEY = S.SEMANTIC_ATTRIBUTE_CACHE_KEY),
      (n.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = S.SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME),
      (n.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = S.SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD),
      (n.SEMANTIC_ATTRIBUTE_PROFILE_ID = S.SEMANTIC_ATTRIBUTE_PROFILE_ID),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = S.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON =
        S.SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = S.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE =
        S.SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_OP = S.SEMANTIC_ATTRIBUTE_SENTRY_OP),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = S.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE =
        S.SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = S.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = S.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE),
      (n.SEMANTIC_ATTRIBUTE_URL_FULL = S.SEMANTIC_ATTRIBUTE_URL_FULL),
      (n.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = S.SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE),
      (n.createEventEnvelope = E.createEventEnvelope),
      (n.createSessionEnvelope = E.createSessionEnvelope),
      (n.createSpanEnvelope = E.createSpanEnvelope),
      (n.addEventProcessor = T.addEventProcessor),
      (n.captureCheckIn = T.captureCheckIn),
      (n.captureEvent = T.captureEvent),
      (n.captureException = T.captureException),
      (n.captureMessage = T.captureMessage),
      (n.captureSession = T.captureSession),
      (n.close = T.close),
      (n.endSession = T.endSession),
      (n.flush = T.flush),
      (n.isEnabled = T.isEnabled),
      (n.isInitialized = T.isInitialized),
      (n.lastEventId = T.lastEventId),
      (n.setContext = T.setContext),
      (n.setExtra = T.setExtra),
      (n.setExtras = T.setExtras),
      (n.setTag = T.setTag),
      (n.setTags = T.setTags),
      (n.setUser = T.setUser),
      (n.startSession = T.startSession),
      (n.withMonitor = T.withMonitor),
      (n.getClient = m.getClient),
      (n.getCurrentScope = m.getCurrentScope),
      (n.getGlobalScope = m.getGlobalScope),
      (n.getIsolationScope = m.getIsolationScope),
      (n.getTraceContextFromScope = m.getTraceContextFromScope),
      (n.withIsolationScope = m.withIsolationScope),
      (n.withScope = m.withScope),
      (n.getDefaultCurrentScope = g.getDefaultCurrentScope),
      (n.getDefaultIsolationScope = g.getDefaultIsolationScope),
      (n.setAsyncContextStrategy = f.setAsyncContextStrategy),
      (n.getGlobalSingleton = h.getGlobalSingleton),
      (n.getMainCarrier = h.getMainCarrier),
      (n.closeSession = A.closeSession),
      (n.makeSession = A.makeSession),
      (n.updateSession = A.updateSession),
      (n.Scope = R.Scope),
      (n.notifyEventProcessors = y.notifyEventProcessors),
      (n.getEnvelopeEndpointWithUrlEncodedAuth = I.getEnvelopeEndpointWithUrlEncodedAuth),
      (n.getReportDialogEndpoint = I.getReportDialogEndpoint),
      (n.Client = b.Client),
      (n.ServerRuntimeClient = N.ServerRuntimeClient),
      (n.initAndBind = O.initAndBind),
      (n.setCurrentClient = O.setCurrentClient),
      (n.createTransport = v.createTransport),
      (n.makeOfflineTransport = C.makeOfflineTransport),
      (n.makeMultiplexedTransport = P.makeMultiplexedTransport),
      (n.addIntegration = M.addIntegration),
      (n.defineIntegration = M.defineIntegration),
      (n.getIntegrationsToSetup = M.getIntegrationsToSetup),
      (n.applyScopeDataToEvent = L.applyScopeDataToEvent),
      (n.mergeScopeData = L.mergeScopeData),
      (n.prepareEvent = U.prepareEvent),
      (n.createCheckInEnvelope = D.createCheckInEnvelope),
      (n.hasSpansEnabled = x.hasSpansEnabled),
      (n.isSentryRequestUrl = w.isSentryRequestUrl),
      (n.handleCallbackErrors = k.handleCallbackErrors),
      (n.fmt = G.fmt),
      (n.parameterize = G.parameterize),
      (n.addAutoIpAddressToSession = V.addAutoIpAddressToSession),
      (n.addAutoIpAddressToUser = V.addAutoIpAddressToUser),
      (n.addChildSpanToSpan = $.addChildSpanToSpan),
      (n.convertSpanLinksForEnvelope = $.convertSpanLinksForEnvelope),
      (n.getActiveSpan = $.getActiveSpan),
      (n.getRootSpan = $.getRootSpan),
      (n.getSpanDescendants = $.getSpanDescendants),
      (n.getStatusMessage = $.getStatusMessage),
      (n.spanIsSampled = $.spanIsSampled),
      (n.spanTimeInputToSeconds = $.spanTimeInputToSeconds),
      (n.spanToJSON = $.spanToJSON),
      (n.spanToTraceContext = $.spanToTraceContext),
      (n.spanToTraceHeader = $.spanToTraceHeader),
      (n.updateSpanName = $.updateSpanName),
      (n.parseSampleRate = B.parseSampleRate),
      (n.applySdkMetadata = H.applySdkMetadata),
      (n.getTraceData = j.getTraceData),
      (n.getTraceMetaTags = F.getTraceMetaTags),
      (n.debounce = Z.debounce),
      (n.extractQueryParamsFromUrl = Y.extractQueryParamsFromUrl),
      (n.headersToDict = Y.headersToDict),
      (n.httpRequestToRequestData = Y.httpRequestToRequestData),
      (n.winterCGHeadersToDict = Y.winterCGHeadersToDict),
      (n.winterCGRequestToRequestData = Y.winterCGRequestToRequestData),
      (n.DEFAULT_ENVIRONMENT = W.DEFAULT_ENVIRONMENT),
      (n.addBreadcrumb = K.addBreadcrumb),
      (n.functionToStringIntegration = z.functionToStringIntegration),
      (n.eventFiltersIntegration = X.eventFiltersIntegration),
      (n.inboundFiltersIntegration = X.inboundFiltersIntegration),
      (n.linkedErrorsIntegration = J.linkedErrorsIntegration),
      (n.moduleMetadataIntegration = Q.moduleMetadataIntegration),
      (n.requestDataIntegration = q.requestDataIntegration),
      (n.captureConsoleIntegration = ee.captureConsoleIntegration),
      (n.dedupeIntegration = et.dedupeIntegration),
      (n.extraErrorDataIntegration = en.extraErrorDataIntegration),
      (n.rewriteFramesIntegration = er.rewriteFramesIntegration),
      (n.instrumentSupabaseClient = ei.instrumentSupabaseClient),
      (n.supabaseIntegration = ei.supabaseIntegration),
      (n.zodErrorsIntegration = eo.zodErrorsIntegration),
      (n.thirdPartyErrorFilterIntegration = ea.thirdPartyErrorFilterIntegration),
      (n.consoleIntegration = es.consoleIntegration),
      (n.featureFlagsIntegration = eu.featureFlagsIntegration),
      (n.profiler = el.profiler),
      (n.instrumentFetchRequest = ec.instrumentFetchRequest),
      (n.trpcMiddleware = ed.trpcMiddleware),
      (n.wrapMcpServerWithSentry = ep.wrapMcpServerWithSentry),
      (n.captureFeedback = e_.captureFeedback),
      (n._INTERNAL_captureLog = eS._INTERNAL_captureLog),
      (n._INTERNAL_captureSerializedLog = eS._INTERNAL_captureSerializedLog),
      (n._INTERNAL_flushLogsBuffer = eS._INTERNAL_flushLogsBuffer),
      (n.consoleLoggingIntegration = eE.consoleLoggingIntegration),
      (n.addVercelAiProcessors = eT.addVercelAiProcessors),
      (n._INTERNAL_cleanupToolCallSpan = em._INTERNAL_cleanupToolCallSpan),
      (n._INTERNAL_getSpanForToolCallId = em._INTERNAL_getSpanForToolCallId),
      (n.instrumentOpenAiClient = eg.instrumentOpenAiClient),
      (n.OPENAI_INTEGRATION_NAME = ef.OPENAI_INTEGRATION_NAME),
      (n.instrumentAnthropicAiClient = eh.instrumentAnthropicAiClient),
      (n.ANTHROPIC_AI_INTEGRATION_NAME = eA.ANTHROPIC_AI_INTEGRATION_NAME),
      (n._INTERNAL_FLAG_BUFFER_SIZE = eR._INTERNAL_FLAG_BUFFER_SIZE),
      (n._INTERNAL_MAX_FLAGS_PER_SPAN = eR._INTERNAL_MAX_FLAGS_PER_SPAN),
      (n._INTERNAL_addFeatureFlagToActiveSpan = eR._INTERNAL_addFeatureFlagToActiveSpan),
      (n._INTERNAL_copyFlagsFromScopeToEvent = eR._INTERNAL_copyFlagsFromScopeToEvent),
      (n._INTERNAL_insertFlagToScope = eR._INTERNAL_insertFlagToScope),
      (n.applyAggregateErrorsToEvent = ey.applyAggregateErrorsToEvent),
      (n.getBreadcrumbLogLevelFromHttpStatusCode = eI.getBreadcrumbLogLevelFromHttpStatusCode),
      (n.getComponentName = eb.getComponentName),
      (n.getLocationHref = eb.getLocationHref),
      (n.htmlTreeAsString = eb.htmlTreeAsString),
      (n.dsnFromString = eN.dsnFromString),
      (n.dsnToString = eN.dsnToString),
      (n.makeDsn = eN.makeDsn),
      (n.SentryError = eO.SentryError),
      (n.GLOBAL_OBJ = ev.GLOBAL_OBJ),
      (n.addConsoleInstrumentationHandler = eC.addConsoleInstrumentationHandler),
      (n.addFetchEndInstrumentationHandler = eP.addFetchEndInstrumentationHandler),
      (n.addFetchInstrumentationHandler = eP.addFetchInstrumentationHandler),
      (n.addGlobalErrorInstrumentationHandler = eM.addGlobalErrorInstrumentationHandler),
      (n.addGlobalUnhandledRejectionInstrumentationHandler =
        eL.addGlobalUnhandledRejectionInstrumentationHandler),
      (n.addHandler = eU.addHandler),
      (n.maybeInstrument = eU.maybeInstrument),
      (n.resetInstrumentationHandlers = eU.resetInstrumentationHandlers),
      (n.triggerHandlers = eU.triggerHandlers),
      (n.isDOMError = eD.isDOMError),
      (n.isDOMException = eD.isDOMException),
      (n.isElement = eD.isElement),
      (n.isError = eD.isError),
      (n.isErrorEvent = eD.isErrorEvent),
      (n.isEvent = eD.isEvent),
      (n.isInstanceOf = eD.isInstanceOf),
      (n.isParameterizedString = eD.isParameterizedString),
      (n.isPlainObject = eD.isPlainObject),
      (n.isPrimitive = eD.isPrimitive),
      (n.isRegExp = eD.isRegExp),
      (n.isString = eD.isString),
      (n.isSyntheticEvent = eD.isSyntheticEvent),
      (n.isThenable = eD.isThenable),
      (n.isVueViewModel = eD.isVueViewModel),
      (n.isBrowser = ex.isBrowser),
      (n.CONSOLE_LEVELS = ew.CONSOLE_LEVELS),
      (n.consoleSandbox = ew.consoleSandbox),
      (n.debug = ew.debug),
      (n.originalConsoleMethods = ew.originalConsoleMethods),
      (n.addContextToFrame = ek.addContextToFrame),
      (n.addExceptionMechanism = ek.addExceptionMechanism),
      (n.addExceptionTypeValue = ek.addExceptionTypeValue),
      (n.checkOrSetAlreadyCaught = ek.checkOrSetAlreadyCaught),
      (n.getEventDescription = ek.getEventDescription),
      (n.parseSemver = ek.parseSemver),
      (n.uuid4 = ek.uuid4),
      (n.isNodeEnv = eG.isNodeEnv),
      (n.loadModule = eG.loadModule),
      (n.normalize = eV.normalize),
      (n.normalizeToSize = eV.normalizeToSize),
      (n.normalizeUrlToBase = eV.normalizeUrlToBase),
      (n.addNonEnumerableProperty = e$.addNonEnumerableProperty),
      (n.convertToPlainObject = e$.convertToPlainObject),
      (n.dropUndefinedKeys = e$.dropUndefinedKeys),
      (n.extractExceptionKeysForMessage = e$.extractExceptionKeysForMessage),
      (n.fill = e$.fill),
      (n.getOriginalFunction = e$.getOriginalFunction),
      (n.markFunctionWrapped = e$.markFunctionWrapped),
      (n.objectify = e$.objectify),
      (n.basename = eB.basename),
      (n.dirname = eB.dirname),
      (n.isAbsolute = eB.isAbsolute),
      (n.join = eB.join),
      (n.normalizePath = eB.normalizePath),
      (n.relative = eB.relative),
      (n.resolve = eB.resolve),
      (n.SENTRY_BUFFER_FULL_ERROR = eH.SENTRY_BUFFER_FULL_ERROR),
      (n.makePromiseBuffer = eH.makePromiseBuffer),
      (n.severityLevelFromString = ej.severityLevelFromString),
      (n.UNKNOWN_FUNCTION = eF.UNKNOWN_FUNCTION),
      (n.createStackParser = eF.createStackParser),
      (n.getFramesFromEvent = eF.getFramesFromEvent),
      (n.getFunctionName = eF.getFunctionName),
      (n.stackParserFromStackParserOptions = eF.stackParserFromStackParserOptions),
      (n.stripSentryFramesAndReverse = eF.stripSentryFramesAndReverse),
      (n.filenameIsInApp = eZ.filenameIsInApp),
      (n.node = eZ.node),
      (n.nodeStackLineParser = eZ.nodeStackLineParser),
      (n.isMatchingPattern = eY.isMatchingPattern),
      (n.safeJoin = eY.safeJoin),
      (n.snipLine = eY.snipLine),
      (n.stringMatchesSomePattern = eY.stringMatchesSomePattern),
      (n.truncate = eY.truncate),
      (n.isNativeFunction = eW.isNativeFunction),
      (n.supportsDOMError = eW.supportsDOMError),
      (n.supportsDOMException = eW.supportsDOMException),
      (n.supportsErrorEvent = eW.supportsErrorEvent),
      (n.supportsFetch = eW.supportsFetch),
      (n.supportsHistory = eW.supportsHistory),
      (n.supportsNativeFetch = eW.supportsNativeFetch),
      (n.supportsReferrerPolicy = eW.supportsReferrerPolicy),
      (n.supportsReportingObserver = eW.supportsReportingObserver),
      (n.SyncPromise = eK.SyncPromise),
      (n.rejectedSyncPromise = eK.rejectedSyncPromise),
      (n.resolvedSyncPromise = eK.resolvedSyncPromise),
      (n.browserPerformanceTimeOrigin = ez.browserPerformanceTimeOrigin),
      (n.dateTimestampInSeconds = ez.dateTimestampInSeconds),
      (n.timestampInSeconds = ez.timestampInSeconds),
      (n.TRACEPARENT_REGEXP = eX.TRACEPARENT_REGEXP),
      (n.extractTraceparentData = eX.extractTraceparentData),
      (n.generateSentryTraceHeader = eX.generateSentryTraceHeader),
      (n.propagationContextFromHeaders = eX.propagationContextFromHeaders),
      (n.shouldContinueTrace = eX.shouldContinueTrace),
      (n.getSDKSource = eJ.getSDKSource),
      (n.isBrowserBundle = eJ.isBrowserBundle),
      (n.addItemToEnvelope = eQ.addItemToEnvelope),
      (n.createAttachmentEnvelopeItem = eQ.createAttachmentEnvelopeItem),
      (n.createEnvelope = eQ.createEnvelope),
      (n.createEventEnvelopeHeaders = eQ.createEventEnvelopeHeaders),
      (n.createSpanEnvelopeItem = eQ.createSpanEnvelopeItem),
      (n.envelopeContainsItemType = eQ.envelopeContainsItemType),
      (n.envelopeItemTypeToDataCategory = eQ.envelopeItemTypeToDataCategory),
      (n.forEachEnvelopeItem = eQ.forEachEnvelopeItem),
      (n.getSdkMetadataForEnvelopeHeader = eQ.getSdkMetadataForEnvelopeHeader),
      (n.parseEnvelope = eQ.parseEnvelope),
      (n.serializeEnvelope = eQ.serializeEnvelope),
      (n.createClientReportEnvelope = eq.createClientReportEnvelope),
      (n.DEFAULT_RETRY_AFTER = e0.DEFAULT_RETRY_AFTER),
      (n.disabledUntil = e0.disabledUntil),
      (n.isRateLimited = e0.isRateLimited),
      (n.parseRetryAfterHeader = e0.parseRetryAfterHeader),
      (n.updateRateLimits = e0.updateRateLimits),
      (n.MAX_BAGGAGE_STRING_LENGTH = e1.MAX_BAGGAGE_STRING_LENGTH),
      (n.SENTRY_BAGGAGE_KEY_PREFIX = e1.SENTRY_BAGGAGE_KEY_PREFIX),
      (n.SENTRY_BAGGAGE_KEY_PREFIX_REGEX = e1.SENTRY_BAGGAGE_KEY_PREFIX_REGEX),
      (n.baggageHeaderToDynamicSamplingContext = e1.baggageHeaderToDynamicSamplingContext),
      (n.dynamicSamplingContextToSentryBaggageHeader =
        e1.dynamicSamplingContextToSentryBaggageHeader),
      (n.objectToBaggageHeader = e1.objectToBaggageHeader),
      (n.parseBaggageHeader = e1.parseBaggageHeader),
      (n.getHttpSpanDetailsFromUrlObject = e2.getHttpSpanDetailsFromUrlObject),
      (n.getSanitizedUrlString = e2.getSanitizedUrlString),
      (n.getSanitizedUrlStringFromUrlObject = e2.getSanitizedUrlStringFromUrlObject),
      (n.isURLObjectRelative = e2.isURLObjectRelative),
      (n.parseStringToURLObject = e2.parseStringToURLObject),
      (n.parseUrl = e2.parseUrl),
      (n.stripUrlQueryAndFragment = e2.stripUrlQueryAndFragment),
      (n.eventFromMessage = e5.eventFromMessage),
      (n.eventFromUnknownInput = e5.eventFromUnknownInput),
      (n.exceptionFromError = e5.exceptionFromError),
      (n.parseStackFrames = e5.parseStackFrames),
      (n.callFrameToStackFrame = e4.callFrameToStackFrame),
      (n.watchdogTimer = e4.watchdogTimer),
      (n.LRUMap = e9.LRUMap),
      (n.generateSpanId = e3.generateSpanId),
      (n.generateTraceId = e3.generateTraceId),
      (n.vercelWaitUntil = e6.vercelWaitUntil),
      (n.flushIfServerless = e7.flushIfServerless),
      (n.SDK_VERSION = e8.SDK_VERSION),
      (n.getDebugImagesForResources = te.getDebugImagesForResources),
      (n.getFilenameToDebugIdMap = te.getFilenameToDebugIdMap),
      (n.escapeStringForRegex = tt.escapeStringForRegex));
  },
  46827,
  (e) => {
    'use strict';
    e.s(['context', () => t]);
    var t = e.i(34150).ContextAPI.getInstance();
  },
  25148,
  70236,
  (e) => {
    'use strict';
    (e.s(['metrics', () => b], 25148),
      e.s(['NOOP_METER', () => p, 'createNoopMeter', () => h], 70236));
    var t = (function () {
        var e = function (t, n) {
          return (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            })(t, n);
        };
        return function (t, n) {
          if ('function' != typeof n && null !== n)
            throw TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
          function r() {
            this.constructor = t;
          }
          (e(t, n),
            (t.prototype = null === n ? Object.create(n) : ((r.prototype = n.prototype), new r())));
        };
      })(),
      n = (function () {
        function e() {}
        return (
          (e.prototype.createGauge = function (e, t) {
            return S;
          }),
          (e.prototype.createHistogram = function (e, t) {
            return E;
          }),
          (e.prototype.createCounter = function (e, t) {
            return _;
          }),
          (e.prototype.createUpDownCounter = function (e, t) {
            return T;
          }),
          (e.prototype.createObservableGauge = function (e, t) {
            return g;
          }),
          (e.prototype.createObservableCounter = function (e, t) {
            return m;
          }),
          (e.prototype.createObservableUpDownCounter = function (e, t) {
            return f;
          }),
          (e.prototype.addBatchObservableCallback = function (e, t) {}),
          (e.prototype.removeBatchObservableCallback = function (e) {}),
          e
        );
      })(),
      r = function () {},
      i = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), (n.prototype.add = function (e, t) {}), n);
      })(r),
      o = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), (n.prototype.add = function (e, t) {}), n);
      })(r),
      a = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), (n.prototype.record = function (e, t) {}), n);
      })(r),
      s = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), (n.prototype.record = function (e, t) {}), n);
      })(r),
      u = (function () {
        function e() {}
        return (
          (e.prototype.addCallback = function (e) {}),
          (e.prototype.removeCallback = function (e) {}),
          e
        );
      })(),
      l = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), n);
      })(u),
      c = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), n);
      })(u),
      d = (function (e) {
        function n() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (t(n, e), n);
      })(u),
      p = new n(),
      _ = new i(),
      S = new a(),
      E = new s(),
      T = new o(),
      m = new l(),
      g = new c(),
      f = new d();
    function h() {
      return p;
    }
    var A = new ((function () {
        function e() {}
        return (
          (e.prototype.getMeter = function (e, t, n) {
            return p;
          }),
          e
        );
      })())(),
      R = e.i(188),
      y = e.i(32223),
      I = 'metrics',
      b = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalMeterProvider = function (e) {
            return (0, R.registerGlobal)(I, e, y.DiagAPI.instance());
          }),
          (e.prototype.getMeterProvider = function () {
            return (0, R.getGlobal)(I) || A;
          }),
          (e.prototype.getMeter = function (e, t, n) {
            return this.getMeterProvider().getMeter(e, t, n);
          }),
          (e.prototype.disable = function () {
            (0, R.unregisterGlobal)(I, y.DiagAPI.instance());
          }),
          e
        );
      })().getInstance();
  },
  1647,
  43393,
  49377,
  (e) => {
    'use strict';
    e.s(['propagation', () => A], 1647);
    var t = e.i(188),
      n = (function () {
        function e() {}
        return (
          (e.prototype.inject = function (e, t) {}),
          (e.prototype.extract = function (e, t) {
            return e;
          }),
          (e.prototype.fields = function () {
            return [];
          }),
          e
        );
      })();
    e.s(['defaultTextMapGetter', () => r, 'defaultTextMapSetter', () => i], 43393);
    var r = {
        get: function (e, t) {
          if (null != e) return e[t];
        },
        keys: function (e) {
          return null == e ? [] : Object.keys(e);
        },
      },
      i = {
        set: function (e, t, n) {
          null != e && (e[t] = n);
        },
      },
      o = e.i(34150),
      a = (0, e.i(55360).createContextKey)('OpenTelemetry Baggage Key');
    function s(e) {
      return e.getValue(a) || void 0;
    }
    function u() {
      return s(o.ContextAPI.getInstance().active());
    }
    function l(e, t) {
      return e.setValue(a, t);
    }
    function c(e) {
      return e.deleteValue(a);
    }
    e.s(['baggageEntryMetadataFromString', () => g, 'createBaggage', () => m], 49377);
    var d = e.i(32223),
      p = function (e, t) {
        var n = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r,
          i,
          o = n.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(r = o.next()).done; ) a.push(r.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            r && !r.done && (n = o.return) && n.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      _ = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          n = t && e[t],
          r = 0;
        if (n) return n.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e });
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      },
      S = (function () {
        function e(e) {
          this._entries = e ? new Map(e) : new Map();
        }
        return (
          (e.prototype.getEntry = function (e) {
            var t = this._entries.get(e);
            if (t) return Object.assign({}, t);
          }),
          (e.prototype.getAllEntries = function () {
            return Array.from(this._entries.entries()).map(function (e) {
              var t = p(e, 2);
              return [t[0], t[1]];
            });
          }),
          (e.prototype.setEntry = function (t, n) {
            var r = new e(this._entries);
            return (r._entries.set(t, n), r);
          }),
          (e.prototype.removeEntry = function (t) {
            var n = new e(this._entries);
            return (n._entries.delete(t), n);
          }),
          (e.prototype.removeEntries = function () {
            for (var t, n, r = [], i = 0; i < arguments.length; i++) r[i] = arguments[i];
            var o = new e(this._entries);
            try {
              for (var a = _(r), s = a.next(); !s.done; s = a.next()) {
                var u = s.value;
                o._entries.delete(u);
              }
            } catch (e) {
              t = { error: e };
            } finally {
              try {
                s && !s.done && (n = a.return) && n.call(a);
              } finally {
                if (t) throw t.error;
              }
            }
            return o;
          }),
          (e.prototype.clear = function () {
            return new e();
          }),
          e
        );
      })(),
      E = Symbol('BaggageEntryMetadata'),
      T = d.DiagAPI.instance();
    function m(e) {
      return (void 0 === e && (e = {}), new S(new Map(Object.entries(e))));
    }
    function g(e) {
      return (
        'string' != typeof e &&
          (T.error('Cannot create baggage metadata from unknown type: ' + typeof e), (e = '')),
        {
          __TYPE__: E,
          toString: function () {
            return e;
          },
        }
      );
    }
    var f = 'propagation',
      h = new n(),
      A = (function () {
        function e() {
          ((this.createBaggage = m),
            (this.getBaggage = s),
            (this.getActiveBaggage = u),
            (this.setBaggage = l),
            (this.deleteBaggage = c));
        }
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalPropagator = function (e) {
            return (0, t.registerGlobal)(f, e, d.DiagAPI.instance());
          }),
          (e.prototype.inject = function (e, t, n) {
            return (void 0 === n && (n = i), this._getGlobalPropagator().inject(e, t, n));
          }),
          (e.prototype.extract = function (e, t, n) {
            return (void 0 === n && (n = r), this._getGlobalPropagator().extract(e, t, n));
          }),
          (e.prototype.fields = function () {
            return this._getGlobalPropagator().fields();
          }),
          (e.prototype.disable = function () {
            (0, t.unregisterGlobal)(f, d.DiagAPI.instance());
          }),
          (e.prototype._getGlobalPropagator = function () {
            return (0, t.getGlobal)(f) || h;
          }),
          e
        );
      })().getInstance();
  },
  34150,
  55360,
  58787,
  14667,
  19718,
  9813,
  45671,
  78224,
  (e) => {
    'use strict';
    function t(e) {
      return Symbol.for(e);
    }
    (e.s(['ContextAPI', () => _], 34150),
      e.s(['ROOT_CONTEXT', () => r, 'createContextKey', () => t], 55360));
    var n,
      r = new (function e(t) {
        var n = this;
        ((n._currentContext = t ? new Map(t) : new Map()),
          (n.getValue = function (e) {
            return n._currentContext.get(e);
          }),
          (n.setValue = function (t, r) {
            var i = new e(n._currentContext);
            return (i._currentContext.set(t, r), i);
          }),
          (n.deleteValue = function (t) {
            var r = new e(n._currentContext);
            return (r._currentContext.delete(t), r);
          }));
      })(),
      i = function (e, t) {
        var n = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r,
          i,
          o = n.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(r = o.next()).done; ) a.push(r.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            r && !r.done && (n = o.return) && n.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      o = function (e, t, n) {
        if (n || 2 == arguments.length)
          for (var r, i = 0, o = t.length; i < o; i++)
            (!r && i in t) || (r || (r = Array.prototype.slice.call(t, 0, i)), (r[i] = t[i]));
        return e.concat(r || Array.prototype.slice.call(t));
      },
      a = (function () {
        function e() {}
        return (
          (e.prototype.active = function () {
            return r;
          }),
          (e.prototype.with = function (e, t, n) {
            for (var r = [], a = 3; a < arguments.length; a++) r[a - 3] = arguments[a];
            return t.call.apply(t, o([n], i(r), !1));
          }),
          (e.prototype.bind = function (e, t) {
            return t;
          }),
          (e.prototype.enable = function () {
            return this;
          }),
          (e.prototype.disable = function () {
            return this;
          }),
          e
        );
      })(),
      s = e.i(188),
      u = e.i(32223),
      l = function (e, t) {
        var n = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r,
          i,
          o = n.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(r = o.next()).done; ) a.push(r.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            r && !r.done && (n = o.return) && n.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      c = function (e, t, n) {
        if (n || 2 == arguments.length)
          for (var r, i = 0, o = t.length; i < o; i++)
            (!r && i in t) || (r || (r = Array.prototype.slice.call(t, 0, i)), (r[i] = t[i]));
        return e.concat(r || Array.prototype.slice.call(t));
      },
      d = 'context',
      p = new a(),
      _ = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalContextManager = function (e) {
            return (0, s.registerGlobal)(d, e, u.DiagAPI.instance());
          }),
          (e.prototype.active = function () {
            return this._getContextManager().active();
          }),
          (e.prototype.with = function (e, t, n) {
            for (var r, i = [], o = 3; o < arguments.length; o++) i[o - 3] = arguments[o];
            return (r = this._getContextManager()).with.apply(r, c([e, t, n], l(i), !1));
          }),
          (e.prototype.bind = function (e, t) {
            return this._getContextManager().bind(e, t);
          }),
          (e.prototype._getContextManager = function () {
            return (0, s.getGlobal)(d) || p;
          }),
          (e.prototype.disable = function () {
            (this._getContextManager().disable(), (0, s.unregisterGlobal)(d, u.DiagAPI.instance()));
          }),
          e
        );
      })();
    (e.s(['trace', () => G], 78224),
      e.s(['ProxyTracerProvider', () => w], 45671),
      e.s(['ProxyTracer', () => D], 9813),
      e.s(
        ['INVALID_SPANID', () => S, 'INVALID_SPAN_CONTEXT', () => T, 'INVALID_TRACEID', () => E],
        14667
      ),
      e.s(['TraceFlags', () => n], 58787),
      (function (e) {
        ((e[(e.NONE = 0)] = 'NONE'), (e[(e.SAMPLED = 1)] = 'SAMPLED'));
      })(n || (n = {})));
    var S = '0000000000000000',
      E = '00000000000000000000000000000000',
      T = { traceId: E, spanId: S, traceFlags: n.NONE },
      m = (function () {
        function e(e) {
          (void 0 === e && (e = T), (this._spanContext = e));
        }
        return (
          (e.prototype.spanContext = function () {
            return this._spanContext;
          }),
          (e.prototype.setAttribute = function (e, t) {
            return this;
          }),
          (e.prototype.setAttributes = function (e) {
            return this;
          }),
          (e.prototype.addEvent = function (e, t) {
            return this;
          }),
          (e.prototype.addLink = function (e) {
            return this;
          }),
          (e.prototype.addLinks = function (e) {
            return this;
          }),
          (e.prototype.setStatus = function (e) {
            return this;
          }),
          (e.prototype.updateName = function (e) {
            return this;
          }),
          (e.prototype.end = function (e) {}),
          (e.prototype.isRecording = function () {
            return !1;
          }),
          (e.prototype.recordException = function (e, t) {}),
          e
        );
      })(),
      g = t('OpenTelemetry Context Key SPAN');
    function f(e) {
      return e.getValue(g) || void 0;
    }
    function h() {
      return f(_.getInstance().active());
    }
    function A(e, t) {
      return e.setValue(g, t);
    }
    function R(e) {
      return e.deleteValue(g);
    }
    function y(e, t) {
      return A(e, new m(t));
    }
    function I(e) {
      var t;
      return null == (t = f(e)) ? void 0 : t.spanContext();
    }
    e.s(
      [
        'isSpanContextValid',
        () => C,
        'isValidSpanId',
        () => v,
        'isValidTraceId',
        () => O,
        'wrapSpanContext',
        () => P,
      ],
      19718
    );
    var b = /^([0-9a-f]{32})$/i,
      N = /^[0-9a-f]{16}$/i;
    function O(e) {
      return b.test(e) && e !== E;
    }
    function v(e) {
      return N.test(e) && e !== S;
    }
    function C(e) {
      return O(e.traceId) && v(e.spanId);
    }
    function P(e) {
      return new m(e);
    }
    var M = _.getInstance(),
      L = (function () {
        function e() {}
        return (
          (e.prototype.startSpan = function (e, t, n) {
            if ((void 0 === n && (n = M.active()), null == t ? void 0 : t.root)) return new m();
            var r,
              i = n && I(n);
            return 'object' == typeof (r = i) &&
              'string' == typeof r.spanId &&
              'string' == typeof r.traceId &&
              'number' == typeof r.traceFlags &&
              C(i)
              ? new m(i)
              : new m();
          }),
          (e.prototype.startActiveSpan = function (e, t, n, r) {
            if (!(arguments.length < 2)) {
              2 == arguments.length
                ? (a = t)
                : 3 == arguments.length
                  ? ((i = t), (a = n))
                  : ((i = t), (o = n), (a = r));
              var i,
                o,
                a,
                s = null != o ? o : M.active(),
                u = this.startSpan(e, i, s),
                l = A(s, u);
              return M.with(l, a, void 0, u);
            }
          }),
          e
        );
      })(),
      U = new L(),
      D = (function () {
        function e(e, t, n, r) {
          ((this._provider = e), (this.name = t), (this.version = n), (this.options = r));
        }
        return (
          (e.prototype.startSpan = function (e, t, n) {
            return this._getTracer().startSpan(e, t, n);
          }),
          (e.prototype.startActiveSpan = function (e, t, n, r) {
            var i = this._getTracer();
            return Reflect.apply(i.startActiveSpan, i, arguments);
          }),
          (e.prototype._getTracer = function () {
            if (this._delegate) return this._delegate;
            var e = this._provider.getDelegateTracer(this.name, this.version, this.options);
            return e ? ((this._delegate = e), this._delegate) : U;
          }),
          e
        );
      })(),
      x = new ((function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, n) {
            return new L();
          }),
          e
        );
      })())(),
      w = (function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, n) {
            var r;
            return null != (r = this.getDelegateTracer(e, t, n)) ? r : new D(this, e, t, n);
          }),
          (e.prototype.getDelegate = function () {
            var e;
            return null != (e = this._delegate) ? e : x;
          }),
          (e.prototype.setDelegate = function (e) {
            this._delegate = e;
          }),
          (e.prototype.getDelegateTracer = function (e, t, n) {
            var r;
            return null == (r = this._delegate) ? void 0 : r.getTracer(e, t, n);
          }),
          e
        );
      })(),
      k = 'trace',
      G = (function () {
        function e() {
          ((this._proxyTracerProvider = new w()),
            (this.wrapSpanContext = P),
            (this.isSpanContextValid = C),
            (this.deleteSpan = R),
            (this.getSpan = f),
            (this.getActiveSpan = h),
            (this.getSpanContext = I),
            (this.setSpan = A),
            (this.setSpanContext = y));
        }
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalTracerProvider = function (e) {
            var t = (0, s.registerGlobal)(k, this._proxyTracerProvider, u.DiagAPI.instance());
            return (t && this._proxyTracerProvider.setDelegate(e), t);
          }),
          (e.prototype.getTracerProvider = function () {
            return (0, s.getGlobal)(k) || this._proxyTracerProvider;
          }),
          (e.prototype.getTracer = function (e, t) {
            return this.getTracerProvider().getTracer(e, t);
          }),
          (e.prototype.disable = function () {
            ((0, s.unregisterGlobal)(k, u.DiagAPI.instance()),
              (this._proxyTracerProvider = new w()));
          }),
          e
        );
      })().getInstance();
  },
  57888,
  77367,
  94958,
  (e) => {
    'use strict';
    var t, n, r;
    (e.s(['SamplingDecision', () => t], 57888),
      (function (e) {
        ((e[(e.NOT_RECORD = 0)] = 'NOT_RECORD'),
          (e[(e.RECORD = 1)] = 'RECORD'),
          (e[(e.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'));
      })(t || (t = {})),
      e.s(['SpanKind', () => n], 77367),
      (function (e) {
        ((e[(e.INTERNAL = 0)] = 'INTERNAL'),
          (e[(e.SERVER = 1)] = 'SERVER'),
          (e[(e.CLIENT = 2)] = 'CLIENT'),
          (e[(e.PRODUCER = 3)] = 'PRODUCER'),
          (e[(e.CONSUMER = 4)] = 'CONSUMER'));
      })(n || (n = {})),
      e.s(['SpanStatusCode', () => r], 94958),
      (function (e) {
        ((e[(e.UNSET = 0)] = 'UNSET'), (e[(e.OK = 1)] = 'OK'), (e[(e.ERROR = 2)] = 'ERROR'));
      })(r || (r = {})));
  },
  52305,
  (e) => {
    'use strict';
    (e.s(
      [
        'DiagConsoleLogger',
        () => d,
        'DiagLogLevel',
        () => p.DiagLogLevel,
        'INVALID_SPANID',
        () => v.INVALID_SPANID,
        'INVALID_SPAN_CONTEXT',
        () => v.INVALID_SPAN_CONTEXT,
        'INVALID_TRACEID',
        () => v.INVALID_TRACEID,
        'ProxyTracer',
        () => E.ProxyTracer,
        'ProxyTracerProvider',
        () => T.ProxyTracerProvider,
        'ROOT_CONTEXT',
        () => l.ROOT_CONTEXT,
        'SamplingDecision',
        () => m.SamplingDecision,
        'SpanKind',
        () => g.SpanKind,
        'SpanStatusCode',
        () => f.SpanStatusCode,
        'TraceFlags',
        () => h.TraceFlags,
        'ValueType',
        () => t,
        'baggageEntryMetadataFromString',
        () => u.baggageEntryMetadataFromString,
        'context',
        () => C.context,
        'createContextKey',
        () => l.createContextKey,
        'createNoopMeter',
        () => _.createNoopMeter,
        'createTraceState',
        () => N,
        'default',
        () => s,
        'defaultTextMapGetter',
        () => S.defaultTextMapGetter,
        'defaultTextMapSetter',
        () => S.defaultTextMapSetter,
        'diag',
        () => P.diag,
        'isSpanContextValid',
        () => O.isSpanContextValid,
        'isValidSpanId',
        () => O.isValidSpanId,
        'isValidTraceId',
        () => O.isValidTraceId,
        'metrics',
        () => M.metrics,
        'propagation',
        () => L.propagation,
        'trace',
        () => U.trace,
      ],
      52305
    ),
      e.s(['default', () => s], 68893));
    var t,
      n = e.i(46827),
      r = e.i(43170),
      i = e.i(25148),
      o = e.i(1647),
      a = e.i(78224);
    let s = {
      context: n.context,
      diag: r.diag,
      metrics: i.metrics,
      propagation: o.propagation,
      trace: a.trace,
    };
    e.i(68893);
    var u = e.i(49377),
      l = e.i(55360),
      c = [
        { n: 'error', c: 'error' },
        { n: 'warn', c: 'warn' },
        { n: 'info', c: 'info' },
        { n: 'debug', c: 'debug' },
        { n: 'verbose', c: 'trace' },
      ],
      d = function () {
        for (var e = 0; e < c.length; e++)
          this[c[e].n] = (function (e) {
            return function () {
              for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];
              if (console) {
                var r = console[e];
                if (('function' != typeof r && (r = console.log), 'function' == typeof r))
                  return r.apply(console, t);
              }
            };
          })(c[e].c);
      },
      p = e.i(25834),
      _ = e.i(70236);
    !(function (e) {
      ((e[(e.INT = 0)] = 'INT'), (e[(e.DOUBLE = 1)] = 'DOUBLE'));
    })(t || (t = {}));
    var S = e.i(43393),
      E = e.i(9813),
      T = e.i(45671),
      m = e.i(57888),
      g = e.i(77367),
      f = e.i(94958),
      h = e.i(58787),
      A = '[_0-9a-z-*/]',
      R = RegExp(
        '^(?:[a-z]' + A + '{0,255}|' + ('[a-z0-9]' + A + '{0,240}@[a-z]') + A + '{0,13})$'
      ),
      y = /^[ -~]{0,255}[!-~]$/,
      I = /,|=/,
      b = (function () {
        function e(e) {
          ((this._internalState = new Map()), e && this._parse(e));
        }
        return (
          (e.prototype.set = function (e, t) {
            var n = this._clone();
            return (
              n._internalState.has(e) && n._internalState.delete(e),
              n._internalState.set(e, t),
              n
            );
          }),
          (e.prototype.unset = function (e) {
            var t = this._clone();
            return (t._internalState.delete(e), t);
          }),
          (e.prototype.get = function (e) {
            return this._internalState.get(e);
          }),
          (e.prototype.serialize = function () {
            var e = this;
            return this._keys()
              .reduce(function (t, n) {
                return (t.push(n + '=' + e.get(n)), t);
              }, [])
              .join(',');
          }),
          (e.prototype._parse = function (e) {
            !(e.length > 512) &&
              ((this._internalState = e
                .split(',')
                .reverse()
                .reduce(function (e, t) {
                  var n = t.trim(),
                    r = n.indexOf('=');
                  if (-1 !== r) {
                    var i = n.slice(0, r),
                      o = n.slice(r + 1, t.length);
                    R.test(i) && y.test(o) && !I.test(o) && e.set(i, o);
                  }
                  return e;
                }, new Map())),
              this._internalState.size > 32 &&
                (this._internalState = new Map(
                  Array.from(this._internalState.entries()).reverse().slice(0, 32)
                )));
          }),
          (e.prototype._keys = function () {
            return Array.from(this._internalState.keys()).reverse();
          }),
          (e.prototype._clone = function () {
            var t = new e();
            return ((t._internalState = new Map(this._internalState)), t);
          }),
          e
        );
      })();
    function N(e) {
      return new b(e);
    }
    var O = e.i(19718),
      v = e.i(14667),
      C = n,
      P = r,
      M = i,
      L = o,
      U = a;
  },
  1709,
  (e) => {
    'use strict';
    e.s([
      'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED',
      () => n,
      'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED',
      () => r,
      'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED',
      () => i,
      'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED',
      () => o,
      'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED',
      () => l,
      'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER',
      () => c,
      'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER',
      () => d,
      'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED',
      () => p,
      'ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE',
      () => T,
      'ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS',
      () => m,
      'ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT',
      () => t,
      'ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE',
      () => a,
      'ATTR_ASPNETCORE_RATE_LIMITING_POLICY',
      () => s,
      'ATTR_ASPNETCORE_RATE_LIMITING_RESULT',
      () => u,
      'ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED',
      () => _,
      'ATTR_ASPNETCORE_ROUTING_IS_FALLBACK',
      () => S,
      'ATTR_ASPNETCORE_ROUTING_MATCH_STATUS',
      () => E,
      'ATTR_ASPNETCORE_USER_IS_AUTHENTICATED',
      () => g,
      'ATTR_CLIENT_ADDRESS',
      () => f,
      'ATTR_CLIENT_PORT',
      () => h,
      'ATTR_CODE_COLUMN_NUMBER',
      () => A,
      'ATTR_CODE_FILE_PATH',
      () => R,
      'ATTR_CODE_FUNCTION_NAME',
      () => y,
      'ATTR_CODE_LINE_NUMBER',
      () => I,
      'ATTR_CODE_STACKTRACE',
      () => b,
      'ATTR_DB_COLLECTION_NAME',
      () => N,
      'ATTR_DB_NAMESPACE',
      () => O,
      'ATTR_DB_OPERATION_BATCH_SIZE',
      () => v,
      'ATTR_DB_OPERATION_NAME',
      () => C,
      'ATTR_DB_QUERY_SUMMARY',
      () => P,
      'ATTR_DB_QUERY_TEXT',
      () => M,
      'ATTR_DB_RESPONSE_STATUS_CODE',
      () => L,
      'ATTR_DB_STORED_PROCEDURE_NAME',
      () => U,
      'ATTR_DB_SYSTEM_NAME',
      () => D,
      'ATTR_DOTNET_GC_HEAP_GENERATION',
      () => V,
      'ATTR_ERROR_TYPE',
      () => Z,
      'ATTR_EXCEPTION_ESCAPED',
      () => W,
      'ATTR_EXCEPTION_MESSAGE',
      () => K,
      'ATTR_EXCEPTION_STACKTRACE',
      () => z,
      'ATTR_EXCEPTION_TYPE',
      () => X,
      'ATTR_HTTP_REQUEST_HEADER',
      () => J,
      'ATTR_HTTP_REQUEST_METHOD',
      () => Q,
      'ATTR_HTTP_REQUEST_METHOD_ORIGINAL',
      () => el,
      'ATTR_HTTP_REQUEST_RESEND_COUNT',
      () => ec,
      'ATTR_HTTP_RESPONSE_HEADER',
      () => ed,
      'ATTR_HTTP_RESPONSE_STATUS_CODE',
      () => ep,
      'ATTR_HTTP_ROUTE',
      () => e_,
      'ATTR_JVM_GC_ACTION',
      () => eS,
      'ATTR_JVM_GC_NAME',
      () => eE,
      'ATTR_JVM_MEMORY_POOL_NAME',
      () => eT,
      'ATTR_JVM_MEMORY_TYPE',
      () => em,
      'ATTR_JVM_THREAD_DAEMON',
      () => eh,
      'ATTR_JVM_THREAD_STATE',
      () => eA,
      'ATTR_NETWORK_LOCAL_ADDRESS',
      () => ev,
      'ATTR_NETWORK_LOCAL_PORT',
      () => eC,
      'ATTR_NETWORK_PEER_ADDRESS',
      () => eP,
      'ATTR_NETWORK_PEER_PORT',
      () => eM,
      'ATTR_NETWORK_PROTOCOL_NAME',
      () => eL,
      'ATTR_NETWORK_PROTOCOL_VERSION',
      () => eU,
      'ATTR_NETWORK_TRANSPORT',
      () => eD,
      'ATTR_NETWORK_TYPE',
      () => e$,
      'ATTR_OTEL_SCOPE_NAME',
      () => ej,
      'ATTR_OTEL_SCOPE_VERSION',
      () => eF,
      'ATTR_OTEL_STATUS_CODE',
      () => eZ,
      'ATTR_OTEL_STATUS_DESCRIPTION',
      () => eK,
      'ATTR_SERVER_ADDRESS',
      () => ez,
      'ATTR_SERVER_PORT',
      () => eX,
      'ATTR_SERVICE_NAME',
      () => eJ,
      'ATTR_SERVICE_VERSION',
      () => eQ,
      'ATTR_SIGNALR_CONNECTION_STATUS',
      () => eq,
      'ATTR_SIGNALR_TRANSPORT',
      () => e5,
      'ATTR_TELEMETRY_SDK_LANGUAGE',
      () => e6,
      'ATTR_TELEMETRY_SDK_NAME',
      () => tc,
      'ATTR_TELEMETRY_SDK_VERSION',
      () => td,
      'ATTR_URL_FRAGMENT',
      () => tp,
      'ATTR_URL_FULL',
      () => t_,
      'ATTR_URL_PATH',
      () => tS,
      'ATTR_URL_QUERY',
      () => tE,
      'ATTR_URL_SCHEME',
      () => tT,
      'ATTR_USER_AGENT_ORIGINAL',
      () => tm,
      'DB_SYSTEM_NAME_VALUE_MARIADB',
      () => x,
      'DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER',
      () => w,
      'DB_SYSTEM_NAME_VALUE_MYSQL',
      () => k,
      'DB_SYSTEM_NAME_VALUE_POSTGRESQL',
      () => G,
      'DOTNET_GC_HEAP_GENERATION_VALUE_GEN0',
      () => $,
      'DOTNET_GC_HEAP_GENERATION_VALUE_GEN1',
      () => B,
      'DOTNET_GC_HEAP_GENERATION_VALUE_GEN2',
      () => H,
      'DOTNET_GC_HEAP_GENERATION_VALUE_LOH',
      () => j,
      'DOTNET_GC_HEAP_GENERATION_VALUE_POH',
      () => F,
      'ERROR_TYPE_VALUE_OTHER',
      () => Y,
      'HTTP_REQUEST_METHOD_VALUE_CONNECT',
      () => ee,
      'HTTP_REQUEST_METHOD_VALUE_DELETE',
      () => et,
      'HTTP_REQUEST_METHOD_VALUE_GET',
      () => en,
      'HTTP_REQUEST_METHOD_VALUE_HEAD',
      () => er,
      'HTTP_REQUEST_METHOD_VALUE_OPTIONS',
      () => ei,
      'HTTP_REQUEST_METHOD_VALUE_OTHER',
      () => q,
      'HTTP_REQUEST_METHOD_VALUE_PATCH',
      () => eo,
      'HTTP_REQUEST_METHOD_VALUE_POST',
      () => ea,
      'HTTP_REQUEST_METHOD_VALUE_PUT',
      () => es,
      'HTTP_REQUEST_METHOD_VALUE_TRACE',
      () => eu,
      'JVM_MEMORY_TYPE_VALUE_HEAP',
      () => eg,
      'JVM_MEMORY_TYPE_VALUE_NON_HEAP',
      () => ef,
      'JVM_THREAD_STATE_VALUE_BLOCKED',
      () => eR,
      'JVM_THREAD_STATE_VALUE_NEW',
      () => ey,
      'JVM_THREAD_STATE_VALUE_RUNNABLE',
      () => eI,
      'JVM_THREAD_STATE_VALUE_TERMINATED',
      () => eb,
      'JVM_THREAD_STATE_VALUE_TIMED_WAITING',
      () => eN,
      'JVM_THREAD_STATE_VALUE_WAITING',
      () => eO,
      'NETWORK_TRANSPORT_VALUE_PIPE',
      () => ex,
      'NETWORK_TRANSPORT_VALUE_QUIC',
      () => ew,
      'NETWORK_TRANSPORT_VALUE_TCP',
      () => ek,
      'NETWORK_TRANSPORT_VALUE_UDP',
      () => eG,
      'NETWORK_TRANSPORT_VALUE_UNIX',
      () => eV,
      'NETWORK_TYPE_VALUE_IPV4',
      () => eB,
      'NETWORK_TYPE_VALUE_IPV6',
      () => eH,
      'OTEL_STATUS_CODE_VALUE_ERROR',
      () => eY,
      'OTEL_STATUS_CODE_VALUE_OK',
      () => eW,
      'SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN',
      () => e0,
      'SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE',
      () => e1,
      'SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT',
      () => e2,
      'SIGNALR_TRANSPORT_VALUE_LONG_POLLING',
      () => e4,
      'SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS',
      () => e9,
      'SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS',
      () => e3,
      'TELEMETRY_SDK_LANGUAGE_VALUE_CPP',
      () => e7,
      'TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET',
      () => e8,
      'TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG',
      () => te,
      'TELEMETRY_SDK_LANGUAGE_VALUE_GO',
      () => tt,
      'TELEMETRY_SDK_LANGUAGE_VALUE_JAVA',
      () => tn,
      'TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS',
      () => tr,
      'TELEMETRY_SDK_LANGUAGE_VALUE_PHP',
      () => ti,
      'TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON',
      () => to,
      'TELEMETRY_SDK_LANGUAGE_VALUE_RUBY',
      () => ta,
      'TELEMETRY_SDK_LANGUAGE_VALUE_RUST',
      () => ts,
      'TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT',
      () => tu,
      'TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS',
      () => tl,
    ]);
    let t = 'aspnetcore.diagnostics.exception.result',
      n = 'aborted',
      r = 'handled',
      i = 'skipped',
      o = 'unhandled',
      a = 'aspnetcore.diagnostics.handler.type',
      s = 'aspnetcore.rate_limiting.policy',
      u = 'aspnetcore.rate_limiting.result',
      l = 'acquired',
      c = 'endpoint_limiter',
      d = 'global_limiter',
      p = 'request_canceled',
      _ = 'aspnetcore.request.is_unhandled',
      S = 'aspnetcore.routing.is_fallback',
      E = 'aspnetcore.routing.match_status',
      T = 'failure',
      m = 'success',
      g = 'aspnetcore.user.is_authenticated',
      f = 'client.address',
      h = 'client.port',
      A = 'code.column.number',
      R = 'code.file.path',
      y = 'code.function.name',
      I = 'code.line.number',
      b = 'code.stacktrace',
      N = 'db.collection.name',
      O = 'db.namespace',
      v = 'db.operation.batch.size',
      C = 'db.operation.name',
      P = 'db.query.summary',
      M = 'db.query.text',
      L = 'db.response.status_code',
      U = 'db.stored_procedure.name',
      D = 'db.system.name',
      x = 'mariadb',
      w = 'microsoft.sql_server',
      k = 'mysql',
      G = 'postgresql',
      V = 'dotnet.gc.heap.generation',
      $ = 'gen0',
      B = 'gen1',
      H = 'gen2',
      j = 'loh',
      F = 'poh',
      Z = 'error.type',
      Y = '_OTHER',
      W = 'exception.escaped',
      K = 'exception.message',
      z = 'exception.stacktrace',
      X = 'exception.type',
      J = (e) => `http.request.header.${e}`,
      Q = 'http.request.method',
      q = '_OTHER',
      ee = 'CONNECT',
      et = 'DELETE',
      en = 'GET',
      er = 'HEAD',
      ei = 'OPTIONS',
      eo = 'PATCH',
      ea = 'POST',
      es = 'PUT',
      eu = 'TRACE',
      el = 'http.request.method_original',
      ec = 'http.request.resend_count',
      ed = (e) => `http.response.header.${e}`,
      ep = 'http.response.status_code',
      e_ = 'http.route',
      eS = 'jvm.gc.action',
      eE = 'jvm.gc.name',
      eT = 'jvm.memory.pool.name',
      em = 'jvm.memory.type',
      eg = 'heap',
      ef = 'non_heap',
      eh = 'jvm.thread.daemon',
      eA = 'jvm.thread.state',
      eR = 'blocked',
      ey = 'new',
      eI = 'runnable',
      eb = 'terminated',
      eN = 'timed_waiting',
      eO = 'waiting',
      ev = 'network.local.address',
      eC = 'network.local.port',
      eP = 'network.peer.address',
      eM = 'network.peer.port',
      eL = 'network.protocol.name',
      eU = 'network.protocol.version',
      eD = 'network.transport',
      ex = 'pipe',
      ew = 'quic',
      ek = 'tcp',
      eG = 'udp',
      eV = 'unix',
      e$ = 'network.type',
      eB = 'ipv4',
      eH = 'ipv6',
      ej = 'otel.scope.name',
      eF = 'otel.scope.version',
      eZ = 'otel.status_code',
      eY = 'ERROR',
      eW = 'OK',
      eK = 'otel.status_description',
      ez = 'server.address',
      eX = 'server.port',
      eJ = 'service.name',
      eQ = 'service.version',
      eq = 'signalr.connection.status',
      e0 = 'app_shutdown',
      e1 = 'normal_closure',
      e2 = 'timeout',
      e5 = 'signalr.transport',
      e4 = 'long_polling',
      e9 = 'server_sent_events',
      e3 = 'web_sockets',
      e6 = 'telemetry.sdk.language',
      e7 = 'cpp',
      e8 = 'dotnet',
      te = 'erlang',
      tt = 'go',
      tn = 'java',
      tr = 'nodejs',
      ti = 'php',
      to = 'python',
      ta = 'ruby',
      ts = 'rust',
      tu = 'swift',
      tl = 'webjs',
      tc = 'telemetry.sdk.name',
      td = 'telemetry.sdk.version',
      tp = 'url.fragment',
      t_ = 'url.full',
      tS = 'url.path',
      tE = 'url.query',
      tT = 'url.scheme',
      tm = 'user_agent.original';
  },
  54234,
  (e) => {
    'use strict';
    (e.s(
      [
        'AnchoredClock',
        () => T,
        'BindOnceFuture',
        () => eU,
        'CompositePropagator',
        () => W,
        'ExportResultCode',
        () => t,
        'RPCType',
        () => n,
        'SDK_INFO',
        () => V,
        'TRACE_PARENT_HEADER',
        () => ei,
        'TRACE_STATE_HEADER',
        () => eo,
        'TimeoutError',
        () => ev,
        'TraceState',
        () => er,
        'W3CBaggagePropagator',
        () => E,
        'W3CTraceContextPropagator',
        () => eu,
        '_globalThis',
        () => $,
        'addHrTimes',
        () => k,
        'callWithTimeout',
        () => eC,
        'deleteRPCMetadata',
        () => ed,
        'diagLogLevelFromString',
        () => ew,
        'getBooleanFromEnv',
        () => F,
        'getNumberFromEnv',
        () => H,
        'getRPCMetadata',
        () => ep,
        'getStringFromEnv',
        () => j,
        'getStringListFromEnv',
        () => Z,
        'getTimeOrigin',
        () => O,
        'globalErrorHandler',
        () => I,
        'hrTime',
        () => v,
        'hrTimeDuration',
        () => P,
        'hrTimeToMicroseconds',
        () => D,
        'hrTimeToMilliseconds',
        () => U,
        'hrTimeToNanoseconds',
        () => L,
        'hrTimeToTimeStamp',
        () => M,
        'internal',
        () => l,
        'isAttributeValue',
        () => f,
        'isTimeInput',
        () => w,
        'isTimeInputHrTime',
        () => x,
        'isTracingSuppressed',
        () => u,
        'isUrlIgnored',
        () => eM,
        'loggingErrorHandler',
        () => A,
        'merge',
        () => eA,
        'millisToHrTime',
        () => N,
        'otperformance',
        () => b,
        'parseKeyPairsIntoRecord',
        () => S,
        'parseTraceParent',
        () => es,
        'sanitizeAttributes',
        () => g,
        'setGlobalErrorHandler',
        () => y,
        'setRPCMetadata',
        () => ec,
        'suppressTracing',
        () => a,
        'timeInputToHrTime',
        () => C,
        'unrefTimer',
        () => Y,
        'unsuppressTracing',
        () => s,
        'urlMatches',
        () => eP,
      ],
      54234
    ),
      e.s(['internal', () => l], 57192));
    var t,
      n,
      r = e.i(46827),
      i = e.i(55360);
    let o = (0, i.createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
    function a(e) {
      return e.setValue(o, !0);
    }
    function s(e) {
      return e.deleteValue(o);
    }
    function u(e) {
      return !0 === e.getValue(o);
    }
    let l = {
      _export: function (e, t) {
        return new Promise((n) => {
          r.context.with(a(r.context.active()), () => {
            e.export(t, (e) => {
              n(e);
            });
          });
        });
      },
    };
    e.i(57192);
    var c = e.i(1647);
    let d = 'baggage';
    var p = e.i(49377);
    function _(e) {
      let t,
        n = e.split(';');
      if (n.length <= 0) return;
      let r = n.shift();
      if (!r) return;
      let i = r.indexOf('=');
      if (i <= 0) return;
      let o = decodeURIComponent(r.substring(0, i).trim()),
        a = decodeURIComponent(r.substring(i + 1).trim());
      return (
        n.length > 0 && (t = (0, p.baggageEntryMetadataFromString)(n.join(';'))),
        { key: o, value: a, metadata: t }
      );
    }
    function S(e) {
      let t = {};
      return (
        'string' == typeof e &&
          e.length > 0 &&
          e.split(',').forEach((e) => {
            let n = _(e);
            void 0 !== n && n.value.length > 0 && (t[n.key] = n.value);
          }),
        t
      );
    }
    class E {
      inject(e, t, n) {
        let r = c.propagation.getBaggage(e);
        if (!r || u(e)) return;
        let i = r
          .getAllEntries()
          .map(([e, t]) => {
            let n = `${encodeURIComponent(e)}=${encodeURIComponent(t.value)}`;
            return (void 0 !== t.metadata && (n += ';' + t.metadata.toString()), n);
          })
          .filter((e) => e.length <= 4096)
          .slice(0, 180)
          .reduce((e, t) => {
            let n = `${e}${'' !== e ? ',' : ''}${t}`;
            return n.length > 8192 ? e : n;
          }, '');
        i.length > 0 && n.set(t, d, i);
      }
      extract(e, t, n) {
        let r = n.get(t, d),
          i = Array.isArray(r) ? r.join(',') : r;
        if (!i) return e;
        let o = {};
        return 0 === i.length ||
          (i.split(',').forEach((e) => {
            let t = _(e);
            if (t) {
              let e = { value: t.value };
              (t.metadata && (e.metadata = t.metadata), (o[t.key] = e));
            }
          }),
          0 === Object.entries(o).length)
          ? e
          : c.propagation.setBaggage(e, c.propagation.createBaggage(o));
      }
      fields() {
        return [d];
      }
    }
    class T {
      _monotonicClock;
      _epochMillis;
      _performanceMillis;
      constructor(e, t) {
        ((this._monotonicClock = t),
          (this._epochMillis = e.now()),
          (this._performanceMillis = t.now()));
      }
      now() {
        let e = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + e;
      }
    }
    var m = e.i(43170);
    function g(e) {
      let t = {};
      if ('object' != typeof e || null == e) return t;
      for (let [r, i] of Object.entries(e)) {
        var n;
        if (!('string' == typeof (n = r) && n.length > 0)) {
          m.diag.warn(`Invalid attribute key: ${r}`);
          continue;
        }
        if (!f(i)) {
          m.diag.warn(`Invalid attribute value set for key: ${r}`);
          continue;
        }
        Array.isArray(i) ? (t[r] = i.slice()) : (t[r] = i);
      }
      return t;
    }
    function f(e) {
      return (
        null == e ||
        (Array.isArray(e)
          ? (function (e) {
              let t;
              for (let n of e)
                if (null != n) {
                  if (!t) {
                    if (h(n)) {
                      t = typeof n;
                      continue;
                    }
                    return !1;
                  }
                  if (typeof n !== t) return !1;
                }
              return !0;
            })(e)
          : h(e))
      );
    }
    function h(e) {
      switch (typeof e) {
        case 'number':
        case 'boolean':
        case 'string':
          return !0;
      }
      return !1;
    }
    function A() {
      return (e) => {
        var t;
        m.diag.error(
          'string' == typeof (t = e)
            ? t
            : JSON.stringify(
                (function (e) {
                  let t = {},
                    n = e;
                  for (; null !== n; )
                    (Object.getOwnPropertyNames(n).forEach((e) => {
                      if (t[e]) return;
                      let r = n[e];
                      r && (t[e] = String(r));
                    }),
                      (n = Object.getPrototypeOf(n)));
                  return t;
                })(t)
              )
        );
      };
    }
    let R = A();
    function y(e) {
      R = e;
    }
    function I(e) {
      try {
        R(e);
      } catch {}
    }
    let b = e.i(60438).performance;
    function N(e) {
      return [Math.trunc(e / 1e3), Math.round((e % 1e3) * 1e6)];
    }
    function O() {
      let e = b.timeOrigin;
      return ('number' != typeof e && (e = b.timing && b.timing.fetchStart), e);
    }
    function v(e) {
      return k(N(O()), N('number' == typeof e ? e : b.now()));
    }
    function C(e) {
      if (x(e)) return e;
      if ('number' == typeof e)
        if (e < O()) return v(e);
        else return N(e);
      if (e instanceof Date) return N(e.getTime());
      throw TypeError('Invalid input type');
    }
    function P(e, t) {
      let n = t[0] - e[0],
        r = t[1] - e[1];
      return (r < 0 && ((n -= 1), (r += 1e9)), [n, r]);
    }
    function M(e) {
      let t = `${'0'.repeat(9)}${e[1]}Z`,
        n = t.substring(t.length - 9 - 1);
      return new Date(1e3 * e[0]).toISOString().replace('000Z', n);
    }
    function L(e) {
      return 1e9 * e[0] + e[1];
    }
    function U(e) {
      return 1e3 * e[0] + e[1] / 1e6;
    }
    function D(e) {
      return 1e6 * e[0] + e[1] / 1e3;
    }
    function x(e) {
      return (
        Array.isArray(e) && 2 === e.length && 'number' == typeof e[0] && 'number' == typeof e[1]
      );
    }
    function w(e) {
      return x(e) || 'number' == typeof e || e instanceof Date;
    }
    function k(e, t) {
      let n = [e[0] + t[0], e[1] + t[1]];
      return (n[1] >= 1e9 && ((n[1] -= 1e9), (n[0] += 1)), n);
    }
    !(function (e) {
      ((e[(e.SUCCESS = 0)] = 'SUCCESS'), (e[(e.FAILED = 1)] = 'FAILED'));
    })(t || (t = {}));
    var G = e.i(1709);
    let V = {
        [G.ATTR_TELEMETRY_SDK_NAME]: 'opentelemetry',
        'process.runtime.name': 'node',
        [G.ATTR_TELEMETRY_SDK_LANGUAGE]: G.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
        [G.ATTR_TELEMETRY_SDK_VERSION]: '2.0.1',
      },
      $ = 'object' == typeof globalThis ? globalThis : e.g;
    var B = e.i(24361);
    function H(e) {
      let t = process.env[e];
      if (null == t || '' === t.trim()) return;
      let n = Number(t);
      return isNaN(n)
        ? void m.diag.warn(
            `Unknown value ${(0, B.inspect)(t)} for ${e}, expected a number, using defaults`
          )
        : n;
    }
    function j(e) {
      let t = process.env[e];
      if (null != t && '' !== t.trim()) return t;
    }
    function F(e) {
      let t = process.env[e]?.trim().toLowerCase();
      return (
        null != t &&
        '' !== t &&
        ('true' === t ||
          ('false' !== t &&
            (m.diag.warn(
              `Unknown value ${(0, B.inspect)(t)} for ${e}, expected 'true' or 'false', falling back to 'false' (default)`
            ),
            !1)))
      );
    }
    function Z(e) {
      return j(e)
        ?.split(',')
        .map((e) => e.trim())
        .filter((e) => '' !== e);
    }
    function Y(e) {
      e.unref();
    }
    class W {
      _propagators;
      _fields;
      constructor(e = {}) {
        ((this._propagators = e.propagators ?? []),
          (this._fields = Array.from(
            new Set(
              this._propagators
                .map((e) => ('function' == typeof e.fields ? e.fields() : []))
                .reduce((e, t) => e.concat(t), [])
            )
          )));
      }
      inject(e, t, n) {
        for (let r of this._propagators)
          try {
            r.inject(e, t, n);
          } catch (e) {
            m.diag.warn(`Failed to inject with ${r.constructor.name}. Err: ${e.message}`);
          }
      }
      extract(e, t, n) {
        return this._propagators.reduce((e, r) => {
          try {
            return r.extract(e, t, n);
          } catch (e) {
            m.diag.warn(`Failed to extract with ${r.constructor.name}. Err: ${e.message}`);
          }
          return e;
        }, e);
      }
      fields() {
        return this._fields.slice();
      }
    }
    var K = e.i(19718),
      z = e.i(78224),
      X = e.i(58787);
    let J = '[_0-9a-z-*/]',
      Q = `[a-z]${J}{0,255}`,
      q = `[a-z0-9]${J}{0,240}@[a-z]${J}{0,13}`,
      ee = RegExp(`^(?:${Q}|${q})$`),
      et = /^[ -~]{0,255}[!-~]$/,
      en = /,|=/;
    class er {
      _internalState = new Map();
      constructor(e) {
        e && this._parse(e);
      }
      set(e, t) {
        let n = this._clone();
        return (
          n._internalState.has(e) && n._internalState.delete(e),
          n._internalState.set(e, t),
          n
        );
      }
      unset(e) {
        let t = this._clone();
        return (t._internalState.delete(e), t);
      }
      get(e) {
        return this._internalState.get(e);
      }
      serialize() {
        return this._keys()
          .reduce((e, t) => (e.push(t + '=' + this.get(t)), e), [])
          .join(',');
      }
      _parse(e) {
        !(e.length > 512) &&
          ((this._internalState = e
            .split(',')
            .reverse()
            .reduce((e, t) => {
              let n = t.trim(),
                r = n.indexOf('=');
              if (-1 !== r) {
                let i = n.slice(0, r),
                  o = n.slice(r + 1, t.length);
                ee.test(i) && et.test(o) && !en.test(o) && e.set(i, o);
              }
              return e;
            }, new Map())),
          this._internalState.size > 32 &&
            (this._internalState = new Map(
              Array.from(this._internalState.entries()).reverse().slice(0, 32)
            )));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let e = new er();
        return ((e._internalState = new Map(this._internalState)), e);
      }
    }
    let ei = 'traceparent',
      eo = 'tracestate',
      ea = RegExp(
        '^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$'
      );
    function es(e) {
      let t = ea.exec(e);
      return !t || ('00' === t[1] && t[5])
        ? null
        : { traceId: t[2], spanId: t[3], traceFlags: parseInt(t[4], 16) };
    }
    class eu {
      inject(e, t, n) {
        let r = z.trace.getSpanContext(e);
        if (!r || u(e) || !(0, K.isSpanContextValid)(r)) return;
        let i = `00-${r.traceId}-${r.spanId}-0${Number(r.traceFlags || X.TraceFlags.NONE).toString(16)}`;
        (n.set(t, ei, i), r.traceState && n.set(t, eo, r.traceState.serialize()));
      }
      extract(e, t, n) {
        let r = n.get(t, ei);
        if (!r) return e;
        let i = Array.isArray(r) ? r[0] : r;
        if ('string' != typeof i) return e;
        let o = es(i);
        if (!o) return e;
        o.isRemote = !0;
        let a = n.get(t, eo);
        if (a) {
          let e = Array.isArray(a) ? a.join(',') : a;
          o.traceState = new er('string' == typeof e ? e : void 0);
        }
        return z.trace.setSpanContext(e, o);
      }
      fields() {
        return [ei, eo];
      }
    }
    let el = (0, i.createContextKey)('OpenTelemetry SDK Context Key RPC_METADATA');
    function ec(e, t) {
      return e.setValue(el, t);
    }
    function ed(e) {
      return e.deleteValue(el);
    }
    function ep(e) {
      return e.getValue(el);
    }
    (n || (n = {})).HTTP = 'http';
    let e_ = Function.prototype.toString,
      eS = e_.call(Object),
      eE = Object.getPrototypeOf,
      eT = Object.prototype,
      em = eT.hasOwnProperty,
      eg = Symbol ? Symbol.toStringTag : void 0,
      ef = eT.toString;
    function eh(e) {
      var t, n, r;
      if (
        null == (t = e) ||
        'object' != typeof t ||
        '[object Object]' !==
          (null == (n = e)
            ? void 0 === n
              ? '[object Undefined]'
              : '[object Null]'
            : eg && eg in Object(n)
              ? (function (e) {
                  let t = em.call(e, eg),
                    n = e[eg],
                    r = !1;
                  try {
                    ((e[eg] = void 0), (r = !0));
                  } catch (e) {}
                  let i = ef.call(e);
                  return (r && (t ? (e[eg] = n) : delete e[eg]), i);
                })(n)
              : ((r = n), ef.call(r)))
      )
        return !1;
      let i = eE(e);
      if (null === i) return !0;
      let o = em.call(i, 'constructor') && i.constructor;
      return 'function' == typeof o && o instanceof o && e_.call(o) === eS;
    }
    function eA(...e) {
      let t = e.shift(),
        n = new WeakMap();
      for (; e.length > 0; )
        t = (function e(t, n, r = 0, i) {
          let o;
          if (!(r > 20)) {
            if ((r++, eO(t) || eO(n) || eb(n))) o = eR(n);
            else if (eI(t)) {
              if (((o = t.slice()), eI(n)))
                for (let e = 0, t = n.length; e < t; e++) o.push(eR(n[e]));
              else if (eN(n)) {
                let e = Object.keys(n);
                for (let t = 0, r = e.length; t < r; t++) {
                  let r = e[t];
                  o[r] = eR(n[r]);
                }
              }
            } else if (eN(t))
              if (eN(n)) {
                var a, s;
                if (((a = t), (s = n), !(eh(a) && eh(s)))) return n;
                o = Object.assign({}, t);
                let u = Object.keys(n);
                for (let a = 0, s = u.length; a < s; a++) {
                  let s = u[a],
                    l = n[s];
                  if (eO(l)) void 0 === l ? delete o[s] : (o[s] = l);
                  else {
                    let a = o[s];
                    if (ey(t, s, i) || ey(n, s, i)) delete o[s];
                    else {
                      if (eN(a) && eN(l)) {
                        let e = i.get(a) || [],
                          r = i.get(l) || [];
                        (e.push({ obj: t, key: s }),
                          r.push({ obj: n, key: s }),
                          i.set(a, e),
                          i.set(l, r));
                      }
                      o[s] = e(o[s], l, r, i);
                    }
                  }
                }
              } else o = n;
            return o;
          }
        })(t, e.shift(), 0, n);
      return t;
    }
    function eR(e) {
      return eI(e) ? e.slice() : e;
    }
    function ey(e, t, n) {
      let r = n.get(e[t]) || [];
      for (let n = 0, i = r.length; n < i; n++) {
        let i = r[n];
        if (i.key === t && i.obj === e) return !0;
      }
      return !1;
    }
    function eI(e) {
      return Array.isArray(e);
    }
    function eb(e) {
      return 'function' == typeof e;
    }
    function eN(e) {
      return !eO(e) && !eI(e) && !eb(e) && 'object' == typeof e;
    }
    function eO(e) {
      return (
        'string' == typeof e ||
        'number' == typeof e ||
        'boolean' == typeof e ||
        void 0 === e ||
        e instanceof Date ||
        e instanceof RegExp ||
        null === e
      );
    }
    class ev extends Error {
      constructor(e) {
        (super(e), Object.setPrototypeOf(this, ev.prototype));
      }
    }
    function eC(e, t) {
      let n;
      return Promise.race([
        e,
        new Promise(function (e, r) {
          n = setTimeout(function () {
            r(new ev('Operation timed out.'));
          }, t);
        }),
      ]).then(
        (e) => (clearTimeout(n), e),
        (e) => {
          throw (clearTimeout(n), e);
        }
      );
    }
    function eP(e, t) {
      return 'string' == typeof t ? e === t : !!e.match(t);
    }
    function eM(e, t) {
      if (!t) return !1;
      for (let n of t) if (eP(e, n)) return !0;
      return !1;
    }
    class eL {
      _promise;
      _resolve;
      _reject;
      constructor() {
        this._promise = new Promise((e, t) => {
          ((this._resolve = e), (this._reject = t));
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(e) {
        this._resolve(e);
      }
      reject(e) {
        this._reject(e);
      }
    }
    class eU {
      _callback;
      _that;
      _isCalled = !1;
      _deferred = new eL();
      constructor(e, t) {
        ((this._callback = e), (this._that = t));
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...e) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...e)).then(
              (e) => this._deferred.resolve(e),
              (e) => this._deferred.reject(e)
            );
          } catch (e) {
            this._deferred.reject(e);
          }
        }
        return this._deferred.promise;
      }
    }
    var eD = e.i(25834);
    let ex = {
      ALL: eD.DiagLogLevel.ALL,
      VERBOSE: eD.DiagLogLevel.VERBOSE,
      DEBUG: eD.DiagLogLevel.DEBUG,
      INFO: eD.DiagLogLevel.INFO,
      WARN: eD.DiagLogLevel.WARN,
      ERROR: eD.DiagLogLevel.ERROR,
      NONE: eD.DiagLogLevel.NONE,
    };
    function ew(e) {
      if (null == e) return;
      let t = ex[e.toUpperCase()];
      return null == t
        ? (m.diag.warn(
            `Unknown log level "${e}", expected one of ${Object.keys(ex)}, using default`
          ),
          eD.DiagLogLevel.INFO)
        : t;
    }
  },
  79797,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.VERSION = void 0),
      (n.VERSION = '0.203.0'));
  },
  75235,
  (e) => {
    'use strict';
    (e.s(
      [
        'InstrumentationBase',
        () => er,
        'InstrumentationNodeModuleDefinition',
        () => eo,
        'InstrumentationNodeModuleFile',
        () => ea,
        'SemconvStability',
        () => t,
        'isWrapped',
        () => en,
        'registerInstrumentations',
        () => _,
        'safeExecuteInTheMiddle',
        () => ee,
        'safeExecuteInTheMiddleAsync',
        () => et,
        'semconvStabilityFromStr',
        () => es,
      ],
      75235
    ),
      e.s([], 71),
      e.i(71));
    var t,
      n = e.i(78224),
      r = e.i(25148);
    let i = 'object' == typeof globalThis ? globalThis : e.g,
      o = Symbol.for('io.opentelemetry.js.api.logs');
    class a {
      emit(e) {}
    }
    let s = new a(),
      u = new (class {
        getLogger(e, t, n) {
          return new a();
        }
      })();
    class l {
      constructor(e, t, n, r) {
        ((this._provider = e), (this.name = t), (this.version = n), (this.options = r));
      }
      emit(e) {
        this._getLogger().emit(e);
      }
      _getLogger() {
        if (this._delegate) return this._delegate;
        let e = this._provider.getDelegateLogger(this.name, this.version, this.options);
        return e ? ((this._delegate = e), this._delegate) : s;
      }
    }
    class c {
      getLogger(e, t, n) {
        var r;
        return null != (r = this.getDelegateLogger(e, t, n)) ? r : new l(this, e, t, n);
      }
      getDelegate() {
        var e;
        return null != (e = this._delegate) ? e : u;
      }
      setDelegate(e) {
        this._delegate = e;
      }
      getDelegateLogger(e, t, n) {
        var r;
        return null == (r = this._delegate) ? void 0 : r.getLogger(e, t, n);
      }
    }
    class d {
      constructor() {
        this._proxyLoggerProvider = new c();
      }
      static getInstance() {
        return (this._instance || (this._instance = new d()), this._instance);
      }
      setGlobalLoggerProvider(e) {
        return i[o]
          ? this.getLoggerProvider()
          : ((i[o] = (t) => (1 === t ? e : u)), this._proxyLoggerProvider.setDelegate(e), e);
      }
      getLoggerProvider() {
        var e, t;
        return null != (t = null == (e = i[o]) ? void 0 : e.call(i, 1))
          ? t
          : this._proxyLoggerProvider;
      }
      getLogger(e, t, n) {
        return this.getLoggerProvider().getLogger(e, t, n);
      }
      disable() {
        (delete i[o], (this._proxyLoggerProvider = new c()));
      }
    }
    let p = d.getInstance();
    function _(e) {
      let t = e.tracerProvider || n.trace.getTracerProvider(),
        i = e.meterProvider || r.metrics.getMeterProvider(),
        o = e.loggerProvider || p.getLoggerProvider(),
        a = e.instrumentations?.flat() ?? [];
      for (let e = 0, n = a.length; e < n; e++) {
        let n = a[e];
        (t && n.setTracerProvider(t),
          i && n.setMeterProvider(i),
          o && n.setLoggerProvider && n.setLoggerProvider(o),
          n.getConfig().enabled || n.enable());
      }
      return () => {
        a.forEach((e) => e.disable());
      };
    }
    var S = e.i(14747),
      E = e.i(24361),
      T = e.i(43170);
    let m =
        /^(?:v)?(?<version>(?<major>0|[1-9]\d*)\.(?<minor>0|[1-9]\d*)\.(?<patch>0|[1-9]\d*))(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,
      g =
        /^(?<op><|>|=|==|<=|>=|~|\^|~>)?\s*(?:v)?(?<version>(?<major>x|X|\*|0|[1-9]\d*)(?:\.(?<minor>x|X|\*|0|[1-9]\d*))?(?:\.(?<patch>x|X|\*|0|[1-9]\d*))?)(?:-(?<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?<build>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,
      f = { '>': [1], '>=': [0, 1], '=': [0], '<=': [-1, 0], '<': [-1], '!=': [-1, 1] };
    function h(e, t, n, r) {
      if (t.includes('||')) {
        for (let i of t.trim().split('||')) if (A(e, i, n, r)) return !0;
        return !1;
      }
      if (t.includes(' - ')) {
        var i, o;
        ((i = t),
          (o = r),
          (t = i.replace(
            w,
            (e, t, n, r, i, a, s, u, l, c, d, p) => (
              (t = R(n)
                ? ''
                : R(r)
                  ? `>=${n}.0.0${o?.includePrerelease ? '-0' : ''}`
                  : R(i)
                    ? `>=${n}.${r}.0${o?.includePrerelease ? '-0' : ''}`
                    : a
                      ? `>=${t}`
                      : `>=${t}${o?.includePrerelease ? '-0' : ''}`),
              (u = R(l)
                ? ''
                : R(c)
                  ? `<${+l + 1}.0.0-0`
                  : R(d)
                    ? `<${l}.${+c + 1}.0-0`
                    : p
                      ? `<=${l}.${c}.${d}-${p}`
                      : o?.includePrerelease
                        ? `<${l}.${c}.${+d + 1}-0`
                        : `<=${u}`),
              `${t} ${u}`.trim()
            )
          )));
      } else if (t.includes(' ')) {
        for (let i of t
          .trim()
          .replace(/\s{2,}/g, ' ')
          .split(' '))
          if (!A(e, i, n, r)) return !1;
        return !0;
      }
      return A(e, t, n, r);
    }
    function A(e, t, n, r) {
      var i, o, a, s;
      if (
        ((i = t),
        (o = r),
        (t = ((a = i =
          (i = (function (e, t) {
            let n = t?.includePrerelease ? '-0' : '';
            return e.replace(G, (e, t, r, i, o) =>
              R(t)
                ? ''
                : R(r)
                  ? `>=${t}.0.0${n} <${+t + 1}.0.0-0`
                  : R(i)
                    ? '0' === t
                      ? `>=${t}.${r}.0${n} <${t}.${+r + 1}.0-0`
                      : `>=${t}.${r}.0${n} <${+t + 1}.0.0-0`
                    : o
                      ? '0' === t
                        ? '0' === r
                          ? `>=${t}.${r}.${i}-${o} <${t}.${r}.${+i + 1}-0`
                          : `>=${t}.${r}.${i}-${o} <${t}.${+r + 1}.0-0`
                        : `>=${t}.${r}.${i}-${o} <${+t + 1}.0.0-0`
                      : '0' === t
                        ? '0' === r
                          ? `>=${t}.${r}.${i}${n} <${t}.${r}.${+i + 1}-0`
                          : `>=${t}.${r}.${i}${n} <${t}.${+r + 1}.0-0`
                        : `>=${t}.${r}.${i} <${+t + 1}.0.0-0`
            );
          })((i = i.trim()), o)).replace(k, (e, t, n, r, i) =>
            R(t)
              ? ''
              : R(n)
                ? `>=${t}.0.0 <${+t + 1}.0.0-0`
                : R(r)
                  ? `>=${t}.${n}.0 <${t}.${+n + 1}.0-0`
                  : i
                    ? `>=${t}.${n}.${r}-${i} <${t}.${+n + 1}.0-0`
                    : `>=${t}.${n}.${r} <${t}.${+n + 1}.0-0`
          )),
        (s = o),
        (i = a.replace(x, (e, t, n, r, i, o) => {
          let a = R(n),
            u = a || R(r),
            l = u || R(i);
          return (
            '=' === t && l && (t = ''),
            (o = s?.includePrerelease ? '-0' : ''),
            a
              ? (e = '>' === t || '<' === t ? '<0.0.0-0' : '*')
              : t && l
                ? (u && (r = 0),
                  (i = 0),
                  '>' === t
                    ? ((t = '>='), u ? ((n = +n + 1), (r = 0)) : (r = +r + 1), (i = 0))
                    : '<=' === t && ((t = '<'), u ? (n = +n + 1) : (r = +r + 1)),
                  '<' === t && (o = '-0'),
                  (e = `${t + n}.${r}.${i}${o}`))
                : u
                  ? (e = `>=${n}.0.0${o} <${+n + 1}.0.0-0`)
                  : l && (e = `>=${n}.${r}.0${o} <${n}.${+r + 1}.0-0`),
            e
          );
        }))).trim())).includes(' ')
      )
        return h(e, t, n, r);
      {
        let r = (function (e) {
          if (!e) return {};
          let t = e.match(g);
          if (!t) return (T.diag.error(`Invalid range: ${e}`), { invalid: !0 });
          let n = t.groups.op,
            r = t.groups.version,
            i = t.groups.prerelease,
            o = t.groups.build,
            a = r.split('.'),
            s = i?.split('.');
          return (
            '==' === n && (n = '='),
            {
              op: n || '=',
              version: r,
              versionSegments: a,
              versionSegmentCount: a.length,
              prerelease: i,
              prereleaseSegments: s,
              prereleaseSegmentCount: s ? s.length : 0,
              build: o,
            }
          );
        })(t);
        return (
          n.push(r),
          (function (e, t) {
            if (t.invalid) return !1;
            if (!t.version || y(t.version)) return !0;
            let n = b(e.versionSegments || [], t.versionSegments || []);
            if (0 === n) {
              let r = e.prereleaseSegments || [],
                i = t.prereleaseSegments || [];
              n =
                r.length || i.length
                  ? !r.length && i.length
                    ? 1
                    : r.length && !i.length
                      ? -1
                      : b(r, i)
                  : 0;
            }
            return f[t.op]?.includes(n);
          })(e, r)
        );
      }
    }
    function R(e) {
      return !e || 'x' === e.toLowerCase() || '*' === e;
    }
    function y(e) {
      return '*' === e || 'x' === e || 'X' === e;
    }
    function I(e) {
      let t = parseInt(e, 10);
      return isNaN(t) ? e : t;
    }
    function b(e, t) {
      for (let n = 0; n < Math.max(e.length, t.length); n++) {
        let r = (function (e, t) {
          if (y(e) || y(t)) return 0;
          let [n, r] = (function (e, t) {
            if (typeof e != typeof t) return [String(e), String(t)];
            if ('number' == typeof e) return [e, t];
            if ('string' == typeof e) return [e, t];
            throw Error('Version segments can only be strings or numbers');
          })(I(e), I(t));
          return n > r ? 1 : n < r ? -1 : 0;
        })(e[n] || '0', t[n] || '0');
        if (0 !== r) return r;
      }
      return 0;
    }
    let N = '[a-zA-Z0-9-]',
      O = '0|[1-9]\\d*',
      v = `\\d*[a-zA-Z-]${N}*`,
      C = `(?:${O}|${v})`,
      P = `(?:-(${C}(?:\\.${C})*))`,
      M = `${N}+`,
      L = `(?:\\+(${M}(?:\\.${M})*))`,
      U = `${O}|x|X|\\*`,
      D = `[v=\\s]*(${U})(?:\\.(${U})(?:\\.(${U})(?:${P})?${L}?)?)?`,
      x = RegExp(`^((?:<|>)?=?)\\s*${D}$`),
      w = RegExp(`^\\s*(${D})\\s+-\\s+(${D})\\s*$`),
      k = RegExp(`^(?:~>?)${D}$`),
      G = RegExp(`^(?:\\^)${D}$`),
      V = console.error.bind(console);
    function $(e, t, n) {
      let r = !!e[t] && Object.prototype.propertyIsEnumerable.call(e, t);
      Object.defineProperty(e, t, { configurable: !0, enumerable: r, writable: !0, value: n });
    }
    let B = (e, t, n) => {
        if (!e || !e[t]) return void V('no original function ' + String(t) + ' to wrap');
        if (!n) {
          (V('no wrapper function'), V(Error().stack));
          return;
        }
        let r = e[t];
        if ('function' != typeof r || 'function' != typeof n)
          return void V('original object and wrapper must be functions');
        let i = n(r, t);
        return (
          $(i, '__original', r),
          $(i, '__unwrap', () => {
            e[t] === i && $(e, t, r);
          }),
          $(i, '__wrapped', !0),
          $(e, t, i),
          i
        );
      },
      H = (e, t, n) => {
        if (e) Array.isArray(e) || (e = [e]);
        else {
          (V('must provide one or more modules to patch'), V(Error().stack));
          return;
        }
        if (!(t && Array.isArray(t)))
          return void V('must provide one or more functions to wrap on modules');
        e.forEach((e) => {
          t.forEach((t) => {
            B(e, t, n);
          });
        });
      },
      j = (e, t) => {
        if (!e || !e[t]) {
          (V('no function to unwrap.'), V(Error().stack));
          return;
        }
        let n = e[t];
        if (n.__unwrap) return void n.__unwrap();
        V('no original to unwrap to -- has ' + String(t) + ' already been unwrapped?');
      },
      F = (e, t) => {
        if (e) Array.isArray(e) || (e = [e]);
        else {
          (V('must provide one or more modules to patch'), V(Error().stack));
          return;
        }
        if (!(t && Array.isArray(t)))
          return void V('must provide one or more functions to unwrap on modules');
        e.forEach((e) => {
          t.forEach((t) => {
            j(e, t);
          });
        });
      };
    function Z(e) {
      e &&
        e.logger &&
        ('function' != typeof e.logger
          ? V("new logger isn't a function, not replacing")
          : (V = e.logger));
    }
    ((Z.wrap = B),
      (Z.massWrap = H),
      (Z.unwrap = j),
      (Z.massUnwrap = F),
      (globalThis._sentryNextJsVersion = '15.5.2'));
    class Y {
      instrumentationName;
      instrumentationVersion;
      _config = {};
      _tracer;
      _meter;
      _logger;
      _diag;
      constructor(e, t, i) {
        ((this.instrumentationName = e),
          (this.instrumentationVersion = t),
          this.setConfig(i),
          (this._diag = T.diag.createComponentLogger({ namespace: e })),
          (this._tracer = n.trace.getTracer(e, t)),
          (this._meter = r.metrics.getMeter(e, t)),
          (this._logger = p.getLogger(e, t)),
          this._updateMetricInstruments());
      }
      _wrap = B;
      _unwrap = j;
      _massWrap = H;
      _massUnwrap = F;
      get meter() {
        return this._meter;
      }
      setMeterProvider(e) {
        ((this._meter = e.getMeter(this.instrumentationName, this.instrumentationVersion)),
          this._updateMetricInstruments());
      }
      get logger() {
        return this._logger;
      }
      setLoggerProvider(e) {
        this._logger = e.getLogger(this.instrumentationName, this.instrumentationVersion);
      }
      getModuleDefinitions() {
        let e = this.init() ?? [];
        return Array.isArray(e) ? e : [e];
      }
      _updateMetricInstruments() {}
      getConfig() {
        return this._config;
      }
      setConfig(e) {
        this._config = { enabled: !0, ...e };
      }
      setTracerProvider(e) {
        this._tracer = e.getTracer(this.instrumentationName, this.instrumentationVersion);
      }
      get tracer() {
        return this._tracer;
      }
      _runSpanCustomizationHook(e, t, n, r) {
        if (e)
          try {
            e(n, r);
          } catch (e) {
            this._diag.error(
              'Error running span customization hook due to exception in handler',
              { triggerName: t },
              e
            );
          }
      }
    }
    var W = e.i(79314);
    class K {
      hooks = [];
      children = new Map();
    }
    class z {
      _trie = new K();
      _counter = 0;
      insert(e) {
        let t = this._trie;
        for (let n of e.moduleName.split('/')) {
          let e = t.children.get(n);
          (e || ((e = new K()), t.children.set(n, e)), (t = e));
        }
        t.hooks.push({ hook: e, insertedId: this._counter++ });
      }
      search(e, { maintainInsertionOrder: t, fullOnly: n } = {}) {
        let r = this._trie,
          i = [],
          o = !0;
        for (let t of e.split('/')) {
          let e = r.children.get(t);
          if (!e) {
            o = !1;
            break;
          }
          (n || i.push(...e.hooks), (r = e));
        }
        return (n && o && i.push(...r.hooks), 0 === i.length)
          ? []
          : 1 === i.length
            ? [i[0].hook]
            : (t && i.sort((e, t) => e.insertedId - t.insertedId), i.map(({ hook: e }) => e));
      }
    }
    let X = ['afterEach', 'after', 'beforeEach', 'before', 'describe', 'it'].every(
      (t) => 'function' == typeof e.g[t]
    );
    class J {
      _moduleNameTrie = new z();
      static _instance;
      constructor() {
        this._initialize();
      }
      _initialize() {
        new W.Hook(null, { internals: !0 }, (e, t, n) => {
          var r;
          let i = ((r = t), '/' !== S.sep ? r.split(S.sep).join('/') : r);
          for (let { onRequire: r } of this._moduleNameTrie.search(i, {
            maintainInsertionOrder: !0,
            fullOnly: void 0 === n,
          }))
            e = r(e, t, n);
          return e;
        });
      }
      register(e, t) {
        let n = { moduleName: e, onRequire: t };
        return (this._moduleNameTrie.insert(n), n);
      }
      static getInstance() {
        return X ? new J() : (this._instance = this._instance ?? new J());
      }
    }
    var Q = e.i(85397),
      q = e.i(22734);
    function ee(e, t, n) {
      let r, i;
      try {
        i = e();
      } catch (e) {
        r = e;
      } finally {
        if ((t(r, i), r && !n)) throw r;
        return i;
      }
    }
    async function et(e, t, n) {
      let r, i;
      try {
        i = await e();
      } catch (e) {
        r = e;
      } finally {
        if ((t(r, i), r && !n)) throw r;
        return i;
      }
    }
    function en(e) {
      return (
        'function' == typeof e &&
        'function' == typeof e.__original &&
        'function' == typeof e.__unwrap &&
        !0 === e.__wrapped
      );
    }
    globalThis._sentryNextJsVersion = '15.5.2';
    class er extends Y {
      _modules;
      _hooks = [];
      _requireInTheMiddleSingleton = J.getInstance();
      _enabled = !1;
      constructor(e, t, n) {
        super(e, t, n);
        let r = this.init();
        (r && !Array.isArray(r) && (r = [r]),
          (this._modules = r || []),
          this._config.enabled && this.enable());
      }
      _wrap = (e, t, n) => {
        if ((en(e[t]) && this._unwrap(e, t), !E.types.isProxy(e))) return B(e, t, n);
        {
          let r = B(Object.assign({}, e), t, n);
          return (Object.defineProperty(e, t, { value: r }), r);
        }
      };
      _unwrap = (e, t) =>
        E.types.isProxy(e) ? Object.defineProperty(e, t, { value: e[t] }) : j(e, t);
      _massWrap = (e, t, n) =>
        e
          ? (Array.isArray(e) || (e = [e]), t && Array.isArray(t))
            ? void e.forEach((e) => {
                t.forEach((t) => {
                  this._wrap(e, t, n);
                });
              })
            : void T.diag.error('must provide one or more functions to wrap on modules')
          : void T.diag.error('must provide one or more modules to patch');
      _massUnwrap = (e, t) =>
        e
          ? (Array.isArray(e) || (e = [e]), t && Array.isArray(t))
            ? void e.forEach((e) => {
                t.forEach((t) => {
                  this._unwrap(e, t);
                });
              })
            : void T.diag.error('must provide one or more functions to wrap on modules')
          : void T.diag.error('must provide one or more modules to patch');
      _warnOnPreloadedModules() {
        this._modules.forEach((t) => {
          let { name: n } = t;
          try {
            let t = (() => {
              let e = Error('Cannot find module as expression is too dynamic');
              throw ((e.code = 'MODULE_NOT_FOUND'), e);
            })();
            e.c[t] &&
              this._diag.warn(
                `Module ${n} has been loaded before ${this.instrumentationName} so it might not work, please initialize it before requiring ${n}`
              );
          } catch {}
        });
      }
      _extractPackageVersion(e) {
        try {
          let t = (0, q.readFileSync)(S.join(e, 'package.json'), { encoding: 'utf8' }),
            n = JSON.parse(t).version;
          return 'string' == typeof n ? n : void 0;
        } catch {
          T.diag.warn('Failed extracting version', e);
        }
      }
      _onRequire(e, t, n, r) {
        if (!r)
          return 'function' == typeof e.patch && ((e.moduleExports = t), this._enabled)
            ? (this._diag.debug(
                'Applying instrumentation patch for nodejs core module on require hook',
                { module: e.name }
              ),
              e.patch(t))
            : t;
        let i = this._extractPackageVersion(r);
        if (((e.moduleVersion = i), e.name === n))
          return ei(e.supportedVersions, i, e.includePrerelease) &&
            'function' == typeof e.patch &&
            ((e.moduleExports = t), this._enabled)
            ? (this._diag.debug('Applying instrumentation patch for module on require hook', {
                module: e.name,
                version: e.moduleVersion,
                baseDir: r,
              }),
              e.patch(t, e.moduleVersion))
            : t;
        let o = e.files ?? [],
          a = S.normalize(n);
        return o
          .filter((e) => e.name === a)
          .filter((t) => ei(t.supportedVersions, i, e.includePrerelease))
          .reduce(
            (t, n) =>
              ((n.moduleExports = t), this._enabled)
                ? (this._diag.debug(
                    'Applying instrumentation patch for nodejs module file on require hook',
                    { module: e.name, version: e.moduleVersion, fileName: n.name, baseDir: r }
                  ),
                  n.patch(t, e.moduleVersion))
                : t,
            t
          );
      }
      enable() {
        if (!this._enabled) {
          if (((this._enabled = !0), this._hooks.length > 0)) {
            for (let e of this._modules)
              for (let t of ('function' == typeof e.patch &&
                e.moduleExports &&
                (this._diag.debug(
                  'Applying instrumentation patch for nodejs module on instrumentation enabled',
                  { module: e.name, version: e.moduleVersion }
                ),
                e.patch(e.moduleExports, e.moduleVersion)),
              e.files))
                t.moduleExports &&
                  (this._diag.debug(
                    'Applying instrumentation patch for nodejs module file on instrumentation enabled',
                    { module: e.name, version: e.moduleVersion, fileName: t.name }
                  ),
                  t.patch(t.moduleExports, e.moduleVersion));
            return;
          }
          for (let e of (this._warnOnPreloadedModules(), this._modules)) {
            let t = (t, n, r) => {
                if (!r && S.isAbsolute(n)) {
                  let e = S.parse(n);
                  ((n = e.name), (r = e.dir));
                }
                return this._onRequire(e, t, n, r);
              },
              n = (t, n, r) => this._onRequire(e, t, n, r),
              r = S.isAbsolute(e.name)
                ? new W.Hook([e.name], { internals: !0 }, n)
                : this._requireInTheMiddleSingleton.register(e.name, n);
            this._hooks.push(r);
            let i = new Q.Hook([e.name], { internals: !1 }, t);
            this._hooks.push(i);
          }
        }
      }
      disable() {
        if (this._enabled)
          for (let e of ((this._enabled = !1), this._modules))
            for (let t of ('function' == typeof e.unpatch &&
              e.moduleExports &&
              (this._diag.debug(
                'Removing instrumentation patch for nodejs module on instrumentation disabled',
                { module: e.name, version: e.moduleVersion }
              ),
              e.unpatch(e.moduleExports, e.moduleVersion)),
            e.files))
              t.moduleExports &&
                (this._diag.debug(
                  'Removing instrumentation patch for nodejs module file on instrumentation disabled',
                  { module: e.name, version: e.moduleVersion, fileName: t.name }
                ),
                t.unpatch(t.moduleExports, e.moduleVersion));
      }
      isEnabled() {
        return this._enabled;
      }
    }
    function ei(e, t, n) {
      return void 0 === t
        ? e.includes('*')
        : e.some((e) =>
            (function (e, t, n) {
              var r, i, o;
              if (!('string' == typeof (r = e) && m.test(r)))
                return (T.diag.error(`Invalid version: ${e}`), !1);
              if (!t) return !0;
              t = t.replace(/([<>=~^]+)\s+/g, '$1');
              let a = (function (e) {
                let t = e.match(m);
                if (!t) return void T.diag.error(`Invalid version: ${e}`);
                let n = t.groups.version,
                  r = t.groups.prerelease,
                  i = t.groups.build,
                  o = n.split('.'),
                  a = r?.split('.');
                return {
                  op: void 0,
                  version: n,
                  versionSegments: o,
                  versionSegmentCount: o.length,
                  prerelease: r,
                  prereleaseSegments: a,
                  prereleaseSegmentCount: a ? a.length : 0,
                  build: i,
                };
              })(e);
              if (!a) return !1;
              let s = [],
                u = h(a, t, s, n);
              return u && !n?.includePrerelease
                ? ((i = a),
                  (o = s),
                  !i.prerelease || o.some((e) => e.prerelease && e.version === i.version))
                : u;
            })(t, e, { includePrerelease: n })
          );
    }
    class eo {
      name;
      supportedVersions;
      patch;
      unpatch;
      files;
      constructor(e, t, n, r, i) {
        ((this.name = e),
          (this.supportedVersions = t),
          (this.patch = n),
          (this.unpatch = r),
          (this.files = i || []));
      }
    }
    class ea {
      supportedVersions;
      patch;
      unpatch;
      name;
      constructor(e, t, n, r) {
        ((this.supportedVersions = t),
          (this.patch = n),
          (this.unpatch = r),
          (this.name = (0, S.normalize)(e)));
      }
    }
    function es(e, n) {
      let r = t.OLD;
      for (let i of n
        ?.split(',')
        .map((e) => e.trim())
        .filter((e) => '' !== e) ?? [])
        if (i.toLowerCase() === e + '/dup') {
          r = t.DUPLICATE;
          break;
        } else i.toLowerCase() === e && (r = t.STABLE);
      return r;
    }
    !(function (e) {
      ((e[(e.STABLE = 1)] = 'STABLE'),
        (e[(e.OLD = 2)] = 'OLD'),
        (e[(e.DUPLICATE = 3)] = 'DUPLICATE'));
    })(t || (t = {}));
  },
  81964,
  (e) => {
    'use strict';
    function t(e) {
      let t = {},
        n = e.length;
      for (let r = 0; r < n; r++) {
        let n = e[r];
        n && (t[String(n).toUpperCase().replace(/[-.]/g, '_')] = n);
      }
      return t;
    }
    (e.s(
      [
        'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED',
        () => dl.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
        'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED',
        () => dl.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
        'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED',
        () => dl.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
        'ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED',
        () => dl.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
        'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED',
        () => dl.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
        'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER',
        () => dl.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
        'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER',
        () => dl.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
        'ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED',
        () => dl.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
        'ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE',
        () => dl.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
        'ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS',
        () => dl.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
        'ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT',
        () => dl.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
        'ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE',
        () => dl.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
        'ATTR_ASPNETCORE_RATE_LIMITING_POLICY',
        () => dl.ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
        'ATTR_ASPNETCORE_RATE_LIMITING_RESULT',
        () => dl.ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
        'ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED',
        () => dl.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
        'ATTR_ASPNETCORE_ROUTING_IS_FALLBACK',
        () => dl.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
        'ATTR_ASPNETCORE_ROUTING_MATCH_STATUS',
        () => dl.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
        'ATTR_ASPNETCORE_USER_IS_AUTHENTICATED',
        () => dl.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED,
        'ATTR_CLIENT_ADDRESS',
        () => dl.ATTR_CLIENT_ADDRESS,
        'ATTR_CLIENT_PORT',
        () => dl.ATTR_CLIENT_PORT,
        'ATTR_CODE_COLUMN_NUMBER',
        () => dl.ATTR_CODE_COLUMN_NUMBER,
        'ATTR_CODE_FILE_PATH',
        () => dl.ATTR_CODE_FILE_PATH,
        'ATTR_CODE_FUNCTION_NAME',
        () => dl.ATTR_CODE_FUNCTION_NAME,
        'ATTR_CODE_LINE_NUMBER',
        () => dl.ATTR_CODE_LINE_NUMBER,
        'ATTR_CODE_STACKTRACE',
        () => dl.ATTR_CODE_STACKTRACE,
        'ATTR_DB_COLLECTION_NAME',
        () => dl.ATTR_DB_COLLECTION_NAME,
        'ATTR_DB_NAMESPACE',
        () => dl.ATTR_DB_NAMESPACE,
        'ATTR_DB_OPERATION_BATCH_SIZE',
        () => dl.ATTR_DB_OPERATION_BATCH_SIZE,
        'ATTR_DB_OPERATION_NAME',
        () => dl.ATTR_DB_OPERATION_NAME,
        'ATTR_DB_QUERY_SUMMARY',
        () => dl.ATTR_DB_QUERY_SUMMARY,
        'ATTR_DB_QUERY_TEXT',
        () => dl.ATTR_DB_QUERY_TEXT,
        'ATTR_DB_RESPONSE_STATUS_CODE',
        () => dl.ATTR_DB_RESPONSE_STATUS_CODE,
        'ATTR_DB_STORED_PROCEDURE_NAME',
        () => dl.ATTR_DB_STORED_PROCEDURE_NAME,
        'ATTR_DB_SYSTEM_NAME',
        () => dl.ATTR_DB_SYSTEM_NAME,
        'ATTR_DOTNET_GC_HEAP_GENERATION',
        () => dl.ATTR_DOTNET_GC_HEAP_GENERATION,
        'ATTR_ERROR_TYPE',
        () => dl.ATTR_ERROR_TYPE,
        'ATTR_EXCEPTION_ESCAPED',
        () => dl.ATTR_EXCEPTION_ESCAPED,
        'ATTR_EXCEPTION_MESSAGE',
        () => dl.ATTR_EXCEPTION_MESSAGE,
        'ATTR_EXCEPTION_STACKTRACE',
        () => dl.ATTR_EXCEPTION_STACKTRACE,
        'ATTR_EXCEPTION_TYPE',
        () => dl.ATTR_EXCEPTION_TYPE,
        'ATTR_HTTP_REQUEST_HEADER',
        () => dl.ATTR_HTTP_REQUEST_HEADER,
        'ATTR_HTTP_REQUEST_METHOD',
        () => dl.ATTR_HTTP_REQUEST_METHOD,
        'ATTR_HTTP_REQUEST_METHOD_ORIGINAL',
        () => dl.ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
        'ATTR_HTTP_REQUEST_RESEND_COUNT',
        () => dl.ATTR_HTTP_REQUEST_RESEND_COUNT,
        'ATTR_HTTP_RESPONSE_HEADER',
        () => dl.ATTR_HTTP_RESPONSE_HEADER,
        'ATTR_HTTP_RESPONSE_STATUS_CODE',
        () => dl.ATTR_HTTP_RESPONSE_STATUS_CODE,
        'ATTR_HTTP_ROUTE',
        () => dl.ATTR_HTTP_ROUTE,
        'ATTR_JVM_GC_ACTION',
        () => dl.ATTR_JVM_GC_ACTION,
        'ATTR_JVM_GC_NAME',
        () => dl.ATTR_JVM_GC_NAME,
        'ATTR_JVM_MEMORY_POOL_NAME',
        () => dl.ATTR_JVM_MEMORY_POOL_NAME,
        'ATTR_JVM_MEMORY_TYPE',
        () => dl.ATTR_JVM_MEMORY_TYPE,
        'ATTR_JVM_THREAD_DAEMON',
        () => dl.ATTR_JVM_THREAD_DAEMON,
        'ATTR_JVM_THREAD_STATE',
        () => dl.ATTR_JVM_THREAD_STATE,
        'ATTR_NETWORK_LOCAL_ADDRESS',
        () => dl.ATTR_NETWORK_LOCAL_ADDRESS,
        'ATTR_NETWORK_LOCAL_PORT',
        () => dl.ATTR_NETWORK_LOCAL_PORT,
        'ATTR_NETWORK_PEER_ADDRESS',
        () => dl.ATTR_NETWORK_PEER_ADDRESS,
        'ATTR_NETWORK_PEER_PORT',
        () => dl.ATTR_NETWORK_PEER_PORT,
        'ATTR_NETWORK_PROTOCOL_NAME',
        () => dl.ATTR_NETWORK_PROTOCOL_NAME,
        'ATTR_NETWORK_PROTOCOL_VERSION',
        () => dl.ATTR_NETWORK_PROTOCOL_VERSION,
        'ATTR_NETWORK_TRANSPORT',
        () => dl.ATTR_NETWORK_TRANSPORT,
        'ATTR_NETWORK_TYPE',
        () => dl.ATTR_NETWORK_TYPE,
        'ATTR_OTEL_SCOPE_NAME',
        () => dl.ATTR_OTEL_SCOPE_NAME,
        'ATTR_OTEL_SCOPE_VERSION',
        () => dl.ATTR_OTEL_SCOPE_VERSION,
        'ATTR_OTEL_STATUS_CODE',
        () => dl.ATTR_OTEL_STATUS_CODE,
        'ATTR_OTEL_STATUS_DESCRIPTION',
        () => dl.ATTR_OTEL_STATUS_DESCRIPTION,
        'ATTR_SERVER_ADDRESS',
        () => dl.ATTR_SERVER_ADDRESS,
        'ATTR_SERVER_PORT',
        () => dl.ATTR_SERVER_PORT,
        'ATTR_SERVICE_NAME',
        () => dl.ATTR_SERVICE_NAME,
        'ATTR_SERVICE_VERSION',
        () => dl.ATTR_SERVICE_VERSION,
        'ATTR_SIGNALR_CONNECTION_STATUS',
        () => dl.ATTR_SIGNALR_CONNECTION_STATUS,
        'ATTR_SIGNALR_TRANSPORT',
        () => dl.ATTR_SIGNALR_TRANSPORT,
        'ATTR_TELEMETRY_SDK_LANGUAGE',
        () => dl.ATTR_TELEMETRY_SDK_LANGUAGE,
        'ATTR_TELEMETRY_SDK_NAME',
        () => dl.ATTR_TELEMETRY_SDK_NAME,
        'ATTR_TELEMETRY_SDK_VERSION',
        () => dl.ATTR_TELEMETRY_SDK_VERSION,
        'ATTR_URL_FRAGMENT',
        () => dl.ATTR_URL_FRAGMENT,
        'ATTR_URL_FULL',
        () => dl.ATTR_URL_FULL,
        'ATTR_URL_PATH',
        () => dl.ATTR_URL_PATH,
        'ATTR_URL_QUERY',
        () => dl.ATTR_URL_QUERY,
        'ATTR_URL_SCHEME',
        () => dl.ATTR_URL_SCHEME,
        'ATTR_USER_AGENT_ORIGINAL',
        () => dl.ATTR_USER_AGENT_ORIGINAL,
        'AWSECSLAUNCHTYPEVALUES_EC2',
        () => cE,
        'AWSECSLAUNCHTYPEVALUES_FARGATE',
        () => cT,
        'AwsEcsLaunchtypeValues',
        () => cm,
        'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS',
        () => l3,
        'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC',
        () => l6,
        'CLOUDPLATFORMVALUES_AWS_EC2',
        () => l7,
        'CLOUDPLATFORMVALUES_AWS_ECS',
        () => l8,
        'CLOUDPLATFORMVALUES_AWS_EKS',
        () => ce,
        'CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK',
        () => cn,
        'CLOUDPLATFORMVALUES_AWS_LAMBDA',
        () => ct,
        'CLOUDPLATFORMVALUES_AZURE_AKS',
        () => co,
        'CLOUDPLATFORMVALUES_AZURE_APP_SERVICE',
        () => cs,
        'CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES',
        () => ci,
        'CLOUDPLATFORMVALUES_AZURE_FUNCTIONS',
        () => ca,
        'CLOUDPLATFORMVALUES_AZURE_VM',
        () => cr,
        'CLOUDPLATFORMVALUES_GCP_APP_ENGINE',
        () => cp,
        'CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS',
        () => cd,
        'CLOUDPLATFORMVALUES_GCP_CLOUD_RUN',
        () => cl,
        'CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE',
        () => cu,
        'CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE',
        () => cc,
        'CLOUDPROVIDERVALUES_ALIBABA_CLOUD',
        () => lG,
        'CLOUDPROVIDERVALUES_AWS',
        () => lV,
        'CLOUDPROVIDERVALUES_AZURE',
        () => l$,
        'CLOUDPROVIDERVALUES_GCP',
        () => lB,
        'CloudPlatformValues',
        () => c_,
        'CloudProviderValues',
        () => lH,
        'DBCASSANDRACONSISTENCYLEVELVALUES_ALL',
        () => iX,
        'DBCASSANDRACONSISTENCYLEVELVALUES_ANY',
        () => i4,
        'DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM',
        () => iJ,
        'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE',
        () => i5,
        'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM',
        () => iq,
        'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL',
        () => i3,
        'DBCASSANDRACONSISTENCYLEVELVALUES_ONE',
        () => i0,
        'DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM',
        () => iQ,
        'DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL',
        () => i9,
        'DBCASSANDRACONSISTENCYLEVELVALUES_THREE',
        () => i2,
        'DBCASSANDRACONSISTENCYLEVELVALUES_TWO',
        () => i1,
        'DBSYSTEMVALUES_ADABAS',
        () => id,
        'DBSYSTEMVALUES_CACHE',
        () => ic,
        'DBSYSTEMVALUES_CASSANDRA',
        () => iC,
        'DBSYSTEMVALUES_CLOUDSCAPE',
        () => it,
        'DBSYSTEMVALUES_COCKROACHDB',
        () => iB,
        'DBSYSTEMVALUES_COLDFUSION',
        () => iv,
        'DBSYSTEMVALUES_COSMOSDB',
        () => ix,
        'DBSYSTEMVALUES_COUCHBASE',
        () => iU,
        'DBSYSTEMVALUES_COUCHDB',
        () => iD,
        'DBSYSTEMVALUES_DB2',
        () => r6,
        'DBSYSTEMVALUES_DERBY',
        () => i_,
        'DBSYSTEMVALUES_DYNAMODB',
        () => iw,
        'DBSYSTEMVALUES_EDB',
        () => il,
        'DBSYSTEMVALUES_ELASTICSEARCH',
        () => iV,
        'DBSYSTEMVALUES_FILEMAKER',
        () => iS,
        'DBSYSTEMVALUES_FIREBIRD',
        () => ip,
        'DBSYSTEMVALUES_FIRSTSQL',
        () => iu,
        'DBSYSTEMVALUES_GEODE',
        () => iG,
        'DBSYSTEMVALUES_H2',
        () => iO,
        'DBSYSTEMVALUES_HANADB',
        () => ia,
        'DBSYSTEMVALUES_HBASE',
        () => iP,
        'DBSYSTEMVALUES_HIVE',
        () => ie,
        'DBSYSTEMVALUES_HSQLDB',
        () => ir,
        'DBSYSTEMVALUES_INFORMIX',
        () => iE,
        'DBSYSTEMVALUES_INGRES',
        () => is,
        'DBSYSTEMVALUES_INSTANTDB',
        () => iT,
        'DBSYSTEMVALUES_INTERBASE',
        () => im,
        'DBSYSTEMVALUES_MARIADB',
        () => ig,
        'DBSYSTEMVALUES_MAXDB',
        () => io,
        'DBSYSTEMVALUES_MEMCACHED',
        () => i$,
        'DBSYSTEMVALUES_MONGODB',
        () => iM,
        'DBSYSTEMVALUES_MSSQL',
        () => r4,
        'DBSYSTEMVALUES_MYSQL',
        () => r9,
        'DBSYSTEMVALUES_NEO4J',
        () => ik,
        'DBSYSTEMVALUES_NETEZZA',
        () => ih,
        'DBSYSTEMVALUES_ORACLE',
        () => r3,
        'DBSYSTEMVALUES_OTHER_SQL',
        () => r5,
        'DBSYSTEMVALUES_PERVASIVE',
        () => iA,
        'DBSYSTEMVALUES_POINTBASE',
        () => iR,
        'DBSYSTEMVALUES_POSTGRESQL',
        () => r7,
        'DBSYSTEMVALUES_PROGRESS',
        () => ii,
        'DBSYSTEMVALUES_REDIS',
        () => iL,
        'DBSYSTEMVALUES_REDSHIFT',
        () => r8,
        'DBSYSTEMVALUES_SQLITE',
        () => iy,
        'DBSYSTEMVALUES_SYBASE',
        () => iI,
        'DBSYSTEMVALUES_TERADATA',
        () => ib,
        'DBSYSTEMVALUES_VERTICA',
        () => iN,
        'DB_SYSTEM_NAME_VALUE_MARIADB',
        () => dl.DB_SYSTEM_NAME_VALUE_MARIADB,
        'DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER',
        () => dl.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER,
        'DB_SYSTEM_NAME_VALUE_MYSQL',
        () => dl.DB_SYSTEM_NAME_VALUE_MYSQL,
        'DB_SYSTEM_NAME_VALUE_POSTGRESQL',
        () => dl.DB_SYSTEM_NAME_VALUE_POSTGRESQL,
        'DOTNET_GC_HEAP_GENERATION_VALUE_GEN0',
        () => dl.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0,
        'DOTNET_GC_HEAP_GENERATION_VALUE_GEN1',
        () => dl.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1,
        'DOTNET_GC_HEAP_GENERATION_VALUE_GEN2',
        () => dl.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2,
        'DOTNET_GC_HEAP_GENERATION_VALUE_LOH',
        () => dl.DOTNET_GC_HEAP_GENERATION_VALUE_LOH,
        'DOTNET_GC_HEAP_GENERATION_VALUE_POH',
        () => dl.DOTNET_GC_HEAP_GENERATION_VALUE_POH,
        'DbCassandraConsistencyLevelValues',
        () => i6,
        'DbSystemValues',
        () => iH,
        'ERROR_TYPE_VALUE_OTHER',
        () => dl.ERROR_TYPE_VALUE_OTHER,
        'EVENT_EXCEPTION',
        () => d6,
        'FAASDOCUMENTOPERATIONVALUES_DELETE',
        () => oS,
        'FAASDOCUMENTOPERATIONVALUES_EDIT',
        () => o_,
        'FAASDOCUMENTOPERATIONVALUES_INSERT',
        () => op,
        'FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD',
        () => og,
        'FAASINVOKEDPROVIDERVALUES_AWS',
        () => of,
        'FAASINVOKEDPROVIDERVALUES_AZURE',
        () => oh,
        'FAASINVOKEDPROVIDERVALUES_GCP',
        () => oA,
        'FAASTRIGGERVALUES_DATASOURCE',
        () => or,
        'FAASTRIGGERVALUES_HTTP',
        () => oi,
        'FAASTRIGGERVALUES_OTHER',
        () => os,
        'FAASTRIGGERVALUES_PUBSUB',
        () => oo,
        'FAASTRIGGERVALUES_TIMER',
        () => oa,
        'FaasDocumentOperationValues',
        () => oE,
        'FaasInvokedProviderValues',
        () => oR,
        'FaasTriggerValues',
        () => ou,
        'HOSTARCHVALUES_AMD64',
        () => cI,
        'HOSTARCHVALUES_ARM32',
        () => cb,
        'HOSTARCHVALUES_ARM64',
        () => cN,
        'HOSTARCHVALUES_IA64',
        () => cO,
        'HOSTARCHVALUES_PPC32',
        () => cv,
        'HOSTARCHVALUES_PPC64',
        () => cC,
        'HOSTARCHVALUES_X86',
        () => cP,
        'HTTPFLAVORVALUES_HTTP_1_0',
        () => aN,
        'HTTPFLAVORVALUES_HTTP_1_1',
        () => aO,
        'HTTPFLAVORVALUES_HTTP_2_0',
        () => av,
        'HTTPFLAVORVALUES_QUIC',
        () => aP,
        'HTTPFLAVORVALUES_SPDY',
        () => aC,
        'HTTP_REQUEST_METHOD_VALUE_CONNECT',
        () => dl.HTTP_REQUEST_METHOD_VALUE_CONNECT,
        'HTTP_REQUEST_METHOD_VALUE_DELETE',
        () => dl.HTTP_REQUEST_METHOD_VALUE_DELETE,
        'HTTP_REQUEST_METHOD_VALUE_GET',
        () => dl.HTTP_REQUEST_METHOD_VALUE_GET,
        'HTTP_REQUEST_METHOD_VALUE_HEAD',
        () => dl.HTTP_REQUEST_METHOD_VALUE_HEAD,
        'HTTP_REQUEST_METHOD_VALUE_OPTIONS',
        () => dl.HTTP_REQUEST_METHOD_VALUE_OPTIONS,
        'HTTP_REQUEST_METHOD_VALUE_OTHER',
        () => dl.HTTP_REQUEST_METHOD_VALUE_OTHER,
        'HTTP_REQUEST_METHOD_VALUE_PATCH',
        () => dl.HTTP_REQUEST_METHOD_VALUE_PATCH,
        'HTTP_REQUEST_METHOD_VALUE_POST',
        () => dl.HTTP_REQUEST_METHOD_VALUE_POST,
        'HTTP_REQUEST_METHOD_VALUE_PUT',
        () => dl.HTTP_REQUEST_METHOD_VALUE_PUT,
        'HTTP_REQUEST_METHOD_VALUE_TRACE',
        () => dl.HTTP_REQUEST_METHOD_VALUE_TRACE,
        'HostArchValues',
        () => cM,
        'HttpFlavorValues',
        () => aM,
        'JVM_MEMORY_TYPE_VALUE_HEAP',
        () => dl.JVM_MEMORY_TYPE_VALUE_HEAP,
        'JVM_MEMORY_TYPE_VALUE_NON_HEAP',
        () => dl.JVM_MEMORY_TYPE_VALUE_NON_HEAP,
        'JVM_THREAD_STATE_VALUE_BLOCKED',
        () => dl.JVM_THREAD_STATE_VALUE_BLOCKED,
        'JVM_THREAD_STATE_VALUE_NEW',
        () => dl.JVM_THREAD_STATE_VALUE_NEW,
        'JVM_THREAD_STATE_VALUE_RUNNABLE',
        () => dl.JVM_THREAD_STATE_VALUE_RUNNABLE,
        'JVM_THREAD_STATE_VALUE_TERMINATED',
        () => dl.JVM_THREAD_STATE_VALUE_TERMINATED,
        'JVM_THREAD_STATE_VALUE_TIMED_WAITING',
        () => dl.JVM_THREAD_STATE_VALUE_TIMED_WAITING,
        'JVM_THREAD_STATE_VALUE_WAITING',
        () => dl.JVM_THREAD_STATE_VALUE_WAITING,
        'MESSAGETYPEVALUES_RECEIVED',
        () => a8,
        'MESSAGETYPEVALUES_SENT',
        () => a7,
        'MESSAGINGDESTINATIONKINDVALUES_QUEUE',
        () => aD,
        'MESSAGINGDESTINATIONKINDVALUES_TOPIC',
        () => ax,
        'MESSAGINGOPERATIONVALUES_PROCESS',
        () => a$,
        'MESSAGINGOPERATIONVALUES_RECEIVE',
        () => aV,
        'METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS',
        () => dc,
        'METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES',
        () => dd,
        'METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS',
        () => dp,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS',
        () => dE,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION',
        () => dS,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE',
        () => d_,
        'METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS',
        () => dT,
        'METRIC_DB_CLIENT_OPERATION_DURATION',
        () => dm,
        'METRIC_DOTNET_ASSEMBLY_COUNT',
        () => dg,
        'METRIC_DOTNET_EXCEPTIONS',
        () => df,
        'METRIC_DOTNET_GC_COLLECTIONS',
        () => dh,
        'METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED',
        () => dA,
        'METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE',
        () => dR,
        'METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE',
        () => dy,
        'METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE',
        () => dI,
        'METRIC_DOTNET_GC_PAUSE_TIME',
        () => db,
        'METRIC_DOTNET_JIT_COMPILATION_TIME',
        () => dN,
        'METRIC_DOTNET_JIT_COMPILED_IL_SIZE',
        () => dO,
        'METRIC_DOTNET_JIT_COMPILED_METHODS',
        () => dv,
        'METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS',
        () => dC,
        'METRIC_DOTNET_PROCESS_CPU_COUNT',
        () => dP,
        'METRIC_DOTNET_PROCESS_CPU_TIME',
        () => dM,
        'METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET',
        () => dL,
        'METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH',
        () => dU,
        'METRIC_DOTNET_THREAD_POOL_THREAD_COUNT',
        () => dD,
        'METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT',
        () => dx,
        'METRIC_DOTNET_TIMER_COUNT',
        () => dw,
        'METRIC_HTTP_CLIENT_REQUEST_DURATION',
        () => dk,
        'METRIC_HTTP_SERVER_REQUEST_DURATION',
        () => dG,
        'METRIC_JVM_CLASS_COUNT',
        () => dV,
        'METRIC_JVM_CLASS_LOADED',
        () => d$,
        'METRIC_JVM_CLASS_UNLOADED',
        () => dB,
        'METRIC_JVM_CPU_COUNT',
        () => dH,
        'METRIC_JVM_CPU_RECENT_UTILIZATION',
        () => dj,
        'METRIC_JVM_CPU_TIME',
        () => dF,
        'METRIC_JVM_GC_DURATION',
        () => dZ,
        'METRIC_JVM_MEMORY_COMMITTED',
        () => dY,
        'METRIC_JVM_MEMORY_LIMIT',
        () => dW,
        'METRIC_JVM_MEMORY_USED',
        () => dK,
        'METRIC_JVM_MEMORY_USED_AFTER_LAST_GC',
        () => dz,
        'METRIC_JVM_THREAD_COUNT',
        () => dX,
        'METRIC_KESTREL_ACTIVE_CONNECTIONS',
        () => dJ,
        'METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES',
        () => dQ,
        'METRIC_KESTREL_CONNECTION_DURATION',
        () => dq,
        'METRIC_KESTREL_QUEUED_CONNECTIONS',
        () => d0,
        'METRIC_KESTREL_QUEUED_REQUESTS',
        () => d1,
        'METRIC_KESTREL_REJECTED_CONNECTIONS',
        () => d2,
        'METRIC_KESTREL_TLS_HANDSHAKE_DURATION',
        () => d5,
        'METRIC_KESTREL_UPGRADED_CONNECTIONS',
        () => d4,
        'METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS',
        () => d9,
        'METRIC_SIGNALR_SERVER_CONNECTION_DURATION',
        () => d3,
        'MessageTypeValues',
        () => se,
        'MessagingDestinationKindValues',
        () => aw,
        'MessagingOperationValues',
        () => aB,
        'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA',
        () => ao,
        'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT',
        () => au,
        'NETHOSTCONNECTIONSUBTYPEVALUES_EDGE',
        () => ar,
        'NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD',
        () => aE,
        'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0',
        () => aa,
        'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A',
        () => as,
        'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B',
        () => a_,
        'NETHOSTCONNECTIONSUBTYPEVALUES_GPRS',
        () => an,
        'NETHOSTCONNECTIONSUBTYPEVALUES_GSM',
        () => am,
        'NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA',
        () => al,
        'NETHOSTCONNECTIONSUBTYPEVALUES_HSPA',
        () => ad,
        'NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP',
        () => aT,
        'NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA',
        () => ac,
        'NETHOSTCONNECTIONSUBTYPEVALUES_IDEN',
        () => ap,
        'NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN',
        () => af,
        'NETHOSTCONNECTIONSUBTYPEVALUES_LTE',
        () => aS,
        'NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA',
        () => aR,
        'NETHOSTCONNECTIONSUBTYPEVALUES_NR',
        () => ah,
        'NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA',
        () => aA,
        'NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA',
        () => ag,
        'NETHOSTCONNECTIONSUBTYPEVALUES_UMTS',
        () => ai,
        'NETHOSTCONNECTIONTYPEVALUES_CELL',
        () => oF,
        'NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE',
        () => oZ,
        'NETHOSTCONNECTIONTYPEVALUES_UNKNOWN',
        () => oY,
        'NETHOSTCONNECTIONTYPEVALUES_WIFI',
        () => oH,
        'NETHOSTCONNECTIONTYPEVALUES_WIRED',
        () => oj,
        'NETTRANSPORTVALUES_INPROC',
        () => oD,
        'NETTRANSPORTVALUES_IP',
        () => oM,
        'NETTRANSPORTVALUES_IP_TCP',
        () => oC,
        'NETTRANSPORTVALUES_IP_UDP',
        () => oP,
        'NETTRANSPORTVALUES_OTHER',
        () => ox,
        'NETTRANSPORTVALUES_PIPE',
        () => oU,
        'NETTRANSPORTVALUES_UNIX',
        () => oL,
        'NETWORK_TRANSPORT_VALUE_PIPE',
        () => dl.NETWORK_TRANSPORT_VALUE_PIPE,
        'NETWORK_TRANSPORT_VALUE_QUIC',
        () => dl.NETWORK_TRANSPORT_VALUE_QUIC,
        'NETWORK_TRANSPORT_VALUE_TCP',
        () => dl.NETWORK_TRANSPORT_VALUE_TCP,
        'NETWORK_TRANSPORT_VALUE_UDP',
        () => dl.NETWORK_TRANSPORT_VALUE_UDP,
        'NETWORK_TRANSPORT_VALUE_UNIX',
        () => dl.NETWORK_TRANSPORT_VALUE_UNIX,
        'NETWORK_TYPE_VALUE_IPV4',
        () => dl.NETWORK_TYPE_VALUE_IPV4,
        'NETWORK_TYPE_VALUE_IPV6',
        () => dl.NETWORK_TYPE_VALUE_IPV6,
        'NetHostConnectionSubtypeValues',
        () => ay,
        'NetHostConnectionTypeValues',
        () => oW,
        'NetTransportValues',
        () => ow,
        'OSTYPEVALUES_AIX',
        () => cX,
        'OSTYPEVALUES_DARWIN',
        () => cF,
        'OSTYPEVALUES_DRAGONFLYBSD',
        () => cK,
        'OSTYPEVALUES_FREEBSD',
        () => cZ,
        'OSTYPEVALUES_HPUX',
        () => cz,
        'OSTYPEVALUES_LINUX',
        () => cj,
        'OSTYPEVALUES_NETBSD',
        () => cY,
        'OSTYPEVALUES_OPENBSD',
        () => cW,
        'OSTYPEVALUES_SOLARIS',
        () => cJ,
        'OSTYPEVALUES_WINDOWS',
        () => cH,
        'OSTYPEVALUES_Z_OS',
        () => cQ,
        'OTEL_STATUS_CODE_VALUE_ERROR',
        () => dl.OTEL_STATUS_CODE_VALUE_ERROR,
        'OTEL_STATUS_CODE_VALUE_OK',
        () => dl.OTEL_STATUS_CODE_VALUE_OK,
        'OsTypeValues',
        () => cq,
        'RPCGRPCSTATUSCODEVALUES_ABORTED',
        () => aQ,
        'RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS',
        () => aK,
        'RPCGRPCSTATUSCODEVALUES_CANCELLED',
        () => aj,
        'RPCGRPCSTATUSCODEVALUES_DATA_LOSS',
        () => a5,
        'RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED',
        () => aY,
        'RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION',
        () => aJ,
        'RPCGRPCSTATUSCODEVALUES_INTERNAL',
        () => a1,
        'RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT',
        () => aZ,
        'RPCGRPCSTATUSCODEVALUES_NOT_FOUND',
        () => aW,
        'RPCGRPCSTATUSCODEVALUES_OK',
        () => aH,
        'RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE',
        () => aq,
        'RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED',
        () => az,
        'RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED',
        () => aX,
        'RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED',
        () => a4,
        'RPCGRPCSTATUSCODEVALUES_UNAVAILABLE',
        () => a2,
        'RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED',
        () => a0,
        'RPCGRPCSTATUSCODEVALUES_UNKNOWN',
        () => aF,
        'RpcGrpcStatusCodeValues',
        () => a9,
        'SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET',
        () => nM,
        'SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS',
        () => nj,
        'SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ',
        () => nv,
        'SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY',
        () => nI,
        'SEMATTRS_AWS_DYNAMODB_COUNT',
        () => nB,
        'SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE',
        () => nw,
        'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES',
        () => nD,
        'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES',
        () => nF,
        'SEMATTRS_AWS_DYNAMODB_INDEX_NAME',
        () => nL,
        'SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS',
        () => nb,
        'SEMATTRS_AWS_DYNAMODB_LIMIT',
        () => nP,
        'SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES',
        () => nx,
        'SEMATTRS_AWS_DYNAMODB_PROJECTION',
        () => nC,
        'SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY',
        () => nN,
        'SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY',
        () => nO,
        'SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT',
        () => nH,
        'SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD',
        () => nG,
        'SEMATTRS_AWS_DYNAMODB_SEGMENT',
        () => nV,
        'SEMATTRS_AWS_DYNAMODB_SELECT',
        () => nU,
        'SEMATTRS_AWS_DYNAMODB_TABLE_COUNT',
        () => nk,
        'SEMATTRS_AWS_DYNAMODB_TABLE_NAMES',
        () => ny,
        'SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS',
        () => n$,
        'SEMATTRS_AWS_LAMBDA_INVOKED_ARN',
        () => tp,
        'SEMATTRS_CODE_FILEPATH',
        () => na,
        'SEMATTRS_CODE_FUNCTION',
        () => ni,
        'SEMATTRS_CODE_LINENO',
        () => ns,
        'SEMATTRS_CODE_NAMESPACE',
        () => no,
        'SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL',
        () => ty,
        'SEMATTRS_DB_CASSANDRA_COORDINATOR_DC',
        () => tv,
        'SEMATTRS_DB_CASSANDRA_COORDINATOR_ID',
        () => tO,
        'SEMATTRS_DB_CASSANDRA_IDEMPOTENCE',
        () => tb,
        'SEMATTRS_DB_CASSANDRA_KEYSPACE',
        () => tA,
        'SEMATTRS_DB_CASSANDRA_PAGE_SIZE',
        () => tR,
        'SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT',
        () => tN,
        'SEMATTRS_DB_CASSANDRA_TABLE',
        () => tI,
        'SEMATTRS_DB_CONNECTION_STRING',
        () => tS,
        'SEMATTRS_DB_HBASE_NAMESPACE',
        () => tC,
        'SEMATTRS_DB_JDBC_DRIVER_CLASSNAME',
        () => tT,
        'SEMATTRS_DB_MONGODB_COLLECTION',
        () => tM,
        'SEMATTRS_DB_MSSQL_INSTANCE_NAME',
        () => th,
        'SEMATTRS_DB_NAME',
        () => tm,
        'SEMATTRS_DB_OPERATION',
        () => tf,
        'SEMATTRS_DB_REDIS_DATABASE_INDEX',
        () => tP,
        'SEMATTRS_DB_SQL_TABLE',
        () => tL,
        'SEMATTRS_DB_STATEMENT',
        () => tg,
        'SEMATTRS_DB_SYSTEM',
        () => t_,
        'SEMATTRS_DB_USER',
        () => tE,
        'SEMATTRS_ENDUSER_ID',
        () => t8,
        'SEMATTRS_ENDUSER_ROLE',
        () => ne,
        'SEMATTRS_ENDUSER_SCOPE',
        () => nt,
        'SEMATTRS_EXCEPTION_ESCAPED',
        () => tw,
        'SEMATTRS_EXCEPTION_MESSAGE',
        () => tD,
        'SEMATTRS_EXCEPTION_STACKTRACE',
        () => tx,
        'SEMATTRS_EXCEPTION_TYPE',
        () => tU,
        'SEMATTRS_FAAS_COLDSTART',
        () => tZ,
        'SEMATTRS_FAAS_CRON',
        () => tF,
        'SEMATTRS_FAAS_DOCUMENT_COLLECTION',
        () => tV,
        'SEMATTRS_FAAS_DOCUMENT_NAME',
        () => tH,
        'SEMATTRS_FAAS_DOCUMENT_OPERATION',
        () => t$,
        'SEMATTRS_FAAS_DOCUMENT_TIME',
        () => tB,
        'SEMATTRS_FAAS_EXECUTION',
        () => tG,
        'SEMATTRS_FAAS_INVOKED_NAME',
        () => tY,
        'SEMATTRS_FAAS_INVOKED_PROVIDER',
        () => tW,
        'SEMATTRS_FAAS_INVOKED_REGION',
        () => tK,
        'SEMATTRS_FAAS_TIME',
        () => tj,
        'SEMATTRS_FAAS_TRIGGER',
        () => tk,
        'SEMATTRS_HTTP_CLIENT_IP',
        () => nR,
        'SEMATTRS_HTTP_FLAVOR',
        () => nS,
        'SEMATTRS_HTTP_HOST',
        () => nd,
        'SEMATTRS_HTTP_METHOD',
        () => nu,
        'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH',
        () => nT,
        'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED',
        () => nm,
        'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH',
        () => ng,
        'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED',
        () => nf,
        'SEMATTRS_HTTP_ROUTE',
        () => nA,
        'SEMATTRS_HTTP_SCHEME',
        () => np,
        'SEMATTRS_HTTP_SERVER_NAME',
        () => nh,
        'SEMATTRS_HTTP_STATUS_CODE',
        () => n_,
        'SEMATTRS_HTTP_TARGET',
        () => nc,
        'SEMATTRS_HTTP_URL',
        () => nl,
        'SEMATTRS_HTTP_USER_AGENT',
        () => nE,
        'SEMATTRS_MESSAGE_COMPRESSED_SIZE',
        () => rc,
        'SEMATTRS_MESSAGE_ID',
        () => rl,
        'SEMATTRS_MESSAGE_TYPE',
        () => ru,
        'SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE',
        () => rd,
        'SEMATTRS_MESSAGING_CONSUMER_ID',
        () => n5,
        'SEMATTRS_MESSAGING_CONVERSATION_ID',
        () => nq,
        'SEMATTRS_MESSAGING_DESTINATION',
        () => nY,
        'SEMATTRS_MESSAGING_DESTINATION_KIND',
        () => nW,
        'SEMATTRS_MESSAGING_KAFKA_CLIENT_ID',
        () => n6,
        'SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP',
        () => n3,
        'SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY',
        () => n9,
        'SEMATTRS_MESSAGING_KAFKA_PARTITION',
        () => n7,
        'SEMATTRS_MESSAGING_KAFKA_TOMBSTONE',
        () => n8,
        'SEMATTRS_MESSAGING_MESSAGE_ID',
        () => nQ,
        'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES',
        () => n1,
        'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES',
        () => n0,
        'SEMATTRS_MESSAGING_OPERATION',
        () => n2,
        'SEMATTRS_MESSAGING_PROTOCOL',
        () => nz,
        'SEMATTRS_MESSAGING_PROTOCOL_VERSION',
        () => nX,
        'SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY',
        () => n4,
        'SEMATTRS_MESSAGING_SYSTEM',
        () => nZ,
        'SEMATTRS_MESSAGING_TEMP_DESTINATION',
        () => nK,
        'SEMATTRS_MESSAGING_URL',
        () => nJ,
        'SEMATTRS_NET_HOST_CARRIER_ICC',
        () => t6,
        'SEMATTRS_NET_HOST_CARRIER_MCC',
        () => t9,
        'SEMATTRS_NET_HOST_CARRIER_MNC',
        () => t3,
        'SEMATTRS_NET_HOST_CARRIER_NAME',
        () => t4,
        'SEMATTRS_NET_HOST_CONNECTION_SUBTYPE',
        () => t5,
        'SEMATTRS_NET_HOST_CONNECTION_TYPE',
        () => t2,
        'SEMATTRS_NET_HOST_IP',
        () => tq,
        'SEMATTRS_NET_HOST_NAME',
        () => t1,
        'SEMATTRS_NET_HOST_PORT',
        () => t0,
        'SEMATTRS_NET_PEER_IP',
        () => tX,
        'SEMATTRS_NET_PEER_NAME',
        () => tQ,
        'SEMATTRS_NET_PEER_PORT',
        () => tJ,
        'SEMATTRS_NET_TRANSPORT',
        () => tz,
        'SEMATTRS_PEER_SERVICE',
        () => t7,
        'SEMATTRS_RPC_GRPC_STATUS_CODE',
        () => rr,
        'SEMATTRS_RPC_JSONRPC_ERROR_CODE',
        () => ra,
        'SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE',
        () => rs,
        'SEMATTRS_RPC_JSONRPC_REQUEST_ID',
        () => ro,
        'SEMATTRS_RPC_JSONRPC_VERSION',
        () => ri,
        'SEMATTRS_RPC_METHOD',
        () => rn,
        'SEMATTRS_RPC_SERVICE',
        () => rt,
        'SEMATTRS_RPC_SYSTEM',
        () => re,
        'SEMATTRS_THREAD_ID',
        () => nn,
        'SEMATTRS_THREAD_NAME',
        () => nr,
        'SEMRESATTRS_AWS_ECS_CLUSTER_ARN',
        () => uI,
        'SEMRESATTRS_AWS_ECS_CONTAINER_ARN',
        () => uy,
        'SEMRESATTRS_AWS_ECS_LAUNCHTYPE',
        () => ub,
        'SEMRESATTRS_AWS_ECS_TASK_ARN',
        () => uN,
        'SEMRESATTRS_AWS_ECS_TASK_FAMILY',
        () => uO,
        'SEMRESATTRS_AWS_ECS_TASK_REVISION',
        () => uv,
        'SEMRESATTRS_AWS_EKS_CLUSTER_ARN',
        () => uC,
        'SEMRESATTRS_AWS_LOG_GROUP_ARNS',
        () => uM,
        'SEMRESATTRS_AWS_LOG_GROUP_NAMES',
        () => uP,
        'SEMRESATTRS_AWS_LOG_STREAM_ARNS',
        () => uU,
        'SEMRESATTRS_AWS_LOG_STREAM_NAMES',
        () => uL,
        'SEMRESATTRS_CLOUD_ACCOUNT_ID',
        () => uf,
        'SEMRESATTRS_CLOUD_AVAILABILITY_ZONE',
        () => uA,
        'SEMRESATTRS_CLOUD_PLATFORM',
        () => uR,
        'SEMRESATTRS_CLOUD_PROVIDER',
        () => ug,
        'SEMRESATTRS_CLOUD_REGION',
        () => uh,
        'SEMRESATTRS_CONTAINER_ID',
        () => ux,
        'SEMRESATTRS_CONTAINER_IMAGE_NAME',
        () => uk,
        'SEMRESATTRS_CONTAINER_IMAGE_TAG',
        () => uG,
        'SEMRESATTRS_CONTAINER_NAME',
        () => uD,
        'SEMRESATTRS_CONTAINER_RUNTIME',
        () => uw,
        'SEMRESATTRS_DEPLOYMENT_ENVIRONMENT',
        () => uV,
        'SEMRESATTRS_DEVICE_ID',
        () => u$,
        'SEMRESATTRS_DEVICE_MODEL_IDENTIFIER',
        () => uB,
        'SEMRESATTRS_DEVICE_MODEL_NAME',
        () => uH,
        'SEMRESATTRS_FAAS_ID',
        () => uF,
        'SEMRESATTRS_FAAS_INSTANCE',
        () => uY,
        'SEMRESATTRS_FAAS_MAX_MEMORY',
        () => uW,
        'SEMRESATTRS_FAAS_NAME',
        () => uj,
        'SEMRESATTRS_FAAS_VERSION',
        () => uZ,
        'SEMRESATTRS_HOST_ARCH',
        () => uJ,
        'SEMRESATTRS_HOST_ID',
        () => uK,
        'SEMRESATTRS_HOST_IMAGE_ID',
        () => uq,
        'SEMRESATTRS_HOST_IMAGE_NAME',
        () => uQ,
        'SEMRESATTRS_HOST_IMAGE_VERSION',
        () => u0,
        'SEMRESATTRS_HOST_NAME',
        () => uz,
        'SEMRESATTRS_HOST_TYPE',
        () => uX,
        'SEMRESATTRS_K8S_CLUSTER_NAME',
        () => u1,
        'SEMRESATTRS_K8S_CONTAINER_NAME',
        () => u6,
        'SEMRESATTRS_K8S_CRONJOB_NAME',
        () => ll,
        'SEMRESATTRS_K8S_CRONJOB_UID',
        () => lu,
        'SEMRESATTRS_K8S_DAEMONSET_NAME',
        () => lo,
        'SEMRESATTRS_K8S_DAEMONSET_UID',
        () => li,
        'SEMRESATTRS_K8S_DEPLOYMENT_NAME',
        () => lt,
        'SEMRESATTRS_K8S_DEPLOYMENT_UID',
        () => le,
        'SEMRESATTRS_K8S_JOB_NAME',
        () => ls,
        'SEMRESATTRS_K8S_JOB_UID',
        () => la,
        'SEMRESATTRS_K8S_NAMESPACE_NAME',
        () => u4,
        'SEMRESATTRS_K8S_NODE_NAME',
        () => u2,
        'SEMRESATTRS_K8S_NODE_UID',
        () => u5,
        'SEMRESATTRS_K8S_POD_NAME',
        () => u3,
        'SEMRESATTRS_K8S_POD_UID',
        () => u9,
        'SEMRESATTRS_K8S_REPLICASET_NAME',
        () => u8,
        'SEMRESATTRS_K8S_REPLICASET_UID',
        () => u7,
        'SEMRESATTRS_K8S_STATEFULSET_NAME',
        () => lr,
        'SEMRESATTRS_K8S_STATEFULSET_UID',
        () => ln,
        'SEMRESATTRS_OS_DESCRIPTION',
        () => ld,
        'SEMRESATTRS_OS_NAME',
        () => lp,
        'SEMRESATTRS_OS_TYPE',
        () => lc,
        'SEMRESATTRS_OS_VERSION',
        () => l_,
        'SEMRESATTRS_PROCESS_COMMAND',
        () => lm,
        'SEMRESATTRS_PROCESS_COMMAND_ARGS',
        () => lf,
        'SEMRESATTRS_PROCESS_COMMAND_LINE',
        () => lg,
        'SEMRESATTRS_PROCESS_EXECUTABLE_NAME',
        () => lE,
        'SEMRESATTRS_PROCESS_EXECUTABLE_PATH',
        () => lT,
        'SEMRESATTRS_PROCESS_OWNER',
        () => lh,
        'SEMRESATTRS_PROCESS_PID',
        () => lS,
        'SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION',
        () => ly,
        'SEMRESATTRS_PROCESS_RUNTIME_NAME',
        () => lA,
        'SEMRESATTRS_PROCESS_RUNTIME_VERSION',
        () => lR,
        'SEMRESATTRS_SERVICE_INSTANCE_ID',
        () => lN,
        'SEMRESATTRS_SERVICE_NAME',
        () => lI,
        'SEMRESATTRS_SERVICE_NAMESPACE',
        () => lb,
        'SEMRESATTRS_SERVICE_VERSION',
        () => lO,
        'SEMRESATTRS_TELEMETRY_AUTO_VERSION',
        () => lM,
        'SEMRESATTRS_TELEMETRY_SDK_LANGUAGE',
        () => lC,
        'SEMRESATTRS_TELEMETRY_SDK_NAME',
        () => lv,
        'SEMRESATTRS_TELEMETRY_SDK_VERSION',
        () => lP,
        'SEMRESATTRS_WEBENGINE_DESCRIPTION',
        () => lD,
        'SEMRESATTRS_WEBENGINE_NAME',
        () => lL,
        'SEMRESATTRS_WEBENGINE_VERSION',
        () => lU,
        'SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN',
        () => dl.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
        'SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE',
        () => dl.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
        'SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT',
        () => dl.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
        'SIGNALR_TRANSPORT_VALUE_LONG_POLLING',
        () => dl.SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
        'SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS',
        () => dl.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
        'SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS',
        () => dl.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
        'SemanticAttributes',
        () => rp,
        'SemanticResourceAttributes',
        () => lx,
        'TELEMETRYSDKLANGUAGEVALUES_CPP',
        () => c6,
        'TELEMETRYSDKLANGUAGEVALUES_DOTNET',
        () => c7,
        'TELEMETRYSDKLANGUAGEVALUES_ERLANG',
        () => c8,
        'TELEMETRYSDKLANGUAGEVALUES_GO',
        () => de,
        'TELEMETRYSDKLANGUAGEVALUES_JAVA',
        () => dt,
        'TELEMETRYSDKLANGUAGEVALUES_NODEJS',
        () => dn,
        'TELEMETRYSDKLANGUAGEVALUES_PHP',
        () => dr,
        'TELEMETRYSDKLANGUAGEVALUES_PYTHON',
        () => di,
        'TELEMETRYSDKLANGUAGEVALUES_RUBY',
        () => da,
        'TELEMETRYSDKLANGUAGEVALUES_WEBJS',
        () => ds,
        'TELEMETRY_SDK_LANGUAGE_VALUE_CPP',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
        'TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
        'TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
        'TELEMETRY_SDK_LANGUAGE_VALUE_GO',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_GO,
        'TELEMETRY_SDK_LANGUAGE_VALUE_JAVA',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
        'TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
        'TELEMETRY_SDK_LANGUAGE_VALUE_PHP',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
        'TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
        'TELEMETRY_SDK_LANGUAGE_VALUE_RUBY',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
        'TELEMETRY_SDK_LANGUAGE_VALUE_RUST',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
        'TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
        'TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS',
        () => dl.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
        'TelemetrySdkLanguageValues',
        () => du,
      ],
      81964
    ),
      e.s([], 39424),
      e.i(39424),
      e.s(
        [
          'DBCASSANDRACONSISTENCYLEVELVALUES_ALL',
          () => iX,
          'DBCASSANDRACONSISTENCYLEVELVALUES_ANY',
          () => i4,
          'DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM',
          () => iJ,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE',
          () => i5,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM',
          () => iq,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL',
          () => i3,
          'DBCASSANDRACONSISTENCYLEVELVALUES_ONE',
          () => i0,
          'DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM',
          () => iQ,
          'DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL',
          () => i9,
          'DBCASSANDRACONSISTENCYLEVELVALUES_THREE',
          () => i2,
          'DBCASSANDRACONSISTENCYLEVELVALUES_TWO',
          () => i1,
          'DBSYSTEMVALUES_ADABAS',
          () => id,
          'DBSYSTEMVALUES_CACHE',
          () => ic,
          'DBSYSTEMVALUES_CASSANDRA',
          () => iC,
          'DBSYSTEMVALUES_CLOUDSCAPE',
          () => it,
          'DBSYSTEMVALUES_COCKROACHDB',
          () => iB,
          'DBSYSTEMVALUES_COLDFUSION',
          () => iv,
          'DBSYSTEMVALUES_COSMOSDB',
          () => ix,
          'DBSYSTEMVALUES_COUCHBASE',
          () => iU,
          'DBSYSTEMVALUES_COUCHDB',
          () => iD,
          'DBSYSTEMVALUES_DB2',
          () => r6,
          'DBSYSTEMVALUES_DERBY',
          () => i_,
          'DBSYSTEMVALUES_DYNAMODB',
          () => iw,
          'DBSYSTEMVALUES_EDB',
          () => il,
          'DBSYSTEMVALUES_ELASTICSEARCH',
          () => iV,
          'DBSYSTEMVALUES_FILEMAKER',
          () => iS,
          'DBSYSTEMVALUES_FIREBIRD',
          () => ip,
          'DBSYSTEMVALUES_FIRSTSQL',
          () => iu,
          'DBSYSTEMVALUES_GEODE',
          () => iG,
          'DBSYSTEMVALUES_H2',
          () => iO,
          'DBSYSTEMVALUES_HANADB',
          () => ia,
          'DBSYSTEMVALUES_HBASE',
          () => iP,
          'DBSYSTEMVALUES_HIVE',
          () => ie,
          'DBSYSTEMVALUES_HSQLDB',
          () => ir,
          'DBSYSTEMVALUES_INFORMIX',
          () => iE,
          'DBSYSTEMVALUES_INGRES',
          () => is,
          'DBSYSTEMVALUES_INSTANTDB',
          () => iT,
          'DBSYSTEMVALUES_INTERBASE',
          () => im,
          'DBSYSTEMVALUES_MARIADB',
          () => ig,
          'DBSYSTEMVALUES_MAXDB',
          () => io,
          'DBSYSTEMVALUES_MEMCACHED',
          () => i$,
          'DBSYSTEMVALUES_MONGODB',
          () => iM,
          'DBSYSTEMVALUES_MSSQL',
          () => r4,
          'DBSYSTEMVALUES_MYSQL',
          () => r9,
          'DBSYSTEMVALUES_NEO4J',
          () => ik,
          'DBSYSTEMVALUES_NETEZZA',
          () => ih,
          'DBSYSTEMVALUES_ORACLE',
          () => r3,
          'DBSYSTEMVALUES_OTHER_SQL',
          () => r5,
          'DBSYSTEMVALUES_PERVASIVE',
          () => iA,
          'DBSYSTEMVALUES_POINTBASE',
          () => iR,
          'DBSYSTEMVALUES_POSTGRESQL',
          () => r7,
          'DBSYSTEMVALUES_PROGRESS',
          () => ii,
          'DBSYSTEMVALUES_REDIS',
          () => iL,
          'DBSYSTEMVALUES_REDSHIFT',
          () => r8,
          'DBSYSTEMVALUES_SQLITE',
          () => iy,
          'DBSYSTEMVALUES_SYBASE',
          () => iI,
          'DBSYSTEMVALUES_TERADATA',
          () => ib,
          'DBSYSTEMVALUES_VERTICA',
          () => iN,
          'DbCassandraConsistencyLevelValues',
          () => i6,
          'DbSystemValues',
          () => iH,
          'FAASDOCUMENTOPERATIONVALUES_DELETE',
          () => oS,
          'FAASDOCUMENTOPERATIONVALUES_EDIT',
          () => o_,
          'FAASDOCUMENTOPERATIONVALUES_INSERT',
          () => op,
          'FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD',
          () => og,
          'FAASINVOKEDPROVIDERVALUES_AWS',
          () => of,
          'FAASINVOKEDPROVIDERVALUES_AZURE',
          () => oh,
          'FAASINVOKEDPROVIDERVALUES_GCP',
          () => oA,
          'FAASTRIGGERVALUES_DATASOURCE',
          () => or,
          'FAASTRIGGERVALUES_HTTP',
          () => oi,
          'FAASTRIGGERVALUES_OTHER',
          () => os,
          'FAASTRIGGERVALUES_PUBSUB',
          () => oo,
          'FAASTRIGGERVALUES_TIMER',
          () => oa,
          'FaasDocumentOperationValues',
          () => oE,
          'FaasInvokedProviderValues',
          () => oR,
          'FaasTriggerValues',
          () => ou,
          'HTTPFLAVORVALUES_HTTP_1_0',
          () => aN,
          'HTTPFLAVORVALUES_HTTP_1_1',
          () => aO,
          'HTTPFLAVORVALUES_HTTP_2_0',
          () => av,
          'HTTPFLAVORVALUES_QUIC',
          () => aP,
          'HTTPFLAVORVALUES_SPDY',
          () => aC,
          'HttpFlavorValues',
          () => aM,
          'MESSAGETYPEVALUES_RECEIVED',
          () => a8,
          'MESSAGETYPEVALUES_SENT',
          () => a7,
          'MESSAGINGDESTINATIONKINDVALUES_QUEUE',
          () => aD,
          'MESSAGINGDESTINATIONKINDVALUES_TOPIC',
          () => ax,
          'MESSAGINGOPERATIONVALUES_PROCESS',
          () => a$,
          'MESSAGINGOPERATIONVALUES_RECEIVE',
          () => aV,
          'MessageTypeValues',
          () => se,
          'MessagingDestinationKindValues',
          () => aw,
          'MessagingOperationValues',
          () => aB,
          'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA',
          () => ao,
          'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT',
          () => au,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EDGE',
          () => ar,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD',
          () => aE,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0',
          () => aa,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A',
          () => as,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B',
          () => a_,
          'NETHOSTCONNECTIONSUBTYPEVALUES_GPRS',
          () => an,
          'NETHOSTCONNECTIONSUBTYPEVALUES_GSM',
          () => am,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA',
          () => al,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSPA',
          () => ad,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP',
          () => aT,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA',
          () => ac,
          'NETHOSTCONNECTIONSUBTYPEVALUES_IDEN',
          () => ap,
          'NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN',
          () => af,
          'NETHOSTCONNECTIONSUBTYPEVALUES_LTE',
          () => aS,
          'NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA',
          () => aR,
          'NETHOSTCONNECTIONSUBTYPEVALUES_NR',
          () => ah,
          'NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA',
          () => aA,
          'NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA',
          () => ag,
          'NETHOSTCONNECTIONSUBTYPEVALUES_UMTS',
          () => ai,
          'NETHOSTCONNECTIONTYPEVALUES_CELL',
          () => oF,
          'NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE',
          () => oZ,
          'NETHOSTCONNECTIONTYPEVALUES_UNKNOWN',
          () => oY,
          'NETHOSTCONNECTIONTYPEVALUES_WIFI',
          () => oH,
          'NETHOSTCONNECTIONTYPEVALUES_WIRED',
          () => oj,
          'NETTRANSPORTVALUES_INPROC',
          () => oD,
          'NETTRANSPORTVALUES_IP',
          () => oM,
          'NETTRANSPORTVALUES_IP_TCP',
          () => oC,
          'NETTRANSPORTVALUES_IP_UDP',
          () => oP,
          'NETTRANSPORTVALUES_OTHER',
          () => ox,
          'NETTRANSPORTVALUES_PIPE',
          () => oU,
          'NETTRANSPORTVALUES_UNIX',
          () => oL,
          'NetHostConnectionSubtypeValues',
          () => ay,
          'NetHostConnectionTypeValues',
          () => oW,
          'NetTransportValues',
          () => ow,
          'RPCGRPCSTATUSCODEVALUES_ABORTED',
          () => aQ,
          'RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS',
          () => aK,
          'RPCGRPCSTATUSCODEVALUES_CANCELLED',
          () => aj,
          'RPCGRPCSTATUSCODEVALUES_DATA_LOSS',
          () => a5,
          'RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED',
          () => aY,
          'RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION',
          () => aJ,
          'RPCGRPCSTATUSCODEVALUES_INTERNAL',
          () => a1,
          'RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT',
          () => aZ,
          'RPCGRPCSTATUSCODEVALUES_NOT_FOUND',
          () => aW,
          'RPCGRPCSTATUSCODEVALUES_OK',
          () => aH,
          'RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE',
          () => aq,
          'RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED',
          () => az,
          'RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED',
          () => aX,
          'RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED',
          () => a4,
          'RPCGRPCSTATUSCODEVALUES_UNAVAILABLE',
          () => a2,
          'RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED',
          () => a0,
          'RPCGRPCSTATUSCODEVALUES_UNKNOWN',
          () => aF,
          'RpcGrpcStatusCodeValues',
          () => a9,
          'SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET',
          () => nM,
          'SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS',
          () => nj,
          'SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ',
          () => nv,
          'SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY',
          () => nI,
          'SEMATTRS_AWS_DYNAMODB_COUNT',
          () => nB,
          'SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE',
          () => nw,
          'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES',
          () => nD,
          'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES',
          () => nF,
          'SEMATTRS_AWS_DYNAMODB_INDEX_NAME',
          () => nL,
          'SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS',
          () => nb,
          'SEMATTRS_AWS_DYNAMODB_LIMIT',
          () => nP,
          'SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES',
          () => nx,
          'SEMATTRS_AWS_DYNAMODB_PROJECTION',
          () => nC,
          'SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY',
          () => nN,
          'SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY',
          () => nO,
          'SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT',
          () => nH,
          'SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD',
          () => nG,
          'SEMATTRS_AWS_DYNAMODB_SEGMENT',
          () => nV,
          'SEMATTRS_AWS_DYNAMODB_SELECT',
          () => nU,
          'SEMATTRS_AWS_DYNAMODB_TABLE_COUNT',
          () => nk,
          'SEMATTRS_AWS_DYNAMODB_TABLE_NAMES',
          () => ny,
          'SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS',
          () => n$,
          'SEMATTRS_AWS_LAMBDA_INVOKED_ARN',
          () => tp,
          'SEMATTRS_CODE_FILEPATH',
          () => na,
          'SEMATTRS_CODE_FUNCTION',
          () => ni,
          'SEMATTRS_CODE_LINENO',
          () => ns,
          'SEMATTRS_CODE_NAMESPACE',
          () => no,
          'SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL',
          () => ty,
          'SEMATTRS_DB_CASSANDRA_COORDINATOR_DC',
          () => tv,
          'SEMATTRS_DB_CASSANDRA_COORDINATOR_ID',
          () => tO,
          'SEMATTRS_DB_CASSANDRA_IDEMPOTENCE',
          () => tb,
          'SEMATTRS_DB_CASSANDRA_KEYSPACE',
          () => tA,
          'SEMATTRS_DB_CASSANDRA_PAGE_SIZE',
          () => tR,
          'SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT',
          () => tN,
          'SEMATTRS_DB_CASSANDRA_TABLE',
          () => tI,
          'SEMATTRS_DB_CONNECTION_STRING',
          () => tS,
          'SEMATTRS_DB_HBASE_NAMESPACE',
          () => tC,
          'SEMATTRS_DB_JDBC_DRIVER_CLASSNAME',
          () => tT,
          'SEMATTRS_DB_MONGODB_COLLECTION',
          () => tM,
          'SEMATTRS_DB_MSSQL_INSTANCE_NAME',
          () => th,
          'SEMATTRS_DB_NAME',
          () => tm,
          'SEMATTRS_DB_OPERATION',
          () => tf,
          'SEMATTRS_DB_REDIS_DATABASE_INDEX',
          () => tP,
          'SEMATTRS_DB_SQL_TABLE',
          () => tL,
          'SEMATTRS_DB_STATEMENT',
          () => tg,
          'SEMATTRS_DB_SYSTEM',
          () => t_,
          'SEMATTRS_DB_USER',
          () => tE,
          'SEMATTRS_ENDUSER_ID',
          () => t8,
          'SEMATTRS_ENDUSER_ROLE',
          () => ne,
          'SEMATTRS_ENDUSER_SCOPE',
          () => nt,
          'SEMATTRS_EXCEPTION_ESCAPED',
          () => tw,
          'SEMATTRS_EXCEPTION_MESSAGE',
          () => tD,
          'SEMATTRS_EXCEPTION_STACKTRACE',
          () => tx,
          'SEMATTRS_EXCEPTION_TYPE',
          () => tU,
          'SEMATTRS_FAAS_COLDSTART',
          () => tZ,
          'SEMATTRS_FAAS_CRON',
          () => tF,
          'SEMATTRS_FAAS_DOCUMENT_COLLECTION',
          () => tV,
          'SEMATTRS_FAAS_DOCUMENT_NAME',
          () => tH,
          'SEMATTRS_FAAS_DOCUMENT_OPERATION',
          () => t$,
          'SEMATTRS_FAAS_DOCUMENT_TIME',
          () => tB,
          'SEMATTRS_FAAS_EXECUTION',
          () => tG,
          'SEMATTRS_FAAS_INVOKED_NAME',
          () => tY,
          'SEMATTRS_FAAS_INVOKED_PROVIDER',
          () => tW,
          'SEMATTRS_FAAS_INVOKED_REGION',
          () => tK,
          'SEMATTRS_FAAS_TIME',
          () => tj,
          'SEMATTRS_FAAS_TRIGGER',
          () => tk,
          'SEMATTRS_HTTP_CLIENT_IP',
          () => nR,
          'SEMATTRS_HTTP_FLAVOR',
          () => nS,
          'SEMATTRS_HTTP_HOST',
          () => nd,
          'SEMATTRS_HTTP_METHOD',
          () => nu,
          'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH',
          () => nT,
          'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED',
          () => nm,
          'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH',
          () => ng,
          'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED',
          () => nf,
          'SEMATTRS_HTTP_ROUTE',
          () => nA,
          'SEMATTRS_HTTP_SCHEME',
          () => np,
          'SEMATTRS_HTTP_SERVER_NAME',
          () => nh,
          'SEMATTRS_HTTP_STATUS_CODE',
          () => n_,
          'SEMATTRS_HTTP_TARGET',
          () => nc,
          'SEMATTRS_HTTP_URL',
          () => nl,
          'SEMATTRS_HTTP_USER_AGENT',
          () => nE,
          'SEMATTRS_MESSAGE_COMPRESSED_SIZE',
          () => rc,
          'SEMATTRS_MESSAGE_ID',
          () => rl,
          'SEMATTRS_MESSAGE_TYPE',
          () => ru,
          'SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE',
          () => rd,
          'SEMATTRS_MESSAGING_CONSUMER_ID',
          () => n5,
          'SEMATTRS_MESSAGING_CONVERSATION_ID',
          () => nq,
          'SEMATTRS_MESSAGING_DESTINATION',
          () => nY,
          'SEMATTRS_MESSAGING_DESTINATION_KIND',
          () => nW,
          'SEMATTRS_MESSAGING_KAFKA_CLIENT_ID',
          () => n6,
          'SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP',
          () => n3,
          'SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY',
          () => n9,
          'SEMATTRS_MESSAGING_KAFKA_PARTITION',
          () => n7,
          'SEMATTRS_MESSAGING_KAFKA_TOMBSTONE',
          () => n8,
          'SEMATTRS_MESSAGING_MESSAGE_ID',
          () => nQ,
          'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES',
          () => n1,
          'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES',
          () => n0,
          'SEMATTRS_MESSAGING_OPERATION',
          () => n2,
          'SEMATTRS_MESSAGING_PROTOCOL',
          () => nz,
          'SEMATTRS_MESSAGING_PROTOCOL_VERSION',
          () => nX,
          'SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY',
          () => n4,
          'SEMATTRS_MESSAGING_SYSTEM',
          () => nZ,
          'SEMATTRS_MESSAGING_TEMP_DESTINATION',
          () => nK,
          'SEMATTRS_MESSAGING_URL',
          () => nJ,
          'SEMATTRS_NET_HOST_CARRIER_ICC',
          () => t6,
          'SEMATTRS_NET_HOST_CARRIER_MCC',
          () => t9,
          'SEMATTRS_NET_HOST_CARRIER_MNC',
          () => t3,
          'SEMATTRS_NET_HOST_CARRIER_NAME',
          () => t4,
          'SEMATTRS_NET_HOST_CONNECTION_SUBTYPE',
          () => t5,
          'SEMATTRS_NET_HOST_CONNECTION_TYPE',
          () => t2,
          'SEMATTRS_NET_HOST_IP',
          () => tq,
          'SEMATTRS_NET_HOST_NAME',
          () => t1,
          'SEMATTRS_NET_HOST_PORT',
          () => t0,
          'SEMATTRS_NET_PEER_IP',
          () => tX,
          'SEMATTRS_NET_PEER_NAME',
          () => tQ,
          'SEMATTRS_NET_PEER_PORT',
          () => tJ,
          'SEMATTRS_NET_TRANSPORT',
          () => tz,
          'SEMATTRS_PEER_SERVICE',
          () => t7,
          'SEMATTRS_RPC_GRPC_STATUS_CODE',
          () => rr,
          'SEMATTRS_RPC_JSONRPC_ERROR_CODE',
          () => ra,
          'SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE',
          () => rs,
          'SEMATTRS_RPC_JSONRPC_REQUEST_ID',
          () => ro,
          'SEMATTRS_RPC_JSONRPC_VERSION',
          () => ri,
          'SEMATTRS_RPC_METHOD',
          () => rn,
          'SEMATTRS_RPC_SERVICE',
          () => rt,
          'SEMATTRS_RPC_SYSTEM',
          () => re,
          'SEMATTRS_THREAD_ID',
          () => nn,
          'SEMATTRS_THREAD_NAME',
          () => nr,
          'SemanticAttributes',
          () => rp,
        ],
        22671
      ),
      e.s([], 67833),
      e.i(67833),
      e.s(
        [
          'DBCASSANDRACONSISTENCYLEVELVALUES_ALL',
          () => iX,
          'DBCASSANDRACONSISTENCYLEVELVALUES_ANY',
          () => i4,
          'DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM',
          () => iJ,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE',
          () => i5,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM',
          () => iq,
          'DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL',
          () => i3,
          'DBCASSANDRACONSISTENCYLEVELVALUES_ONE',
          () => i0,
          'DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM',
          () => iQ,
          'DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL',
          () => i9,
          'DBCASSANDRACONSISTENCYLEVELVALUES_THREE',
          () => i2,
          'DBCASSANDRACONSISTENCYLEVELVALUES_TWO',
          () => i1,
          'DBSYSTEMVALUES_ADABAS',
          () => id,
          'DBSYSTEMVALUES_CACHE',
          () => ic,
          'DBSYSTEMVALUES_CASSANDRA',
          () => iC,
          'DBSYSTEMVALUES_CLOUDSCAPE',
          () => it,
          'DBSYSTEMVALUES_COCKROACHDB',
          () => iB,
          'DBSYSTEMVALUES_COLDFUSION',
          () => iv,
          'DBSYSTEMVALUES_COSMOSDB',
          () => ix,
          'DBSYSTEMVALUES_COUCHBASE',
          () => iU,
          'DBSYSTEMVALUES_COUCHDB',
          () => iD,
          'DBSYSTEMVALUES_DB2',
          () => r6,
          'DBSYSTEMVALUES_DERBY',
          () => i_,
          'DBSYSTEMVALUES_DYNAMODB',
          () => iw,
          'DBSYSTEMVALUES_EDB',
          () => il,
          'DBSYSTEMVALUES_ELASTICSEARCH',
          () => iV,
          'DBSYSTEMVALUES_FILEMAKER',
          () => iS,
          'DBSYSTEMVALUES_FIREBIRD',
          () => ip,
          'DBSYSTEMVALUES_FIRSTSQL',
          () => iu,
          'DBSYSTEMVALUES_GEODE',
          () => iG,
          'DBSYSTEMVALUES_H2',
          () => iO,
          'DBSYSTEMVALUES_HANADB',
          () => ia,
          'DBSYSTEMVALUES_HBASE',
          () => iP,
          'DBSYSTEMVALUES_HIVE',
          () => ie,
          'DBSYSTEMVALUES_HSQLDB',
          () => ir,
          'DBSYSTEMVALUES_INFORMIX',
          () => iE,
          'DBSYSTEMVALUES_INGRES',
          () => is,
          'DBSYSTEMVALUES_INSTANTDB',
          () => iT,
          'DBSYSTEMVALUES_INTERBASE',
          () => im,
          'DBSYSTEMVALUES_MARIADB',
          () => ig,
          'DBSYSTEMVALUES_MAXDB',
          () => io,
          'DBSYSTEMVALUES_MEMCACHED',
          () => i$,
          'DBSYSTEMVALUES_MONGODB',
          () => iM,
          'DBSYSTEMVALUES_MSSQL',
          () => r4,
          'DBSYSTEMVALUES_MYSQL',
          () => r9,
          'DBSYSTEMVALUES_NEO4J',
          () => ik,
          'DBSYSTEMVALUES_NETEZZA',
          () => ih,
          'DBSYSTEMVALUES_ORACLE',
          () => r3,
          'DBSYSTEMVALUES_OTHER_SQL',
          () => r5,
          'DBSYSTEMVALUES_PERVASIVE',
          () => iA,
          'DBSYSTEMVALUES_POINTBASE',
          () => iR,
          'DBSYSTEMVALUES_POSTGRESQL',
          () => r7,
          'DBSYSTEMVALUES_PROGRESS',
          () => ii,
          'DBSYSTEMVALUES_REDIS',
          () => iL,
          'DBSYSTEMVALUES_REDSHIFT',
          () => r8,
          'DBSYSTEMVALUES_SQLITE',
          () => iy,
          'DBSYSTEMVALUES_SYBASE',
          () => iI,
          'DBSYSTEMVALUES_TERADATA',
          () => ib,
          'DBSYSTEMVALUES_VERTICA',
          () => iN,
          'DbCassandraConsistencyLevelValues',
          () => i6,
          'DbSystemValues',
          () => iH,
          'FAASDOCUMENTOPERATIONVALUES_DELETE',
          () => oS,
          'FAASDOCUMENTOPERATIONVALUES_EDIT',
          () => o_,
          'FAASDOCUMENTOPERATIONVALUES_INSERT',
          () => op,
          'FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD',
          () => og,
          'FAASINVOKEDPROVIDERVALUES_AWS',
          () => of,
          'FAASINVOKEDPROVIDERVALUES_AZURE',
          () => oh,
          'FAASINVOKEDPROVIDERVALUES_GCP',
          () => oA,
          'FAASTRIGGERVALUES_DATASOURCE',
          () => or,
          'FAASTRIGGERVALUES_HTTP',
          () => oi,
          'FAASTRIGGERVALUES_OTHER',
          () => os,
          'FAASTRIGGERVALUES_PUBSUB',
          () => oo,
          'FAASTRIGGERVALUES_TIMER',
          () => oa,
          'FaasDocumentOperationValues',
          () => oE,
          'FaasInvokedProviderValues',
          () => oR,
          'FaasTriggerValues',
          () => ou,
          'HTTPFLAVORVALUES_HTTP_1_0',
          () => aN,
          'HTTPFLAVORVALUES_HTTP_1_1',
          () => aO,
          'HTTPFLAVORVALUES_HTTP_2_0',
          () => av,
          'HTTPFLAVORVALUES_QUIC',
          () => aP,
          'HTTPFLAVORVALUES_SPDY',
          () => aC,
          'HttpFlavorValues',
          () => aM,
          'MESSAGETYPEVALUES_RECEIVED',
          () => a8,
          'MESSAGETYPEVALUES_SENT',
          () => a7,
          'MESSAGINGDESTINATIONKINDVALUES_QUEUE',
          () => aD,
          'MESSAGINGDESTINATIONKINDVALUES_TOPIC',
          () => ax,
          'MESSAGINGOPERATIONVALUES_PROCESS',
          () => a$,
          'MESSAGINGOPERATIONVALUES_RECEIVE',
          () => aV,
          'MessageTypeValues',
          () => se,
          'MessagingDestinationKindValues',
          () => aw,
          'MessagingOperationValues',
          () => aB,
          'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA',
          () => ao,
          'NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT',
          () => au,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EDGE',
          () => ar,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD',
          () => aE,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0',
          () => aa,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A',
          () => as,
          'NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B',
          () => a_,
          'NETHOSTCONNECTIONSUBTYPEVALUES_GPRS',
          () => an,
          'NETHOSTCONNECTIONSUBTYPEVALUES_GSM',
          () => am,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA',
          () => al,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSPA',
          () => ad,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP',
          () => aT,
          'NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA',
          () => ac,
          'NETHOSTCONNECTIONSUBTYPEVALUES_IDEN',
          () => ap,
          'NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN',
          () => af,
          'NETHOSTCONNECTIONSUBTYPEVALUES_LTE',
          () => aS,
          'NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA',
          () => aR,
          'NETHOSTCONNECTIONSUBTYPEVALUES_NR',
          () => ah,
          'NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA',
          () => aA,
          'NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA',
          () => ag,
          'NETHOSTCONNECTIONSUBTYPEVALUES_UMTS',
          () => ai,
          'NETHOSTCONNECTIONTYPEVALUES_CELL',
          () => oF,
          'NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE',
          () => oZ,
          'NETHOSTCONNECTIONTYPEVALUES_UNKNOWN',
          () => oY,
          'NETHOSTCONNECTIONTYPEVALUES_WIFI',
          () => oH,
          'NETHOSTCONNECTIONTYPEVALUES_WIRED',
          () => oj,
          'NETTRANSPORTVALUES_INPROC',
          () => oD,
          'NETTRANSPORTVALUES_IP',
          () => oM,
          'NETTRANSPORTVALUES_IP_TCP',
          () => oC,
          'NETTRANSPORTVALUES_IP_UDP',
          () => oP,
          'NETTRANSPORTVALUES_OTHER',
          () => ox,
          'NETTRANSPORTVALUES_PIPE',
          () => oU,
          'NETTRANSPORTVALUES_UNIX',
          () => oL,
          'NetHostConnectionSubtypeValues',
          () => ay,
          'NetHostConnectionTypeValues',
          () => oW,
          'NetTransportValues',
          () => ow,
          'RPCGRPCSTATUSCODEVALUES_ABORTED',
          () => aQ,
          'RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS',
          () => aK,
          'RPCGRPCSTATUSCODEVALUES_CANCELLED',
          () => aj,
          'RPCGRPCSTATUSCODEVALUES_DATA_LOSS',
          () => a5,
          'RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED',
          () => aY,
          'RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION',
          () => aJ,
          'RPCGRPCSTATUSCODEVALUES_INTERNAL',
          () => a1,
          'RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT',
          () => aZ,
          'RPCGRPCSTATUSCODEVALUES_NOT_FOUND',
          () => aW,
          'RPCGRPCSTATUSCODEVALUES_OK',
          () => aH,
          'RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE',
          () => aq,
          'RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED',
          () => az,
          'RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED',
          () => aX,
          'RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED',
          () => a4,
          'RPCGRPCSTATUSCODEVALUES_UNAVAILABLE',
          () => a2,
          'RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED',
          () => a0,
          'RPCGRPCSTATUSCODEVALUES_UNKNOWN',
          () => aF,
          'RpcGrpcStatusCodeValues',
          () => a9,
          'SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET',
          () => nM,
          'SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS',
          () => nj,
          'SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ',
          () => nv,
          'SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY',
          () => nI,
          'SEMATTRS_AWS_DYNAMODB_COUNT',
          () => nB,
          'SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE',
          () => nw,
          'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES',
          () => nD,
          'SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES',
          () => nF,
          'SEMATTRS_AWS_DYNAMODB_INDEX_NAME',
          () => nL,
          'SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS',
          () => nb,
          'SEMATTRS_AWS_DYNAMODB_LIMIT',
          () => nP,
          'SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES',
          () => nx,
          'SEMATTRS_AWS_DYNAMODB_PROJECTION',
          () => nC,
          'SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY',
          () => nN,
          'SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY',
          () => nO,
          'SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT',
          () => nH,
          'SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD',
          () => nG,
          'SEMATTRS_AWS_DYNAMODB_SEGMENT',
          () => nV,
          'SEMATTRS_AWS_DYNAMODB_SELECT',
          () => nU,
          'SEMATTRS_AWS_DYNAMODB_TABLE_COUNT',
          () => nk,
          'SEMATTRS_AWS_DYNAMODB_TABLE_NAMES',
          () => ny,
          'SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS',
          () => n$,
          'SEMATTRS_AWS_LAMBDA_INVOKED_ARN',
          () => tp,
          'SEMATTRS_CODE_FILEPATH',
          () => na,
          'SEMATTRS_CODE_FUNCTION',
          () => ni,
          'SEMATTRS_CODE_LINENO',
          () => ns,
          'SEMATTRS_CODE_NAMESPACE',
          () => no,
          'SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL',
          () => ty,
          'SEMATTRS_DB_CASSANDRA_COORDINATOR_DC',
          () => tv,
          'SEMATTRS_DB_CASSANDRA_COORDINATOR_ID',
          () => tO,
          'SEMATTRS_DB_CASSANDRA_IDEMPOTENCE',
          () => tb,
          'SEMATTRS_DB_CASSANDRA_KEYSPACE',
          () => tA,
          'SEMATTRS_DB_CASSANDRA_PAGE_SIZE',
          () => tR,
          'SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT',
          () => tN,
          'SEMATTRS_DB_CASSANDRA_TABLE',
          () => tI,
          'SEMATTRS_DB_CONNECTION_STRING',
          () => tS,
          'SEMATTRS_DB_HBASE_NAMESPACE',
          () => tC,
          'SEMATTRS_DB_JDBC_DRIVER_CLASSNAME',
          () => tT,
          'SEMATTRS_DB_MONGODB_COLLECTION',
          () => tM,
          'SEMATTRS_DB_MSSQL_INSTANCE_NAME',
          () => th,
          'SEMATTRS_DB_NAME',
          () => tm,
          'SEMATTRS_DB_OPERATION',
          () => tf,
          'SEMATTRS_DB_REDIS_DATABASE_INDEX',
          () => tP,
          'SEMATTRS_DB_SQL_TABLE',
          () => tL,
          'SEMATTRS_DB_STATEMENT',
          () => tg,
          'SEMATTRS_DB_SYSTEM',
          () => t_,
          'SEMATTRS_DB_USER',
          () => tE,
          'SEMATTRS_ENDUSER_ID',
          () => t8,
          'SEMATTRS_ENDUSER_ROLE',
          () => ne,
          'SEMATTRS_ENDUSER_SCOPE',
          () => nt,
          'SEMATTRS_EXCEPTION_ESCAPED',
          () => tw,
          'SEMATTRS_EXCEPTION_MESSAGE',
          () => tD,
          'SEMATTRS_EXCEPTION_STACKTRACE',
          () => tx,
          'SEMATTRS_EXCEPTION_TYPE',
          () => tU,
          'SEMATTRS_FAAS_COLDSTART',
          () => tZ,
          'SEMATTRS_FAAS_CRON',
          () => tF,
          'SEMATTRS_FAAS_DOCUMENT_COLLECTION',
          () => tV,
          'SEMATTRS_FAAS_DOCUMENT_NAME',
          () => tH,
          'SEMATTRS_FAAS_DOCUMENT_OPERATION',
          () => t$,
          'SEMATTRS_FAAS_DOCUMENT_TIME',
          () => tB,
          'SEMATTRS_FAAS_EXECUTION',
          () => tG,
          'SEMATTRS_FAAS_INVOKED_NAME',
          () => tY,
          'SEMATTRS_FAAS_INVOKED_PROVIDER',
          () => tW,
          'SEMATTRS_FAAS_INVOKED_REGION',
          () => tK,
          'SEMATTRS_FAAS_TIME',
          () => tj,
          'SEMATTRS_FAAS_TRIGGER',
          () => tk,
          'SEMATTRS_HTTP_CLIENT_IP',
          () => nR,
          'SEMATTRS_HTTP_FLAVOR',
          () => nS,
          'SEMATTRS_HTTP_HOST',
          () => nd,
          'SEMATTRS_HTTP_METHOD',
          () => nu,
          'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH',
          () => nT,
          'SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED',
          () => nm,
          'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH',
          () => ng,
          'SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED',
          () => nf,
          'SEMATTRS_HTTP_ROUTE',
          () => nA,
          'SEMATTRS_HTTP_SCHEME',
          () => np,
          'SEMATTRS_HTTP_SERVER_NAME',
          () => nh,
          'SEMATTRS_HTTP_STATUS_CODE',
          () => n_,
          'SEMATTRS_HTTP_TARGET',
          () => nc,
          'SEMATTRS_HTTP_URL',
          () => nl,
          'SEMATTRS_HTTP_USER_AGENT',
          () => nE,
          'SEMATTRS_MESSAGE_COMPRESSED_SIZE',
          () => rc,
          'SEMATTRS_MESSAGE_ID',
          () => rl,
          'SEMATTRS_MESSAGE_TYPE',
          () => ru,
          'SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE',
          () => rd,
          'SEMATTRS_MESSAGING_CONSUMER_ID',
          () => n5,
          'SEMATTRS_MESSAGING_CONVERSATION_ID',
          () => nq,
          'SEMATTRS_MESSAGING_DESTINATION',
          () => nY,
          'SEMATTRS_MESSAGING_DESTINATION_KIND',
          () => nW,
          'SEMATTRS_MESSAGING_KAFKA_CLIENT_ID',
          () => n6,
          'SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP',
          () => n3,
          'SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY',
          () => n9,
          'SEMATTRS_MESSAGING_KAFKA_PARTITION',
          () => n7,
          'SEMATTRS_MESSAGING_KAFKA_TOMBSTONE',
          () => n8,
          'SEMATTRS_MESSAGING_MESSAGE_ID',
          () => nQ,
          'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES',
          () => n1,
          'SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES',
          () => n0,
          'SEMATTRS_MESSAGING_OPERATION',
          () => n2,
          'SEMATTRS_MESSAGING_PROTOCOL',
          () => nz,
          'SEMATTRS_MESSAGING_PROTOCOL_VERSION',
          () => nX,
          'SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY',
          () => n4,
          'SEMATTRS_MESSAGING_SYSTEM',
          () => nZ,
          'SEMATTRS_MESSAGING_TEMP_DESTINATION',
          () => nK,
          'SEMATTRS_MESSAGING_URL',
          () => nJ,
          'SEMATTRS_NET_HOST_CARRIER_ICC',
          () => t6,
          'SEMATTRS_NET_HOST_CARRIER_MCC',
          () => t9,
          'SEMATTRS_NET_HOST_CARRIER_MNC',
          () => t3,
          'SEMATTRS_NET_HOST_CARRIER_NAME',
          () => t4,
          'SEMATTRS_NET_HOST_CONNECTION_SUBTYPE',
          () => t5,
          'SEMATTRS_NET_HOST_CONNECTION_TYPE',
          () => t2,
          'SEMATTRS_NET_HOST_IP',
          () => tq,
          'SEMATTRS_NET_HOST_NAME',
          () => t1,
          'SEMATTRS_NET_HOST_PORT',
          () => t0,
          'SEMATTRS_NET_PEER_IP',
          () => tX,
          'SEMATTRS_NET_PEER_NAME',
          () => tQ,
          'SEMATTRS_NET_PEER_PORT',
          () => tJ,
          'SEMATTRS_NET_TRANSPORT',
          () => tz,
          'SEMATTRS_PEER_SERVICE',
          () => t7,
          'SEMATTRS_RPC_GRPC_STATUS_CODE',
          () => rr,
          'SEMATTRS_RPC_JSONRPC_ERROR_CODE',
          () => ra,
          'SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE',
          () => rs,
          'SEMATTRS_RPC_JSONRPC_REQUEST_ID',
          () => ro,
          'SEMATTRS_RPC_JSONRPC_VERSION',
          () => ri,
          'SEMATTRS_RPC_METHOD',
          () => rn,
          'SEMATTRS_RPC_SERVICE',
          () => rt,
          'SEMATTRS_RPC_SYSTEM',
          () => re,
          'SEMATTRS_THREAD_ID',
          () => nn,
          'SEMATTRS_THREAD_NAME',
          () => nr,
          'SemanticAttributes',
          () => rp,
        ],
        79328
      ));
    let n = 'aws.lambda.invoked_arn',
      r = 'db.system',
      i = 'db.connection_string',
      o = 'db.user',
      a = 'db.jdbc.driver_classname',
      s = 'db.name',
      u = 'db.statement',
      l = 'db.operation',
      c = 'db.mssql.instance_name',
      d = 'db.cassandra.keyspace',
      p = 'db.cassandra.page_size',
      _ = 'db.cassandra.consistency_level',
      S = 'db.cassandra.table',
      E = 'db.cassandra.idempotence',
      T = 'db.cassandra.speculative_execution_count',
      m = 'db.cassandra.coordinator.id',
      g = 'db.cassandra.coordinator.dc',
      f = 'db.hbase.namespace',
      h = 'db.redis.database_index',
      A = 'db.mongodb.collection',
      R = 'db.sql.table',
      y = 'exception.type',
      I = 'exception.message',
      b = 'exception.stacktrace',
      N = 'exception.escaped',
      O = 'faas.trigger',
      v = 'faas.execution',
      C = 'faas.document.collection',
      P = 'faas.document.operation',
      M = 'faas.document.time',
      L = 'faas.document.name',
      U = 'faas.time',
      D = 'faas.cron',
      x = 'faas.coldstart',
      w = 'faas.invoked_name',
      k = 'faas.invoked_provider',
      G = 'faas.invoked_region',
      V = 'net.transport',
      $ = 'net.peer.ip',
      B = 'net.peer.port',
      H = 'net.peer.name',
      j = 'net.host.ip',
      F = 'net.host.port',
      Z = 'net.host.name',
      Y = 'net.host.connection.type',
      W = 'net.host.connection.subtype',
      K = 'net.host.carrier.name',
      z = 'net.host.carrier.mcc',
      X = 'net.host.carrier.mnc',
      J = 'net.host.carrier.icc',
      Q = 'peer.service',
      q = 'enduser.id',
      ee = 'enduser.role',
      et = 'enduser.scope',
      en = 'thread.id',
      er = 'thread.name',
      ei = 'code.function',
      eo = 'code.namespace',
      ea = 'code.filepath',
      es = 'code.lineno',
      eu = 'http.method',
      el = 'http.url',
      ec = 'http.target',
      ed = 'http.host',
      ep = 'http.scheme',
      e_ = 'http.status_code',
      eS = 'http.flavor',
      eE = 'http.user_agent',
      eT = 'http.request_content_length',
      em = 'http.request_content_length_uncompressed',
      eg = 'http.response_content_length',
      ef = 'http.response_content_length_uncompressed',
      eh = 'http.server_name',
      eA = 'http.route',
      eR = 'http.client_ip',
      ey = 'aws.dynamodb.table_names',
      eI = 'aws.dynamodb.consumed_capacity',
      eb = 'aws.dynamodb.item_collection_metrics',
      eN = 'aws.dynamodb.provisioned_read_capacity',
      eO = 'aws.dynamodb.provisioned_write_capacity',
      ev = 'aws.dynamodb.consistent_read',
      eC = 'aws.dynamodb.projection',
      eP = 'aws.dynamodb.limit',
      eM = 'aws.dynamodb.attributes_to_get',
      eL = 'aws.dynamodb.index_name',
      eU = 'aws.dynamodb.select',
      eD = 'aws.dynamodb.global_secondary_indexes',
      ex = 'aws.dynamodb.local_secondary_indexes',
      ew = 'aws.dynamodb.exclusive_start_table',
      ek = 'aws.dynamodb.table_count',
      eG = 'aws.dynamodb.scan_forward',
      eV = 'aws.dynamodb.segment',
      e$ = 'aws.dynamodb.total_segments',
      eB = 'aws.dynamodb.count',
      eH = 'aws.dynamodb.scanned_count',
      ej = 'aws.dynamodb.attribute_definitions',
      eF = 'aws.dynamodb.global_secondary_index_updates',
      eZ = 'messaging.system',
      eY = 'messaging.destination',
      eW = 'messaging.destination_kind',
      eK = 'messaging.temp_destination',
      ez = 'messaging.protocol',
      eX = 'messaging.protocol_version',
      eJ = 'messaging.url',
      eQ = 'messaging.message_id',
      eq = 'messaging.conversation_id',
      e0 = 'messaging.message_payload_size_bytes',
      e1 = 'messaging.message_payload_compressed_size_bytes',
      e2 = 'messaging.operation',
      e5 = 'messaging.consumer_id',
      e4 = 'messaging.rabbitmq.routing_key',
      e9 = 'messaging.kafka.message_key',
      e3 = 'messaging.kafka.consumer_group',
      e6 = 'messaging.kafka.client_id',
      e7 = 'messaging.kafka.partition',
      e8 = 'messaging.kafka.tombstone',
      te = 'rpc.system',
      tt = 'rpc.service',
      tn = 'rpc.method',
      tr = 'rpc.grpc.status_code',
      ti = 'rpc.jsonrpc.version',
      to = 'rpc.jsonrpc.request_id',
      ta = 'rpc.jsonrpc.error_code',
      ts = 'rpc.jsonrpc.error_message',
      tu = 'message.type',
      tl = 'message.id',
      tc = 'message.compressed_size',
      td = 'message.uncompressed_size',
      tp = n,
      t_ = r,
      tS = i,
      tE = o,
      tT = a,
      tm = s,
      tg = u,
      tf = l,
      th = c,
      tA = d,
      tR = p,
      ty = _,
      tI = S,
      tb = E,
      tN = T,
      tO = m,
      tv = g,
      tC = f,
      tP = h,
      tM = A,
      tL = R,
      tU = y,
      tD = I,
      tx = b,
      tw = N,
      tk = O,
      tG = v,
      tV = C,
      t$ = P,
      tB = M,
      tH = L,
      tj = U,
      tF = D,
      tZ = x,
      tY = w,
      tW = k,
      tK = G,
      tz = V,
      tX = $,
      tJ = B,
      tQ = H,
      tq = j,
      t0 = F,
      t1 = Z,
      t2 = Y,
      t5 = W,
      t4 = K,
      t9 = z,
      t3 = X,
      t6 = J,
      t7 = Q,
      t8 = q,
      ne = ee,
      nt = et,
      nn = en,
      nr = er,
      ni = ei,
      no = eo,
      na = ea,
      ns = es,
      nu = eu,
      nl = el,
      nc = ec,
      nd = ed,
      np = ep,
      n_ = e_,
      nS = eS,
      nE = eE,
      nT = eT,
      nm = em,
      ng = eg,
      nf = ef,
      nh = eh,
      nA = eA,
      nR = eR,
      ny = ey,
      nI = eI,
      nb = eb,
      nN = eN,
      nO = eO,
      nv = ev,
      nC = eC,
      nP = eP,
      nM = eM,
      nL = eL,
      nU = eU,
      nD = eD,
      nx = ex,
      nw = ew,
      nk = ek,
      nG = eG,
      nV = eV,
      n$ = e$,
      nB = eB,
      nH = eH,
      nj = ej,
      nF = eF,
      nZ = eZ,
      nY = eY,
      nW = eW,
      nK = eK,
      nz = ez,
      nX = eX,
      nJ = eJ,
      nQ = eQ,
      nq = eq,
      n0 = e0,
      n1 = e1,
      n2 = e2,
      n5 = e5,
      n4 = e4,
      n9 = e9,
      n3 = e3,
      n6 = e6,
      n7 = e7,
      n8 = e8,
      re = te,
      rt = tt,
      rn = tn,
      rr = tr,
      ri = ti,
      ro = to,
      ra = ta,
      rs = ts,
      ru = tu,
      rl = tl,
      rc = tc,
      rd = td,
      rp = t([
        n,
        r,
        i,
        o,
        a,
        s,
        u,
        l,
        c,
        d,
        p,
        _,
        S,
        E,
        T,
        m,
        g,
        f,
        h,
        A,
        R,
        y,
        I,
        b,
        N,
        O,
        v,
        C,
        P,
        M,
        L,
        U,
        D,
        x,
        w,
        k,
        G,
        V,
        $,
        B,
        H,
        j,
        F,
        Z,
        Y,
        W,
        K,
        z,
        X,
        J,
        Q,
        q,
        ee,
        et,
        en,
        er,
        ei,
        eo,
        ea,
        es,
        eu,
        el,
        ec,
        ed,
        ep,
        e_,
        eS,
        eE,
        eT,
        em,
        eg,
        ef,
        eh,
        eA,
        eR,
        ey,
        eI,
        eb,
        eN,
        eO,
        ev,
        eC,
        eP,
        eM,
        eL,
        eU,
        eD,
        ex,
        ew,
        ek,
        eG,
        eV,
        e$,
        eB,
        eH,
        ej,
        eF,
        eZ,
        eY,
        eW,
        eK,
        ez,
        eX,
        eJ,
        eQ,
        eq,
        e0,
        e1,
        e2,
        e5,
        e4,
        e9,
        e3,
        e6,
        e7,
        e8,
        te,
        tt,
        tn,
        tr,
        ti,
        to,
        ta,
        ts,
        tu,
        tl,
        tc,
        td,
      ]),
      r_ = 'other_sql',
      rS = 'mssql',
      rE = 'mysql',
      rT = 'oracle',
      rm = 'postgresql',
      rg = 'redshift',
      rf = 'hive',
      rh = 'cloudscape',
      rA = 'hsqldb',
      rR = 'progress',
      ry = 'maxdb',
      rI = 'hanadb',
      rb = 'ingres',
      rN = 'firstsql',
      rO = 'cache',
      rv = 'adabas',
      rC = 'firebird',
      rP = 'derby',
      rM = 'filemaker',
      rL = 'informix',
      rU = 'instantdb',
      rD = 'interbase',
      rx = 'mariadb',
      rw = 'netezza',
      rk = 'pervasive',
      rG = 'pointbase',
      rV = 'sqlite',
      r$ = 'sybase',
      rB = 'teradata',
      rH = 'vertica',
      rj = 'coldfusion',
      rF = 'cassandra',
      rZ = 'hbase',
      rY = 'mongodb',
      rW = 'redis',
      rK = 'couchbase',
      rz = 'couchdb',
      rX = 'cosmosdb',
      rJ = 'dynamodb',
      rQ = 'neo4j',
      rq = 'geode',
      r0 = 'elasticsearch',
      r1 = 'memcached',
      r2 = 'cockroachdb',
      r5 = r_,
      r4 = rS,
      r9 = rE,
      r3 = rT,
      r6 = 'db2',
      r7 = rm,
      r8 = rg,
      ie = rf,
      it = rh,
      ir = rA,
      ii = rR,
      io = ry,
      ia = rI,
      is = rb,
      iu = rN,
      il = 'edb',
      ic = rO,
      id = rv,
      ip = rC,
      i_ = rP,
      iS = rM,
      iE = rL,
      iT = rU,
      im = rD,
      ig = rx,
      ih = rw,
      iA = rk,
      iR = rG,
      iy = rV,
      iI = r$,
      ib = rB,
      iN = rH,
      iO = 'h2',
      iv = rj,
      iC = rF,
      iP = rZ,
      iM = rY,
      iL = rW,
      iU = rK,
      iD = rz,
      ix = rX,
      iw = rJ,
      ik = rQ,
      iG = rq,
      iV = r0,
      i$ = r1,
      iB = r2,
      iH = t([
        r_,
        rS,
        rE,
        rT,
        'db2',
        rm,
        rg,
        rf,
        rh,
        rA,
        rR,
        ry,
        rI,
        rb,
        rN,
        'edb',
        rO,
        rv,
        rC,
        rP,
        rM,
        rL,
        rU,
        rD,
        rx,
        rw,
        rk,
        rG,
        rV,
        r$,
        rB,
        rH,
        'h2',
        rj,
        rF,
        rZ,
        rY,
        rW,
        rK,
        rz,
        rX,
        rJ,
        rQ,
        rq,
        r0,
        r1,
        r2,
      ]),
      ij = 'each_quorum',
      iF = 'quorum',
      iZ = 'local_quorum',
      iY = 'three',
      iW = 'local_one',
      iK = 'serial',
      iz = 'local_serial',
      iX = 'all',
      iJ = ij,
      iQ = iF,
      iq = iZ,
      i0 = 'one',
      i1 = 'two',
      i2 = iY,
      i5 = iW,
      i4 = 'any',
      i9 = iK,
      i3 = iz,
      i6 = t(['all', ij, iF, iZ, 'one', 'two', iY, iW, 'any', iK, iz]),
      i7 = 'datasource',
      i8 = 'http',
      oe = 'pubsub',
      ot = 'timer',
      on = 'other',
      or = i7,
      oi = i8,
      oo = oe,
      oa = ot,
      os = on,
      ou = t([i7, i8, oe, ot, on]),
      ol = 'insert',
      oc = 'edit',
      od = 'delete',
      op = ol,
      o_ = oc,
      oS = od,
      oE = t([ol, oc, od]),
      oT = 'alibaba_cloud',
      om = 'azure',
      og = oT,
      of = 'aws',
      oh = om,
      oA = 'gcp',
      oR = t([oT, 'aws', om, 'gcp']),
      oy = 'ip_tcp',
      oI = 'ip_udp',
      ob = 'unix',
      oN = 'pipe',
      oO = 'inproc',
      ov = 'other',
      oC = oy,
      oP = oI,
      oM = 'ip',
      oL = ob,
      oU = oN,
      oD = oO,
      ox = ov,
      ow = t([oy, oI, 'ip', ob, oN, oO, ov]),
      ok = 'wifi',
      oG = 'wired',
      oV = 'cell',
      o$ = 'unavailable',
      oB = 'unknown',
      oH = ok,
      oj = oG,
      oF = oV,
      oZ = o$,
      oY = oB,
      oW = t([ok, oG, oV, o$, oB]),
      oK = 'gprs',
      oz = 'edge',
      oX = 'umts',
      oJ = 'cdma',
      oQ = 'evdo_0',
      oq = 'evdo_a',
      o0 = 'cdma2000_1xrtt',
      o1 = 'hsdpa',
      o2 = 'hsupa',
      o5 = 'hspa',
      o4 = 'iden',
      o9 = 'evdo_b',
      o3 = 'ehrpd',
      o6 = 'hspap',
      o7 = 'td_scdma',
      o8 = 'iwlan',
      ae = 'nrnsa',
      at = 'lte_ca',
      an = oK,
      ar = oz,
      ai = oX,
      ao = oJ,
      aa = oQ,
      as = oq,
      au = o0,
      al = o1,
      ac = o2,
      ad = o5,
      ap = o4,
      a_ = o9,
      aS = 'lte',
      aE = o3,
      aT = o6,
      am = 'gsm',
      ag = o7,
      af = o8,
      ah = 'nr',
      aA = ae,
      aR = at,
      ay = t([
        oK,
        oz,
        oX,
        oJ,
        oQ,
        oq,
        o0,
        o1,
        o2,
        o5,
        o4,
        o9,
        'lte',
        o3,
        o6,
        'gsm',
        o7,
        o8,
        'nr',
        ae,
        at,
      ]),
      aI = 'SPDY',
      ab = 'QUIC',
      aN = '1.0',
      aO = '1.1',
      av = '2.0',
      aC = aI,
      aP = ab,
      aM = { HTTP_1_0: '1.0', HTTP_1_1: '1.1', HTTP_2_0: '2.0', SPDY: aI, QUIC: ab },
      aL = 'queue',
      aU = 'topic',
      aD = aL,
      ax = aU,
      aw = t([aL, aU]),
      ak = 'receive',
      aG = 'process',
      aV = ak,
      a$ = aG,
      aB = t([ak, aG]),
      aH = 0,
      aj = 1,
      aF = 2,
      aZ = 3,
      aY = 4,
      aW = 5,
      aK = 6,
      az = 7,
      aX = 8,
      aJ = 9,
      aQ = 10,
      aq = 11,
      a0 = 12,
      a1 = 13,
      a2 = 14,
      a5 = 15,
      a4 = 16,
      a9 = {
        OK: 0,
        CANCELLED: 1,
        UNKNOWN: 2,
        INVALID_ARGUMENT: 3,
        DEADLINE_EXCEEDED: 4,
        NOT_FOUND: 5,
        ALREADY_EXISTS: 6,
        PERMISSION_DENIED: 7,
        RESOURCE_EXHAUSTED: 8,
        FAILED_PRECONDITION: 9,
        ABORTED: 10,
        OUT_OF_RANGE: 11,
        UNIMPLEMENTED: 12,
        INTERNAL: 13,
        UNAVAILABLE: 14,
        DATA_LOSS: 15,
        UNAUTHENTICATED: 16,
      },
      a3 = 'SENT',
      a6 = 'RECEIVED',
      a7 = a3,
      a8 = a6,
      se = t([a3, a6]);
    (e.i(79328),
      e.i(22671),
      e.s(
        [
          'AWSECSLAUNCHTYPEVALUES_EC2',
          () => cE,
          'AWSECSLAUNCHTYPEVALUES_FARGATE',
          () => cT,
          'AwsEcsLaunchtypeValues',
          () => cm,
          'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS',
          () => l3,
          'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC',
          () => l6,
          'CLOUDPLATFORMVALUES_AWS_EC2',
          () => l7,
          'CLOUDPLATFORMVALUES_AWS_ECS',
          () => l8,
          'CLOUDPLATFORMVALUES_AWS_EKS',
          () => ce,
          'CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK',
          () => cn,
          'CLOUDPLATFORMVALUES_AWS_LAMBDA',
          () => ct,
          'CLOUDPLATFORMVALUES_AZURE_AKS',
          () => co,
          'CLOUDPLATFORMVALUES_AZURE_APP_SERVICE',
          () => cs,
          'CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES',
          () => ci,
          'CLOUDPLATFORMVALUES_AZURE_FUNCTIONS',
          () => ca,
          'CLOUDPLATFORMVALUES_AZURE_VM',
          () => cr,
          'CLOUDPLATFORMVALUES_GCP_APP_ENGINE',
          () => cp,
          'CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS',
          () => cd,
          'CLOUDPLATFORMVALUES_GCP_CLOUD_RUN',
          () => cl,
          'CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE',
          () => cu,
          'CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE',
          () => cc,
          'CLOUDPROVIDERVALUES_ALIBABA_CLOUD',
          () => lG,
          'CLOUDPROVIDERVALUES_AWS',
          () => lV,
          'CLOUDPROVIDERVALUES_AZURE',
          () => l$,
          'CLOUDPROVIDERVALUES_GCP',
          () => lB,
          'CloudPlatformValues',
          () => c_,
          'CloudProviderValues',
          () => lH,
          'HOSTARCHVALUES_AMD64',
          () => cI,
          'HOSTARCHVALUES_ARM32',
          () => cb,
          'HOSTARCHVALUES_ARM64',
          () => cN,
          'HOSTARCHVALUES_IA64',
          () => cO,
          'HOSTARCHVALUES_PPC32',
          () => cv,
          'HOSTARCHVALUES_PPC64',
          () => cC,
          'HOSTARCHVALUES_X86',
          () => cP,
          'HostArchValues',
          () => cM,
          'OSTYPEVALUES_AIX',
          () => cX,
          'OSTYPEVALUES_DARWIN',
          () => cF,
          'OSTYPEVALUES_DRAGONFLYBSD',
          () => cK,
          'OSTYPEVALUES_FREEBSD',
          () => cZ,
          'OSTYPEVALUES_HPUX',
          () => cz,
          'OSTYPEVALUES_LINUX',
          () => cj,
          'OSTYPEVALUES_NETBSD',
          () => cY,
          'OSTYPEVALUES_OPENBSD',
          () => cW,
          'OSTYPEVALUES_SOLARIS',
          () => cJ,
          'OSTYPEVALUES_WINDOWS',
          () => cH,
          'OSTYPEVALUES_Z_OS',
          () => cQ,
          'OsTypeValues',
          () => cq,
          'SEMRESATTRS_AWS_ECS_CLUSTER_ARN',
          () => uI,
          'SEMRESATTRS_AWS_ECS_CONTAINER_ARN',
          () => uy,
          'SEMRESATTRS_AWS_ECS_LAUNCHTYPE',
          () => ub,
          'SEMRESATTRS_AWS_ECS_TASK_ARN',
          () => uN,
          'SEMRESATTRS_AWS_ECS_TASK_FAMILY',
          () => uO,
          'SEMRESATTRS_AWS_ECS_TASK_REVISION',
          () => uv,
          'SEMRESATTRS_AWS_EKS_CLUSTER_ARN',
          () => uC,
          'SEMRESATTRS_AWS_LOG_GROUP_ARNS',
          () => uM,
          'SEMRESATTRS_AWS_LOG_GROUP_NAMES',
          () => uP,
          'SEMRESATTRS_AWS_LOG_STREAM_ARNS',
          () => uU,
          'SEMRESATTRS_AWS_LOG_STREAM_NAMES',
          () => uL,
          'SEMRESATTRS_CLOUD_ACCOUNT_ID',
          () => uf,
          'SEMRESATTRS_CLOUD_AVAILABILITY_ZONE',
          () => uA,
          'SEMRESATTRS_CLOUD_PLATFORM',
          () => uR,
          'SEMRESATTRS_CLOUD_PROVIDER',
          () => ug,
          'SEMRESATTRS_CLOUD_REGION',
          () => uh,
          'SEMRESATTRS_CONTAINER_ID',
          () => ux,
          'SEMRESATTRS_CONTAINER_IMAGE_NAME',
          () => uk,
          'SEMRESATTRS_CONTAINER_IMAGE_TAG',
          () => uG,
          'SEMRESATTRS_CONTAINER_NAME',
          () => uD,
          'SEMRESATTRS_CONTAINER_RUNTIME',
          () => uw,
          'SEMRESATTRS_DEPLOYMENT_ENVIRONMENT',
          () => uV,
          'SEMRESATTRS_DEVICE_ID',
          () => u$,
          'SEMRESATTRS_DEVICE_MODEL_IDENTIFIER',
          () => uB,
          'SEMRESATTRS_DEVICE_MODEL_NAME',
          () => uH,
          'SEMRESATTRS_FAAS_ID',
          () => uF,
          'SEMRESATTRS_FAAS_INSTANCE',
          () => uY,
          'SEMRESATTRS_FAAS_MAX_MEMORY',
          () => uW,
          'SEMRESATTRS_FAAS_NAME',
          () => uj,
          'SEMRESATTRS_FAAS_VERSION',
          () => uZ,
          'SEMRESATTRS_HOST_ARCH',
          () => uJ,
          'SEMRESATTRS_HOST_ID',
          () => uK,
          'SEMRESATTRS_HOST_IMAGE_ID',
          () => uq,
          'SEMRESATTRS_HOST_IMAGE_NAME',
          () => uQ,
          'SEMRESATTRS_HOST_IMAGE_VERSION',
          () => u0,
          'SEMRESATTRS_HOST_NAME',
          () => uz,
          'SEMRESATTRS_HOST_TYPE',
          () => uX,
          'SEMRESATTRS_K8S_CLUSTER_NAME',
          () => u1,
          'SEMRESATTRS_K8S_CONTAINER_NAME',
          () => u6,
          'SEMRESATTRS_K8S_CRONJOB_NAME',
          () => ll,
          'SEMRESATTRS_K8S_CRONJOB_UID',
          () => lu,
          'SEMRESATTRS_K8S_DAEMONSET_NAME',
          () => lo,
          'SEMRESATTRS_K8S_DAEMONSET_UID',
          () => li,
          'SEMRESATTRS_K8S_DEPLOYMENT_NAME',
          () => lt,
          'SEMRESATTRS_K8S_DEPLOYMENT_UID',
          () => le,
          'SEMRESATTRS_K8S_JOB_NAME',
          () => ls,
          'SEMRESATTRS_K8S_JOB_UID',
          () => la,
          'SEMRESATTRS_K8S_NAMESPACE_NAME',
          () => u4,
          'SEMRESATTRS_K8S_NODE_NAME',
          () => u2,
          'SEMRESATTRS_K8S_NODE_UID',
          () => u5,
          'SEMRESATTRS_K8S_POD_NAME',
          () => u3,
          'SEMRESATTRS_K8S_POD_UID',
          () => u9,
          'SEMRESATTRS_K8S_REPLICASET_NAME',
          () => u8,
          'SEMRESATTRS_K8S_REPLICASET_UID',
          () => u7,
          'SEMRESATTRS_K8S_STATEFULSET_NAME',
          () => lr,
          'SEMRESATTRS_K8S_STATEFULSET_UID',
          () => ln,
          'SEMRESATTRS_OS_DESCRIPTION',
          () => ld,
          'SEMRESATTRS_OS_NAME',
          () => lp,
          'SEMRESATTRS_OS_TYPE',
          () => lc,
          'SEMRESATTRS_OS_VERSION',
          () => l_,
          'SEMRESATTRS_PROCESS_COMMAND',
          () => lm,
          'SEMRESATTRS_PROCESS_COMMAND_ARGS',
          () => lf,
          'SEMRESATTRS_PROCESS_COMMAND_LINE',
          () => lg,
          'SEMRESATTRS_PROCESS_EXECUTABLE_NAME',
          () => lE,
          'SEMRESATTRS_PROCESS_EXECUTABLE_PATH',
          () => lT,
          'SEMRESATTRS_PROCESS_OWNER',
          () => lh,
          'SEMRESATTRS_PROCESS_PID',
          () => lS,
          'SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION',
          () => ly,
          'SEMRESATTRS_PROCESS_RUNTIME_NAME',
          () => lA,
          'SEMRESATTRS_PROCESS_RUNTIME_VERSION',
          () => lR,
          'SEMRESATTRS_SERVICE_INSTANCE_ID',
          () => lN,
          'SEMRESATTRS_SERVICE_NAME',
          () => lI,
          'SEMRESATTRS_SERVICE_NAMESPACE',
          () => lb,
          'SEMRESATTRS_SERVICE_VERSION',
          () => lO,
          'SEMRESATTRS_TELEMETRY_AUTO_VERSION',
          () => lM,
          'SEMRESATTRS_TELEMETRY_SDK_LANGUAGE',
          () => lC,
          'SEMRESATTRS_TELEMETRY_SDK_NAME',
          () => lv,
          'SEMRESATTRS_TELEMETRY_SDK_VERSION',
          () => lP,
          'SEMRESATTRS_WEBENGINE_DESCRIPTION',
          () => lD,
          'SEMRESATTRS_WEBENGINE_NAME',
          () => lL,
          'SEMRESATTRS_WEBENGINE_VERSION',
          () => lU,
          'SemanticResourceAttributes',
          () => lx,
          'TELEMETRYSDKLANGUAGEVALUES_CPP',
          () => c6,
          'TELEMETRYSDKLANGUAGEVALUES_DOTNET',
          () => c7,
          'TELEMETRYSDKLANGUAGEVALUES_ERLANG',
          () => c8,
          'TELEMETRYSDKLANGUAGEVALUES_GO',
          () => de,
          'TELEMETRYSDKLANGUAGEVALUES_JAVA',
          () => dt,
          'TELEMETRYSDKLANGUAGEVALUES_NODEJS',
          () => dn,
          'TELEMETRYSDKLANGUAGEVALUES_PHP',
          () => dr,
          'TELEMETRYSDKLANGUAGEVALUES_PYTHON',
          () => di,
          'TELEMETRYSDKLANGUAGEVALUES_RUBY',
          () => da,
          'TELEMETRYSDKLANGUAGEVALUES_WEBJS',
          () => ds,
          'TelemetrySdkLanguageValues',
          () => du,
        ],
        74109
      ),
      e.s([], 14067),
      e.i(14067),
      e.s(
        [
          'AWSECSLAUNCHTYPEVALUES_EC2',
          () => cE,
          'AWSECSLAUNCHTYPEVALUES_FARGATE',
          () => cT,
          'AwsEcsLaunchtypeValues',
          () => cm,
          'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS',
          () => l3,
          'CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC',
          () => l6,
          'CLOUDPLATFORMVALUES_AWS_EC2',
          () => l7,
          'CLOUDPLATFORMVALUES_AWS_ECS',
          () => l8,
          'CLOUDPLATFORMVALUES_AWS_EKS',
          () => ce,
          'CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK',
          () => cn,
          'CLOUDPLATFORMVALUES_AWS_LAMBDA',
          () => ct,
          'CLOUDPLATFORMVALUES_AZURE_AKS',
          () => co,
          'CLOUDPLATFORMVALUES_AZURE_APP_SERVICE',
          () => cs,
          'CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES',
          () => ci,
          'CLOUDPLATFORMVALUES_AZURE_FUNCTIONS',
          () => ca,
          'CLOUDPLATFORMVALUES_AZURE_VM',
          () => cr,
          'CLOUDPLATFORMVALUES_GCP_APP_ENGINE',
          () => cp,
          'CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS',
          () => cd,
          'CLOUDPLATFORMVALUES_GCP_CLOUD_RUN',
          () => cl,
          'CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE',
          () => cu,
          'CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE',
          () => cc,
          'CLOUDPROVIDERVALUES_ALIBABA_CLOUD',
          () => lG,
          'CLOUDPROVIDERVALUES_AWS',
          () => lV,
          'CLOUDPROVIDERVALUES_AZURE',
          () => l$,
          'CLOUDPROVIDERVALUES_GCP',
          () => lB,
          'CloudPlatformValues',
          () => c_,
          'CloudProviderValues',
          () => lH,
          'HOSTARCHVALUES_AMD64',
          () => cI,
          'HOSTARCHVALUES_ARM32',
          () => cb,
          'HOSTARCHVALUES_ARM64',
          () => cN,
          'HOSTARCHVALUES_IA64',
          () => cO,
          'HOSTARCHVALUES_PPC32',
          () => cv,
          'HOSTARCHVALUES_PPC64',
          () => cC,
          'HOSTARCHVALUES_X86',
          () => cP,
          'HostArchValues',
          () => cM,
          'OSTYPEVALUES_AIX',
          () => cX,
          'OSTYPEVALUES_DARWIN',
          () => cF,
          'OSTYPEVALUES_DRAGONFLYBSD',
          () => cK,
          'OSTYPEVALUES_FREEBSD',
          () => cZ,
          'OSTYPEVALUES_HPUX',
          () => cz,
          'OSTYPEVALUES_LINUX',
          () => cj,
          'OSTYPEVALUES_NETBSD',
          () => cY,
          'OSTYPEVALUES_OPENBSD',
          () => cW,
          'OSTYPEVALUES_SOLARIS',
          () => cJ,
          'OSTYPEVALUES_WINDOWS',
          () => cH,
          'OSTYPEVALUES_Z_OS',
          () => cQ,
          'OsTypeValues',
          () => cq,
          'SEMRESATTRS_AWS_ECS_CLUSTER_ARN',
          () => uI,
          'SEMRESATTRS_AWS_ECS_CONTAINER_ARN',
          () => uy,
          'SEMRESATTRS_AWS_ECS_LAUNCHTYPE',
          () => ub,
          'SEMRESATTRS_AWS_ECS_TASK_ARN',
          () => uN,
          'SEMRESATTRS_AWS_ECS_TASK_FAMILY',
          () => uO,
          'SEMRESATTRS_AWS_ECS_TASK_REVISION',
          () => uv,
          'SEMRESATTRS_AWS_EKS_CLUSTER_ARN',
          () => uC,
          'SEMRESATTRS_AWS_LOG_GROUP_ARNS',
          () => uM,
          'SEMRESATTRS_AWS_LOG_GROUP_NAMES',
          () => uP,
          'SEMRESATTRS_AWS_LOG_STREAM_ARNS',
          () => uU,
          'SEMRESATTRS_AWS_LOG_STREAM_NAMES',
          () => uL,
          'SEMRESATTRS_CLOUD_ACCOUNT_ID',
          () => uf,
          'SEMRESATTRS_CLOUD_AVAILABILITY_ZONE',
          () => uA,
          'SEMRESATTRS_CLOUD_PLATFORM',
          () => uR,
          'SEMRESATTRS_CLOUD_PROVIDER',
          () => ug,
          'SEMRESATTRS_CLOUD_REGION',
          () => uh,
          'SEMRESATTRS_CONTAINER_ID',
          () => ux,
          'SEMRESATTRS_CONTAINER_IMAGE_NAME',
          () => uk,
          'SEMRESATTRS_CONTAINER_IMAGE_TAG',
          () => uG,
          'SEMRESATTRS_CONTAINER_NAME',
          () => uD,
          'SEMRESATTRS_CONTAINER_RUNTIME',
          () => uw,
          'SEMRESATTRS_DEPLOYMENT_ENVIRONMENT',
          () => uV,
          'SEMRESATTRS_DEVICE_ID',
          () => u$,
          'SEMRESATTRS_DEVICE_MODEL_IDENTIFIER',
          () => uB,
          'SEMRESATTRS_DEVICE_MODEL_NAME',
          () => uH,
          'SEMRESATTRS_FAAS_ID',
          () => uF,
          'SEMRESATTRS_FAAS_INSTANCE',
          () => uY,
          'SEMRESATTRS_FAAS_MAX_MEMORY',
          () => uW,
          'SEMRESATTRS_FAAS_NAME',
          () => uj,
          'SEMRESATTRS_FAAS_VERSION',
          () => uZ,
          'SEMRESATTRS_HOST_ARCH',
          () => uJ,
          'SEMRESATTRS_HOST_ID',
          () => uK,
          'SEMRESATTRS_HOST_IMAGE_ID',
          () => uq,
          'SEMRESATTRS_HOST_IMAGE_NAME',
          () => uQ,
          'SEMRESATTRS_HOST_IMAGE_VERSION',
          () => u0,
          'SEMRESATTRS_HOST_NAME',
          () => uz,
          'SEMRESATTRS_HOST_TYPE',
          () => uX,
          'SEMRESATTRS_K8S_CLUSTER_NAME',
          () => u1,
          'SEMRESATTRS_K8S_CONTAINER_NAME',
          () => u6,
          'SEMRESATTRS_K8S_CRONJOB_NAME',
          () => ll,
          'SEMRESATTRS_K8S_CRONJOB_UID',
          () => lu,
          'SEMRESATTRS_K8S_DAEMONSET_NAME',
          () => lo,
          'SEMRESATTRS_K8S_DAEMONSET_UID',
          () => li,
          'SEMRESATTRS_K8S_DEPLOYMENT_NAME',
          () => lt,
          'SEMRESATTRS_K8S_DEPLOYMENT_UID',
          () => le,
          'SEMRESATTRS_K8S_JOB_NAME',
          () => ls,
          'SEMRESATTRS_K8S_JOB_UID',
          () => la,
          'SEMRESATTRS_K8S_NAMESPACE_NAME',
          () => u4,
          'SEMRESATTRS_K8S_NODE_NAME',
          () => u2,
          'SEMRESATTRS_K8S_NODE_UID',
          () => u5,
          'SEMRESATTRS_K8S_POD_NAME',
          () => u3,
          'SEMRESATTRS_K8S_POD_UID',
          () => u9,
          'SEMRESATTRS_K8S_REPLICASET_NAME',
          () => u8,
          'SEMRESATTRS_K8S_REPLICASET_UID',
          () => u7,
          'SEMRESATTRS_K8S_STATEFULSET_NAME',
          () => lr,
          'SEMRESATTRS_K8S_STATEFULSET_UID',
          () => ln,
          'SEMRESATTRS_OS_DESCRIPTION',
          () => ld,
          'SEMRESATTRS_OS_NAME',
          () => lp,
          'SEMRESATTRS_OS_TYPE',
          () => lc,
          'SEMRESATTRS_OS_VERSION',
          () => l_,
          'SEMRESATTRS_PROCESS_COMMAND',
          () => lm,
          'SEMRESATTRS_PROCESS_COMMAND_ARGS',
          () => lf,
          'SEMRESATTRS_PROCESS_COMMAND_LINE',
          () => lg,
          'SEMRESATTRS_PROCESS_EXECUTABLE_NAME',
          () => lE,
          'SEMRESATTRS_PROCESS_EXECUTABLE_PATH',
          () => lT,
          'SEMRESATTRS_PROCESS_OWNER',
          () => lh,
          'SEMRESATTRS_PROCESS_PID',
          () => lS,
          'SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION',
          () => ly,
          'SEMRESATTRS_PROCESS_RUNTIME_NAME',
          () => lA,
          'SEMRESATTRS_PROCESS_RUNTIME_VERSION',
          () => lR,
          'SEMRESATTRS_SERVICE_INSTANCE_ID',
          () => lN,
          'SEMRESATTRS_SERVICE_NAME',
          () => lI,
          'SEMRESATTRS_SERVICE_NAMESPACE',
          () => lb,
          'SEMRESATTRS_SERVICE_VERSION',
          () => lO,
          'SEMRESATTRS_TELEMETRY_AUTO_VERSION',
          () => lM,
          'SEMRESATTRS_TELEMETRY_SDK_LANGUAGE',
          () => lC,
          'SEMRESATTRS_TELEMETRY_SDK_NAME',
          () => lv,
          'SEMRESATTRS_TELEMETRY_SDK_VERSION',
          () => lP,
          'SEMRESATTRS_WEBENGINE_DESCRIPTION',
          () => lD,
          'SEMRESATTRS_WEBENGINE_NAME',
          () => lL,
          'SEMRESATTRS_WEBENGINE_VERSION',
          () => lU,
          'SemanticResourceAttributes',
          () => lx,
          'TELEMETRYSDKLANGUAGEVALUES_CPP',
          () => c6,
          'TELEMETRYSDKLANGUAGEVALUES_DOTNET',
          () => c7,
          'TELEMETRYSDKLANGUAGEVALUES_ERLANG',
          () => c8,
          'TELEMETRYSDKLANGUAGEVALUES_GO',
          () => de,
          'TELEMETRYSDKLANGUAGEVALUES_JAVA',
          () => dt,
          'TELEMETRYSDKLANGUAGEVALUES_NODEJS',
          () => dn,
          'TELEMETRYSDKLANGUAGEVALUES_PHP',
          () => dr,
          'TELEMETRYSDKLANGUAGEVALUES_PYTHON',
          () => di,
          'TELEMETRYSDKLANGUAGEVALUES_RUBY',
          () => da,
          'TELEMETRYSDKLANGUAGEVALUES_WEBJS',
          () => ds,
          'TelemetrySdkLanguageValues',
          () => du,
        ],
        14811
      ));
    let st = 'cloud.provider',
      sn = 'cloud.account.id',
      sr = 'cloud.region',
      si = 'cloud.availability_zone',
      so = 'cloud.platform',
      sa = 'aws.ecs.container.arn',
      ss = 'aws.ecs.cluster.arn',
      su = 'aws.ecs.launchtype',
      sl = 'aws.ecs.task.arn',
      sc = 'aws.ecs.task.family',
      sd = 'aws.ecs.task.revision',
      sp = 'aws.eks.cluster.arn',
      s_ = 'aws.log.group.names',
      sS = 'aws.log.group.arns',
      sE = 'aws.log.stream.names',
      sT = 'aws.log.stream.arns',
      sm = 'container.name',
      sg = 'container.id',
      sf = 'container.runtime',
      sh = 'container.image.name',
      sA = 'container.image.tag',
      sR = 'deployment.environment',
      sy = 'device.id',
      sI = 'device.model.identifier',
      sb = 'device.model.name',
      sN = 'faas.name',
      sO = 'faas.id',
      sv = 'faas.version',
      sC = 'faas.instance',
      sP = 'faas.max_memory',
      sM = 'host.id',
      sL = 'host.name',
      sU = 'host.type',
      sD = 'host.arch',
      sx = 'host.image.name',
      sw = 'host.image.id',
      sk = 'host.image.version',
      sG = 'k8s.cluster.name',
      sV = 'k8s.node.name',
      s$ = 'k8s.node.uid',
      sB = 'k8s.namespace.name',
      sH = 'k8s.pod.uid',
      sj = 'k8s.pod.name',
      sF = 'k8s.container.name',
      sZ = 'k8s.replicaset.uid',
      sY = 'k8s.replicaset.name',
      sW = 'k8s.deployment.uid',
      sK = 'k8s.deployment.name',
      sz = 'k8s.statefulset.uid',
      sX = 'k8s.statefulset.name',
      sJ = 'k8s.daemonset.uid',
      sQ = 'k8s.daemonset.name',
      sq = 'k8s.job.uid',
      s0 = 'k8s.job.name',
      s1 = 'k8s.cronjob.uid',
      s2 = 'k8s.cronjob.name',
      s5 = 'os.type',
      s4 = 'os.description',
      s9 = 'os.name',
      s3 = 'os.version',
      s6 = 'process.pid',
      s7 = 'process.executable.name',
      s8 = 'process.executable.path',
      ue = 'process.command',
      ut = 'process.command_line',
      un = 'process.command_args',
      ur = 'process.owner',
      ui = 'process.runtime.name',
      uo = 'process.runtime.version',
      ua = 'process.runtime.description',
      us = 'service.name',
      uu = 'service.namespace',
      ul = 'service.instance.id',
      uc = 'service.version',
      ud = 'telemetry.sdk.name',
      up = 'telemetry.sdk.language',
      u_ = 'telemetry.sdk.version',
      uS = 'telemetry.auto.version',
      uE = 'webengine.name',
      uT = 'webengine.version',
      um = 'webengine.description',
      ug = st,
      uf = sn,
      uh = sr,
      uA = si,
      uR = so,
      uy = sa,
      uI = ss,
      ub = su,
      uN = sl,
      uO = sc,
      uv = sd,
      uC = sp,
      uP = s_,
      uM = sS,
      uL = sE,
      uU = sT,
      uD = sm,
      ux = sg,
      uw = sf,
      uk = sh,
      uG = sA,
      uV = sR,
      u$ = sy,
      uB = sI,
      uH = sb,
      uj = sN,
      uF = sO,
      uZ = sv,
      uY = sC,
      uW = sP,
      uK = sM,
      uz = sL,
      uX = sU,
      uJ = sD,
      uQ = sx,
      uq = sw,
      u0 = sk,
      u1 = sG,
      u2 = sV,
      u5 = s$,
      u4 = sB,
      u9 = sH,
      u3 = sj,
      u6 = sF,
      u7 = sZ,
      u8 = sY,
      le = sW,
      lt = sK,
      ln = sz,
      lr = sX,
      li = sJ,
      lo = sQ,
      la = sq,
      ls = s0,
      lu = s1,
      ll = s2,
      lc = s5,
      ld = s4,
      lp = s9,
      l_ = s3,
      lS = s6,
      lE = s7,
      lT = s8,
      lm = ue,
      lg = ut,
      lf = un,
      lh = ur,
      lA = ui,
      lR = uo,
      ly = ua,
      lI = us,
      lb = uu,
      lN = ul,
      lO = uc,
      lv = ud,
      lC = up,
      lP = u_,
      lM = uS,
      lL = uE,
      lU = uT,
      lD = um,
      lx = t([
        st,
        sn,
        sr,
        si,
        so,
        sa,
        ss,
        su,
        sl,
        sc,
        sd,
        sp,
        s_,
        sS,
        sE,
        sT,
        sm,
        sg,
        sf,
        sh,
        sA,
        sR,
        sy,
        sI,
        sb,
        sN,
        sO,
        sv,
        sC,
        sP,
        sM,
        sL,
        sU,
        sD,
        sx,
        sw,
        sk,
        sG,
        sV,
        s$,
        sB,
        sH,
        sj,
        sF,
        sZ,
        sY,
        sW,
        sK,
        sz,
        sX,
        sJ,
        sQ,
        sq,
        s0,
        s1,
        s2,
        s5,
        s4,
        s9,
        s3,
        s6,
        s7,
        s8,
        ue,
        ut,
        un,
        ur,
        ui,
        uo,
        ua,
        us,
        uu,
        ul,
        uc,
        ud,
        up,
        u_,
        uS,
        uE,
        uT,
        um,
      ]),
      lw = 'alibaba_cloud',
      lk = 'azure',
      lG = lw,
      lV = 'aws',
      l$ = lk,
      lB = 'gcp',
      lH = t([lw, 'aws', lk, 'gcp']),
      lj = 'alibaba_cloud_ecs',
      lF = 'alibaba_cloud_fc',
      lZ = 'aws_ec2',
      lY = 'aws_ecs',
      lW = 'aws_eks',
      lK = 'aws_lambda',
      lz = 'aws_elastic_beanstalk',
      lX = 'azure_vm',
      lJ = 'azure_container_instances',
      lQ = 'azure_aks',
      lq = 'azure_functions',
      l0 = 'azure_app_service',
      l1 = 'gcp_compute_engine',
      l2 = 'gcp_cloud_run',
      l5 = 'gcp_kubernetes_engine',
      l4 = 'gcp_cloud_functions',
      l9 = 'gcp_app_engine',
      l3 = lj,
      l6 = lF,
      l7 = lZ,
      l8 = lY,
      ce = lW,
      ct = lK,
      cn = lz,
      cr = lX,
      ci = lJ,
      co = lQ,
      ca = lq,
      cs = l0,
      cu = l1,
      cl = l2,
      cc = l5,
      cd = l4,
      cp = l9,
      c_ = t([lj, lF, lZ, lY, lW, lK, lz, lX, lJ, lQ, lq, l0, l1, l2, l5, l4, l9]),
      cS = 'fargate',
      cE = 'ec2',
      cT = cS,
      cm = t(['ec2', cS]),
      cg = 'amd64',
      cf = 'arm32',
      ch = 'arm64',
      cA = 'ia64',
      cR = 'ppc32',
      cy = 'ppc64',
      cI = cg,
      cb = cf,
      cN = ch,
      cO = cA,
      cv = cR,
      cC = cy,
      cP = 'x86',
      cM = t([cg, cf, ch, cA, cR, cy, 'x86']),
      cL = 'windows',
      cU = 'linux',
      cD = 'darwin',
      cx = 'freebsd',
      cw = 'netbsd',
      ck = 'openbsd',
      cG = 'dragonflybsd',
      cV = 'hpux',
      c$ = 'solaris',
      cB = 'z_os',
      cH = cL,
      cj = cU,
      cF = cD,
      cZ = cx,
      cY = cw,
      cW = ck,
      cK = cG,
      cz = cV,
      cX = 'aix',
      cJ = c$,
      cQ = cB,
      cq = t([cL, cU, cD, cx, cw, ck, cG, cV, 'aix', c$, cB]),
      c0 = 'dotnet',
      c1 = 'erlang',
      c2 = 'java',
      c5 = 'nodejs',
      c4 = 'python',
      c9 = 'ruby',
      c3 = 'webjs',
      c6 = 'cpp',
      c7 = c0,
      c8 = c1,
      de = 'go',
      dt = c2,
      dn = c5,
      dr = 'php',
      di = c4,
      da = c9,
      ds = c3,
      du = t(['cpp', c0, c1, 'go', c2, c5, 'php', c4, c9, c3]);
    (e.i(14811), e.i(74109));
    var dl = e.i(1709);
    e.s(
      [
        'METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS',
        () => dc,
        'METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES',
        () => dd,
        'METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS',
        () => dp,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS',
        () => dE,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION',
        () => dS,
        'METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE',
        () => d_,
        'METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS',
        () => dT,
        'METRIC_DB_CLIENT_OPERATION_DURATION',
        () => dm,
        'METRIC_DOTNET_ASSEMBLY_COUNT',
        () => dg,
        'METRIC_DOTNET_EXCEPTIONS',
        () => df,
        'METRIC_DOTNET_GC_COLLECTIONS',
        () => dh,
        'METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED',
        () => dA,
        'METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE',
        () => dR,
        'METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE',
        () => dy,
        'METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE',
        () => dI,
        'METRIC_DOTNET_GC_PAUSE_TIME',
        () => db,
        'METRIC_DOTNET_JIT_COMPILATION_TIME',
        () => dN,
        'METRIC_DOTNET_JIT_COMPILED_IL_SIZE',
        () => dO,
        'METRIC_DOTNET_JIT_COMPILED_METHODS',
        () => dv,
        'METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS',
        () => dC,
        'METRIC_DOTNET_PROCESS_CPU_COUNT',
        () => dP,
        'METRIC_DOTNET_PROCESS_CPU_TIME',
        () => dM,
        'METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET',
        () => dL,
        'METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH',
        () => dU,
        'METRIC_DOTNET_THREAD_POOL_THREAD_COUNT',
        () => dD,
        'METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT',
        () => dx,
        'METRIC_DOTNET_TIMER_COUNT',
        () => dw,
        'METRIC_HTTP_CLIENT_REQUEST_DURATION',
        () => dk,
        'METRIC_HTTP_SERVER_REQUEST_DURATION',
        () => dG,
        'METRIC_JVM_CLASS_COUNT',
        () => dV,
        'METRIC_JVM_CLASS_LOADED',
        () => d$,
        'METRIC_JVM_CLASS_UNLOADED',
        () => dB,
        'METRIC_JVM_CPU_COUNT',
        () => dH,
        'METRIC_JVM_CPU_RECENT_UTILIZATION',
        () => dj,
        'METRIC_JVM_CPU_TIME',
        () => dF,
        'METRIC_JVM_GC_DURATION',
        () => dZ,
        'METRIC_JVM_MEMORY_COMMITTED',
        () => dY,
        'METRIC_JVM_MEMORY_LIMIT',
        () => dW,
        'METRIC_JVM_MEMORY_USED',
        () => dK,
        'METRIC_JVM_MEMORY_USED_AFTER_LAST_GC',
        () => dz,
        'METRIC_JVM_THREAD_COUNT',
        () => dX,
        'METRIC_KESTREL_ACTIVE_CONNECTIONS',
        () => dJ,
        'METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES',
        () => dQ,
        'METRIC_KESTREL_CONNECTION_DURATION',
        () => dq,
        'METRIC_KESTREL_QUEUED_CONNECTIONS',
        () => d0,
        'METRIC_KESTREL_QUEUED_REQUESTS',
        () => d1,
        'METRIC_KESTREL_REJECTED_CONNECTIONS',
        () => d2,
        'METRIC_KESTREL_TLS_HANDSHAKE_DURATION',
        () => d5,
        'METRIC_KESTREL_UPGRADED_CONNECTIONS',
        () => d4,
        'METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS',
        () => d9,
        'METRIC_SIGNALR_SERVER_CONNECTION_DURATION',
        () => d3,
      ],
      501
    );
    let dc = 'aspnetcore.diagnostics.exceptions',
      dd = 'aspnetcore.rate_limiting.active_request_leases',
      dp = 'aspnetcore.rate_limiting.queued_requests',
      d_ = 'aspnetcore.rate_limiting.request.time_in_queue',
      dS = 'aspnetcore.rate_limiting.request_lease.duration',
      dE = 'aspnetcore.rate_limiting.requests',
      dT = 'aspnetcore.routing.match_attempts',
      dm = 'db.client.operation.duration',
      dg = 'dotnet.assembly.count',
      df = 'dotnet.exceptions',
      dh = 'dotnet.gc.collections',
      dA = 'dotnet.gc.heap.total_allocated',
      dR = 'dotnet.gc.last_collection.heap.fragmentation.size',
      dy = 'dotnet.gc.last_collection.heap.size',
      dI = 'dotnet.gc.last_collection.memory.committed_size',
      db = 'dotnet.gc.pause.time',
      dN = 'dotnet.jit.compilation.time',
      dO = 'dotnet.jit.compiled_il.size',
      dv = 'dotnet.jit.compiled_methods',
      dC = 'dotnet.monitor.lock_contentions',
      dP = 'dotnet.process.cpu.count',
      dM = 'dotnet.process.cpu.time',
      dL = 'dotnet.process.memory.working_set',
      dU = 'dotnet.thread_pool.queue.length',
      dD = 'dotnet.thread_pool.thread.count',
      dx = 'dotnet.thread_pool.work_item.count',
      dw = 'dotnet.timer.count',
      dk = 'http.client.request.duration',
      dG = 'http.server.request.duration',
      dV = 'jvm.class.count',
      d$ = 'jvm.class.loaded',
      dB = 'jvm.class.unloaded',
      dH = 'jvm.cpu.count',
      dj = 'jvm.cpu.recent_utilization',
      dF = 'jvm.cpu.time',
      dZ = 'jvm.gc.duration',
      dY = 'jvm.memory.committed',
      dW = 'jvm.memory.limit',
      dK = 'jvm.memory.used',
      dz = 'jvm.memory.used_after_last_gc',
      dX = 'jvm.thread.count',
      dJ = 'kestrel.active_connections',
      dQ = 'kestrel.active_tls_handshakes',
      dq = 'kestrel.connection.duration',
      d0 = 'kestrel.queued_connections',
      d1 = 'kestrel.queued_requests',
      d2 = 'kestrel.rejected_connections',
      d5 = 'kestrel.tls_handshake.duration',
      d4 = 'kestrel.upgraded_connections',
      d9 = 'signalr.server.active_connections',
      d3 = 'signalr.server.connection.duration';
    (e.i(501), e.s(['EVENT_EXCEPTION', () => d6], 15137));
    let d6 = 'exception';
    e.i(15137);
  },
  69416,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.HTTP_FLAVOR_VALUE_HTTP_1_1 =
        n.NET_TRANSPORT_VALUE_IP_UDP =
        n.NET_TRANSPORT_VALUE_IP_TCP =
        n.ATTR_NET_TRANSPORT =
        n.ATTR_NET_PEER_PORT =
        n.ATTR_NET_PEER_NAME =
        n.ATTR_NET_PEER_IP =
        n.ATTR_NET_HOST_PORT =
        n.ATTR_NET_HOST_NAME =
        n.ATTR_NET_HOST_IP =
        n.ATTR_HTTP_USER_AGENT =
        n.ATTR_HTTP_URL =
        n.ATTR_HTTP_TARGET =
        n.ATTR_HTTP_STATUS_CODE =
        n.ATTR_HTTP_SERVER_NAME =
        n.ATTR_HTTP_SCHEME =
        n.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =
        n.ATTR_HTTP_RESPONSE_CONTENT_LENGTH =
        n.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =
        n.ATTR_HTTP_REQUEST_CONTENT_LENGTH =
        n.ATTR_HTTP_METHOD =
        n.ATTR_HTTP_HOST =
        n.ATTR_HTTP_FLAVOR =
        n.ATTR_HTTP_CLIENT_IP =
        n.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST =
        n.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT =
        n.ATTR_USER_AGENT_SYNTHETIC_TYPE =
          void 0),
      (n.ATTR_USER_AGENT_SYNTHETIC_TYPE = 'user_agent.synthetic.type'),
      (n.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT = 'bot'),
      (n.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST = 'test'),
      (n.ATTR_HTTP_CLIENT_IP = 'http.client_ip'),
      (n.ATTR_HTTP_FLAVOR = 'http.flavor'),
      (n.ATTR_HTTP_HOST = 'http.host'),
      (n.ATTR_HTTP_METHOD = 'http.method'),
      (n.ATTR_HTTP_REQUEST_CONTENT_LENGTH = 'http.request_content_length'),
      (n.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED =
        'http.request_content_length_uncompressed'),
      (n.ATTR_HTTP_RESPONSE_CONTENT_LENGTH = 'http.response_content_length'),
      (n.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED =
        'http.response_content_length_uncompressed'),
      (n.ATTR_HTTP_SCHEME = 'http.scheme'),
      (n.ATTR_HTTP_SERVER_NAME = 'http.server_name'),
      (n.ATTR_HTTP_STATUS_CODE = 'http.status_code'),
      (n.ATTR_HTTP_TARGET = 'http.target'),
      (n.ATTR_HTTP_URL = 'http.url'),
      (n.ATTR_HTTP_USER_AGENT = 'http.user_agent'),
      (n.ATTR_NET_HOST_IP = 'net.host.ip'),
      (n.ATTR_NET_HOST_NAME = 'net.host.name'),
      (n.ATTR_NET_HOST_PORT = 'net.host.port'),
      (n.ATTR_NET_PEER_IP = 'net.peer.ip'),
      (n.ATTR_NET_PEER_NAME = 'net.peer.name'),
      (n.ATTR_NET_PEER_PORT = 'net.peer.port'),
      (n.ATTR_NET_TRANSPORT = 'net.transport'),
      (n.NET_TRANSPORT_VALUE_IP_TCP = 'ip_tcp'),
      (n.NET_TRANSPORT_VALUE_IP_UDP = 'ip_udp'),
      (n.HTTP_FLAVOR_VALUE_HTTP_1_1 = '1.1'));
  },
  69866,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.HTTP_ERROR_NAME = 'http.error_name'),
          (e.HTTP_ERROR_MESSAGE = 'http.error_message'),
          (e.HTTP_STATUS_TEXT = 'http.status_text'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  43134,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SYNTHETIC_BOT_NAMES = n.SYNTHETIC_TEST_NAMES = void 0),
      (n.SYNTHETIC_TEST_NAMES = ['alwayson']),
      (n.SYNTHETIC_BOT_NAMES = ['googlebot', 'bingbot']));
  },
  43716,
  (e, t, n) => {
    'use strict';
    function r(e, t) {
      (Error.captureStackTrace(this, r),
        (this.name = this.constructor.name),
        (this.message = e),
        (this.input = t));
    }
    (e.r(24361).inherits(r, Error), (t.exports = r));
  },
  42130,
  (e, t, n) => {
    'use strict';
    t.exports = {
      isDelimiter: function (e) {
        return (
          34 === e ||
          40 === e ||
          41 === e ||
          44 === e ||
          47 === e ||
          (e >= 58 && e <= 64) ||
          (e >= 91 && e <= 93) ||
          123 === e ||
          125 === e
        );
      },
      isTokenChar: function (e) {
        return (
          33 === e ||
          (e >= 35 && e <= 39) ||
          42 === e ||
          43 === e ||
          45 === e ||
          46 === e ||
          (e >= 48 && e <= 57) ||
          (e >= 65 && e <= 90) ||
          (e >= 94 && e <= 122) ||
          124 === e ||
          126 === e
        );
      },
      isExtended: function (e) {
        return e >= 128 && e <= 255;
      },
      isPrint: function (e) {
        return e >= 32 && e <= 126;
      },
    };
  },
  12067,
  (e, t, n) => {
    'use strict';
    var r = e.r(24361),
      i = e.r(43716),
      o = e.r(42130),
      a = o.isDelimiter,
      s = o.isTokenChar,
      u = o.isExtended,
      l = o.isPrint;
    function c(e) {
      return e.replace(/\\(.)/g, '$1');
    }
    function d(e, t) {
      return r.format("Unexpected character '%s' at index %d", e.charAt(t), t);
    }
    t.exports = function (e) {
      for (
        var t, n, r = !1, o = !1, p = !1, _ = {}, S = [], E = -1, T = -1, m = 0;
        m < e.length;
        m++
      )
        if (((n = e.charCodeAt(m)), void 0 === t)) {
          if (0 !== m && -1 === E && (32 === n || 9 === n)) continue;
          if (s(n)) -1 === E && (E = m);
          else if (61 === n && -1 !== E) ((t = e.slice(E, m).toLowerCase()), (E = -1));
          else throw new i(d(e, m), e);
        } else if (o && (9 === n || l(n) || u(n))) o = !1;
        else if (s(n)) {
          if (-1 !== T) throw new i(d(e, m), e);
          -1 === E && (E = m);
        } else if (a(n) || u(n))
          if (p)
            34 === n
              ? ((p = !1), (T = m))
              : 92 === n
                ? (-1 === E && (E = m), (o = r = !0))
                : -1 === E && (E = m);
          else if (34 === n && 61 === e.charCodeAt(m - 1)) p = !0;
          else if ((44 === n || 59 === n) && (-1 !== E || -1 !== T))
            (-1 !== E
              ? (-1 === T && (T = m), (_[t] = r ? c(e.slice(E, T)) : e.slice(E, T)))
              : (_[t] = ''),
              44 === n && (S.push(_), (_ = {})),
              (t = void 0),
              (E = T = -1));
          else throw new i(d(e, m), e);
        else if (32 === n || 9 === n) {
          if (-1 !== T) continue;
          if (p) -1 === E && (E = m);
          else if (-1 !== E) T = m;
          else throw new i(d(e, m), e);
        } else throw new i(d(e, m), e);
      if (void 0 === t || p || (-1 === E && -1 === T) || 32 === n || 9 === n)
        throw new i('Unexpected end of input', e);
      return (
        -1 !== E
          ? (-1 === T && (T = m), (_[t] = r ? c(e.slice(E, T)) : e.slice(E, T)))
          : (_[t] = ''),
        S.push(_),
        S
      );
    };
  },
  95135,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.headerCapture =
        n.getIncomingStableRequestMetricAttributesOnResponse =
        n.getIncomingRequestMetricAttributesOnResponse =
        n.getIncomingRequestAttributesOnResponse =
        n.getIncomingRequestMetricAttributes =
        n.getIncomingRequestAttributes =
        n.getRemoteClientAddress =
        n.getOutgoingStableRequestMetricAttributesOnResponse =
        n.getOutgoingRequestMetricAttributesOnResponse =
        n.getOutgoingRequestAttributesOnResponse =
        n.setAttributesFromHttpKind =
        n.getOutgoingRequestMetricAttributes =
        n.getOutgoingRequestAttributes =
        n.extractHostnameAndPort =
        n.isValidOptionsType =
        n.getRequestInfo =
        n.isCompressed =
        n.setResponseContentLengthAttribute =
        n.setRequestContentLengthAttribute =
        n.setSpanWithError =
        n.satisfiesPattern =
        n.parseResponseStatus =
        n.getAbsoluteUrl =
          void 0));
    let r = e.r(52305),
      i = e.r(81964),
      o = e.r(69416),
      a = e.r(54234),
      s = e.r(75235),
      u = e.r(92509),
      l = e.r(69866),
      c = e.r(43134),
      d = e.r(12067);
    function p(e) {
      let t = e['content-length'];
      if (void 0 === t) return null;
      let n = parseInt(t, 10);
      return isNaN(n) ? null : n;
    }
    ((n.getAbsoluteUrl = (e, t, n = 'http:') => {
      let r = e || {},
        i = r.protocol || n,
        o = (r.port || '').toString(),
        a = r.path || '/',
        s = r.host || r.hostname || t.host || 'localhost';
      return (
        -1 === s.indexOf(':') && o && '80' !== o && '443' !== o && (s += `:${o}`),
        `${i}//${s}${a}`
      );
    }),
      (n.parseResponseStatus = (e, t) => {
        let n = e === r.SpanKind.CLIENT ? 400 : 500;
        return t && t >= 100 && t < n ? r.SpanStatusCode.UNSET : r.SpanStatusCode.ERROR;
      }),
      (n.satisfiesPattern = (e, t) => {
        if ('string' == typeof t) return t === e;
        if (t instanceof RegExp) return t.test(e);
        if ('function' == typeof t) return t(e);
        throw TypeError('Pattern is in unsupported datatype');
      }),
      (n.setSpanWithError = (e, t, n) => {
        let o = t.message;
        (n & s.SemconvStability.OLD &&
          (e.setAttribute(l.AttributeNames.HTTP_ERROR_NAME, t.name),
          e.setAttribute(l.AttributeNames.HTTP_ERROR_MESSAGE, o)),
          n & s.SemconvStability.STABLE && e.setAttribute(i.ATTR_ERROR_TYPE, t.name),
          e.setStatus({ code: r.SpanStatusCode.ERROR, message: o }),
          e.recordException(t));
      }),
      (n.setRequestContentLengthAttribute = (e, t) => {
        let r = p(e.headers);
        null !== r &&
          ((0, n.isCompressed)(e.headers)
            ? (t[o.ATTR_HTTP_REQUEST_CONTENT_LENGTH] = r)
            : (t[o.ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED] = r));
      }),
      (n.setResponseContentLengthAttribute = (e, t) => {
        let r = p(e.headers);
        null !== r &&
          ((0, n.isCompressed)(e.headers)
            ? (t[o.ATTR_HTTP_RESPONSE_CONTENT_LENGTH] = r)
            : (t[o.ATTR_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED] = r));
      }),
      (n.isCompressed = (e) => {
        let t = e['content-encoding'];
        return !!t && 'identity' !== t;
      }),
      (n.getRequestInfo = (e, t, n) => {
        let r,
          i,
          o,
          a = !1;
        if ('string' == typeof t) {
          try {
            let e = (function (e) {
              let {
                  hostname: t,
                  pathname: n,
                  port: r,
                  username: i,
                  password: o,
                  search: a,
                  protocol: s,
                  hash: u,
                  href: l,
                  origin: c,
                  host: d,
                } = new URL(e),
                p = {
                  protocol: s,
                  hostname: t && '[' === t[0] ? t.slice(1, -1) : t,
                  hash: u,
                  search: a,
                  pathname: n,
                  path: `${n || ''}${a || ''}`,
                  href: l,
                  origin: c,
                  host: d,
                };
              return (
                '' !== r && (p.port = Number(r)),
                (i || o) && (p.auth = `${decodeURIComponent(i)}:${decodeURIComponent(o)}`),
                p
              );
            })(t);
            ((o = e), (r = e.pathname || '/'));
          } catch (n) {
            ((a = !0),
              e.verbose(
                'Unable to parse URL provided to HTTP request, using fallback to determine path. Original error:',
                n
              ),
              (r = (o = { path: t }).path || '/'));
          }
          ((i = `${o.protocol || 'http:'}//${o.host}`), void 0 !== n && Object.assign(o, n));
        } else if (t instanceof u.URL)
          ((o = {
            protocol: t.protocol,
            hostname:
              'string' == typeof t.hostname && t.hostname.startsWith('[')
                ? t.hostname.slice(1, -1)
                : t.hostname,
            path: `${t.pathname || ''}${t.search || ''}`,
          }),
            '' !== t.port && (o.port = Number(t.port)),
            (t.username || t.password) && (o.auth = `${t.username}:${t.password}`),
            (r = t.pathname),
            (i = t.origin),
            void 0 !== n && Object.assign(o, n));
        else {
          let e =
            (o = Object.assign({ protocol: t.host ? 'http:' : void 0 }, t)).host ||
            (null != o.port ? `${o.hostname}${o.port}` : o.hostname);
          if (((i = `${o.protocol || 'http:'}//${e}`), !(r = t.pathname) && o.path))
            try {
              r = new URL(o.path, i).pathname || '/';
            } catch {
              r = '/';
            }
        }
        return {
          origin: i,
          pathname: r,
          method: o.method ? o.method.toUpperCase() : 'GET',
          optionsParsed: o,
          invalidUrl: a,
        };
      }),
      (n.isValidOptionsType = (e) => {
        if (!e) return !1;
        let t = typeof e;
        return 'string' === t || ('object' === t && !Array.isArray(e));
      }),
      (n.extractHostnameAndPort = (e) => {
        if (e.hostname && e.port) return { hostname: e.hostname, port: e.port };
        let t = e.host?.match(/^([^:/ ]+)(:\d{1,5})?/) || null,
          n = e.hostname || (null === t ? 'localhost' : t[1]),
          r = e.port;
        return (
          r || (r = t && t[2] ? t[2].substring(1) : 'https:' === e.protocol ? '443' : '80'),
          { hostname: n, port: r }
        );
      }),
      (n.getOutgoingRequestAttributes = (e, t, r, a) => {
        let u = t.hostname,
          l = t.port,
          c = e.method ?? 'GET',
          d = m(c),
          p = e.headers || {},
          S = p['user-agent'],
          E = (0, n.getAbsoluteUrl)(e, p, `${t.component}:`),
          T = {
            [o.ATTR_HTTP_URL]: E,
            [o.ATTR_HTTP_METHOD]: c,
            [o.ATTR_HTTP_TARGET]: e.path || '/',
            [o.ATTR_NET_PEER_NAME]: u,
            [o.ATTR_HTTP_HOST]: p.host ?? `${u}:${l}`,
          },
          g = {
            [i.ATTR_HTTP_REQUEST_METHOD]: d,
            [i.ATTR_SERVER_ADDRESS]: u,
            [i.ATTR_SERVER_PORT]: Number(l),
            [i.ATTR_URL_FULL]: E,
            [i.ATTR_USER_AGENT_ORIGINAL]: S,
          };
        switch (
          (c !== d && (g[i.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = c),
          a && S && (g[o.ATTR_USER_AGENT_SYNTHETIC_TYPE] = _(S)),
          void 0 !== S && (T[o.ATTR_HTTP_USER_AGENT] = S),
          r)
        ) {
          case s.SemconvStability.STABLE:
            return Object.assign(g, t.hookAttributes);
          case s.SemconvStability.OLD:
            return Object.assign(T, t.hookAttributes);
        }
        return Object.assign(T, g, t.hookAttributes);
      }),
      (n.getOutgoingRequestMetricAttributes = (e) => {
        let t = {};
        return (
          (t[o.ATTR_HTTP_METHOD] = e[o.ATTR_HTTP_METHOD]),
          (t[o.ATTR_NET_PEER_NAME] = e[o.ATTR_NET_PEER_NAME]),
          t
        );
      }),
      (n.setAttributesFromHttpKind = (e, t) => {
        e &&
          ((t[o.ATTR_HTTP_FLAVOR] = e),
          'QUIC' !== e.toUpperCase()
            ? (t[o.ATTR_NET_TRANSPORT] = o.NET_TRANSPORT_VALUE_IP_TCP)
            : (t[o.ATTR_NET_TRANSPORT] = o.NET_TRANSPORT_VALUE_IP_UDP));
      }));
    let _ = (e) => {
      let t = String(e).toLowerCase();
      for (let e of c.SYNTHETIC_TEST_NAMES)
        if (t.includes(e)) return o.USER_AGENT_SYNTHETIC_TYPE_VALUE_TEST;
      for (let e of c.SYNTHETIC_BOT_NAMES)
        if (t.includes(e)) return o.USER_AGENT_SYNTHETIC_TYPE_VALUE_BOT;
    };
    function S(e, t) {
      let n = e.split(':');
      if (1 === n.length)
        return 'http' === t
          ? { host: n[0], port: '80' }
          : 'https' === t
            ? { host: n[0], port: '443' }
            : { host: n[0] };
      if (2 === n.length) return { host: n[0], port: n[1] };
      if (n[0].startsWith('[')) {
        if (n[n.length - 1].endsWith(']')) {
          if ('http' === t) return { host: e, port: '80' };
          if ('https' === t) return { host: e, port: '443' };
        } else if (n[n.length - 2].endsWith(']'))
          return { host: n.slice(0, -1).join(':'), port: n[n.length - 1] };
      }
      return { host: e };
    }
    function E(e) {
      let t = e.headers.forwarded;
      if (t) {
        for (let e of g(t)) if (e.for) return e.for;
      }
      let n = e.headers['x-forwarded-for'];
      if ('string' == typeof n) return n;
      if (Array.isArray(n)) return n[0];
      let r = e.socket.remoteAddress;
      return r || null;
    }
    ((n.getOutgoingRequestAttributesOnResponse = (e, t) => {
      let { statusCode: r, statusMessage: a, httpVersion: u, socket: c } = e,
        d = {},
        p = {};
      if ((null != r && (p[i.ATTR_HTTP_RESPONSE_STATUS_CODE] = r), c)) {
        let { remoteAddress: t, remotePort: n } = c;
        ((d[o.ATTR_NET_PEER_IP] = t),
          (d[o.ATTR_NET_PEER_PORT] = n),
          (p[i.ATTR_NETWORK_PEER_ADDRESS] = t),
          (p[i.ATTR_NETWORK_PEER_PORT] = n),
          (p[i.ATTR_NETWORK_PROTOCOL_VERSION] = e.httpVersion));
      }
      switch (
        ((0, n.setResponseContentLengthAttribute)(e, d),
        r &&
          ((d[o.ATTR_HTTP_STATUS_CODE] = r),
          (d[l.AttributeNames.HTTP_STATUS_TEXT] = (a || '').toUpperCase())),
        (0, n.setAttributesFromHttpKind)(u, d),
        t)
      ) {
        case s.SemconvStability.STABLE:
          return p;
        case s.SemconvStability.OLD:
          return d;
      }
      return Object.assign(d, p);
    }),
      (n.getOutgoingRequestMetricAttributesOnResponse = (e) => {
        let t = {};
        return (
          (t[o.ATTR_NET_PEER_PORT] = e[o.ATTR_NET_PEER_PORT]),
          (t[o.ATTR_HTTP_STATUS_CODE] = e[o.ATTR_HTTP_STATUS_CODE]),
          (t[o.ATTR_HTTP_FLAVOR] = e[o.ATTR_HTTP_FLAVOR]),
          t
        );
      }),
      (n.getOutgoingStableRequestMetricAttributesOnResponse = (e) => {
        let t = {};
        return (
          e[i.ATTR_NETWORK_PROTOCOL_VERSION] &&
            (t[i.ATTR_NETWORK_PROTOCOL_VERSION] = e[i.ATTR_NETWORK_PROTOCOL_VERSION]),
          e[i.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
            (t[i.ATTR_HTTP_RESPONSE_STATUS_CODE] = e[i.ATTR_HTTP_RESPONSE_STATUS_CODE]),
          t
        );
      }),
      (n.getRemoteClientAddress = E),
      (n.getIncomingRequestAttributes = (e, t, r) => {
        let a = e.headers,
          u = a['user-agent'],
          l = a['x-forwarded-for'],
          c = e.httpVersion,
          d = a.host,
          p = d?.replace(/^(.*)(:[0-9]{1,5})/, '$1') || 'localhost',
          T = e.method,
          f = m(T),
          h = (function (e, t) {
            let n = e.headers.forwarded;
            if (n) {
              for (let e of g(n)) if (e.host) return S(e.host, e.proto);
            }
            let r = e.headers['x-forwarded-host'];
            if ('string' == typeof r)
              return 'string' == typeof e.headers['x-forwarded-proto']
                ? S(r, e.headers['x-forwarded-proto'])
                : Array.isArray(e.headers['x-forwarded-proto'])
                  ? S(r, e.headers['x-forwarded-proto'][0])
                  : S(r);
            if (Array.isArray(r) && 'string' == typeof r[0] && r[0].length > 0)
              return 'string' == typeof e.headers['x-forwarded-proto']
                ? S(r[0], e.headers['x-forwarded-proto'])
                : Array.isArray(e.headers['x-forwarded-proto'])
                  ? S(r[0], e.headers['x-forwarded-proto'][0])
                  : S(r[0]);
            let i = e.headers.host;
            return 'string' == typeof i && i.length > 0 ? S(i, t) : null;
          })(e, t.component),
          A = t.serverName,
          R = E(e),
          y = {
            [i.ATTR_HTTP_REQUEST_METHOD]: f,
            [i.ATTR_URL_SCHEME]: t.component,
            [i.ATTR_SERVER_ADDRESS]: h?.host,
            [i.ATTR_NETWORK_PEER_ADDRESS]: e.socket.remoteAddress,
            [i.ATTR_NETWORK_PEER_PORT]: e.socket.remotePort,
            [i.ATTR_NETWORK_PROTOCOL_VERSION]: e.httpVersion,
            [i.ATTR_USER_AGENT_ORIGINAL]: u,
          },
          I = (function (e, t, n) {
            try {
              if (t.headers.host) return new URL(t.url ?? '/', `${e}://${t.headers.host}`);
              {
                let n = new URL(t.url ?? '/', `${e}://localhost`);
                return {
                  pathname: n.pathname,
                  search: n.search,
                  toString: function () {
                    return n.pathname + n.search;
                  },
                };
              }
            } catch (e) {
              return (n.verbose('Unable to get URL from request', e), {});
            }
          })(t.component, e, r);
        (I?.pathname != null && (y[i.ATTR_URL_PATH] = I.pathname),
          I.search && (y[i.ATTR_URL_QUERY] = I.search.slice(1)),
          null != R && (y[i.ATTR_CLIENT_ADDRESS] = R.split(',')[0]),
          h?.port != null && (y[i.ATTR_SERVER_PORT] = Number(h.port)),
          T !== f && (y[i.ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = T),
          t.enableSyntheticSourceDetection && u && (y[o.ATTR_USER_AGENT_SYNTHETIC_TYPE] = _(u)));
        let b = {
          [o.ATTR_HTTP_URL]: I.toString(),
          [o.ATTR_HTTP_HOST]: d,
          [o.ATTR_NET_HOST_NAME]: p,
          [o.ATTR_HTTP_METHOD]: T,
          [o.ATTR_HTTP_SCHEME]: t.component,
        };
        switch (
          ('string' == typeof l && (b[o.ATTR_HTTP_CLIENT_IP] = l.split(',')[0]),
          'string' == typeof A && (b[o.ATTR_HTTP_SERVER_NAME] = A),
          I?.pathname && (b[o.ATTR_HTTP_TARGET] = I?.pathname + I?.search || '/'),
          void 0 !== u && (b[o.ATTR_HTTP_USER_AGENT] = u),
          (0, n.setRequestContentLengthAttribute)(e, b),
          (0, n.setAttributesFromHttpKind)(c, b),
          t.semconvStability)
        ) {
          case s.SemconvStability.STABLE:
            return Object.assign(y, t.hookAttributes);
          case s.SemconvStability.OLD:
            return Object.assign(b, t.hookAttributes);
        }
        return Object.assign(b, y, t.hookAttributes);
      }),
      (n.getIncomingRequestMetricAttributes = (e) => {
        let t = {};
        return (
          (t[o.ATTR_HTTP_SCHEME] = e[o.ATTR_HTTP_SCHEME]),
          (t[o.ATTR_HTTP_METHOD] = e[o.ATTR_HTTP_METHOD]),
          (t[o.ATTR_NET_HOST_NAME] = e[o.ATTR_NET_HOST_NAME]),
          (t[o.ATTR_HTTP_FLAVOR] = e[o.ATTR_HTTP_FLAVOR]),
          t
        );
      }),
      (n.getIncomingRequestAttributesOnResponse = (e, t, n) => {
        let { socket: u } = e,
          { statusCode: c, statusMessage: d } = t,
          p = { [i.ATTR_HTTP_RESPONSE_STATUS_CODE]: c },
          _ = (0, a.getRPCMetadata)(r.context.active()),
          S = {};
        if (u) {
          let { localAddress: e, localPort: t, remoteAddress: n, remotePort: r } = u;
          ((S[o.ATTR_NET_HOST_IP] = e),
            (S[o.ATTR_NET_HOST_PORT] = t),
            (S[o.ATTR_NET_PEER_IP] = n),
            (S[o.ATTR_NET_PEER_PORT] = r));
        }
        switch (
          ((S[o.ATTR_HTTP_STATUS_CODE] = c),
          (S[l.AttributeNames.HTTP_STATUS_TEXT] = (d || '').toUpperCase()),
          _?.type === a.RPCType.HTTP &&
            void 0 !== _.route &&
            ((S[i.ATTR_HTTP_ROUTE] = _.route), (p[i.ATTR_HTTP_ROUTE] = _.route)),
          n)
        ) {
          case s.SemconvStability.STABLE:
            return p;
          case s.SemconvStability.OLD:
            return S;
        }
        return Object.assign(S, p);
      }),
      (n.getIncomingRequestMetricAttributesOnResponse = (e) => {
        let t = {};
        return (
          (t[o.ATTR_HTTP_STATUS_CODE] = e[o.ATTR_HTTP_STATUS_CODE]),
          (t[o.ATTR_NET_HOST_PORT] = e[o.ATTR_NET_HOST_PORT]),
          void 0 !== e[i.ATTR_HTTP_ROUTE] && (t[i.ATTR_HTTP_ROUTE] = e[i.ATTR_HTTP_ROUTE]),
          t
        );
      }),
      (n.getIncomingStableRequestMetricAttributesOnResponse = (e) => {
        let t = {};
        return (
          void 0 !== e[i.ATTR_HTTP_ROUTE] && (t[i.ATTR_HTTP_ROUTE] = e[i.ATTR_HTTP_ROUTE]),
          e[i.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
            (t[i.ATTR_HTTP_RESPONSE_STATUS_CODE] = e[i.ATTR_HTTP_RESPONSE_STATUS_CODE]),
          t
        );
      }),
      (n.headerCapture = function (e, t) {
        let n = new Map();
        for (let e = 0, r = t.length; e < r; e++) {
          let r = t[e].toLowerCase();
          n.set(r, r.replace(/-/g, '_'));
        }
        return (t, r) => {
          for (let i of n.keys()) {
            let o = r(i);
            if (void 0 === o) continue;
            let a = n.get(i),
              s = `http.${e}.header.${a}`;
            'string' == typeof o
              ? t.setAttribute(s, [o])
              : Array.isArray(o)
                ? t.setAttribute(s, o)
                : t.setAttribute(s, [o]);
          }
        };
      }));
    let T = new Set([
      'GET',
      'HEAD',
      'POST',
      'PUT',
      'DELETE',
      'CONNECT',
      'OPTIONS',
      'TRACE',
      'PATCH',
    ]);
    function m(e) {
      if (null == e) return 'GET';
      let t = e.toUpperCase();
      return T.has(t) ? t : '_OTHER';
    }
    function g(e) {
      try {
        return d(e);
      } catch {
        return [];
      }
    }
  },
  21716,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.HttpInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(54234),
      o = e.r(92509),
      a = e.r(79797),
      s = e.r(75235),
      u = e.r(27699),
      l = e.r(81964),
      c = e.r(95135);
    class d extends s.InstrumentationBase {
      _spanNotEnded = new WeakSet();
      _headerCapture;
      _semconvStability = s.SemconvStability.OLD;
      constructor(e = {}) {
        (super('@opentelemetry/instrumentation-http', a.VERSION, e),
          (this._headerCapture = this._createHeaderCapture()),
          (this._semconvStability = (0, s.semconvStabilityFromStr)(
            'http',
            process.env.OTEL_SEMCONV_STABILITY_OPT_IN
          )));
      }
      _updateMetricInstruments() {
        ((this._oldHttpServerDurationHistogram = this.meter.createHistogram(
          'http.server.duration',
          {
            description: 'Measures the duration of inbound HTTP requests.',
            unit: 'ms',
            valueType: r.ValueType.DOUBLE,
          }
        )),
          (this._oldHttpClientDurationHistogram = this.meter.createHistogram(
            'http.client.duration',
            {
              description: 'Measures the duration of outbound HTTP requests.',
              unit: 'ms',
              valueType: r.ValueType.DOUBLE,
            }
          )),
          (this._stableHttpServerDurationHistogram = this.meter.createHistogram(
            l.METRIC_HTTP_SERVER_REQUEST_DURATION,
            {
              description: 'Duration of HTTP server requests.',
              unit: 's',
              valueType: r.ValueType.DOUBLE,
              advice: {
                explicitBucketBoundaries: [
                  0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,
                ],
              },
            }
          )),
          (this._stableHttpClientDurationHistogram = this.meter.createHistogram(
            l.METRIC_HTTP_CLIENT_REQUEST_DURATION,
            {
              description: 'Duration of HTTP client requests.',
              unit: 's',
              valueType: r.ValueType.DOUBLE,
              advice: {
                explicitBucketBoundaries: [
                  0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,
                ],
              },
            }
          )));
      }
      _recordServerDuration(e, t, n) {
        (this._semconvStability & s.SemconvStability.OLD &&
          this._oldHttpServerDurationHistogram.record(e, t),
          this._semconvStability & s.SemconvStability.STABLE &&
            this._stableHttpServerDurationHistogram.record(e / 1e3, n));
      }
      _recordClientDuration(e, t, n) {
        (this._semconvStability & s.SemconvStability.OLD &&
          this._oldHttpClientDurationHistogram.record(e, t),
          this._semconvStability & s.SemconvStability.STABLE &&
            this._stableHttpClientDurationHistogram.record(e / 1e3, n));
      }
      setConfig(e = {}) {
        (super.setConfig(e), (this._headerCapture = this._createHeaderCapture()));
      }
      init() {
        return [this._getHttpsInstrumentation(), this._getHttpInstrumentation()];
      }
      _getHttpInstrumentation() {
        return new s.InstrumentationNodeModuleDefinition(
          'http',
          ['*'],
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag];
            if (!this.getConfig().disableOutgoingRequestInstrumentation) {
              let n = this._wrap(e, 'request', this._getPatchOutgoingRequestFunction('http')),
                r = this._wrap(e, 'get', this._getPatchOutgoingGetFunction(n));
              t && ((e.default.request = n), (e.default.get = r));
            }
            return (
              this.getConfig().disableIncomingRequestInstrumentation ||
                this._wrap(
                  e.Server.prototype,
                  'emit',
                  this._getPatchIncomingRequestFunction('http')
                ),
              e
            );
          },
          (e) => {
            void 0 !== e &&
              (this.getConfig().disableOutgoingRequestInstrumentation ||
                (this._unwrap(e, 'request'), this._unwrap(e, 'get')),
              this.getConfig().disableIncomingRequestInstrumentation ||
                this._unwrap(e.Server.prototype, 'emit'));
          }
        );
      }
      _getHttpsInstrumentation() {
        return new s.InstrumentationNodeModuleDefinition(
          'https',
          ['*'],
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag];
            if (!this.getConfig().disableOutgoingRequestInstrumentation) {
              let n = this._wrap(e, 'request', this._getPatchHttpsOutgoingRequestFunction('https')),
                r = this._wrap(e, 'get', this._getPatchHttpsOutgoingGetFunction(n));
              t && ((e.default.request = n), (e.default.get = r));
            }
            return (
              this.getConfig().disableIncomingRequestInstrumentation ||
                this._wrap(
                  e.Server.prototype,
                  'emit',
                  this._getPatchIncomingRequestFunction('https')
                ),
              e
            );
          },
          (e) => {
            void 0 !== e &&
              (this.getConfig().disableOutgoingRequestInstrumentation ||
                (this._unwrap(e, 'request'), this._unwrap(e, 'get')),
              this.getConfig().disableIncomingRequestInstrumentation ||
                this._unwrap(e.Server.prototype, 'emit'));
          }
        );
      }
      _getPatchIncomingRequestFunction(e) {
        return (t) => this._incomingRequestFunction(e, t);
      }
      _getPatchOutgoingRequestFunction(e) {
        return (t) => this._outgoingRequestFunction(e, t);
      }
      _getPatchOutgoingGetFunction(e) {
        return (t) =>
          function (t, ...n) {
            let r = e(t, ...n);
            return (r.end(), r);
          };
      }
      _getPatchHttpsOutgoingRequestFunction(e) {
        return (t) => {
          let n = this;
          return function (r, ...i) {
            return (
              'https' === e &&
                'object' == typeof r &&
                r?.constructor?.name !== 'URL' &&
                ((r = Object.assign({}, r)), n._setDefaultOptions(r)),
              n._getPatchOutgoingRequestFunction(e)(t)(r, ...i)
            );
          };
        };
      }
      _setDefaultOptions(e) {
        ((e.protocol = e.protocol || 'https:'), (e.port = e.port || 443));
      }
      _getPatchHttpsOutgoingGetFunction(e) {
        return (t) => {
          let n = this;
          return function (r, ...i) {
            return n._getPatchOutgoingGetFunction(e)(t)(r, ...i);
          };
        };
      }
      _traceClientRequest(e, t, n, i, o) {
        this.getConfig().requestHook && this._callRequestHook(t, e);
        let a = !1;
        return (
          e.prependListener('response', (l) => {
            (this._diag.debug('outgoingRequest on response()'),
              1 >= e.listenerCount('response') && l.resume());
            let d = (0, c.getOutgoingRequestAttributesOnResponse)(l, this._semconvStability);
            (t.setAttributes(d),
              (i = Object.assign(i, (0, c.getOutgoingRequestMetricAttributesOnResponse)(d))),
              (o = Object.assign(o, (0, c.getOutgoingStableRequestMetricAttributesOnResponse)(d))),
              this.getConfig().responseHook && this._callResponseHook(t, l),
              this._headerCapture.client.captureRequestHeaders(t, (t) => e.getHeader(t)),
              this._headerCapture.client.captureResponseHeaders(t, (e) => l.headers[e]),
              r.context.bind(r.context.active(), l));
            let p = () => {
              let u;
              (this._diag.debug('outgoingRequest on end()'),
                a ||
                  ((a = !0),
                  (u =
                    l.aborted && !l.complete
                      ? { code: r.SpanStatusCode.ERROR }
                      : { code: (0, c.parseResponseStatus)(r.SpanKind.CLIENT, l.statusCode) }),
                  t.setStatus(u),
                  this.getConfig().applyCustomAttributesOnSpan &&
                    (0, s.safeExecuteInTheMiddle)(
                      () => this.getConfig().applyCustomAttributesOnSpan(t, e, l),
                      () => {},
                      !0
                    ),
                  this._closeHttpSpan(t, r.SpanKind.CLIENT, n, i, o)));
            };
            (l.on('end', p),
              l.on(u.errorMonitor, (e) => {
                (this._diag.debug('outgoingRequest on error()', e),
                  a ||
                    ((a = !0),
                    (0, c.setSpanWithError)(t, e, this._semconvStability),
                    t.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                    this._closeHttpSpan(t, r.SpanKind.CLIENT, n, i, o)));
              }));
          }),
          e.on('close', () => {
            (this._diag.debug('outgoingRequest on request close()'),
              e.aborted || a || ((a = !0), this._closeHttpSpan(t, r.SpanKind.CLIENT, n, i, o)));
          }),
          e.on(u.errorMonitor, (e) => {
            (this._diag.debug('outgoingRequest on request error()', e),
              a ||
                ((a = !0),
                (0, c.setSpanWithError)(t, e, this._semconvStability),
                this._closeHttpSpan(t, r.SpanKind.CLIENT, n, i, o)));
          }),
          this._diag.debug('http.ClientRequest return request'),
          e
        );
      }
      _incomingRequestFunction(e, t) {
        let n = this;
        return function (o, ...a) {
          if ('request' !== o) return t.apply(this, [o, ...a]);
          let d = a[0],
            p = a[1],
            _ = d.method || 'GET';
          if (
            (n._diag.debug(`${e} instrumentation incomingRequest`),
            (0, s.safeExecuteInTheMiddle)(
              () => n.getConfig().ignoreIncomingRequestHook?.(d),
              (e) => {
                null != e && n._diag.error('caught ignoreIncomingRequestHook error: ', e);
              },
              !0
            ))
          )
            return r.context.with(
              (0, i.suppressTracing)(r.context.active()),
              () => (
                r.context.bind(r.context.active(), d),
                r.context.bind(r.context.active(), p),
                t.apply(this, [o, ...a])
              )
            );
          let S = d.headers,
            E = (0, c.getIncomingRequestAttributes)(
              d,
              {
                component: e,
                serverName: n.getConfig().serverName,
                hookAttributes: n._callStartSpanHook(d, n.getConfig().startIncomingSpanHook),
                semconvStability: n._semconvStability,
                enableSyntheticSourceDetection: n.getConfig().enableSyntheticSourceDetection || !1,
              },
              n._diag
            ),
            T = { kind: r.SpanKind.SERVER, attributes: E },
            m = (0, i.hrTime)(),
            g = (0, c.getIncomingRequestMetricAttributes)(E),
            f = {
              [l.ATTR_HTTP_REQUEST_METHOD]: E[l.ATTR_HTTP_REQUEST_METHOD],
              [l.ATTR_URL_SCHEME]: E[l.ATTR_URL_SCHEME],
            };
          E[l.ATTR_NETWORK_PROTOCOL_VERSION] &&
            (f[l.ATTR_NETWORK_PROTOCOL_VERSION] = E[l.ATTR_NETWORK_PROTOCOL_VERSION]);
          let h = r.propagation.extract(r.ROOT_CONTEXT, S),
            A = n._startHttpSpan(_, T, h),
            R = { type: i.RPCType.HTTP, span: A };
          return r.context.with((0, i.setRPCMetadata)(r.trace.setSpan(h, A), R), () => {
            (r.context.bind(r.context.active(), d),
              r.context.bind(r.context.active(), p),
              n.getConfig().requestHook && n._callRequestHook(A, d),
              n.getConfig().responseHook && n._callResponseHook(A, p),
              n._headerCapture.server.captureRequestHeaders(A, (e) => d.headers[e]));
            let e = !1;
            return (
              p.on('close', () => {
                e || n._onServerResponseFinish(d, p, A, g, f, m);
              }),
              p.on(u.errorMonitor, (t) => {
                ((e = !0), n._onServerResponseError(A, g, f, m, t));
              }),
              (0, s.safeExecuteInTheMiddle)(
                () => t.apply(this, [o, ...a]),
                (e) => {
                  if (e)
                    throw (
                      (0, c.setSpanWithError)(A, e, n._semconvStability),
                      n._closeHttpSpan(A, r.SpanKind.SERVER, m, g, f),
                      e
                    );
                }
              )
            );
          });
        };
      }
      _outgoingRequestFunction(e, t) {
        let n = this;
        return function (a, ...u) {
          if (!(0, c.isValidOptionsType)(a)) return t.apply(this, [a, ...u]);
          let d =
              'object' == typeof u[0] && ('string' == typeof a || a instanceof o.URL)
                ? u.shift()
                : void 0,
            { method: p, invalidUrl: _, optionsParsed: S } = (0, c.getRequestInfo)(n._diag, a, d);
          if (
            (0, s.safeExecuteInTheMiddle)(
              () => n.getConfig().ignoreOutgoingRequestHook?.(S),
              (e) => {
                null != e && n._diag.error('caught ignoreOutgoingRequestHook error: ', e);
              },
              !0
            )
          )
            return t.apply(this, [S, ...u]);
          let { hostname: E, port: T } = (0, c.extractHostnameAndPort)(S),
            m = (0, c.getOutgoingRequestAttributes)(
              S,
              {
                component: e,
                port: T,
                hostname: E,
                hookAttributes: n._callStartSpanHook(S, n.getConfig().startOutgoingSpanHook),
              },
              n._semconvStability,
              n.getConfig().enableSyntheticSourceDetection || !1
            ),
            g = (0, i.hrTime)(),
            f = (0, c.getOutgoingRequestMetricAttributes)(m),
            h = {
              [l.ATTR_HTTP_REQUEST_METHOD]: m[l.ATTR_HTTP_REQUEST_METHOD],
              [l.ATTR_SERVER_ADDRESS]: m[l.ATTR_SERVER_ADDRESS],
              [l.ATTR_SERVER_PORT]: m[l.ATTR_SERVER_PORT],
            };
          (m[l.ATTR_HTTP_RESPONSE_STATUS_CODE] &&
            (h[l.ATTR_HTTP_RESPONSE_STATUS_CODE] = m[l.ATTR_HTTP_RESPONSE_STATUS_CODE]),
            m[l.ATTR_NETWORK_PROTOCOL_VERSION] &&
              (h[l.ATTR_NETWORK_PROTOCOL_VERSION] = m[l.ATTR_NETWORK_PROTOCOL_VERSION]));
          let A = { kind: r.SpanKind.CLIENT, attributes: m },
            R = n._startHttpSpan(p, A),
            y = r.context.active(),
            I = r.trace.setSpan(y, R);
          return (
            S.headers ? (S.headers = Object.assign({}, S.headers)) : (S.headers = {}),
            r.propagation.inject(I, S.headers),
            r.context.with(I, () => {
              let i = u[u.length - 1];
              'function' == typeof i && (u[u.length - 1] = r.context.bind(y, i));
              let o = (0, s.safeExecuteInTheMiddle)(
                () => (_ ? t.apply(this, [a, ...u]) : t.apply(this, [S, ...u])),
                (e) => {
                  if (e)
                    throw (
                      (0, c.setSpanWithError)(R, e, n._semconvStability),
                      n._closeHttpSpan(R, r.SpanKind.CLIENT, g, f, h),
                      e
                    );
                }
              );
              return (
                n._diag.debug(`${e} instrumentation outgoingRequest`),
                r.context.bind(y, o),
                n._traceClientRequest(o, R, g, f, h)
              );
            })
          );
        };
      }
      _onServerResponseFinish(e, t, n, i, o, a) {
        let u = (0, c.getIncomingRequestAttributesOnResponse)(e, t, this._semconvStability);
        ((i = Object.assign(i, (0, c.getIncomingRequestMetricAttributesOnResponse)(u))),
          (o = Object.assign(o, (0, c.getIncomingStableRequestMetricAttributesOnResponse)(u))),
          this._headerCapture.server.captureResponseHeaders(n, (e) => t.getHeader(e)),
          n
            .setAttributes(u)
            .setStatus({ code: (0, c.parseResponseStatus)(r.SpanKind.SERVER, t.statusCode) }));
        let d = u[l.ATTR_HTTP_ROUTE];
        (d && n.updateName(`${e.method || 'GET'} ${d}`),
          this.getConfig().applyCustomAttributesOnSpan &&
            (0, s.safeExecuteInTheMiddle)(
              () => this.getConfig().applyCustomAttributesOnSpan(n, e, t),
              () => {},
              !0
            ),
          this._closeHttpSpan(n, r.SpanKind.SERVER, a, i, o));
      }
      _onServerResponseError(e, t, n, i, o) {
        ((0, c.setSpanWithError)(e, o, this._semconvStability),
          this._closeHttpSpan(e, r.SpanKind.SERVER, i, t, n));
      }
      _startHttpSpan(e, t, n = r.context.active()) {
        let i,
          o =
            t.kind === r.SpanKind.CLIENT
              ? this.getConfig().requireParentforOutgoingSpans
              : this.getConfig().requireParentforIncomingSpans,
          a = r.trace.getSpan(n);
        return (
          (i =
            !0 === o && void 0 === a
              ? r.trace.wrapSpanContext(r.INVALID_SPAN_CONTEXT)
              : !0 === o && a?.spanContext().isRemote
                ? a
                : this.tracer.startSpan(e, t, n)),
          this._spanNotEnded.add(i),
          i
        );
      }
      _closeHttpSpan(e, t, n, o, a) {
        if (!this._spanNotEnded.has(e)) return;
        (e.end(), this._spanNotEnded.delete(e));
        let s = (0, i.hrTimeToMilliseconds)((0, i.hrTimeDuration)(n, (0, i.hrTime)()));
        t === r.SpanKind.SERVER
          ? this._recordServerDuration(s, o, a)
          : t === r.SpanKind.CLIENT && this._recordClientDuration(s, o, a);
      }
      _callResponseHook(e, t) {
        (0, s.safeExecuteInTheMiddle)(
          () => this.getConfig().responseHook(e, t),
          () => {},
          !0
        );
      }
      _callRequestHook(e, t) {
        (0, s.safeExecuteInTheMiddle)(
          () => this.getConfig().requestHook(e, t),
          () => {},
          !0
        );
      }
      _callStartSpanHook(e, t) {
        if ('function' == typeof t)
          return (0, s.safeExecuteInTheMiddle)(
            () => t(e),
            () => {},
            !0
          );
      }
      _createHeaderCapture() {
        let e = this.getConfig();
        return {
          client: {
            captureRequestHeaders: (0, c.headerCapture)(
              'request',
              e.headersToSpanAttributes?.client?.requestHeaders ?? []
            ),
            captureResponseHeaders: (0, c.headerCapture)(
              'response',
              e.headersToSpanAttributes?.client?.responseHeaders ?? []
            ),
          },
          server: {
            captureRequestHeaders: (0, c.headerCapture)(
              'request',
              e.headersToSpanAttributes?.server?.requestHeaders ?? []
            ),
            captureResponseHeaders: (0, c.headerCapture)(
              'response',
              e.headersToSpanAttributes?.server?.responseHeaders ?? []
            ),
          },
        };
      }
    }
    n.HttpInstrumentation = d;
  },
  55521,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.HttpInstrumentation = void 0));
    var r = e.r(21716);
    Object.defineProperty(n, 'HttpInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.HttpInstrumentation;
      },
    });
  },
  36442,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(12057),
      i = e.r(48009);
    n.captureLog = function (e, ...t) {
      let [n, o, a] = t;
      if (Array.isArray(o)) {
        let t = { ...a };
        ((t['sentry.message.template'] = n),
          o.forEach((e, n) => {
            t[`sentry.message.parameter.${n}`] = e;
          }));
        let s = r.format(n, ...o);
        i._INTERNAL_captureLog({ level: e, message: s, attributes: t });
      } else i._INTERNAL_captureLog({ level: e, message: n, attributes: o });
    };
  },
  66227,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(36442);
    ((n.fmt = e.r(48009).fmt),
      (n.debug = function (...e) {
        r.captureLog('debug', ...e);
      }),
      (n.error = function (...e) {
        r.captureLog('error', ...e);
      }),
      (n.fatal = function (...e) {
        r.captureLog('fatal', ...e);
      }),
      (n.info = function (...e) {
        r.captureLog('info', ...e);
      }),
      (n.trace = function (...e) {
        r.captureLog('trace', ...e);
      }),
      (n.warn = function (...e) {
        r.captureLog('warn', ...e);
      }));
  },
  20503,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(75235),
      i = {};
    ((n.INSTRUMENTED = i),
      (n.generateInstrumentOnce = function (e, t, n) {
        var o, a, s, u, l;
        return n
          ? ((o = e),
            (a = t),
            (s = n),
            Object.assign(
              (e) => {
                let t = s(e),
                  n = i[o];
                if (n) return (n.setConfig(t), n);
                let u = new a(t);
                return ((i[o] = u), r.registerInstrumentations({ instrumentations: [u] }), u);
              },
              { id: o }
            ))
          : ((u = e),
            (l = t),
            Object.assign(
              (e) => {
                let t = i[u];
                if (t) return (e && t.setConfig(e), t);
                let n = l(e);
                return ((i[u] = n), r.registerInstrumentations({ instrumentations: [n] }), n);
              },
              { id: u }
            ));
      }),
      (n.instrumentWhenWrapped = function (e) {
        let t = !1,
          n = [];
        if ('function' == typeof e._wrap) {
          let r = e._wrap;
          e._wrap = (...e) => ((t = !0), n.forEach((e) => e()), (n = []), r(...e));
        } else t = !0;
        return (e) => {
          t ? e() : n.push(e);
        };
      }));
  },
  87181,
  60531,
  (e) => {
    'use strict';
    e.s(['SDK_INFO', () => n], 87181);
    var t = e.i(1709);
    let n = {
      [t.ATTR_TELEMETRY_SDK_NAME]: 'opentelemetry',
      'process.runtime.name': 'node',
      [t.ATTR_TELEMETRY_SDK_LANGUAGE]: t.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
      [t.ATTR_TELEMETRY_SDK_VERSION]: '2.1.0',
    };
    e.s(
      [
        'getBooleanFromEnv',
        () => s,
        'getNumberFromEnv',
        () => o,
        'getStringFromEnv',
        () => a,
        'getStringListFromEnv',
        () => u,
      ],
      60531
    );
    var r = e.i(43170),
      i = e.i(24361);
    function o(e) {
      let t = process.env[e];
      if (null == t || '' === t.trim()) return;
      let n = Number(t);
      return isNaN(n)
        ? void r.diag.warn(
            `Unknown value ${(0, i.inspect)(t)} for ${e}, expected a number, using defaults`
          )
        : n;
    }
    function a(e) {
      let t = process.env[e];
      if (null != t && '' !== t.trim()) return t;
    }
    function s(e) {
      let t = process.env[e]?.trim().toLowerCase();
      return (
        null != t &&
        '' !== t &&
        ('true' === t ||
          ('false' !== t &&
            (r.diag.warn(
              `Unknown value ${(0, i.inspect)(t)} for ${e}, expected 'true' or 'false', falling back to 'false' (default)`
            ),
            !1)))
      );
    }
    function u(e) {
      return a(e)
        ?.split(',')
        .map((e) => e.trim())
        .filter((e) => '' !== e);
    }
  },
  57476,
  18488,
  68961,
  73913,
  75916,
  6224,
  2239,
  57948,
  36178,
  59245,
  72576,
  (e) => {
    'use strict';
    e.s(['internal', () => s], 57476);
    var t,
      n = e.i(46827);
    e.s(
      ['isTracingSuppressed', () => a, 'suppressTracing', () => i, 'unsuppressTracing', () => o],
      18488
    );
    let r = (0, e.i(55360).createContextKey)('OpenTelemetry SDK Context Key SUPPRESS_TRACING');
    function i(e) {
      return e.setValue(r, !0);
    }
    function o(e) {
      return e.deleteValue(r);
    }
    function a(e) {
      return !0 === e.getValue(r);
    }
    let s = {
      _export: function (e, t) {
        return new Promise((r) => {
          n.context.with(i(n.context.active()), () => {
            e.export(t, (e) => {
              r(e);
            });
          });
        });
      },
    };
    e.s(['isAttributeValue', () => c, 'sanitizeAttributes', () => l], 68961);
    var u = e.i(43170);
    function l(e) {
      let t = {};
      if ('object' != typeof e || null == e) return t;
      for (let [r, i] of Object.entries(e)) {
        var n;
        if (!('string' == typeof (n = r) && n.length > 0)) {
          u.diag.warn(`Invalid attribute key: ${r}`);
          continue;
        }
        if (!c(i)) {
          u.diag.warn(`Invalid attribute value set for key: ${r}`);
          continue;
        }
        Array.isArray(i) ? (t[r] = i.slice()) : (t[r] = i);
      }
      return t;
    }
    function c(e) {
      return (
        null == e ||
        (Array.isArray(e)
          ? (function (e) {
              let t;
              for (let n of e)
                if (null != n) {
                  if (!t) {
                    if (d(n)) {
                      t = typeof n;
                      continue;
                    }
                    return !1;
                  }
                  if (typeof n !== t) return !1;
                }
              return !0;
            })(e)
          : d(e))
      );
    }
    function d(e) {
      switch (typeof e) {
        case 'number':
        case 'boolean':
        case 'string':
          return !0;
      }
      return !1;
    }
    function p() {
      return (e) => {
        var t;
        u.diag.error(
          'string' == typeof (t = e)
            ? t
            : JSON.stringify(
                (function (e) {
                  let t = {},
                    n = e;
                  for (; null !== n; )
                    (Object.getOwnPropertyNames(n).forEach((e) => {
                      if (t[e]) return;
                      let r = n[e];
                      r && (t[e] = String(r));
                    }),
                      (n = Object.getPrototypeOf(n)));
                  return t;
                })(t)
              )
        );
      };
    }
    (e.s(['globalErrorHandler', () => E, 'setGlobalErrorHandler', () => S], 75916),
      e.s(['loggingErrorHandler', () => p], 73913));
    let _ = p();
    function S(e) {
      _ = e;
    }
    function E(e) {
      try {
        _(e);
      } catch {}
    }
    (e.s(
      [
        'addHrTimes',
        () => v,
        'getTimeOrigin',
        () => g,
        'hrTime',
        () => f,
        'hrTimeDuration',
        () => A,
        'hrTimeToMicroseconds',
        () => b,
        'hrTimeToMilliseconds',
        () => I,
        'hrTimeToNanoseconds',
        () => y,
        'hrTimeToTimeStamp',
        () => R,
        'isTimeInput',
        () => O,
        'isTimeInputHrTime',
        () => N,
        'millisToHrTime',
        () => m,
        'timeInputToHrTime',
        () => h,
      ],
      2239
    ),
      e.s(['otperformance', () => T], 6224));
    let T = e.i(60438).performance;
    function m(e) {
      return [Math.trunc(e / 1e3), Math.round((e % 1e3) * 1e6)];
    }
    function g() {
      let e = T.timeOrigin;
      return ('number' != typeof e && (e = T.timing && T.timing.fetchStart), e);
    }
    function f(e) {
      return v(m(g()), m('number' == typeof e ? e : T.now()));
    }
    function h(e) {
      if (N(e)) return e;
      if ('number' == typeof e)
        if (e < g()) return f(e);
        else return m(e);
      if (e instanceof Date) return m(e.getTime());
      throw TypeError('Invalid input type');
    }
    function A(e, t) {
      let n = t[0] - e[0],
        r = t[1] - e[1];
      return (r < 0 && ((n -= 1), (r += 1e9)), [n, r]);
    }
    function R(e) {
      let t = `${'0'.repeat(9)}${e[1]}Z`,
        n = t.substring(t.length - 9 - 1);
      return new Date(1e3 * e[0]).toISOString().replace('000Z', n);
    }
    function y(e) {
      return 1e9 * e[0] + e[1];
    }
    function I(e) {
      return 1e3 * e[0] + e[1] / 1e6;
    }
    function b(e) {
      return 1e6 * e[0] + e[1] / 1e3;
    }
    function N(e) {
      return (
        Array.isArray(e) && 2 === e.length && 'number' == typeof e[0] && 'number' == typeof e[1]
      );
    }
    function O(e) {
      return N(e) || 'number' == typeof e || e instanceof Date;
    }
    function v(e, t) {
      let n = [e[0] + t[0], e[1] + t[1]];
      return (n[1] >= 1e9 && ((n[1] -= 1e9), (n[0] += 1)), n);
    }
    function C(e) {
      e.unref();
    }
    (e.s(['ExportResultCode', () => t], 57948),
      (function (e) {
        ((e[(e.SUCCESS = 0)] = 'SUCCESS'), (e[(e.FAILED = 1)] = 'FAILED'));
      })(t || (t = {})),
      e.s(['unrefTimer', () => C], 36178),
      e.s(['merge', () => G], 59245));
    let P = Function.prototype.toString,
      M = P.call(Object),
      L = Object.getPrototypeOf,
      U = Object.prototype,
      D = U.hasOwnProperty,
      x = Symbol ? Symbol.toStringTag : void 0,
      w = U.toString;
    function k(e) {
      var t, n, r;
      if (
        null == (t = e) ||
        'object' != typeof t ||
        '[object Object]' !==
          (null == (n = e)
            ? void 0 === n
              ? '[object Undefined]'
              : '[object Null]'
            : x && x in Object(n)
              ? (function (e) {
                  let t = D.call(e, x),
                    n = e[x],
                    r = !1;
                  try {
                    ((e[x] = void 0), (r = !0));
                  } catch {}
                  let i = w.call(e);
                  return (r && (t ? (e[x] = n) : delete e[x]), i);
                })(n)
              : ((r = n), w.call(r)))
      )
        return !1;
      let i = L(e);
      if (null === i) return !0;
      let o = D.call(i, 'constructor') && i.constructor;
      return 'function' == typeof o && o instanceof o && P.call(o) === M;
    }
    function G(...e) {
      let t = e.shift(),
        n = new WeakMap();
      for (; e.length > 0; )
        t = (function e(t, n, r = 0, i) {
          let o;
          if (!(r > 20)) {
            if ((r++, F(t) || F(n) || H(n))) o = V(n);
            else if (B(t)) {
              if (((o = t.slice()), B(n)))
                for (let e = 0, t = n.length; e < t; e++) o.push(V(n[e]));
              else if (j(n)) {
                let e = Object.keys(n);
                for (let t = 0, r = e.length; t < r; t++) {
                  let r = e[t];
                  o[r] = V(n[r]);
                }
              }
            } else if (j(t))
              if (j(n)) {
                var a, s;
                if (((a = t), (s = n), !(k(a) && k(s)))) return n;
                o = Object.assign({}, t);
                let u = Object.keys(n);
                for (let a = 0, s = u.length; a < s; a++) {
                  let s = u[a],
                    l = n[s];
                  if (F(l)) void 0 === l ? delete o[s] : (o[s] = l);
                  else {
                    let a = o[s];
                    if ($(t, s, i) || $(n, s, i)) delete o[s];
                    else {
                      if (j(a) && j(l)) {
                        let e = i.get(a) || [],
                          r = i.get(l) || [];
                        (e.push({ obj: t, key: s }),
                          r.push({ obj: n, key: s }),
                          i.set(a, e),
                          i.set(l, r));
                      }
                      o[s] = e(o[s], l, r, i);
                    }
                  }
                }
              } else o = n;
            return o;
          }
        })(t, e.shift(), 0, n);
      return t;
    }
    function V(e) {
      return B(e) ? e.slice() : e;
    }
    function $(e, t, n) {
      let r = n.get(e[t]) || [];
      for (let n = 0, i = r.length; n < i; n++) {
        let i = r[n];
        if (i.key === t && i.obj === e) return !0;
      }
      return !1;
    }
    function B(e) {
      return Array.isArray(e);
    }
    function H(e) {
      return 'function' == typeof e;
    }
    function j(e) {
      return !F(e) && !B(e) && !H(e) && 'object' == typeof e;
    }
    function F(e) {
      return (
        'string' == typeof e ||
        'number' == typeof e ||
        'boolean' == typeof e ||
        void 0 === e ||
        e instanceof Date ||
        e instanceof RegExp ||
        null === e
      );
    }
    e.s(['BindOnceFuture', () => Y], 72576);
    class Z {
      _promise;
      _resolve;
      _reject;
      constructor() {
        this._promise = new Promise((e, t) => {
          ((this._resolve = e), (this._reject = t));
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(e) {
        this._resolve(e);
      }
      reject(e) {
        this._reject(e);
      }
    }
    class Y {
      _callback;
      _that;
      _isCalled = !1;
      _deferred = new Z();
      constructor(e, t) {
        ((this._callback = e), (this._that = t));
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...e) {
        if (!this._isCalled) {
          this._isCalled = !0;
          try {
            Promise.resolve(this._callback.call(this._that, ...e)).then(
              (e) => this._deferred.resolve(e),
              (e) => this._deferred.reject(e)
            );
          } catch (e) {
            this._deferred.reject(e);
          }
        }
        return this._deferred.promise;
      }
    }
  },
  88540,
  (e) => {
    'use strict';
    e.s(
      [
        'AnchoredClock',
        () => c,
        'BindOnceFuture',
        () => K.BindOnceFuture,
        'CompositePropagator',
        () => R,
        'ExportResultCode',
        () => E.ExportResultCode,
        'RPCType',
        () => t,
        'SDK_INFO',
        () => T.SDK_INFO,
        'TRACE_PARENT_HEADER',
        () => U,
        'TRACE_STATE_HEADER',
        () => D,
        'TimeoutError',
        () => F,
        'TraceState',
        () => L,
        'W3CBaggagePropagator',
        () => l,
        'W3CTraceContextPropagator',
        () => k,
        '_globalThis',
        () => m,
        'addHrTimes',
        () => S.addHrTimes,
        'callWithTimeout',
        () => Z,
        'deleteRPCMetadata',
        () => $,
        'diagLogLevelFromString',
        () => J,
        'getBooleanFromEnv',
        () => g.getBooleanFromEnv,
        'getNumberFromEnv',
        () => g.getNumberFromEnv,
        'getRPCMetadata',
        () => B,
        'getStringFromEnv',
        () => g.getStringFromEnv,
        'getStringListFromEnv',
        () => g.getStringListFromEnv,
        'getTimeOrigin',
        () => S.getTimeOrigin,
        'globalErrorHandler',
        () => p.globalErrorHandler,
        'hrTime',
        () => S.hrTime,
        'hrTimeDuration',
        () => S.hrTimeDuration,
        'hrTimeToMicroseconds',
        () => S.hrTimeToMicroseconds,
        'hrTimeToMilliseconds',
        () => S.hrTimeToMilliseconds,
        'hrTimeToNanoseconds',
        () => S.hrTimeToNanoseconds,
        'hrTimeToTimeStamp',
        () => S.hrTimeToTimeStamp,
        'internal',
        () => n.internal,
        'isAttributeValue',
        () => d.isAttributeValue,
        'isTimeInput',
        () => S.isTimeInput,
        'isTimeInputHrTime',
        () => S.isTimeInputHrTime,
        'isTracingSuppressed',
        () => H.isTracingSuppressed,
        'isUrlIgnored',
        () => W,
        'loggingErrorHandler',
        () => _.loggingErrorHandler,
        'merge',
        () => j.merge,
        'millisToHrTime',
        () => S.millisToHrTime,
        'otperformance',
        () => f.otperformance,
        'parseKeyPairsIntoRecord',
        () => u,
        'parseTraceParent',
        () => w,
        'sanitizeAttributes',
        () => d.sanitizeAttributes,
        'setGlobalErrorHandler',
        () => p.setGlobalErrorHandler,
        'setRPCMetadata',
        () => V,
        'suppressTracing',
        () => H.suppressTracing,
        'timeInputToHrTime',
        () => S.timeInputToHrTime,
        'unrefTimer',
        () => h.unrefTimer,
        'unsuppressTracing',
        () => H.unsuppressTracing,
        'urlMatches',
        () => Y,
      ],
      88540
    );
    var t,
      n = e.i(57476),
      r = e.i(1647),
      i = e.i(18488);
    let o = 'baggage';
    var a = e.i(49377);
    function s(e) {
      let t,
        n = e.split(';');
      if (n.length <= 0) return;
      let r = n.shift();
      if (!r) return;
      let i = r.indexOf('=');
      if (i <= 0) return;
      let o = decodeURIComponent(r.substring(0, i).trim()),
        s = decodeURIComponent(r.substring(i + 1).trim());
      return (
        n.length > 0 && (t = (0, a.baggageEntryMetadataFromString)(n.join(';'))),
        { key: o, value: s, metadata: t }
      );
    }
    function u(e) {
      let t = {};
      return (
        'string' == typeof e &&
          e.length > 0 &&
          e.split(',').forEach((e) => {
            let n = s(e);
            void 0 !== n && n.value.length > 0 && (t[n.key] = n.value);
          }),
        t
      );
    }
    class l {
      inject(e, t, n) {
        let a = r.propagation.getBaggage(e);
        if (!a || (0, i.isTracingSuppressed)(e)) return;
        let s = a
          .getAllEntries()
          .map(([e, t]) => {
            let n = `${encodeURIComponent(e)}=${encodeURIComponent(t.value)}`;
            return (void 0 !== t.metadata && (n += ';' + t.metadata.toString()), n);
          })
          .filter((e) => e.length <= 4096)
          .slice(0, 180)
          .reduce((e, t) => {
            let n = `${e}${'' !== e ? ',' : ''}${t}`;
            return n.length > 8192 ? e : n;
          }, '');
        s.length > 0 && n.set(t, o, s);
      }
      extract(e, t, n) {
        let i = n.get(t, o),
          a = Array.isArray(i) ? i.join(',') : i;
        if (!a) return e;
        let u = {};
        return 0 === a.length ||
          (a.split(',').forEach((e) => {
            let t = s(e);
            if (t) {
              let e = { value: t.value };
              (t.metadata && (e.metadata = t.metadata), (u[t.key] = e));
            }
          }),
          0 === Object.entries(u).length)
          ? e
          : r.propagation.setBaggage(e, r.propagation.createBaggage(u));
      }
      fields() {
        return [o];
      }
    }
    class c {
      _monotonicClock;
      _epochMillis;
      _performanceMillis;
      constructor(e, t) {
        ((this._monotonicClock = t),
          (this._epochMillis = e.now()),
          (this._performanceMillis = t.now()));
      }
      now() {
        let e = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + e;
      }
    }
    var d = e.i(68961),
      p = e.i(75916),
      _ = e.i(73913),
      S = e.i(2239),
      E = e.i(57948),
      T = e.i(87181);
    let m = 'object' == typeof globalThis ? globalThis : e.g;
    var g = e.i(60531),
      f = e.i(6224),
      h = e.i(36178),
      A = e.i(43170);
    class R {
      _propagators;
      _fields;
      constructor(e = {}) {
        ((this._propagators = e.propagators ?? []),
          (this._fields = Array.from(
            new Set(
              this._propagators
                .map((e) => ('function' == typeof e.fields ? e.fields() : []))
                .reduce((e, t) => e.concat(t), [])
            )
          )));
      }
      inject(e, t, n) {
        for (let r of this._propagators)
          try {
            r.inject(e, t, n);
          } catch (e) {
            A.diag.warn(`Failed to inject with ${r.constructor.name}. Err: ${e.message}`);
          }
      }
      extract(e, t, n) {
        return this._propagators.reduce((e, r) => {
          try {
            return r.extract(e, t, n);
          } catch (e) {
            A.diag.warn(`Failed to extract with ${r.constructor.name}. Err: ${e.message}`);
          }
          return e;
        }, e);
      }
      fields() {
        return this._fields.slice();
      }
    }
    var y = e.i(19718),
      I = e.i(78224),
      b = e.i(58787);
    let N = '[_0-9a-z-*/]',
      O = `[a-z]${N}{0,255}`,
      v = `[a-z0-9]${N}{0,240}@[a-z]${N}{0,13}`,
      C = RegExp(`^(?:${O}|${v})$`),
      P = /^[ -~]{0,255}[!-~]$/,
      M = /,|=/;
    class L {
      _internalState = new Map();
      constructor(e) {
        e && this._parse(e);
      }
      set(e, t) {
        let n = this._clone();
        return (
          n._internalState.has(e) && n._internalState.delete(e),
          n._internalState.set(e, t),
          n
        );
      }
      unset(e) {
        let t = this._clone();
        return (t._internalState.delete(e), t);
      }
      get(e) {
        return this._internalState.get(e);
      }
      serialize() {
        return this._keys()
          .reduce((e, t) => (e.push(t + '=' + this.get(t)), e), [])
          .join(',');
      }
      _parse(e) {
        !(e.length > 512) &&
          ((this._internalState = e
            .split(',')
            .reverse()
            .reduce((e, t) => {
              let n = t.trim(),
                r = n.indexOf('=');
              if (-1 !== r) {
                let i = n.slice(0, r),
                  o = n.slice(r + 1, t.length);
                C.test(i) && P.test(o) && !M.test(o) && e.set(i, o);
              }
              return e;
            }, new Map())),
          this._internalState.size > 32 &&
            (this._internalState = new Map(
              Array.from(this._internalState.entries()).reverse().slice(0, 32)
            )));
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        let e = new L();
        return ((e._internalState = new Map(this._internalState)), e);
      }
    }
    let U = 'traceparent',
      D = 'tracestate',
      x = RegExp(
        '^\\s?((?!ff)[\\da-f]{2})-((?![0]{32})[\\da-f]{32})-((?![0]{16})[\\da-f]{16})-([\\da-f]{2})(-.*)?\\s?$'
      );
    function w(e) {
      let t = x.exec(e);
      return !t || ('00' === t[1] && t[5])
        ? null
        : { traceId: t[2], spanId: t[3], traceFlags: parseInt(t[4], 16) };
    }
    class k {
      inject(e, t, n) {
        let r = I.trace.getSpanContext(e);
        if (!r || (0, i.isTracingSuppressed)(e) || !(0, y.isSpanContextValid)(r)) return;
        let o = `00-${r.traceId}-${r.spanId}-0${Number(r.traceFlags || b.TraceFlags.NONE).toString(16)}`;
        (n.set(t, U, o), r.traceState && n.set(t, D, r.traceState.serialize()));
      }
      extract(e, t, n) {
        let r = n.get(t, U);
        if (!r) return e;
        let i = Array.isArray(r) ? r[0] : r;
        if ('string' != typeof i) return e;
        let o = w(i);
        if (!o) return e;
        o.isRemote = !0;
        let a = n.get(t, D);
        if (a) {
          let e = Array.isArray(a) ? a.join(',') : a;
          o.traceState = new L('string' == typeof e ? e : void 0);
        }
        return I.trace.setSpanContext(e, o);
      }
      fields() {
        return [U, D];
      }
    }
    let G = (0, e.i(55360).createContextKey)('OpenTelemetry SDK Context Key RPC_METADATA');
    function V(e, t) {
      return e.setValue(G, t);
    }
    function $(e) {
      return e.deleteValue(G);
    }
    function B(e) {
      return e.getValue(G);
    }
    (t || (t = {})).HTTP = 'http';
    var H = i,
      j = e.i(59245);
    class F extends Error {
      constructor(e) {
        (super(e), Object.setPrototypeOf(this, F.prototype));
      }
    }
    function Z(e, t) {
      let n;
      return Promise.race([
        e,
        new Promise(function (e, r) {
          n = setTimeout(function () {
            r(new F('Operation timed out.'));
          }, t);
        }),
      ]).then(
        (e) => (clearTimeout(n), e),
        (e) => {
          throw (clearTimeout(n), e);
        }
      );
    }
    function Y(e, t) {
      return 'string' == typeof t ? e === t : !!e.match(t);
    }
    function W(e, t) {
      if (!t) return !1;
      for (let n of t) if (Y(e, n)) return !0;
      return !1;
    }
    var K = e.i(72576),
      z = e.i(25834);
    let X = {
      ALL: z.DiagLogLevel.ALL,
      VERBOSE: z.DiagLogLevel.VERBOSE,
      DEBUG: z.DiagLogLevel.DEBUG,
      INFO: z.DiagLogLevel.INFO,
      WARN: z.DiagLogLevel.WARN,
      ERROR: z.DiagLogLevel.ERROR,
      NONE: z.DiagLogLevel.NONE,
    };
    function J(e) {
      if (null == e) return;
      let t = X[e.toUpperCase()];
      return null == t
        ? (A.diag.warn(
            `Unknown log level "${e}", expected one of ${Object.keys(X)}, using default`
          ),
          z.DiagLogLevel.INFO)
        : t;
    }
  },
  97017,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEBUG_BUILD = 'undefined' == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__));
  },
  64077,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.getRequestUrl = function (e) {
        let t = e.protocol || '',
          n = e.hostname || e.host || '',
          r =
            !e.port || 80 === e.port || 443 === e.port || /^(.*):(\d+)$/.test(n)
              ? ''
              : `:${e.port}`,
          i = e.path ? e.path : '/';
        return `${t}//${n}${r}${i}`;
      }));
  },
  84111,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.INSTRUMENTATION_NAME = '@sentry/instrumentation-http'),
      (n.MAX_BODY_BYTE_LENGTH = 1048576));
  },
  42851,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(81964),
      a = e.r(48009),
      s = e.r(27699),
      u = e.r(97017),
      l = e.r(84111),
      c = r.createContextKey('sentry_http_server_instrumented'),
      d = new Map(),
      p = new WeakSet();
    function _({ requestIsolationScope: e, response: t, sessionFlushingDelayMS: n }) {
      (e.setSDKProcessingMetadata({ requestSession: { status: 'ok' } }),
        t.once('close', () => {
          let t = a.getClient(),
            r = e.getScopeData().sdkProcessingMetadata.requestSession;
          if (t && r) {
            u.DEBUG_BUILD && a.debug.log(`Recorded request session with status: ${r.status}`);
            let e = new Date();
            e.setSeconds(0, 0);
            let i = e.toISOString(),
              o = d.get(t),
              s = o?.[i] || { exited: 0, crashed: 0, errored: 0 };
            if ((s[{ ok: 'exited', crashed: 'crashed', errored: 'errored' }[r.status]]++, o))
              o[i] = s;
            else {
              u.DEBUG_BUILD && a.debug.log('Opened new request session aggregate.');
              let e = { [i]: s };
              d.set(t, e);
              let r = () => {
                  (clearTimeout(l), o(), d.delete(t));
                  let n = Object.entries(e).map(([e, t]) => ({
                    started: e,
                    exited: t.exited,
                    errored: t.errored,
                    crashed: t.crashed,
                  }));
                  t.sendSession({ aggregates: n });
                },
                o = t.on('flush', () => {
                  (u.DEBUG_BUILD &&
                    a.debug.log('Sending request session aggregate due to client flush'),
                    r());
                }),
                l = setTimeout(() => {
                  (u.DEBUG_BUILD &&
                    a.debug.log('Sending request session aggregate due to flushing schedule'),
                    r());
                }, n).unref();
            }
          }
        }));
    }
    function S(e) {
      let t = a.stripUrlQueryAndFragment(e);
      return !!(
        t.match(/\.(ico|png|jpg|jpeg|gif|svg|css|js|woff|woff2|ttf|eot|webp|avif)$/) ||
        t.match(/^\/(robots\.txt|sitemap\.xml|manifest\.json|browserconfig\.xml)$/)
      );
    }
    ((n.instrumentServer = function (
      e,
      {
        ignoreIncomingRequestBody: t,
        ignoreSpansForIncomingRequests: n,
        maxIncomingRequestBodySize: d = 'medium',
        trackIncomingRequestsAsSessions: E = !0,
        spans: T,
        ignoreStaticAssets: m = !0,
        sessionFlushingDelayMS: g,
        instrumentation: f,
        incomingRequestSpanHook: h,
      }
    ) {
      let A = e.emit;
      if (p.has(A)) {
        u.DEBUG_BUILD &&
          a.debug.log(
            l.INSTRUMENTATION_NAME,
            'Incoming requests already instrumented, not instrumenting again...'
          );
        return;
      }
      let { requestHook: R, responseHook: y, applyCustomAttributesOnSpan: I } = f ?? {},
        b = new Proxy(A, {
          apply(e, p, f) {
            if ('request' !== f[0] || r.context.active().getValue(c)) return e.apply(p, f);
            u.DEBUG_BUILD && a.debug.log(l.INSTRUMENTATION_NAME, 'Handling incoming request');
            let A = a.getClient(),
              b = a.getIsolationScope().clone(),
              N = f[1],
              O = f[2],
              v = a.httpRequestToRequestData(N),
              C = N.ip || N.socket?.remoteAddress,
              P = N.url || '/';
            ('none' === d ||
              t?.(P, N) ||
              (function (e, t, n) {
                let r = 0,
                  i = [];
                u.DEBUG_BUILD && a.debug.log(l.INSTRUMENTATION_NAME, 'Patching request.on');
                let o = new WeakMap(),
                  s = 'small' === n ? 1e3 : 'medium' === n ? 1e4 : l.MAX_BODY_BYTE_LENGTH;
                try {
                  ((e.on = new Proxy(e.on, {
                    apply: (e, t, n) => {
                      let [c, d, ...p] = n;
                      if ('data' === c) {
                        u.DEBUG_BUILD &&
                          a.debug.log(
                            l.INSTRUMENTATION_NAME,
                            `Handling request.on("data") with maximum body size of ${s}b`
                          );
                        let n = new Proxy(d, {
                          apply: (e, t, n) => {
                            try {
                              let e = n[0],
                                t = Buffer.from(e);
                              r < s
                                ? (i.push(t), (r += t.byteLength))
                                : u.DEBUG_BUILD &&
                                  a.debug.log(
                                    l.INSTRUMENTATION_NAME,
                                    `Dropping request body chunk because maximum body length of ${s}b is exceeded.`
                                  );
                            } catch (e) {
                              u.DEBUG_BUILD &&
                                a.debug.error(
                                  l.INSTRUMENTATION_NAME,
                                  'Encountered error while storing body chunk.'
                                );
                            }
                            return Reflect.apply(e, t, n);
                          },
                        });
                        return (o.set(d, n), Reflect.apply(e, t, [c, n, ...p]));
                      }
                      return Reflect.apply(e, t, n);
                    },
                  })),
                    (e.off = new Proxy(e.off, {
                      apply: (e, t, n) => {
                        let [, r] = n,
                          i = o.get(r);
                        if (i) {
                          o.delete(r);
                          let a = n.slice();
                          return ((a[1] = i), Reflect.apply(e, t, a));
                        }
                        return Reflect.apply(e, t, n);
                      },
                    })),
                    e.on('end', () => {
                      try {
                        let e = Buffer.concat(i).toString('utf-8');
                        if (e) {
                          let n =
                            Buffer.byteLength(e, 'utf-8') > s
                              ? `${Buffer.from(e)
                                  .subarray(0, s - 3)
                                  .toString('utf-8')}...`
                              : e;
                          t.setSDKProcessingMetadata({ normalizedRequest: { data: n } });
                        }
                      } catch (e) {
                        u.DEBUG_BUILD &&
                          a.debug.error(
                            l.INSTRUMENTATION_NAME,
                            'Error building captured request body',
                            e
                          );
                      }
                    }));
                } catch (e) {
                  u.DEBUG_BUILD &&
                    a.debug.error(
                      l.INSTRUMENTATION_NAME,
                      'Error patching request to capture body',
                      e
                    );
                }
              })(N, b, d),
              b.setSDKProcessingMetadata({ normalizedRequest: v, ipAddress: C }));
            let M = (N.method || 'GET').toUpperCase(),
              L = a.stripUrlQueryAndFragment(P),
              U = `${M} ${L}`;
            return (
              b.setTransactionName(U),
              !1 !== E &&
                _({ requestIsolationScope: b, response: O, sessionFlushingDelayMS: g ?? 6e4 }),
              a.withIsolationScope(b, () => {
                a.getCurrentScope().getPropagationContext().propagationSpanId = a.generateSpanId();
                let t = r.propagation.extract(r.context.active(), v.headers).setValue(c, !0);
                return r.context.with(t, () => {
                  if (
                    ('undefined' != typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__) ||
                    !T ||
                    !A ||
                    (function (e, { ignoreStaticAssets: t, ignoreSpansForIncomingRequests: n }) {
                      if (i.isTracingSuppressed(r.context.active())) return !0;
                      let o = e.url,
                        a = e.method?.toUpperCase();
                      return !!(
                        'OPTIONS' === a ||
                        'HEAD' === a ||
                        !o ||
                        (t && 'GET' === a && S(o)) ||
                        n?.(o, e)
                      );
                    })(N, { ignoreStaticAssets: m, ignoreSpansForIncomingRequests: n })
                  )
                    return (
                      u.DEBUG_BUILD &&
                        a.debug.log(
                          l.INSTRUMENTATION_NAME,
                          'Skipping span creation for incoming request'
                        ),
                      e.apply(p, f)
                    );
                  let t = v.url || P,
                    c = a.parseStringToURLObject(t),
                    d = N.headers,
                    _ = d['user-agent'],
                    E = d['x-forwarded-for'],
                    g = N.httpVersion,
                    b = d.host,
                    C = b?.replace(/^(.*)(:[0-9]{1,5})/, '$1') || 'localhost',
                    D = A.tracer,
                    x = t.startsWith('https') ? 'https' : 'http',
                    w = D.startSpan(U, {
                      kind: r.SpanKind.SERVER,
                      attributes: {
                        [a.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
                        [a.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.http',
                        'sentry.http.prefetch': '1' === N.headers['next-router-prefetch'] || void 0,
                        'http.url': t,
                        'http.method': M,
                        'http.target': c ? `${c.pathname}${c.search}` : L,
                        'http.host': b,
                        'net.host.name': C,
                        'http.client_ip': 'string' == typeof E ? E.split(',')[0] : void 0,
                        'http.user_agent': _,
                        'http.scheme': x,
                        'http.flavor': g,
                        'net.transport': g?.toUpperCase() === 'QUIC' ? 'ip_udp' : 'ip_tcp',
                        ...(function (e) {
                          let t = (function (e) {
                            let t = e['content-length'];
                            if (void 0 === t) return null;
                            let n = parseInt(t, 10);
                            return isNaN(n) ? null : n;
                          })(e.headers);
                          return null == t
                            ? {}
                            : !(function (e) {
                                  let t = e['content-encoding'];
                                  return !!t && 'identity' !== t;
                                })(e.headers)
                              ? { 'http.request_content_length_uncompressed': t }
                              : { 'http.request_content_length': t };
                        })(N),
                      },
                    });
                  (R?.(w, N), y?.(w, O), I?.(w, N, O), h?.(w, N, O));
                  let k = { type: i.RPCType.HTTP, span: w };
                  r.context.with(
                    i.setRPCMetadata(r.trace.setSpan(r.context.active(), w), k),
                    () => {
                      (r.context.bind(r.context.active(), N),
                        r.context.bind(r.context.active(), O));
                      let t = !1;
                      function n(e) {
                        if (t) return;
                        t = !0;
                        let n = (function (e, t) {
                          let { socket: n } = e,
                            { statusCode: a, statusMessage: s } = t,
                            u = {
                              [o.ATTR_HTTP_RESPONSE_STATUS_CODE]: a,
                              [o.SEMATTRS_HTTP_STATUS_CODE]: a,
                              'http.status_text': s?.toUpperCase(),
                            },
                            l = i.getRPCMetadata(r.context.active());
                          if (n) {
                            let {
                              localAddress: e,
                              localPort: t,
                              remoteAddress: r,
                              remotePort: i,
                            } = n;
                            ((u[o.SEMATTRS_NET_HOST_IP] = e),
                              (u[o.SEMATTRS_NET_HOST_PORT] = t),
                              (u[o.SEMATTRS_NET_PEER_IP] = r),
                              (u['net.peer.port'] = i));
                          }
                          if (
                            ((u[o.SEMATTRS_HTTP_STATUS_CODE] = a),
                            (u['http.status_text'] = (s || '').toUpperCase()),
                            l?.type === i.RPCType.HTTP && void 0 !== l.route)
                          ) {
                            let e = l.route;
                            u[o.ATTR_HTTP_ROUTE] = e;
                          }
                          return u;
                        })(N, O);
                        (w.setAttributes(n), w.setStatus(e), w.end());
                        let s = n['http.route'];
                        s &&
                          a
                            .getIsolationScope()
                            .setTransactionName(`${N.method?.toUpperCase() || 'GET'} ${s}`);
                      }
                      return (
                        O.on('close', () => {
                          n(a.getSpanStatusFromHttpCode(O.statusCode));
                        }),
                        O.on(s.errorMonitor, () => {
                          let e = a.getSpanStatusFromHttpCode(O.statusCode);
                          n(e.code === a.SPAN_STATUS_ERROR ? e : { code: a.SPAN_STATUS_ERROR });
                        }),
                        e.apply(p, f)
                      );
                    }
                  );
                });
              })
            );
          },
        });
      (p.add(b), (e.emit = b));
    }),
      (n.isStaticAssetRequest = S),
      (n.recordRequestSession = _));
  },
  31588,
  73078,
  (e) => {
    'use strict';
    e.s(
      [
        'defaultResource',
        () => c,
        'emptyResource',
        () => l,
        'resourceFromAttributes',
        () => s,
        'resourceFromDetectedResource',
        () => u,
      ],
      31588
    );
    var t = e.i(43170),
      n = e.i(87181),
      r = e.i(1709);
    function i() {
      return `unknown_service:${process.argv0}`;
    }
    e.s(['defaultServiceName', () => i], 73078);
    let o = (e) => null !== e && 'object' == typeof e && 'function' == typeof e.then;
    class a {
      _rawAttributes;
      _asyncAttributesPending = !1;
      _schemaUrl;
      _memoizedAttributes;
      static FromAttributeList(e, t) {
        let n = new a({}, t);
        return (
          (n._rawAttributes = d(e)),
          (n._asyncAttributesPending = e.filter(([e, t]) => o(t)).length > 0),
          n
        );
      }
      constructor(e, n) {
        let r = e.attributes ?? {};
        ((this._rawAttributes = Object.entries(r).map(
          ([e, t]) => (o(t) && (this._asyncAttributesPending = !0), [e, t])
        )),
          (this._rawAttributes = d(this._rawAttributes)),
          (this._schemaUrl = (function (e) {
            if ('string' == typeof e || void 0 === e) return e;
            t.diag.warn(
              'Schema URL must be string or undefined, got %s. Schema URL will be ignored.',
              e
            );
          })(n?.schemaUrl)));
      }
      get asyncAttributesPending() {
        return this._asyncAttributesPending;
      }
      async waitForAsyncAttributes() {
        if (this.asyncAttributesPending) {
          for (let e = 0; e < this._rawAttributes.length; e++) {
            let [t, n] = this._rawAttributes[e];
            this._rawAttributes[e] = [t, o(n) ? await n : n];
          }
          this._asyncAttributesPending = !1;
        }
      }
      get attributes() {
        if (
          (this.asyncAttributesPending &&
            t.diag.error('Accessing resource attributes before async attributes settled'),
          this._memoizedAttributes)
        )
          return this._memoizedAttributes;
        let e = {};
        for (let [n, r] of this._rawAttributes) {
          if (o(r)) {
            t.diag.debug(`Unsettled resource attribute ${n} skipped`);
            continue;
          }
          null != r && (e[n] ??= r);
        }
        return (this._asyncAttributesPending || (this._memoizedAttributes = e), e);
      }
      getRawAttributes() {
        return this._rawAttributes;
      }
      get schemaUrl() {
        return this._schemaUrl;
      }
      merge(e) {
        if (null == e) return this;
        let n = (function (e, n) {
          let r = e?.schemaUrl,
            i = n?.schemaUrl,
            o = void 0 === i || '' === i;
          return void 0 === r || '' === r
            ? i
            : o || r === i
              ? r
              : void t.diag.warn(
                  'Schema URL merge conflict: old resource has "%s", updating resource has "%s". Resulting resource will have undefined Schema URL.',
                  r,
                  i
                );
        })(this, e);
        return a.FromAttributeList(
          [...e.getRawAttributes(), ...this.getRawAttributes()],
          n ? { schemaUrl: n } : void 0
        );
      }
    }
    function s(e, t) {
      return a.FromAttributeList(Object.entries(e), t);
    }
    function u(e, t) {
      return new a(e, t);
    }
    function l() {
      return s({});
    }
    function c() {
      return s({
        [r.ATTR_SERVICE_NAME]: i(),
        [r.ATTR_TELEMETRY_SDK_LANGUAGE]: n.SDK_INFO[r.ATTR_TELEMETRY_SDK_LANGUAGE],
        [r.ATTR_TELEMETRY_SDK_NAME]: n.SDK_INFO[r.ATTR_TELEMETRY_SDK_NAME],
        [r.ATTR_TELEMETRY_SDK_VERSION]: n.SDK_INFO[r.ATTR_TELEMETRY_SDK_VERSION],
      });
    }
    function d(e) {
      return e.map(([e, n]) =>
        o(n)
          ? [
              e,
              n.catch((n) => {
                t.diag.debug('promise rejection for resource attribute: %s - %s', e, n);
              }),
            ]
          : [e, n]
      );
    }
  },
  18271,
  (e) => {
    'use strict';
    (e.s(
      [
        'AlwaysOffSampler',
        () => A,
        'AlwaysOnSampler',
        () => R,
        'BasicTracerProvider',
        () => w,
        'BatchSpanProcessor',
        () => B,
        'ConsoleSpanExporter',
        () => H,
        'InMemorySpanExporter',
        () => j,
        'NoopSpanProcessor',
        () => Y,
        'ParentBasedSampler',
        () => b,
        'RandomIdGenerator',
        () => M,
        'SamplingDecision',
        () => t,
        'SimpleSpanProcessor',
        () => Z,
        'TraceIdRatioBasedSampler',
        () => N,
      ],
      18271
    ),
      e.s([], 2012),
      e.i(2012));
    var t,
      n,
      r,
      i = e.i(59245),
      o = e.i(31588),
      a = e.i(46827),
      s = e.i(78224),
      u = e.i(77367),
      l = e.i(57888),
      c = e.i(58787),
      d = e.i(43170),
      p = e.i(14667),
      _ = e.i(68961),
      S = e.i(18488),
      E = e.i(94958),
      T = e.i(2239),
      m = e.i(6224),
      g = e.i(1709);
    class f {
      _spanContext;
      kind;
      parentSpanContext;
      attributes = {};
      links = [];
      events = [];
      startTime;
      resource;
      instrumentationScope;
      _droppedAttributesCount = 0;
      _droppedEventsCount = 0;
      _droppedLinksCount = 0;
      name;
      status = { code: E.SpanStatusCode.UNSET };
      endTime = [0, 0];
      _ended = !1;
      _duration = [-1, -1];
      _spanProcessor;
      _spanLimits;
      _attributeValueLengthLimit;
      _performanceStartTime;
      _performanceOffset;
      _startTimeProvided;
      constructor(e) {
        let t = Date.now();
        ((this._spanContext = e.spanContext),
          (this._performanceStartTime = m.otperformance.now()),
          (this._performanceOffset = t - (this._performanceStartTime + (0, T.getTimeOrigin)())),
          (this._startTimeProvided = null != e.startTime),
          (this._spanLimits = e.spanLimits),
          (this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0),
          (this._spanProcessor = e.spanProcessor),
          (this.name = e.name),
          (this.parentSpanContext = e.parentSpanContext),
          (this.kind = e.kind),
          (this.links = e.links || []),
          (this.startTime = this._getTime(e.startTime ?? t)),
          (this.resource = e.resource),
          (this.instrumentationScope = e.scope),
          null != e.attributes && this.setAttributes(e.attributes),
          this._spanProcessor.onStart(this, e.context));
      }
      spanContext() {
        return this._spanContext;
      }
      setAttribute(e, t) {
        if (null == t || this._isSpanEnded()) return this;
        if (0 === e.length) return (d.diag.warn(`Invalid attribute key: ${e}`), this);
        if (!(0, _.isAttributeValue)(t))
          return (d.diag.warn(`Invalid attribute value set for key: ${e}`), this);
        let { attributeCountLimit: n } = this._spanLimits;
        return (
          void 0 !== n &&
          Object.keys(this.attributes).length >= n &&
          !Object.prototype.hasOwnProperty.call(this.attributes, e)
            ? this._droppedAttributesCount++
            : (this.attributes[e] = this._truncateToSize(t)),
          this
        );
      }
      setAttributes(e) {
        for (let [t, n] of Object.entries(e)) this.setAttribute(t, n);
        return this;
      }
      addEvent(e, t, n) {
        if (this._isSpanEnded()) return this;
        let { eventCountLimit: r } = this._spanLimits;
        if (0 === r) return (d.diag.warn('No events allowed.'), this._droppedEventsCount++, this);
        (void 0 !== r &&
          this.events.length >= r &&
          (0 === this._droppedEventsCount && d.diag.debug('Dropping extra events.'),
          this.events.shift(),
          this._droppedEventsCount++),
          (0, T.isTimeInput)(t) && ((0, T.isTimeInput)(n) || (n = t), (t = void 0)));
        let i = (0, _.sanitizeAttributes)(t);
        return (
          this.events.push({
            name: e,
            attributes: i,
            time: this._getTime(n),
            droppedAttributesCount: 0,
          }),
          this
        );
      }
      addLink(e) {
        return (this.links.push(e), this);
      }
      addLinks(e) {
        return (this.links.push(...e), this);
      }
      setStatus(e) {
        return (
          this._isSpanEnded() ||
            ((this.status = { ...e }),
            null != this.status.message &&
              'string' != typeof e.message &&
              (d.diag.warn(
                `Dropping invalid status.message of type '${typeof e.message}', expected 'string'`
              ),
              delete this.status.message)),
          this
        );
      }
      updateName(e) {
        return (this._isSpanEnded() || (this.name = e), this);
      }
      end(e) {
        if (this._isSpanEnded())
          return void d.diag.error(
            `${this.name} ${this._spanContext.traceId}-${this._spanContext.spanId} - You can only call end() on a span once.`
          );
        ((this._ended = !0),
          (this.endTime = this._getTime(e)),
          (this._duration = (0, T.hrTimeDuration)(this.startTime, this.endTime)),
          this._duration[0] < 0 &&
            (d.diag.warn(
              'Inconsistent start and end time, startTime > endTime. Setting span duration to 0ms.',
              this.startTime,
              this.endTime
            ),
            (this.endTime = this.startTime.slice()),
            (this._duration = [0, 0])),
          this._droppedEventsCount > 0 &&
            d.diag.warn(
              `Dropped ${this._droppedEventsCount} events because eventCountLimit reached`
            ),
          this._spanProcessor.onEnd(this));
      }
      _getTime(e) {
        if ('number' == typeof e && e <= m.otperformance.now())
          return (0, T.hrTime)(e + this._performanceOffset);
        if ('number' == typeof e) return (0, T.millisToHrTime)(e);
        if (e instanceof Date) return (0, T.millisToHrTime)(e.getTime());
        if ((0, T.isTimeInputHrTime)(e)) return e;
        if (this._startTimeProvided) return (0, T.millisToHrTime)(Date.now());
        let t = m.otperformance.now() - this._performanceStartTime;
        return (0, T.addHrTimes)(this.startTime, (0, T.millisToHrTime)(t));
      }
      isRecording() {
        return !1 === this._ended;
      }
      recordException(e, t) {
        let n = {};
        ('string' == typeof e
          ? (n[g.ATTR_EXCEPTION_MESSAGE] = e)
          : e &&
            (e.code
              ? (n[g.ATTR_EXCEPTION_TYPE] = e.code.toString())
              : e.name && (n[g.ATTR_EXCEPTION_TYPE] = e.name),
            e.message && (n[g.ATTR_EXCEPTION_MESSAGE] = e.message),
            e.stack && (n[g.ATTR_EXCEPTION_STACKTRACE] = e.stack)),
          n[g.ATTR_EXCEPTION_TYPE] || n[g.ATTR_EXCEPTION_MESSAGE]
            ? this.addEvent('exception', n, t)
            : d.diag.warn(`Failed to record an exception ${e}`));
      }
      get duration() {
        return this._duration;
      }
      get ended() {
        return this._ended;
      }
      get droppedAttributesCount() {
        return this._droppedAttributesCount;
      }
      get droppedEventsCount() {
        return this._droppedEventsCount;
      }
      get droppedLinksCount() {
        return this._droppedLinksCount;
      }
      _isSpanEnded() {
        if (this._ended) {
          let e = Error(
            `Operation attempted on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`
          );
          d.diag.warn(
            `Cannot execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`,
            e
          );
        }
        return this._ended;
      }
      _truncateToLimitUtil(e, t) {
        return e.length <= t ? e : e.substring(0, t);
      }
      _truncateToSize(e) {
        let t = this._attributeValueLengthLimit;
        return t <= 0
          ? (d.diag.warn(`Attribute value limit must be positive, got ${t}`), e)
          : 'string' == typeof e
            ? this._truncateToLimitUtil(e, t)
            : Array.isArray(e)
              ? e.map((e) => ('string' == typeof e ? this._truncateToLimitUtil(e, t) : e))
              : e;
      }
    }
    var h = e.i(60531);
    !(function (e) {
      ((e[(e.NOT_RECORD = 0)] = 'NOT_RECORD'),
        (e[(e.RECORD = 1)] = 'RECORD'),
        (e[(e.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'));
    })(t || (t = {}));
    class A {
      shouldSample() {
        return { decision: t.NOT_RECORD };
      }
      toString() {
        return 'AlwaysOffSampler';
      }
    }
    class R {
      shouldSample() {
        return { decision: t.RECORD_AND_SAMPLED };
      }
      toString() {
        return 'AlwaysOnSampler';
      }
    }
    var y = e.i(19718),
      I = e.i(75916);
    class b {
      _root;
      _remoteParentSampled;
      _remoteParentNotSampled;
      _localParentSampled;
      _localParentNotSampled;
      constructor(e) {
        ((this._root = e.root),
          this._root ||
            ((0, I.globalErrorHandler)(
              Error('ParentBasedSampler must have a root sampler configured')
            ),
            (this._root = new R())),
          (this._remoteParentSampled = e.remoteParentSampled ?? new R()),
          (this._remoteParentNotSampled = e.remoteParentNotSampled ?? new A()),
          (this._localParentSampled = e.localParentSampled ?? new R()),
          (this._localParentNotSampled = e.localParentNotSampled ?? new A()));
      }
      shouldSample(e, t, n, r, i, o) {
        let a = s.trace.getSpanContext(e);
        return a && (0, y.isSpanContextValid)(a)
          ? a.isRemote
            ? a.traceFlags & c.TraceFlags.SAMPLED
              ? this._remoteParentSampled.shouldSample(e, t, n, r, i, o)
              : this._remoteParentNotSampled.shouldSample(e, t, n, r, i, o)
            : a.traceFlags & c.TraceFlags.SAMPLED
              ? this._localParentSampled.shouldSample(e, t, n, r, i, o)
              : this._localParentNotSampled.shouldSample(e, t, n, r, i, o)
          : this._root.shouldSample(e, t, n, r, i, o);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    }
    class N {
      _ratio;
      _upperBound;
      constructor(e = 0) {
        ((this._ratio = e),
          (this._ratio = this._normalize(e)),
          (this._upperBound = Math.floor(0xffffffff * this._ratio)));
      }
      shouldSample(e, n) {
        return {
          decision:
            (0, y.isValidTraceId)(n) && this._accumulate(n) < this._upperBound
              ? t.RECORD_AND_SAMPLED
              : t.NOT_RECORD,
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(e) {
        return 'number' != typeof e || isNaN(e) ? 0 : e >= 1 ? 1 : e <= 0 ? 0 : e;
      }
      _accumulate(e) {
        let t = 0;
        for (let n = 0; n < e.length / 8; n++) {
          let r = 8 * n;
          t = (t ^ parseInt(e.slice(r, r + 8), 16)) >>> 0;
        }
        return t;
      }
    }
    function O() {
      return {
        sampler: v(),
        forceFlushTimeoutMillis: 3e4,
        generalLimits: {
          attributeValueLengthLimit:
            (0, h.getNumberFromEnv)('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? 1 / 0,
          attributeCountLimit: (0, h.getNumberFromEnv)('OTEL_ATTRIBUTE_COUNT_LIMIT') ?? 128,
        },
        spanLimits: {
          attributeValueLengthLimit:
            (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ?? 1 / 0,
          attributeCountLimit: (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ?? 128,
          linkCountLimit: (0, h.getNumberFromEnv)('OTEL_SPAN_LINK_COUNT_LIMIT') ?? 128,
          eventCountLimit: (0, h.getNumberFromEnv)('OTEL_SPAN_EVENT_COUNT_LIMIT') ?? 128,
          attributePerEventCountLimit:
            (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT') ?? 128,
          attributePerLinkCountLimit:
            (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT') ?? 128,
        },
      };
    }
    function v() {
      let e = (0, h.getStringFromEnv)('OTEL_TRACES_SAMPLER') ?? n.ParentBasedAlwaysOn;
      switch (e) {
        case n.AlwaysOn:
          return new R();
        case n.AlwaysOff:
          return new A();
        case n.ParentBasedAlwaysOn:
          return new b({ root: new R() });
        case n.ParentBasedAlwaysOff:
          return new b({ root: new A() });
        case n.TraceIdRatio:
          return new N(C());
        case n.ParentBasedTraceIdRatio:
          return new b({ root: new N(C()) });
        default:
          return (
            d.diag.error(
              `OTEL_TRACES_SAMPLER value "${e}" invalid, defaulting to "${n.ParentBasedAlwaysOn}".`
            ),
            new b({ root: new R() })
          );
      }
    }
    function C() {
      let e = (0, h.getNumberFromEnv)('OTEL_TRACES_SAMPLER_ARG');
      return null == e
        ? (d.diag.error('OTEL_TRACES_SAMPLER_ARG is blank, defaulting to 1.'), 1)
        : e < 0 || e > 1
          ? (d.diag.error(
              `OTEL_TRACES_SAMPLER_ARG=${e} was given, but it is out of range ([0..1]), defaulting to 1.`
            ),
            1)
          : e;
    }
    !(function (e) {
      ((e.AlwaysOff = 'always_off'),
        (e.AlwaysOn = 'always_on'),
        (e.ParentBasedAlwaysOff = 'parentbased_always_off'),
        (e.ParentBasedAlwaysOn = 'parentbased_always_on'),
        (e.ParentBasedTraceIdRatio = 'parentbased_traceidratio'),
        (e.TraceIdRatio = 'traceidratio'));
    })(n || (n = {}));
    let P = 1 / 0;
    class M {
      generateTraceId = U(16);
      generateSpanId = U(8);
    }
    let L = Buffer.allocUnsafe(16);
    function U(e) {
      return function () {
        for (let t = 0; t < e / 4; t++) L.writeUInt32BE((0x100000000 * Math.random()) >>> 0, 4 * t);
        for (let t = 0; t < e; t++)
          if (L[t] > 0) break;
          else t === e - 1 && (L[e - 1] = 1);
        return L.toString('hex', 0, e);
      };
    }
    class D {
      _sampler;
      _generalLimits;
      _spanLimits;
      _idGenerator;
      instrumentationScope;
      _resource;
      _spanProcessor;
      constructor(e, t, n, r) {
        let i = (function (e) {
          let t = { sampler: v() },
            n = O(),
            r = Object.assign({}, n, t, e);
          return (
            (r.generalLimits = Object.assign({}, n.generalLimits, e.generalLimits || {})),
            (r.spanLimits = Object.assign({}, n.spanLimits, e.spanLimits || {})),
            r
          );
        })(t);
        ((this._sampler = i.sampler),
          (this._generalLimits = i.generalLimits),
          (this._spanLimits = i.spanLimits),
          (this._idGenerator = t.idGenerator || new M()),
          (this._resource = n),
          (this._spanProcessor = r),
          (this.instrumentationScope = e));
      }
      startSpan(e, t = {}, n = a.context.active()) {
        let r, i, o;
        t.root && (n = s.trace.deleteSpan(n));
        let E = s.trace.getSpan(n);
        if ((0, S.isTracingSuppressed)(n))
          return (
            d.diag.debug('Instrumentation suppressed, returning Noop Span'),
            s.trace.wrapSpanContext(p.INVALID_SPAN_CONTEXT)
          );
        let T = E?.spanContext(),
          m = this._idGenerator.generateSpanId();
        T && s.trace.isSpanContextValid(T)
          ? ((i = T.traceId), (o = T.traceState), (r = T))
          : (i = this._idGenerator.generateTraceId());
        let g = t.kind ?? u.SpanKind.INTERNAL,
          h = (t.links ?? []).map((e) => ({
            context: e.context,
            attributes: (0, _.sanitizeAttributes)(e.attributes),
          })),
          A = (0, _.sanitizeAttributes)(t.attributes),
          R = this._sampler.shouldSample(n, i, e, g, A, h);
        o = R.traceState ?? o;
        let y = {
          traceId: i,
          spanId: m,
          traceFlags:
            R.decision === l.SamplingDecision.RECORD_AND_SAMPLED
              ? c.TraceFlags.SAMPLED
              : c.TraceFlags.NONE,
          traceState: o,
        };
        if (R.decision === l.SamplingDecision.NOT_RECORD)
          return (
            d.diag.debug('Recording is off, propagating context in a non-recording span'),
            s.trace.wrapSpanContext(y)
          );
        let I = (0, _.sanitizeAttributes)(Object.assign(A, R.attributes));
        return new f({
          resource: this._resource,
          scope: this.instrumentationScope,
          context: n,
          spanContext: y,
          name: e,
          kind: g,
          links: h,
          parentSpanContext: r,
          attributes: I,
          startTime: t.startTime,
          spanProcessor: this._spanProcessor,
          spanLimits: this._spanLimits,
        });
      }
      startActiveSpan(e, t, n, r) {
        let i, o, u;
        if (arguments.length < 2) return;
        2 == arguments.length
          ? (u = t)
          : 3 == arguments.length
            ? ((i = t), (u = n))
            : ((i = t), (o = n), (u = r));
        let l = o ?? a.context.active(),
          c = this.startSpan(e, i, l),
          d = s.trace.setSpan(l, c);
        return a.context.with(d, u, void 0, c);
      }
      getGeneralLimits() {
        return this._generalLimits;
      }
      getSpanLimits() {
        return this._spanLimits;
      }
    }
    class x {
      _spanProcessors;
      constructor(e) {
        this._spanProcessors = e;
      }
      forceFlush() {
        let e = [];
        for (let t of this._spanProcessors) e.push(t.forceFlush());
        return new Promise((t) => {
          Promise.all(e)
            .then(() => {
              t();
            })
            .catch((e) => {
              ((0, I.globalErrorHandler)(e || Error('MultiSpanProcessor: forceFlush failed')), t());
            });
        });
      }
      onStart(e, t) {
        for (let n of this._spanProcessors) n.onStart(e, t);
      }
      onEnd(e) {
        for (let t of this._spanProcessors) t.onEnd(e);
      }
      shutdown() {
        let e = [];
        for (let t of this._spanProcessors) e.push(t.shutdown());
        return new Promise((t, n) => {
          Promise.all(e).then(() => {
            t();
          }, n);
        });
      }
    }
    !(function (e) {
      ((e[(e.resolved = 0)] = 'resolved'),
        (e[(e.timeout = 1)] = 'timeout'),
        (e[(e.error = 2)] = 'error'),
        (e[(e.unresolved = 3)] = 'unresolved'));
    })(r || (r = {}));
    class w {
      _config;
      _tracers = new Map();
      _resource;
      _activeSpanProcessor;
      constructor(e = {}) {
        let t = (0, i.merge)(
          {},
          O(),
          (function (e) {
            let t = Object.assign({}, e.spanLimits);
            return (
              (t.attributeCountLimit =
                e.spanLimits?.attributeCountLimit ??
                e.generalLimits?.attributeCountLimit ??
                (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT') ??
                (0, h.getNumberFromEnv)('OTEL_ATTRIBUTE_COUNT_LIMIT') ??
                128),
              (t.attributeValueLengthLimit =
                e.spanLimits?.attributeValueLengthLimit ??
                e.generalLimits?.attributeValueLengthLimit ??
                (0, h.getNumberFromEnv)('OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??
                (0, h.getNumberFromEnv)('OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT') ??
                P),
              Object.assign({}, e, { spanLimits: t })
            );
          })(e)
        );
        ((this._resource = t.resource ?? (0, o.defaultResource)()),
          (this._config = Object.assign({}, t, { resource: this._resource })));
        let n = [];
        (e.spanProcessors?.length && n.push(...e.spanProcessors),
          (this._activeSpanProcessor = new x(n)));
      }
      getTracer(e, t, n) {
        let r = `${e}@${t || ''}:${n?.schemaUrl || ''}`;
        return (
          this._tracers.has(r) ||
            this._tracers.set(
              r,
              new D(
                { name: e, version: t, schemaUrl: n?.schemaUrl },
                this._config,
                this._resource,
                this._activeSpanProcessor
              )
            ),
          this._tracers.get(r)
        );
      }
      forceFlush() {
        let e = this._config.forceFlushTimeoutMillis,
          t = this._activeSpanProcessor._spanProcessors.map(
            (t) =>
              new Promise((n) => {
                let i,
                  o = setTimeout(() => {
                    (n(Error(`Span processor did not completed within timeout period of ${e} ms`)),
                      (i = r.timeout));
                  }, e);
                t.forceFlush()
                  .then(() => {
                    (clearTimeout(o), i !== r.timeout && n((i = r.resolved)));
                  })
                  .catch((e) => {
                    (clearTimeout(o), (i = r.error), n(e));
                  });
              })
          );
        return new Promise((e, n) => {
          Promise.all(t)
            .then((t) => {
              let i = t.filter((e) => e !== r.resolved);
              i.length > 0 ? n(i) : e();
            })
            .catch((e) => n([e]));
        });
      }
      shutdown() {
        return this._activeSpanProcessor.shutdown();
      }
    }
    var k = e.i(72576),
      G = e.i(57948),
      V = e.i(36178);
    class $ {
      _exporter;
      _maxExportBatchSize;
      _maxQueueSize;
      _scheduledDelayMillis;
      _exportTimeoutMillis;
      _isExporting = !1;
      _finishedSpans = [];
      _timer;
      _shutdownOnce;
      _droppedSpansCount = 0;
      constructor(e, t) {
        ((this._exporter = e),
          (this._maxExportBatchSize =
            'number' == typeof t?.maxExportBatchSize
              ? t.maxExportBatchSize
              : ((0, h.getNumberFromEnv)('OTEL_BSP_MAX_EXPORT_BATCH_SIZE') ?? 512)),
          (this._maxQueueSize =
            'number' == typeof t?.maxQueueSize
              ? t.maxQueueSize
              : ((0, h.getNumberFromEnv)('OTEL_BSP_MAX_QUEUE_SIZE') ?? 2048)),
          (this._scheduledDelayMillis =
            'number' == typeof t?.scheduledDelayMillis
              ? t.scheduledDelayMillis
              : ((0, h.getNumberFromEnv)('OTEL_BSP_SCHEDULE_DELAY') ?? 5e3)),
          (this._exportTimeoutMillis =
            'number' == typeof t?.exportTimeoutMillis
              ? t.exportTimeoutMillis
              : ((0, h.getNumberFromEnv)('OTEL_BSP_EXPORT_TIMEOUT') ?? 3e4)),
          (this._shutdownOnce = new k.BindOnceFuture(this._shutdown, this)),
          this._maxExportBatchSize > this._maxQueueSize &&
            (d.diag.warn(
              'BatchSpanProcessor: maxExportBatchSize must be smaller or equal to maxQueueSize, setting maxExportBatchSize to match maxQueueSize'
            ),
            (this._maxExportBatchSize = this._maxQueueSize)));
      }
      forceFlush() {
        return this._shutdownOnce.isCalled ? this._shutdownOnce.promise : this._flushAll();
      }
      onStart(e, t) {}
      onEnd(e) {
        this._shutdownOnce.isCalled ||
          ((e.spanContext().traceFlags & c.TraceFlags.SAMPLED) != 0 && this._addToBuffer(e));
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return Promise.resolve()
          .then(() => this.onShutdown())
          .then(() => this._flushAll())
          .then(() => this._exporter.shutdown());
      }
      _addToBuffer(e) {
        if (this._finishedSpans.length >= this._maxQueueSize) {
          (0 === this._droppedSpansCount && d.diag.debug('maxQueueSize reached, dropping spans'),
            this._droppedSpansCount++);
          return;
        }
        (this._droppedSpansCount > 0 &&
          (d.diag.warn(`Dropped ${this._droppedSpansCount} spans because maxQueueSize reached`),
          (this._droppedSpansCount = 0)),
          this._finishedSpans.push(e),
          this._maybeStartTimer());
      }
      _flushAll() {
        return new Promise((e, t) => {
          let n = [],
            r = Math.ceil(this._finishedSpans.length / this._maxExportBatchSize);
          for (let e = 0; e < r; e++) n.push(this._flushOneBatch());
          Promise.all(n)
            .then(() => {
              e();
            })
            .catch(t);
        });
      }
      _flushOneBatch() {
        return (this._clearTimer(), 0 === this._finishedSpans.length)
          ? Promise.resolve()
          : new Promise((e, t) => {
              let n = setTimeout(() => {
                t(Error('Timeout'));
              }, this._exportTimeoutMillis);
              a.context.with((0, S.suppressTracing)(a.context.active()), () => {
                let r;
                this._finishedSpans.length <= this._maxExportBatchSize
                  ? ((r = this._finishedSpans), (this._finishedSpans = []))
                  : (r = this._finishedSpans.splice(0, this._maxExportBatchSize));
                let i = () =>
                    this._exporter.export(r, (r) => {
                      (clearTimeout(n),
                        r.code === G.ExportResultCode.SUCCESS
                          ? e()
                          : t(r.error ?? Error('BatchSpanProcessor: span export failed')));
                    }),
                  o = null;
                for (let e = 0, t = r.length; e < t; e++) {
                  let t = r[e];
                  t.resource.asyncAttributesPending &&
                    t.resource.waitForAsyncAttributes &&
                    (o ??= []).push(t.resource.waitForAsyncAttributes());
                }
                null === o
                  ? i()
                  : Promise.all(o).then(i, (e) => {
                      ((0, I.globalErrorHandler)(e), t(e));
                    });
              });
            });
      }
      _maybeStartTimer() {
        if (this._isExporting) return;
        let e = () => {
          ((this._isExporting = !0),
            this._flushOneBatch()
              .finally(() => {
                ((this._isExporting = !1),
                  this._finishedSpans.length > 0 && (this._clearTimer(), this._maybeStartTimer()));
              })
              .catch((e) => {
                ((this._isExporting = !1), (0, I.globalErrorHandler)(e));
              }));
        };
        if (this._finishedSpans.length >= this._maxExportBatchSize) return e();
        void 0 === this._timer &&
          ((this._timer = setTimeout(() => e(), this._scheduledDelayMillis)),
          (0, V.unrefTimer)(this._timer));
      }
      _clearTimer() {
        void 0 !== this._timer && (clearTimeout(this._timer), (this._timer = void 0));
      }
    }
    class B extends $ {
      onShutdown() {}
    }
    class H {
      export(e, t) {
        return this._sendSpans(e, t);
      }
      shutdown() {
        return (this._sendSpans([]), this.forceFlush());
      }
      forceFlush() {
        return Promise.resolve();
      }
      _exportInfo(e) {
        return {
          resource: { attributes: e.resource.attributes },
          instrumentationScope: e.instrumentationScope,
          traceId: e.spanContext().traceId,
          parentSpanContext: e.parentSpanContext,
          traceState: e.spanContext().traceState?.serialize(),
          name: e.name,
          id: e.spanContext().spanId,
          kind: e.kind,
          timestamp: (0, T.hrTimeToMicroseconds)(e.startTime),
          duration: (0, T.hrTimeToMicroseconds)(e.duration),
          attributes: e.attributes,
          status: e.status,
          events: e.events,
          links: e.links,
        };
      }
      _sendSpans(e, t) {
        for (let t of e) console.dir(this._exportInfo(t), { depth: 3 });
        if (t) return t({ code: G.ExportResultCode.SUCCESS });
      }
    }
    class j {
      _finishedSpans = [];
      _stopped = !1;
      export(e, t) {
        if (this._stopped)
          return t({ code: G.ExportResultCode.FAILED, error: Error('Exporter has been stopped') });
        (this._finishedSpans.push(...e),
          setTimeout(() => t({ code: G.ExportResultCode.SUCCESS }), 0));
      }
      shutdown() {
        return ((this._stopped = !0), (this._finishedSpans = []), this.forceFlush());
      }
      forceFlush() {
        return Promise.resolve();
      }
      reset() {
        this._finishedSpans = [];
      }
      getFinishedSpans() {
        return this._finishedSpans;
      }
    }
    var F = e.i(57476);
    class Z {
      _exporter;
      _shutdownOnce;
      _pendingExports;
      constructor(e) {
        ((this._exporter = e),
          (this._shutdownOnce = new k.BindOnceFuture(this._shutdown, this)),
          (this._pendingExports = new Set()));
      }
      async forceFlush() {
        (await Promise.all(Array.from(this._pendingExports)),
          this._exporter.forceFlush && (await this._exporter.forceFlush()));
      }
      onStart(e, t) {}
      onEnd(e) {
        if (this._shutdownOnce.isCalled || (e.spanContext().traceFlags & c.TraceFlags.SAMPLED) == 0)
          return;
        let t = this._doExport(e).catch((e) => (0, I.globalErrorHandler)(e));
        (this._pendingExports.add(t), t.finally(() => this._pendingExports.delete(t)));
      }
      async _doExport(e) {
        e.resource.asyncAttributesPending && (await e.resource.waitForAsyncAttributes?.());
        let t = await F.internal._export(this._exporter, [e]);
        if (t.code !== G.ExportResultCode.SUCCESS)
          throw t.error ?? Error(`SimpleSpanProcessor: span export failed (status ${t})`);
      }
      shutdown() {
        return this._shutdownOnce.call();
      }
      _shutdown() {
        return this._exporter.shutdown();
      }
    }
    class Y {
      onStart(e, t) {}
      onEnd(e) {}
      shutdown() {
        return Promise.resolve();
      }
      forceFlush() {
        return Promise.resolve();
      }
    }
  },
  52780,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(81964),
      i = e.r(48009),
      o = e.r(52305),
      a = e.r(88540),
      s = e.r(18271),
      u = 'sentry.parentIsRemote',
      l = 'sentry.graphql.operation';
    function c(e) {
      return 'parentSpanId' in e
        ? e.parentSpanId
        : 'parentSpanContext' in e
          ? e.parentSpanContext?.spanId
          : void 0;
    }
    function d(e) {
      return !!e.attributes && 'object' == typeof e.attributes;
    }
    function p(e) {
      return 'number' == typeof e.kind;
    }
    function _(e) {
      return !!e.status;
    }
    function S(e) {
      return !!e.name;
    }
    function E(e) {
      if (!d(e)) return {};
      let t = e.attributes[r.ATTR_URL_FULL] || e.attributes[r.SEMATTRS_HTTP_URL],
        n = {
          url: t,
          'http.method':
            e.attributes[r.ATTR_HTTP_REQUEST_METHOD] || e.attributes[r.SEMATTRS_HTTP_METHOD],
        };
      !n['http.method'] && n.url && (n['http.method'] = 'GET');
      try {
        if ('string' == typeof t) {
          let e = i.parseUrl(t);
          ((n.url = i.getSanitizedUrlString(e)),
            e.search && (n['http.query'] = e.search),
            e.hash && (n['http.fragment'] = e.hash));
        }
      } catch {}
      return n;
    }
    function T(e) {
      return p(e) ? e.kind : o.SpanKind.INTERNAL;
    }
    let m = 'sentry-trace',
      g = 'baggage',
      f = 'sentry.dsc',
      h = 'sentry.sampled_not_recording',
      A = 'sentry.url',
      R = o.createContextKey('sentry_scopes'),
      y = o.createContextKey('sentry_fork_isolation_scope'),
      I = o.createContextKey('sentry_fork_set_scope'),
      b = o.createContextKey('sentry_fork_set_isolation_scope'),
      N = '_scopeContext';
    function O(e) {
      return e.getValue(R);
    }
    function v(e, t) {
      return e.setValue(R, t);
    }
    function C(e) {
      let { traceFlags: t, traceState: n } = e,
        r = !!n && '1' === n.get(h);
      if (t === o.TraceFlags.SAMPLED) return !0;
      if (r) return !1;
      let a = n ? n.get(f) : void 0,
        s = a ? i.baggageHeaderToDynamicSamplingContext(a) : void 0;
      return s?.sampled === 'true' || (s?.sampled !== 'false' && void 0);
    }
    function P(e, t, n) {
      let a = t[r.ATTR_HTTP_REQUEST_METHOD] || t[r.SEMATTRS_HTTP_METHOD];
      if (a)
        return (function ({ name: e, kind: t, attributes: n }, a) {
          let s = ['http'];
          switch (t) {
            case o.SpanKind.CLIENT:
              s.push('client');
              break;
            case o.SpanKind.SERVER:
              s.push('server');
          }
          n['sentry.http.prefetch'] && s.push('prefetch');
          let {
            urlPath: u,
            url: c,
            query: d,
            fragment: p,
            hasRoute: _,
          } = (function (e, t) {
            let n = e[r.SEMATTRS_HTTP_TARGET],
              a = e[r.SEMATTRS_HTTP_URL] || e[r.ATTR_URL_FULL],
              s = e[r.ATTR_HTTP_ROUTE],
              u = 'string' == typeof a ? i.parseUrl(a) : void 0,
              l = u ? i.getSanitizedUrlString(u) : void 0,
              c = u?.search || void 0,
              d = u?.hash || void 0;
            return 'string' == typeof s
              ? { urlPath: s, url: l, query: c, fragment: d, hasRoute: !0 }
              : t === o.SpanKind.SERVER && 'string' == typeof n
                ? {
                    urlPath: i.stripUrlQueryAndFragment(n),
                    url: l,
                    query: c,
                    fragment: d,
                    hasRoute: !1,
                  }
                : u
                  ? { urlPath: l, url: l, query: c, fragment: d, hasRoute: !1 }
                  : 'string' == typeof n
                    ? {
                        urlPath: i.stripUrlQueryAndFragment(n),
                        url: l,
                        query: c,
                        fragment: d,
                        hasRoute: !1,
                      }
                    : { urlPath: void 0, url: l, query: c, fragment: d, hasRoute: !1 };
          })(n, t);
          if (!u) return { ...L(e, n), op: s.join('.') };
          let S = n[l],
            E = `${a} ${u}`,
            T = S
              ? `${E} (${(function (e) {
                  if (Array.isArray(e)) {
                    let t = e.slice().sort();
                    return t.length <= 5
                      ? t.join(', ')
                      : `${t.slice(0, 5).join(', ')}, +${t.length - 5}`;
                  }
                  return `${e}`;
                })(S)})`
              : E,
            m = {};
          (c && (m.url = c), d && (m['http.query'] = d), p && (m['http.fragment'] = p));
          let g = t === o.SpanKind.CLIENT || t === o.SpanKind.SERVER,
            f = n[i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] || 'manual',
            h = !`${f}`.startsWith('auto'),
            A = 'custom' === n[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
            R = n[i.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME],
            { description: y, source: I } =
              A || null != R || (!g && h)
                ? L(e, n)
                : { description: T, source: _ || '/' === u ? 'route' : 'url' };
          return { op: s.join('.'), description: y, source: I, data: m };
        })({ attributes: t, name: e, kind: n }, a);
      let s = t[r.SEMATTRS_DB_SYSTEM],
        u =
          'string' == typeof t[i.SEMANTIC_ATTRIBUTE_SENTRY_OP] &&
          t[i.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');
      if (s && !u)
        return (function ({ attributes: e, name: t }) {
          let n = e[i.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
          if ('string' == typeof n)
            return {
              op: 'db',
              description: n,
              source: e[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || 'custom',
            };
          if ('custom' === e[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE])
            return { op: 'db', description: t, source: 'custom' };
          let o = e[r.SEMATTRS_DB_STATEMENT];
          return { op: 'db', description: o ? o.toString() : t, source: 'task' };
        })({ attributes: t, name: e });
      let c = 'custom' === t[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ? 'custom' : 'route';
      if (t[r.SEMATTRS_RPC_SERVICE]) return { ...L(e, t, 'route'), op: 'rpc' };
      if (t[r.SEMATTRS_MESSAGING_SYSTEM]) return { ...L(e, t, c), op: 'message' };
      let d = t[r.SEMATTRS_FAAS_TRIGGER];
      return d
        ? { ...L(e, t, c), op: d.toString() }
        : { op: void 0, description: e, source: 'custom' };
    }
    function M(e) {
      let t = d(e) ? e.attributes : {};
      return P(S(e) ? e.name : '<unknown>', t, T(e));
    }
    function L(e, t, n = 'custom') {
      let r = t[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] || n,
        o = t[i.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME];
      return o && 'string' == typeof o
        ? { description: o, source: r }
        : { description: e, source: r };
    }
    function U() {
      return o.trace.getActiveSpan();
    }
    let D = 'undefined' == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
    function x({ dsc: e, sampled: t }) {
      let n = e ? i.dynamicSamplingContextToSentryBaggageHeader(e) : void 0,
        r = new a.TraceState(),
        o = n ? r.set(f, n) : r;
      return !1 === t ? o.set(h, '1') : o;
    }
    let w = new Set();
    function k(e) {
      w.add(e);
    }
    class G extends a.W3CBaggagePropagator {
      constructor() {
        (super(), k('SentryPropagator'), (this._urlMatchesTargetsMap = new i.LRUMap(100)));
      }
      inject(e, t, n) {
        if (a.isTracingSuppressed(e)) {
          D &&
            i.debug.log(
              '[Tracing] Not injecting trace data for url because tracing is suppressed.'
            );
          return;
        }
        let s = o.trace.getSpan(e),
          u =
            s &&
            (function (e) {
              let t = i.spanToJSON(e).data,
                n = t[r.SEMATTRS_HTTP_URL] || t[r.ATTR_URL_FULL];
              if ('string' == typeof n) return n;
              let o = e.spanContext().traceState?.get(A);
              if (o) return o;
            })(s);
        if (
          !$(u, i.getClient()?.getOptions()?.tracePropagationTargets, this._urlMatchesTargetsMap)
        ) {
          D &&
            i.debug.log(
              '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',
              u
            );
          return;
        }
        let l = (function (e) {
            try {
              let t = e[g];
              return Array.isArray(t) ? t.join(',') : t;
            } catch {
              return;
            }
          })(t),
          c = o.propagation.getBaggage(e) || o.propagation.createBaggage({}),
          { dynamicSamplingContext: d, traceId: p, spanId: _, sampled: S } = B(e);
        if (l) {
          let e = i.parseBaggageHeader(l);
          e &&
            Object.entries(e).forEach(([e, t]) => {
              c = c.setEntry(e, { value: t });
            });
        }
        (d &&
          (c = Object.entries(d).reduce(
            (e, [t, n]) => (n ? e.setEntry(`${i.SENTRY_BAGGAGE_KEY_PREFIX}${t}`, { value: n }) : e),
            c
          )),
          p && p !== o.INVALID_TRACEID && n.set(t, m, i.generateSentryTraceHeader(p, _, S)),
          super.inject(o.propagation.setBaggage(e, c), t, n));
      }
      extract(e, t, n) {
        let r = n.get(t, m),
          i = n.get(t, g);
        return j(H(e, { sentryTrace: r ? (Array.isArray(r) ? r[0] : r) : void 0, baggage: i }));
      }
      fields() {
        return [m, g];
      }
    }
    let V =
      '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:';
    function $(e, t, n) {
      if ('string' != typeof e || !t) return !0;
      let r = n?.get(e);
      if (void 0 !== r) return (D && !r && i.debug.log(V, e), r);
      let o = i.stringMatchesSomePattern(e, t);
      return (n?.set(e, o), D && !o && i.debug.log(V, e), o);
    }
    function B(e, t = {}) {
      let n = o.trace.getSpan(e);
      if (n?.spanContext().isRemote) {
        let e = n.spanContext();
        return {
          dynamicSamplingContext: i.getDynamicSamplingContextFromSpan(n),
          traceId: e.traceId,
          spanId: void 0,
          sampled: C(e),
        };
      }
      if (n) {
        let e = n.spanContext();
        return {
          dynamicSamplingContext: i.getDynamicSamplingContextFromSpan(n),
          traceId: e.traceId,
          spanId: e.spanId,
          sampled: C(e),
        };
      }
      let r = t.scope || O(e)?.scope || i.getCurrentScope(),
        a = t.client || i.getClient(),
        s = r.getPropagationContext();
      return {
        dynamicSamplingContext: a ? i.getDynamicSamplingContextFromScope(a, r) : void 0,
        traceId: s.traceId,
        spanId: s.propagationSpanId,
        sampled: s.sampled,
      };
    }
    function H(e, { sentryTrace: t, baggage: n }) {
      let {
          traceId: r,
          parentSpanId: a,
          sampled: s,
          dsc: u,
        } = i.propagationContextFromHeaders(t, n),
        l = i.getClient(),
        c = i.baggageHeaderToDynamicSamplingContext(n);
      if (!a || (l && !i.shouldContinueTrace(l, c?.org_id))) return e;
      let d = (function ({ spanId: e, traceId: t, sampled: n, dsc: r }) {
        let i = x({ dsc: r, sampled: n });
        return {
          traceId: t,
          spanId: e,
          isRemote: !0,
          traceFlags: n ? o.TraceFlags.SAMPLED : o.TraceFlags.NONE,
          traceState: i,
        };
      })({ traceId: r, spanId: a, sampled: s, dsc: u });
      return o.trace.setSpanContext(e, d);
    }
    function j(e) {
      let t = O(e);
      return v(e, {
        scope: t ? t.scope : i.getCurrentScope().clone(),
        isolationScope: t ? t.isolationScope : i.getIsolationScope(),
      });
    }
    function F(e, t) {
      let n = K(),
        { name: r, parentSpan: s } = e;
      return Q(s)(() => {
        let s = X(e.scope, e.forceTransaction),
          u = e.onlyIfParent && !o.trace.getSpan(s) ? a.suppressTracing(s) : s,
          l = z(e);
        return n.startActiveSpan(r, l, u, (e) =>
          i.handleCallbackErrors(
            () => t(e),
            () => {
              void 0 === i.spanToJSON(e).status && e.setStatus({ code: o.SpanStatusCode.ERROR });
            },
            () => e.end()
          )
        );
      });
    }
    function Z(e, t) {
      let n = K(),
        { name: r, parentSpan: s } = e;
      return Q(s)(() => {
        let s = X(e.scope, e.forceTransaction),
          u = e.onlyIfParent && !o.trace.getSpan(s) ? a.suppressTracing(s) : s,
          l = z(e);
        return n.startActiveSpan(r, l, u, (e) =>
          i.handleCallbackErrors(
            () => t(e, () => e.end()),
            () => {
              void 0 === i.spanToJSON(e).status && e.setStatus({ code: o.SpanStatusCode.ERROR });
            }
          )
        );
      });
    }
    function Y(e) {
      let t = K(),
        { name: n, parentSpan: r } = e;
      return Q(r)(() => {
        let r = X(e.scope, e.forceTransaction),
          i = e.onlyIfParent && !o.trace.getSpan(r) ? a.suppressTracing(r) : r,
          s = z(e);
        return t.startSpan(n, s, i);
      });
    }
    function W(e, t) {
      let n = e ? o.trace.setSpan(o.context.active(), e) : o.trace.deleteSpan(o.context.active());
      return o.context.with(n, () => t(i.getCurrentScope()));
    }
    function K() {
      let e = i.getClient();
      return e?.tracer || o.trace.getTracer('@sentry/opentelemetry', i.SDK_VERSION);
    }
    function z(e) {
      var t;
      let { startTime: n, attributes: r, kind: o, op: a, links: s } = e,
        u = 'number' == typeof n ? ((t = n) < 0x2540be3ff ? 1e3 * t : t) : n;
      return {
        attributes: a ? { [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: a, ...r } : r,
        kind: o,
        links: s,
        startTime: u,
      };
    }
    function X(e, t) {
      let n = (function (e) {
          if (e) {
            let t = e[N];
            if (t) return t;
          }
          return o.context.active();
        })(e),
        r = o.trace.getSpan(n);
      if (!r || !t) return n;
      let a = o.trace.deleteSpan(n),
        { spanId: s, traceId: u } = r.spanContext(),
        l = C(r.spanContext()),
        c = i.getRootSpan(r),
        d = x({ dsc: i.getDynamicSamplingContextFromSpan(c), sampled: l }),
        p = {
          traceId: u,
          spanId: s,
          isRemote: !0,
          traceFlags: l ? o.TraceFlags.SAMPLED : o.TraceFlags.NONE,
          traceState: d,
        };
      return o.trace.setSpanContext(a, p);
    }
    function J(e, t) {
      let n = j(H(o.context.active(), e));
      return o.context.with(n, t);
    }
    function Q(e) {
      return void 0 !== e ? (t) => W(e, t) : (e) => e();
    }
    function q(e) {
      let t = a.suppressTracing(o.context.active());
      return o.context.with(t, e);
    }
    function ee({ span: e, scope: t, client: n } = {}) {
      let r = (t && t[N]) ?? o.context.active();
      if (e) {
        let { scope: t } = i.getCapturedScopesOnSpan(e);
        r = (t && t[N]) || o.trace.setSpan(o.context.active(), e);
      }
      let {
        traceId: a,
        spanId: s,
        sampled: u,
        dynamicSamplingContext: l,
      } = B(r, { scope: t, client: n });
      return {
        'sentry-trace': i.generateSentryTraceHeader(a, s, u),
        baggage: i.dynamicSamplingContextToSentryBaggageHeader(l),
      };
    }
    function et(e) {
      return !0 === e.attributes[u] ? void 0 : c(e);
    }
    function en(e, t) {
      let n = e.get(t.id);
      return n?.span
        ? n
        : n && !n.span
          ? ((n.span = t.span), (n.parentNode = t.parentNode), n)
          : (e.set(t.id, t), t);
    }
    let er = {
      1: 'cancelled',
      2: 'unknown_error',
      3: 'invalid_argument',
      4: 'deadline_exceeded',
      5: 'not_found',
      6: 'already_exists',
      7: 'permission_denied',
      8: 'resource_exhausted',
      9: 'failed_precondition',
      10: 'aborted',
      11: 'out_of_range',
      12: 'unimplemented',
      13: 'internal_error',
      14: 'unavailable',
      15: 'data_loss',
      16: 'unauthenticated',
    };
    function ei(e) {
      let t = d(e) ? e.attributes : {},
        n = _(e) ? e.status : void 0;
      if (n) {
        if (n.code === o.SpanStatusCode.OK) return { code: i.SPAN_STATUS_OK };
        else if (n.code === o.SpanStatusCode.ERROR) {
          let e;
          if (void 0 === n.message) {
            let e = eo(t);
            if (e) return e;
          }
          return n.message && ((e = n.message), Object.values(er).includes(e))
            ? { code: i.SPAN_STATUS_ERROR, message: n.message }
            : { code: i.SPAN_STATUS_ERROR, message: 'unknown_error' };
        }
      }
      let r = eo(t);
      return (
        r ||
        (n?.code === o.SpanStatusCode.UNSET
          ? { code: i.SPAN_STATUS_OK }
          : { code: i.SPAN_STATUS_ERROR, message: 'unknown_error' })
      );
    }
    function eo(e) {
      let t = e[r.ATTR_HTTP_RESPONSE_STATUS_CODE] || e[r.SEMATTRS_HTTP_STATUS_CODE],
        n = e[r.SEMATTRS_RPC_GRPC_STATUS_CODE],
        o = 'number' == typeof t ? t : 'string' == typeof t ? parseInt(t) : void 0;
      return 'number' == typeof o
        ? i.getSpanStatusFromHttpCode(o)
        : 'string' == typeof n
          ? { code: i.SPAN_STATUS_ERROR, message: er[n] || 'unknown_error' }
          : void 0;
    }
    class ea {
      constructor(e) {
        ((this._finishedSpanBucketSize = e?.timeout || 300),
          (this._finishedSpanBuckets = Array(this._finishedSpanBucketSize).fill(void 0)),
          (this._lastCleanupTimestampInS = Math.floor(Date.now() / 1e3)),
          (this._spansToBucketEntry = new WeakMap()),
          (this._sentSpans = new Map()),
          (this._debouncedFlush = i.debounce(this.flush.bind(this), 1, { maxWait: 100 })));
      }
      export(e) {
        let t = Math.floor(Date.now() / 1e3);
        if (this._lastCleanupTimestampInS !== t) {
          let e = 0;
          (this._finishedSpanBuckets.forEach((n, r) => {
            n &&
              n.timestampInS <= t - this._finishedSpanBucketSize &&
              ((e += n.spans.size), (this._finishedSpanBuckets[r] = void 0));
          }),
            e > 0 &&
              D &&
              i.debug.log(
                `SpanExporter dropped ${e} spans because they were pending for more than ${this._finishedSpanBucketSize} seconds.`
              ),
            (this._lastCleanupTimestampInS = t));
        }
        let n = t % this._finishedSpanBucketSize,
          r = this._finishedSpanBuckets[n] || { timestampInS: t, spans: new Set() };
        ((this._finishedSpanBuckets[n] = r), r.spans.add(e), this._spansToBucketEntry.set(e, r));
        let o = et(e);
        (!o || this._sentSpans.has(o)) && this._debouncedFlush();
      }
      flush() {
        let e = this._finishedSpanBuckets.flatMap((e) => (e ? Array.from(e.spans) : []));
        this._flushSentSpanCache();
        let t = this._maybeSend(e),
          n = t.size,
          r = e.length - n;
        D &&
          i.debug.log(
            `SpanExporter exported ${n} spans, ${r} spans are waiting for their parent spans to finish`
          );
        let o = Date.now() + 3e5;
        for (let e of t) {
          this._sentSpans.set(e.spanContext().spanId, o);
          let t = this._spansToBucketEntry.get(e);
          t && t.spans.delete(e);
        }
        this._debouncedFlush.cancel();
      }
      clear() {
        ((this._finishedSpanBuckets = this._finishedSpanBuckets.fill(void 0)),
          this._sentSpans.clear(),
          this._debouncedFlush.cancel());
      }
      _maybeSend(e) {
        let t = (function (e) {
            let t = new Map();
            for (let n of e)
              !(function (e, t) {
                let n = t.spanContext().spanId,
                  r = et(t);
                if (!r) return en(e, { id: n, span: t, children: [] });
                let i = (function (e, t) {
                    let n = e.get(t);
                    return n || en(e, { id: t, children: [] });
                  })(e, r),
                  o = en(e, { id: n, span: t, parentNode: i, children: [] });
                i.children.push(o);
              })(t, n);
            return Array.from(t, function ([e, t]) {
              return t;
            });
          })(e),
          n = new Set();
        for (let e of this._getCompletedRootNodes(t)) {
          let t = e.span;
          n.add(t);
          let o = (function (e) {
            let { op: t, description: n, data: o, origin: a = 'manual', source: s } = es(e),
              u = i.getCapturedScopesOnSpan(e),
              l = e.attributes[i.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE],
              d = {
                [i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: s,
                [i.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: l,
                [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: t,
                [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: a,
                ...o,
                ...eu(e.attributes),
              },
              { links: p } = e,
              { traceId: _, spanId: S } = e.spanContext(),
              E = c(e),
              T = ei(e),
              m = {
                parent_span_id: E,
                span_id: S,
                trace_id: _,
                data: d,
                origin: a,
                op: t,
                status: i.getStatusMessage(T),
                links: i.convertSpanLinksForEnvelope(p),
              },
              g = d[r.ATTR_HTTP_RESPONSE_STATUS_CODE];
            return {
              contexts: {
                trace: m,
                otel: { resource: e.resource.attributes },
                ...('number' == typeof g ? { response: { status_code: g } } : void 0),
              },
              spans: [],
              start_timestamp: i.spanTimeInputToSeconds(e.startTime),
              timestamp: i.spanTimeInputToSeconds(e.endTime),
              transaction: n,
              type: 'transaction',
              sdkProcessingMetadata: {
                capturedSpanScope: u.scope,
                capturedSpanIsolationScope: u.isolationScope,
                sampleRate: l,
                dynamicSamplingContext: i.getDynamicSamplingContextFromSpan(e),
              },
              ...(s && { transaction_info: { source: s } }),
            };
          })(t);
          if (e.parentNode && this._sentSpans.has(e.parentNode.id)) {
            let e = o.contexts?.trace?.data;
            e && (e['sentry.parent_span_already_sent'] = !0);
          }
          let a = o.spans || [];
          for (let t of e.children)
            !(function e(t, n, r) {
              let o = t.span;
              if ((o && r.add(o), !o))
                return void t.children.forEach((t) => {
                  e(t, n, r);
                });
              let a = o.spanContext().spanId,
                s = o.spanContext().traceId,
                u = c(o),
                { attributes: l, startTime: d, endTime: p, links: _ } = o,
                { op: S, description: E, data: T, origin: m = 'manual' } = es(o),
                g = {
                  [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: m,
                  [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: S,
                  ...eu(l),
                  ...T,
                },
                f = ei(o),
                h = {
                  span_id: a,
                  trace_id: s,
                  data: g,
                  description: E,
                  parent_span_id: u,
                  start_timestamp: i.spanTimeInputToSeconds(d),
                  timestamp: i.spanTimeInputToSeconds(p) || void 0,
                  status: i.getStatusMessage(f),
                  op: S,
                  origin: m,
                  measurements: i.timedEventsToMeasurements(o.events),
                  links: i.convertSpanLinksForEnvelope(_),
                };
              (n.push(h),
                t.children.forEach((t) => {
                  e(t, n, r);
                }));
            })(t, a, n);
          o.spans =
            a.length > 1e3
              ? a.sort((e, t) => e.start_timestamp - t.start_timestamp).slice(0, 1e3)
              : a;
          let s = i.timedEventsToMeasurements(t.events);
          (s && (o.measurements = s), i.captureEvent(o));
        }
        return n;
      }
      _flushSentSpanCache() {
        let e = Date.now();
        for (let [t, n] of this._sentSpans.entries()) n <= e && this._sentSpans.delete(t);
      }
      _nodeIsCompletedRootNodeOrHasSentParent(e) {
        return !!e.span && (!e.parentNode || this._sentSpans.has(e.parentNode.id));
      }
      _getCompletedRootNodes(e) {
        return e.filter((e) => this._nodeIsCompletedRootNodeOrHasSentParent(e));
      }
    }
    function es(e) {
      let {
          op: t,
          source: n,
          origin: a,
        } = (function (e) {
          let t = e.attributes,
            n = t[i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
          return {
            origin: n,
            op: t[i.SEMANTIC_ATTRIBUTE_SENTRY_OP],
            source: t[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
          };
        })(e),
        { op: s, description: u, source: l, data: c } = M(e);
      return {
        op: t || s,
        description: u,
        source: n || l,
        origin: a,
        data: {
          ...c,
          ...(function (e) {
            let t = e.attributes,
              n = {};
            e.kind !== o.SpanKind.INTERNAL && (n['otel.kind'] = o.SpanKind[e.kind]);
            let i = t[r.SEMATTRS_HTTP_STATUS_CODE];
            i && (n[r.ATTR_HTTP_RESPONSE_STATUS_CODE] = i);
            let a = E(e);
            return (
              a.url && (n.url = a.url),
              a['http.query'] && (n['http.query'] = a['http.query'].slice(1)),
              a['http.fragment'] && (n['http.fragment'] = a['http.fragment'].slice(1)),
              n
            );
          })(e),
        },
      };
    }
    function eu(e) {
      let t = { ...e };
      return (
        delete t[i.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE],
        delete t[u],
        delete t[i.SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME],
        t
      );
    }
    function el({
      decision: e,
      context: t,
      spanAttributes: n,
      sampleRand: i,
      downstreamTraceSampleRate: u,
    }) {
      let l = (function (e, t) {
        let n = o.trace.getSpan(e),
          i = n?.spanContext(),
          s = i?.traceState || new a.TraceState(),
          u = t[r.SEMATTRS_HTTP_URL] || t[r.ATTR_URL_FULL];
        return (u && 'string' == typeof u && (s = s.set(A, u)), s);
      })(t, n);
      return (void 0 !== u && (l = l.set('sentry.sample_rate', `${u}`)),
      void 0 !== i && (l = l.set('sentry.sample_rand', `${i}`)),
      void 0 == e)
        ? { decision: s.SamplingDecision.NOT_RECORD, traceState: l }
        : e === s.SamplingDecision.NOT_RECORD
          ? { decision: e, traceState: l.set(h, '1') }
          : { decision: e, traceState: l };
    }
    ((n.getClient = i.getClient),
      (n.getDynamicSamplingContextFromSpan = i.getDynamicSamplingContextFromSpan),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION = l),
      (n.SentryPropagator = G),
      (n.SentrySampler = class {
        constructor(e) {
          ((this._client = e), k('SentrySampler'));
        }
        shouldSample(e, t, n, a, u, l) {
          let c = this._client.getOptions(),
            d = (function (e) {
              let t = o.trace.getSpan(e);
              return t && o.isSpanContextValid(t.spanContext()) ? t : void 0;
            })(e),
            p = d?.spanContext();
          if (!i.hasSpansEnabled(c)) return el({ decision: void 0, context: e, spanAttributes: u });
          let _ = u[r.SEMATTRS_HTTP_METHOD] || u[r.ATTR_HTTP_REQUEST_METHOD];
          if (a === o.SpanKind.CLIENT && _ && (!d || p?.isRemote))
            return el({ decision: void 0, context: e, spanAttributes: u });
          let S = d
            ? (function (e, t, n) {
                let r = e.spanContext();
                if (o.isSpanContextValid(r) && r.traceId === t) {
                  if (r.isRemote) {
                    let t = C(e.spanContext());
                    return (
                      D &&
                        i.debug.log(
                          `[Tracing] Inheriting remote parent's sampled decision for ${n}: ${t}`
                        ),
                      t
                    );
                  }
                  let t = C(r);
                  return (
                    D &&
                      i.debug.log(`[Tracing] Inheriting parent's sampled decision for ${n}: ${t}`),
                    t
                  );
                }
              })(d, t, n)
            : void 0;
          if (!(!d || p?.isRemote))
            return el({
              decision: S ? s.SamplingDecision.RECORD_AND_SAMPLED : s.SamplingDecision.NOT_RECORD,
              context: e,
              spanAttributes: u,
            });
          let { description: E, data: T, op: m } = P(n, u, a),
            g = { ...T, ...u };
          m && (g[i.SEMANTIC_ATTRIBUTE_SENTRY_OP] = m);
          let h = { decision: !0 };
          if (
            (this._client.emit(
              'beforeSampling',
              { spanAttributes: g, spanName: E, parentSampled: S, parentContext: p },
              h
            ),
            !h.decision)
          )
            return el({ decision: void 0, context: e, spanAttributes: u });
          let { isolationScope: A } = O(e) ?? {},
            R = p?.traceState ? p.traceState.get(f) : void 0,
            y = R ? i.baggageHeaderToDynamicSamplingContext(R) : void 0,
            I = i.parseSampleRate(y?.sample_rand) ?? Math.random(),
            [b, N, v] = i.sampleSpan(
              c,
              {
                name: E,
                attributes: g,
                normalizedRequest: A?.getScopeData().sdkProcessingMetadata.normalizedRequest,
                parentSampled: S,
                parentSampleRate: i.parseSampleRate(y?.sample_rate),
              },
              I
            ),
            M = `${_}`.toUpperCase();
          return 'OPTIONS' === M || 'HEAD' === M
            ? (D &&
                i.debug.log(`[Tracing] Not sampling span because HTTP method is '${M}' for ${n}`),
              el({
                decision: s.SamplingDecision.NOT_RECORD,
                context: e,
                spanAttributes: u,
                sampleRand: I,
                downstreamTraceSampleRate: 0,
              }))
            : (b ||
                void 0 !== S ||
                (D &&
                  i.debug.log(
                    '[Tracing] Discarding root span because its trace was not chosen to be sampled.'
                  ),
                this._client.recordDroppedEvent('sample_rate', 'transaction')),
              {
                ...el({
                  decision: b
                    ? s.SamplingDecision.RECORD_AND_SAMPLED
                    : s.SamplingDecision.NOT_RECORD,
                  context: e,
                  spanAttributes: u,
                  sampleRand: I,
                  downstreamTraceSampleRate: v ? N : void 0,
                }),
                attributes: { [i.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: v ? N : void 0 },
              });
        }
        toString() {
          return 'SentrySampler';
        }
      }),
      (n.SentrySpanProcessor = class {
        constructor(e) {
          (k('SentrySpanProcessor'), (this._exporter = new ea(e)));
        }
        async forceFlush() {
          this._exporter.flush();
        }
        async shutdown() {
          this._exporter.clear();
        }
        onStart(e, t) {
          let n = o.trace.getSpan(t),
            r = O(t);
          (n && !n.spanContext().isRemote && i.addChildSpanToSpan(n, e),
            n?.spanContext().isRemote && e.setAttribute(u, !0),
            t === o.ROOT_CONTEXT &&
              (r = {
                scope: i.getDefaultCurrentScope(),
                isolationScope: i.getDefaultIsolationScope(),
              }),
            r && i.setCapturedScopesOnSpan(e, r.scope, r.isolationScope),
            i.logSpanStart(e));
          let a = i.getClient();
          a?.emit('spanStart', e);
        }
        onEnd(e) {
          i.logSpanEnd(e);
          let t = i.getClient();
          (t?.emit('spanEnd', e), this._exporter.export(e));
        }
      }),
      (n.continueTrace = J),
      (n.enhanceDscWithOpenTelemetryRootSpanName = function (e) {
        e.on('createDsc', (e, t) => {
          if (!t) return;
          let n = i.spanToJSON(t).data[i.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
            { description: r } = S(t) ? M(t) : { description: void 0 };
          if (('url' !== n && r && (e.transaction = r), i.hasSpansEnabled())) {
            let n = C(t.spanContext());
            e.sampled = void 0 == n ? void 0 : String(n);
          }
        });
      }),
      (n.getActiveSpan = U),
      (n.getRequestSpanData = E),
      (n.getScopesFromContext = O),
      (n.getSpanKind = T),
      (n.getTraceContextForScope = function (e, t) {
        let n = t[N],
          r = n && o.trace.getSpan(n),
          a = r ? i.spanToTraceContext(r) : i.getTraceContextFromScope(t);
        return [
          r ? i.getDynamicSamplingContextFromSpan(r) : i.getDynamicSamplingContextFromScope(e, t),
          a,
        ];
      }),
      (n.isSentryRequestSpan = function (e) {
        if (!d(e)) return !1;
        let { attributes: t } = e,
          n = t[r.SEMATTRS_HTTP_URL] || t[r.ATTR_URL_FULL];
        return !!n && i.isSentryRequestUrl(n.toString(), i.getClient());
      }),
      (n.openTelemetrySetupCheck = function () {
        return Array.from(w);
      }),
      (n.setOpenTelemetryContextAsyncContextStrategy = function () {
        function e() {
          let e = O(o.context.active());
          return (
            e || { scope: i.getDefaultCurrentScope(), isolationScope: i.getDefaultIsolationScope() }
          );
        }
        function t() {
          return e().scope;
        }
        function n() {
          return e().isolationScope;
        }
        i.setAsyncContextStrategy({
          withScope: function (e) {
            let n = o.context.active();
            return o.context.with(n, () => e(t()));
          },
          withSetScope: function (e, t) {
            let n = e[N] || o.context.active();
            return o.context.with(n.setValue(I, e), () => t(e));
          },
          withSetIsolationScope: function (e, t) {
            let r = o.context.active();
            return o.context.with(r.setValue(b, e), () => t(n()));
          },
          withIsolationScope: function (e) {
            let t = o.context.active();
            return o.context.with(t.setValue(y, !0), () => e(n()));
          },
          getCurrentScope: t,
          getIsolationScope: n,
          startSpan: F,
          startSpanManual: Z,
          startInactiveSpan: Y,
          getActiveSpan: U,
          suppressTracing: q,
          getTraceData: ee,
          continueTrace: J,
          withActiveSpan: W,
        });
      }),
      (n.setupEventContextTrace = function (e) {
        e.on('preprocessEvent', (e) => {
          let t = U();
          if (!t || 'transaction' === e.type) return;
          e.contexts = { trace: i.spanToTraceContext(t), ...e.contexts };
          let n = i.getRootSpan(t);
          return (
            (e.sdkProcessingMetadata = {
              dynamicSamplingContext: i.getDynamicSamplingContextFromSpan(n),
              ...e.sdkProcessingMetadata,
            }),
            e
          );
        });
      }),
      (n.shouldPropagateTraceForUrl = $),
      (n.spanHasAttributes = d),
      (n.spanHasEvents = function (e) {
        return Array.isArray(e.events);
      }),
      (n.spanHasKind = p),
      (n.spanHasName = S),
      (n.spanHasParentId = function (e) {
        return !!c(e);
      }),
      (n.spanHasStatus = _),
      (n.startInactiveSpan = Y),
      (n.startSpan = F),
      (n.startSpanManual = Z),
      (n.suppressTracing = q),
      (n.withActiveSpan = W),
      (n.wrapClientClass = function (e) {
        return class extends e {
          constructor(...e) {
            super(...e);
          }
          get tracer() {
            if (this._tracer) return this._tracer;
            let e = i.SDK_VERSION,
              t = o.trace.getTracer('@sentry/opentelemetry', e);
            return ((this._tracer = t), t);
          }
          async flush(e) {
            let t = this.traceProvider;
            return (await t?.forceFlush(), super.flush(e));
          }
        };
      }),
      (n.wrapContextManagerClass = function (e) {
        return class extends e {
          constructor(...e) {
            (super(...e), k('SentryContextManager'));
          }
          with(e, t, n, ...r) {
            let o = O(e),
              a = o?.scope || i.getCurrentScope(),
              s = o?.isolationScope || i.getIsolationScope(),
              u = !0 === e.getValue(y),
              l = e.getValue(I),
              c = e.getValue(b),
              d = l || a.clone(),
              p = v(e, { scope: d, isolationScope: c || (u ? s.clone() : s) })
                .deleteValue(y)
                .deleteValue(I)
                .deleteValue(b);
            return (i.addNonEnumerableProperty(d, N, p), super.with(p, t, n, ...r));
          }
        };
      }),
      (n.wrapSamplingDecision = el));
  },
  12613,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.mergeBaggageHeaders = function (e, t) {
      if (!e) return t;
      let n = r.parseBaggageHeader(e),
        i = r.parseBaggageHeader(t);
      if (!i) return e;
      let o = { ...n };
      return (
        Object.entries(i).forEach(([e, t]) => {
          o[e] || (o[e] = t);
        }),
        r.objectToBaggageHeader(o)
      );
    };
  },
  15326,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(52780),
      o = e.r(97017),
      a = e.r(12613),
      s = e.r(84111);
    ((n.addRequestBreadcrumb = function (e, t) {
      let n = (function (e) {
          try {
            let t = e.getHeader('host') || e.host,
              n = new URL(e.path, `${e.protocol}//${t}`),
              i = r.parseUrl(n.toString()),
              o = { url: r.getSanitizedUrlString(i), 'http.method': e.method || 'GET' };
            return (
              i.search && (o['http.query'] = i.search),
              i.hash && (o['http.fragment'] = i.hash),
              o
            );
          } catch {
            return {};
          }
        })(e),
        i = t?.statusCode,
        o = r.getBreadcrumbLogLevelFromHttpStatusCode(i);
      r.addBreadcrumb(
        { category: 'http', data: { status_code: i, ...n }, type: 'http', level: o },
        { event: 'response', request: e, response: t }
      );
    }),
      (n.addTracePropagationHeadersToOutgoingRequest = function (e, t) {
        let n = (function (e) {
            let t = e.getHeader('host') || e.host,
              n = e.protocol,
              r = e.path;
            return `${n}//${t}${r}`;
          })(e),
          u = r.getClient()?.getOptions().tracePropagationTargets,
          l = i.shouldPropagateTraceForUrl(n, u, t) ? r.getTraceData() : void 0;
        if (!l) return;
        let { 'sentry-trace': c, baggage: d } = l;
        if (c && !e.getHeader('sentry-trace'))
          try {
            (e.setHeader('sentry-trace', c),
              o.DEBUG_BUILD &&
                r.debug.log(
                  s.INSTRUMENTATION_NAME,
                  'Added sentry-trace header to outgoing request'
                ));
          } catch (e) {
            o.DEBUG_BUILD &&
              r.debug.error(
                s.INSTRUMENTATION_NAME,
                'Failed to add sentry-trace header to outgoing request:',
                r.isError(e) ? e.message : 'Unknown error'
              );
          }
        if (d) {
          let t = a.mergeBaggageHeaders(e.getHeader('baggage'), d);
          if (t)
            try {
              (e.setHeader('baggage', t),
                o.DEBUG_BUILD &&
                  r.debug.log(s.INSTRUMENTATION_NAME, 'Added baggage header to outgoing request'));
            } catch (e) {
              o.DEBUG_BUILD &&
                r.debug.error(
                  s.INSTRUMENTATION_NAME,
                  'Failed to add baggage header to outgoing request:',
                  r.isError(e) ? e.message : 'Unknown error'
                );
            }
        }
      }),
      (n.getRequestOptions = function (e) {
        return {
          method: e.method,
          protocol: e.protocol,
          host: e.host,
          hostname: e.host,
          path: e.path,
          headers: e.getHeaders(),
        };
      }));
  },
  77945,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(77652),
      i = e.r(52305),
      o = e.r(88540),
      a = e.r(75235),
      s = e.r(48009),
      u = e.r(97017),
      l = e.r(64077),
      c = e.r(84111),
      d = e.r(42851),
      p = e.r(15326);
    class _ extends a.InstrumentationBase {
      constructor(e = {}) {
        (super(c.INSTRUMENTATION_NAME, s.SDK_VERSION, e),
          (this._propagationDecisionMap = new s.LRUMap(100)),
          (this._ignoreOutgoingRequestsMap = new WeakMap()));
      }
      init() {
        let e = !1,
          t = this.getConfig().spans ?? !0,
          n = (e) => {
            d.instrumentServer(e.server, {
              instrumentation: this.getConfig().instrumentation,
              ignoreIncomingRequestBody: this.getConfig().ignoreIncomingRequestBody,
              ignoreSpansForIncomingRequests: this.getConfig().ignoreSpansForIncomingRequests,
              incomingRequestSpanHook: this.getConfig().incomingRequestSpanHook,
              maxIncomingRequestBodySize: this.getConfig().maxIncomingRequestBodySize,
              trackIncomingRequestsAsSessions: this.getConfig().trackIncomingRequestsAsSessions,
              sessionFlushingDelayMS: this.getConfig().sessionFlushingDelayMS ?? 6e4,
              ignoreStaticAssets: this.getConfig().ignoreStaticAssets,
              spans: t && !this.getConfig().disableIncomingRequestSpans,
            });
          },
          i = (e) => {
            this._onOutgoingRequestFinish(e.request, e.response);
          },
          o = (e) => {
            this._onOutgoingRequestFinish(e.request, void 0);
          },
          s = (e) => {
            this._onOutgoingRequestCreated(e.request);
          },
          u = (t) => (
            e ||
              ((e = !0),
              r.subscribe('http.server.request.start', n),
              r.subscribe('http.client.response.finish', i),
              r.subscribe('http.client.request.error', o),
              this.getConfig().propagateTraceInOutgoingRequests &&
                r.subscribe('http.client.request.created', s)),
            t
          ),
          l = () => {
            (r.unsubscribe('http.server.request.start', n),
              r.unsubscribe('http.client.response.finish', i),
              r.unsubscribe('http.client.request.error', o),
              r.unsubscribe('http.client.request.created', s));
          };
        return [
          new a.InstrumentationNodeModuleDefinition('http', ['*'], u, l),
          new a.InstrumentationNodeModuleDefinition('https', ['*'], u, l),
        ];
      }
      _onOutgoingRequestFinish(e, t) {
        u.DEBUG_BUILD && s.debug.log(c.INSTRUMENTATION_NAME, 'Handling finished outgoing request');
        let n = this.getConfig().breadcrumbs,
          r = this._ignoreOutgoingRequestsMap.get(e) ?? this._shouldIgnoreOutgoingRequest(e);
        (this._ignoreOutgoingRequestsMap.set(e, r),
          (void 0 === n || n) && !r && p.addRequestBreadcrumb(e, t));
      }
      _onOutgoingRequestCreated(e) {
        let t = this._ignoreOutgoingRequestsMap.get(e) ?? this._shouldIgnoreOutgoingRequest(e);
        (this._ignoreOutgoingRequestsMap.set(e, t),
          t || p.addTracePropagationHeadersToOutgoingRequest(e, this._propagationDecisionMap));
      }
      _shouldIgnoreOutgoingRequest(e) {
        if (o.isTracingSuppressed(i.context.active())) return !0;
        let t = this.getConfig().ignoreOutgoingRequests;
        if (!t) return !1;
        let n = p.getRequestOptions(e);
        return t(l.getRequestUrl(e), n);
      }
    }
    n.SentryHttpInstrumentation = _;
  },
  1094,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(20503),
      o = e.r(77945),
      a = 'Http',
      s = i.generateInstrumentOnce(`${a}.sentry`, (e) => new o.SentryHttpInstrumentation(e));
    ((n.httpIntegration = r.defineIntegration((e = {}) => {
      let t = e.dropSpansForIncomingRequestStatusCodes ?? [
        [401, 404],
        [300, 399],
      ];
      return {
        name: a,
        setupOnce() {
          s({
            ...e,
            ignoreSpansForIncomingRequests: e.ignoreIncomingRequests,
            disableIncomingRequestSpans: !0,
            propagateTraceInOutgoingRequests: !0,
          });
        },
        processEvent(e) {
          if ('transaction' === e.type) {
            let n = e.contexts?.trace?.data?.['http.response.status_code'];
            if (
              'number' == typeof n &&
              t.some((e) => {
                if ('number' == typeof e) return e === n;
                let [t, r] = e;
                return n >= t && n <= r;
              })
            )
              return null;
          }
          return e;
        },
      };
    })),
      (n.instrumentSentryHttp = s));
  },
  73417,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009).parseSemver(process.versions.node),
      i = r.major,
      o = r.minor;
    ((n.NODE_MAJOR = i), (n.NODE_MINOR = o), (n.NODE_VERSION = r));
  },
  84314,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(75235),
      a = e.r(48009),
      s = e.r(52780),
      u = e.r(54993),
      l = e.r(73417),
      c = e.r(12613),
      d = 'sentry-trace',
      p = 'baggage',
      _ = /baggage: (.*)\r\n/;
    class S extends o.InstrumentationBase {
      constructor(e = {}) {
        (super('@sentry/instrumentation-node-fetch', a.SDK_VERSION, e),
          (this._channelSubs = []),
          (this._propagationDecisionMap = new a.LRUMap(100)),
          (this._ignoreOutgoingRequestsMap = new WeakMap()));
      }
      init() {}
      disable() {
        (super.disable(),
          this._channelSubs.forEach((e) => e.unsubscribe()),
          (this._channelSubs = []));
      }
      enable() {
        (super.enable(),
          (this._channelSubs = this._channelSubs || []),
          this._channelSubs.length > 0 ||
            (this._subscribeToChannel('undici:request:create', this._onRequestCreated.bind(this)),
            this._subscribeToChannel(
              'undici:request:headers',
              this._onResponseHeaders.bind(this)
            )));
      }
      _onRequestCreated({ request: e }) {
        if (!1 === this.getConfig().enabled) return;
        let t = this._shouldIgnoreOutgoingRequest(e);
        if ((this._ignoreOutgoingRequestsMap.set(e, t), t)) return;
        let n = E(e.origin, e.path),
          r = a.getClient()?.getOptions().tracePropagationTargets,
          i = s.shouldPropagateTraceForUrl(n, r, this._propagationDecisionMap)
            ? a.getTraceData()
            : void 0;
        if (!i) return;
        let { 'sentry-trace': o, baggage: u } = i;
        if (Array.isArray(e.headers)) {
          let t = e.headers;
          o && !t.includes(d) && t.push(d, o);
          let n = t.findIndex((e) => e === p);
          if (u && -1 === n) t.push(p, u);
          else if (u) {
            let e = t[n + 1],
              r = c.mergeBaggageHeaders(e, u);
            r && (t[n + 1] = r);
          }
        } else {
          let t = e.headers;
          o &&
            !t.includes(`${d}:`) &&
            (e.headers += `${d}: ${o}\r
`);
          let n = e.headers.match(_)?.[1];
          if (u && !n)
            e.headers += `${p}: ${u}\r
`;
          else if (u) {
            let t = c.mergeBaggageHeaders(n, u);
            t &&
              (e.headers = e.headers.replace(
                _,
                `baggage: ${t}\r
`
              ));
          }
        }
      }
      _onResponseHeaders({ request: e, response: t }) {
        let n = this.getConfig();
        if (!1 === n.enabled) return;
        let r = n.breadcrumbs,
          i = this._ignoreOutgoingRequestsMap.get(e);
        (void 0 === r || r) &&
          !i &&
          (function (e, t) {
            let n = (function (e) {
                try {
                  let t = E(e.origin, e.path),
                    n = a.parseUrl(t),
                    r = { url: a.getSanitizedUrlString(n), 'http.method': e.method || 'GET' };
                  return (
                    n.search && (r['http.query'] = n.search),
                    n.hash && (r['http.fragment'] = n.hash),
                    r
                  );
                } catch {
                  return {};
                }
              })(e),
              r = t.statusCode,
              i = a.getBreadcrumbLogLevelFromHttpStatusCode(r);
            a.addBreadcrumb(
              { category: 'http', data: { status_code: r, ...n }, type: 'http', level: i },
              { event: 'response', request: e, response: t }
            );
          })(e, t);
      }
      _subscribeToChannel(e, t) {
        let n;
        if (l.NODE_MAJOR > 18 || (18 === l.NODE_MAJOR && l.NODE_MINOR >= 19))
          (u.subscribe?.(e, t), (n = () => u.unsubscribe?.(e, t)));
        else {
          let r = u.channel(e);
          (r.subscribe(t), (n = () => r.unsubscribe(t)));
        }
        this._channelSubs.push({ name: e, unsubscribe: n });
      }
      _shouldIgnoreOutgoingRequest(e) {
        if (i.isTracingSuppressed(r.context.active())) return !0;
        let t = E(e.origin, e.path),
          n = this.getConfig().ignoreOutgoingRequests;
        return 'function' == typeof n && !!t && n(t);
      }
    }
    function E(e, t = '/') {
      try {
        return new URL(t, e).toString();
      } catch {
        let n = `${e}`;
        if (n.endsWith('/') && t.startsWith('/')) return `${n}${t.slice(1)}`;
        if (!n.endsWith('/') && !t.startsWith('/')) return `${n}/${t.slice(1)}`;
        return `${n}${t}`;
      }
    }
    n.SentryNodeFetchInstrumentation = S;
  },
  84761,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(20503),
      o = e.r(84314),
      a = i.generateInstrumentOnce('NodeFetch.sentry', o.SentryNodeFetchInstrumentation, (e) => e);
    n.nativeNodeFetchIntegration = r.defineIntegration((e = {}) => ({
      name: 'NodeFetch',
      setupOnce() {
        a(e);
      },
    }));
  },
  22185,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(74533),
      i = e.r(2157),
      o = e.r(60526),
      a = e.r(50227),
      s = e.r(12057),
      u = e.r(48009),
      l = s.promisify(i.readFile),
      c = s.promisify(i.readdir),
      d = u.defineIntegration((e = {}) => {
        let t,
          n = { app: !0, os: !0, device: !0, culture: !0, cloudResource: !0, ...e };
        async function r(e) {
          void 0 === t && (t = i());
          let n = (function (e) {
            if (
              (e.app?.app_memory && (e.app.app_memory = process.memoryUsage().rss),
              e.app?.free_memory && 'function' == typeof process.availableMemory)
            ) {
              let t = process.availableMemory?.();
              null != t && (e.app.free_memory = t);
            }
            return (e.device?.free_memory && (e.device.free_memory = o.freemem()), e);
          })(await t);
          return (
            (e.contexts = {
              ...e.contexts,
              app: { ...n.app, ...e.contexts?.app },
              os: { ...n.os, ...e.contexts?.os },
              device: { ...n.device, ...e.contexts?.device },
              culture: { ...n.culture, ...e.contexts?.culture },
              cloud_resource: { ...n.cloud_resource, ...e.contexts?.cloud_resource },
            }),
            e
          );
        }
        async function i() {
          let e = {};
          if (
            (n.os && (e.os = await p()),
            n.app && (e.app = _()),
            n.device && (e.device = S(n.device)),
            n.culture)
          ) {
            let t = (function () {
              try {
                if ('string' != typeof process.versions.icu) return;
                let e = new Date(9e8),
                  t = new Intl.DateTimeFormat('es', { month: 'long' });
                if ('enero' === t.format(e)) {
                  let e = Intl.DateTimeFormat().resolvedOptions();
                  return { locale: e.locale, timezone: e.timeZone };
                }
              } catch {}
            })();
            t && (e.culture = t);
          }
          return (
            n.cloudResource &&
              (e.cloud_resource = (function () {
                if (process.env.VERCEL)
                  return { 'cloud.provider': 'vercel', 'cloud.region': process.env.VERCEL_REGION };
                if (process.env.AWS_REGION)
                  return {
                    'cloud.provider': 'aws',
                    'cloud.region': process.env.AWS_REGION,
                    'cloud.platform': process.env.AWS_EXECUTION_ENV,
                  };
                if (process.env.GCP_PROJECT) return { 'cloud.provider': 'gcp' };
                if (process.env.ALIYUN_REGION_ID)
                  return {
                    'cloud.provider': 'alibaba_cloud',
                    'cloud.region': process.env.ALIYUN_REGION_ID,
                  };
                if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME)
                  return { 'cloud.provider': 'azure', 'cloud.region': process.env.REGION_NAME };
                else if (process.env.IBM_CLOUD_REGION)
                  return {
                    'cloud.provider': 'ibm_cloud',
                    'cloud.region': process.env.IBM_CLOUD_REGION,
                  };
                else if (process.env.TENCENTCLOUD_REGION)
                  return {
                    'cloud.provider': 'tencent_cloud',
                    'cloud.region': process.env.TENCENTCLOUD_REGION,
                    'cloud.account.id': process.env.TENCENTCLOUD_APPID,
                    'cloud.availability_zone': process.env.TENCENTCLOUD_ZONE,
                  };
                else if (process.env.NETLIFY) return { 'cloud.provider': 'netlify' };
                else if (process.env.FLY_REGION)
                  return { 'cloud.provider': 'fly.io', 'cloud.region': process.env.FLY_REGION };
                else if (process.env.DYNO) return { 'cloud.provider': 'heroku' };
                else return;
              })()),
            e
          );
        }
        return { name: 'Context', processEvent: (e) => r(e) };
      });
    async function p() {
      let e = o.platform();
      switch (e) {
        case 'darwin':
          return f();
        case 'linux':
          return A();
        default:
          return { name: E[e] || e, version: o.release() };
      }
    }
    function _() {
      let e = process.memoryUsage().rss,
        t = {
          app_start_time: new Date(Date.now() - 1e3 * process.uptime()).toISOString(),
          app_memory: e,
        };
      if ('function' == typeof process.availableMemory) {
        let e = process.availableMemory?.();
        null != e && (t.free_memory = e);
      }
      return t;
    }
    function S(e) {
      let t,
        n = {};
      try {
        t = o.uptime();
      } catch {}
      if (
        ('number' == typeof t && (n.boot_time = new Date(Date.now() - 1e3 * t).toISOString()),
        (n.arch = o.arch()),
        (!0 === e || e.memory) && ((n.memory_size = o.totalmem()), (n.free_memory = o.freemem())),
        !0 === e || e.cpu)
      ) {
        let e = o.cpus(),
          t = e?.[0];
        t &&
          ((n.processor_count = e.length),
          (n.cpu_description = t.model),
          (n.processor_frequency = t.speed));
      }
      return n;
    }
    let E = {
        aix: 'IBM AIX',
        freebsd: 'FreeBSD',
        openbsd: 'OpenBSD',
        sunos: 'SunOS',
        win32: 'Windows',
      },
      T = [
        { name: 'fedora-release', distros: ['Fedora'] },
        { name: 'redhat-release', distros: ['Red Hat Linux', 'Centos'] },
        { name: 'redhat_version', distros: ['Red Hat Linux'] },
        { name: 'SuSE-release', distros: ['SUSE Linux'] },
        { name: 'lsb-release', distros: ['Ubuntu Linux', 'Arch Linux'] },
        { name: 'debian_version', distros: ['Debian'] },
        { name: 'debian_release', distros: ['Debian'] },
        { name: 'arch-release', distros: ['Arch Linux'] },
        { name: 'gentoo-release', distros: ['Gentoo Linux'] },
        { name: 'novell-release', distros: ['SUSE Linux'] },
        { name: 'alpine-release', distros: ['Alpine Linux'] },
      ],
      m = {
        alpine: (e) => e,
        arch: (e) => g(/distrib_release=(.*)/, e),
        centos: (e) => g(/release ([^ ]+)/, e),
        debian: (e) => e,
        fedora: (e) => g(/release (..)/, e),
        mint: (e) => g(/distrib_release=(.*)/, e),
        red: (e) => g(/release ([^ ]+)/, e),
        suse: (e) => g(/VERSION = (.*)\n/, e),
        ubuntu: (e) => g(/distrib_release=(.*)/, e),
      };
    function g(e, t) {
      let n = e.exec(t);
      return n ? n[1] : void 0;
    }
    async function f() {
      let e = {
        kernel_version: o.release(),
        name: 'Mac OS X',
        version: `10.${Number(o.release().split('.')[0]) - 4}`,
      };
      try {
        let t = await new Promise((e, t) => {
          r.execFile('/usr/bin/sw_vers', (n, r) => {
            if (n) return void t(n);
            e(r);
          });
        });
        ((e.name = g(/^ProductName:\s+(.*)$/m, t)),
          (e.version = g(/^ProductVersion:\s+(.*)$/m, t)),
          (e.build = g(/^BuildVersion:\s+(.*)$/m, t)));
      } catch {}
      return e;
    }
    function h(e) {
      return e.split(' ')[0].toLowerCase();
    }
    async function A() {
      let e = { kernel_version: o.release(), name: 'Linux' };
      try {
        let t = await c('/etc'),
          n = T.find((e) => t.includes(e.name));
        if (!n) return e;
        let r = a.join('/etc', n.name),
          i = (await l(r, { encoding: 'utf-8' })).toLowerCase(),
          { distros: o } = n;
        e.name = o.find((e) => i.indexOf(h(e)) >= 0) || o[0];
        let s = h(e.name);
        e.version = m[s]?.(i);
      } catch {}
      return e;
    }
    ((n.getAppContext = _),
      (n.getDeviceContext = S),
      (n.nodeContextIntegration = d),
      (n.readDirAsync = c),
      (n.readFileAsync = l));
  },
  60221,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(2157),
      i = e.r(1457),
      o = e.r(48009),
      a = e.r(97017),
      s = new o.LRUMap(10),
      u = new o.LRUMap(20);
    async function l(e, t) {
      let n = {};
      if (t > 0 && e.exception?.values) {
        for (let t of e.exception.values)
          if (t.stacktrace?.frames?.length)
            for (let e = t.stacktrace.frames.length - 1; e >= 0; e--) {
              let r = t.stacktrace.frames[e],
                i = r?.filename;
              !r ||
                'string' != typeof i ||
                'number' != typeof r.lineno ||
                i.startsWith('node:') ||
                i.endsWith('.min.js') ||
                i.endsWith('.min.cjs') ||
                i.endsWith('.min.mjs') ||
                i.startsWith('data:') ||
                (void 0 !== r.lineno && r.lineno > 1e4) ||
                (void 0 !== r.colno && r.colno > 1e3) ||
                (n[i] || (n[i] = []), n[i].push(r.lineno));
            }
      }
      let l = Object.keys(n);
      if (0 == l.length) return e;
      let c = [];
      for (let e of l) {
        if (u.get(e)) continue;
        let l = n[e];
        if (!l) continue;
        l.sort((e, t) => e - t);
        let d = (function (e, t) {
          if (!e.length) return [];
          let n = 0,
            r = e[0];
          if ('number' != typeof r) return [];
          let i = (function (e, t) {
              return [p(e, t), e + t];
            })(r, t),
            o = [];
          for (;;) {
            if (n === e.length - 1) {
              o.push(i);
              break;
            }
            let r = e[n + 1];
            if ('number' != typeof r) break;
            (r <= i[1]
              ? (i[1] = r + t)
              : (o.push(i),
                (i = (function (e, t) {
                  return [p(e, t), e + t];
                })(r, t))),
              n++);
          }
          return o;
        })(l, t);
        if (
          d.every((t) =>
            (function (e, t) {
              let n = s.get(e);
              if (void 0 === n) return !1;
              for (let e = t[0]; e <= t[1]; e++) if (void 0 === n[e]) return !1;
              return !0;
            })(e, t)
          )
        )
          continue;
        let _ = (function (e, t, n) {
          let r = e.get(t);
          return void 0 === r ? (e.set(t, n), n) : r;
        })(s, e, {});
        c.push(
          (function (e, t, n) {
            return new Promise((s, l) => {
              let c = r.createReadStream(e),
                d = i.createInterface({ input: c });
              function p() {
                (c.destroy(), s());
              }
              let _ = 0,
                S = 0,
                E = t[0];
              if (void 0 === E) return void p();
              let T = E[0],
                m = E[1];
              function g(t) {
                (u.set(e, 1),
                  a.DEBUG_BUILD && o.debug.error(`Failed to read file: ${e}. Error: ${t}`),
                  d.close(),
                  d.removeAllListeners(),
                  p());
              }
              (c.on('error', g),
                d.on('error', g),
                d.on('close', p),
                d.on('line', (e) => {
                  if (!(++_ < T) && ((n[_] = o.snipLine(e, 0)), _ >= m)) {
                    if (S === t.length - 1) {
                      (d.close(), d.removeAllListeners());
                      return;
                    }
                    let e = t[++S];
                    if (void 0 === e) {
                      (d.close(), d.removeAllListeners());
                      return;
                    }
                    ((T = e[0]), (m = e[1]));
                  }
                }));
            });
          })(e, d, _)
        );
      }
      if (
        (await Promise.all(c).catch(() => {
          a.DEBUG_BUILD &&
            o.debug.log('Failed to read one or more source files and resolve context lines');
        }),
        t > 0 && e.exception?.values)
      )
        for (let n of e.exception.values)
          n.stacktrace?.frames &&
            n.stacktrace.frames.length > 0 &&
            (function (e, t, n) {
              for (let r of e)
                if (r.filename && void 0 === r.context_line && 'number' == typeof r.lineno) {
                  let e = n.get(r.filename);
                  if (void 0 === e) continue;
                  d(r.lineno, r, t, e);
                }
            })(n.stacktrace.frames, t, s);
      return e;
    }
    function c(e) {
      (delete e.pre_context, delete e.context_line, delete e.post_context);
    }
    function d(e, t, n, r) {
      if (void 0 === t.lineno || void 0 === r) {
        a.DEBUG_BUILD &&
          o.debug.error('Cannot resolve context for frame with no lineno or file contents');
        return;
      }
      t.pre_context = [];
      for (let i = p(e, n); i < e; i++) {
        let e = r[i];
        if (void 0 === e) {
          (c(t), a.DEBUG_BUILD && o.debug.error(`Could not find line ${i} in file ${t.filename}`));
          return;
        }
        t.pre_context.push(e);
      }
      if (void 0 === r[e]) {
        (c(t), a.DEBUG_BUILD && o.debug.error(`Could not find line ${e} in file ${t.filename}`));
        return;
      }
      t.context_line = r[e];
      let i = e + n;
      t.post_context = [];
      for (let n = e + 1; n <= i; n++) {
        let e = r[n];
        if (void 0 === e) break;
        t.post_context.push(e);
      }
    }
    function p(e, t) {
      return Math.max(1, e - t);
    }
    let _ = (e = {}) => {
        let t = void 0 !== e.frameContextLines ? e.frameContextLines : 7;
        return { name: 'ContextLines', processEvent: (e) => l(e, t) };
      },
      S = o.defineIntegration(_);
    ((n.MAX_CONTEXTLINES_COLNO = 1e3),
      (n.MAX_CONTEXTLINES_LINENO = 1e4),
      (n._contextLinesIntegration = _),
      (n.addContextToFrame = d),
      (n.contextLinesIntegration = S));
  },
  7721,
  (e, t, n) => {
    let r;
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.isDebuggerEnabled = async function () {
        if (void 0 === r)
          try {
            r = !!(await e.A(34177)).url();
          } catch {
            r = !1;
          }
        return r;
      }));
  },
  2620,
  (e, t, n) => {
    function r(e) {
      return void 0 !== e && (0 === e.length || '?' === e || '<anonymous>' === e);
    }
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.LOCAL_VARIABLES_KEY = '__SENTRY_ERROR_LOCAL_VARIABLES__'),
      (n.createRateLimiter = function (e, t, n) {
        let r = 0,
          i = 5,
          o = 0;
        return (
          setInterval(() => {
            (0 === o
              ? r > e && (n((i *= 2)), i > 86400 && (i = 86400), (o = i))
              : 0 == (o -= 1) && t(),
              (r = 0));
          }, 1e3).unref(),
          () => {
            r += 1;
          }
        );
      }),
      (n.functionNamesMatch = function (e, t) {
        return e === t || `Object.${e}` === t || e === `Object.${t}` || (r(e) && r(t));
      }),
      (n.isAnonymous = r));
  },
  78037,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(25127),
      i = e.r(48009),
      o = e.r(7721),
      a = e.r(2620),
      s =
        'LyohIEBzZW50cnkvbm9kZS1jb3JlIDEwLjEwLjAgKDYwYmFlOGEpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyBlfWZyb20ibm9kZTppbnNwZWN0b3IvcHJvbWlzZXMiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIHR9ZnJvbSJub2RlOndvcmtlcl90aHJlYWRzIjtjb25zdCBuPWdsb2JhbFRoaXMsaT17fTtjb25zdCBvPSJfX1NFTlRSWV9FUlJPUl9MT0NBTF9WQVJJQUJMRVNfXyI7Y29uc3QgYT10O2Z1bmN0aW9uIHMoLi4uZSl7YS5kZWJ1ZyYmZnVuY3Rpb24oZSl7aWYoISgiY29uc29sZSJpbiBuKSlyZXR1cm4gZSgpO2NvbnN0IHQ9bi5jb25zb2xlLG89e30sYT1PYmplY3Qua2V5cyhpKTthLmZvckVhY2goZT0+e2NvbnN0IG49aVtlXTtvW2VdPXRbZV0sdFtlXT1ufSk7dHJ5e3JldHVybiBlKCl9ZmluYWxseXthLmZvckVhY2goZT0+e3RbZV09b1tlXX0pfX0oKCk9PmNvbnNvbGUubG9nKCJbTG9jYWxWYXJpYWJsZXMgV29ya2VyXSIsLi4uZSkpfWFzeW5jIGZ1bmN0aW9uIGMoZSx0LG4saSl7Y29uc3Qgbz1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pO2lbbl09by5yZXN1bHQuZmlsdGVyKGU9PiJsZW5ndGgiIT09ZS5uYW1lJiYhaXNOYU4ocGFyc2VJbnQoZS5uYW1lLDEwKSkpLnNvcnQoKGUsdCk9PnBhcnNlSW50KGUubmFtZSwxMCktcGFyc2VJbnQodC5uYW1lLDEwKSkubWFwKGU9PmUudmFsdWU/LnZhbHVlKX1hc3luYyBmdW5jdGlvbiByKGUsdCxuLGkpe2NvbnN0IG89YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDp0LG93blByb3BlcnRpZXM6ITB9KTtpW25dPW8ucmVzdWx0Lm1hcChlPT5bZS5uYW1lLGUudmFsdWU/LnZhbHVlXSkucmVkdWNlKChlLFt0LG5dKT0+KGVbdF09bixlKSx7fSl9ZnVuY3Rpb24gdShlLHQpe2UudmFsdWUmJigidmFsdWUiaW4gZS52YWx1ZT92b2lkIDA9PT1lLnZhbHVlLnZhbHVlfHxudWxsPT09ZS52YWx1ZS52YWx1ZT90W2UubmFtZV09YDwke2UudmFsdWUudmFsdWV9PmA6dFtlLm5hbWVdPWUudmFsdWUudmFsdWU6ImRlc2NyaXB0aW9uImluIGUudmFsdWUmJiJmdW5jdGlvbiIhPT1lLnZhbHVlLnR5cGU/dFtlLm5hbWVdPWA8JHtlLnZhbHVlLmRlc2NyaXB0aW9ufT5gOiJ1bmRlZmluZWQiPT09ZS52YWx1ZS50eXBlJiYodFtlLm5hbWVdPSI8dW5kZWZpbmVkPiIpKX1hc3luYyBmdW5jdGlvbiBsKGUsdCl7Y29uc3Qgbj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOnQsb3duUHJvcGVydGllczohMH0pLGk9e307Zm9yKGNvbnN0IHQgb2Ygbi5yZXN1bHQpaWYodC52YWx1ZT8ub2JqZWN0SWQmJiJBcnJheSI9PT10LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3Qgbj10LnZhbHVlLm9iamVjdElkO2F3YWl0IGMoZSxuLHQubmFtZSxpKX1lbHNlIGlmKHQudmFsdWU/Lm9iamVjdElkJiYiT2JqZWN0Ij09PXQudmFsdWUuY2xhc3NOYW1lKXtjb25zdCBuPXQudmFsdWUub2JqZWN0SWQ7YXdhaXQgcihlLG4sdC5uYW1lLGkpfWVsc2UgdC52YWx1ZSYmdSh0LGkpO3JldHVybiBpfWxldCBmOyhhc3luYyBmdW5jdGlvbigpe2NvbnN0IHQ9bmV3IGU7dC5jb25uZWN0VG9NYWluVGhyZWFkKCkscygiQ29ubmVjdGVkIHRvIG1haW4gdGhyZWFkIik7bGV0IG49ITE7dC5vbigiRGVidWdnZXIucmVzdW1lZCIsKCk9PntuPSExfSksdC5vbigiRGVidWdnZXIucGF1c2VkIixlPT57bj0hMCxhc3luYyBmdW5jdGlvbihlLHtyZWFzb246dCxkYXRhOntvYmplY3RJZDpufSxjYWxsRnJhbWVzOml9KXtpZigiZXhjZXB0aW9uIiE9PXQmJiJwcm9taXNlUmVqZWN0aW9uIiE9PXQpcmV0dXJuO2lmKGY/LigpLG51bGw9PW4pcmV0dXJuO2NvbnN0IGE9W107Zm9yKGxldCB0PTA7dDxpLmxlbmd0aDt0Kyspe2NvbnN0e3Njb3BlQ2hhaW46bixmdW5jdGlvbk5hbWU6byx0aGlzOnN9PWlbdF0sYz1uLmZpbmQoZT0+ImxvY2FsIj09PWUudHlwZSkscj0iZ2xvYmFsIiE9PXMuY2xhc3NOYW1lJiZzLmNsYXNzTmFtZT9gJHtzLmNsYXNzTmFtZX0uJHtvfWA6bztpZih2b2lkIDA9PT1jPy5vYmplY3Qub2JqZWN0SWQpYVt0XT17ZnVuY3Rpb246cn07ZWxzZXtjb25zdCBuPWF3YWl0IGwoZSxjLm9iamVjdC5vYmplY3RJZCk7YVt0XT17ZnVuY3Rpb246cix2YXJzOm59fX1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuY2FsbEZ1bmN0aW9uT24iLHtmdW5jdGlvbkRlY2xhcmF0aW9uOmBmdW5jdGlvbigpIHsgdGhpcy4ke299ID0gdGhpcy4ke299IHx8ICR7SlNPTi5zdHJpbmdpZnkoYSl9OyB9YCxzaWxlbnQ6ITAsb2JqZWN0SWQ6bn0pLGF3YWl0IGUucG9zdCgiUnVudGltZS5yZWxlYXNlT2JqZWN0Iix7b2JqZWN0SWQ6bn0pfSh0LGUucGFyYW1zKS50aGVuKGFzeW5jKCk9PntuJiZhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpfSxhc3luYyBlPT57biYmYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5yZXN1bWUiKX0pfSksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiKTtjb25zdCBpPSExIT09YS5jYXB0dXJlQWxsRXhjZXB0aW9ucztpZihhd2FpdCB0LnBvc3QoIkRlYnVnZ2VyLnNldFBhdXNlT25FeGNlcHRpb25zIix7c3RhdGU6aT8iYWxsIjoidW5jYXVnaHQifSksaSl7Y29uc3QgZT1hLm1heEV4Y2VwdGlvbnNQZXJTZWNvbmR8fDUwO2Y9ZnVuY3Rpb24oZSx0LG4pe2xldCBpPTAsbz01LGE9MDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCk9PnswPT09YT9pPmUmJihvKj0yLG4obyksbz44NjQwMCYmKG89ODY0MDApLGE9byk6KGEtPTEsMD09PWEmJnQoKSksaT0wfSwxZTMpLnVucmVmKCksKCk9PntpKz0xfX0oZSxhc3luYygpPT57cygiUmF0ZS1saW1pdCBsaWZ0ZWQuIiksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJhbGwifSl9LGFzeW5jIGU9PntzKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgdC5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pfX0pKCkuY2F0Y2goZT0+e3MoIkZhaWxlZCB0byBzdGFydCBkZWJ1Z2dlciIsZSl9KSxzZXRJbnRlcnZhbCgoKT0+e30sMWU0KTs=';
    function u(...e) {
      i.debug.log('[LocalVariables]', ...e);
    }
    let l = i.defineIntegration((t = {}) => {
      async function n() {
        let t = await e.A(34177);
        t.url() || t.open(0);
      }
      return {
        name: 'LocalVariablesAsync',
        async setup(e) {
          if (!e.getOptions().includeLocalVariables) return;
          if (await o.isDebuggerEnabled())
            return void i.debug.warn(
              'Local variables capture has been disabled because the debugger was already enabled'
            );
          let a = { ...t, debug: i.debug.isEnabled() };
          n().then(
            () => {
              try {
                let e = new r.Worker(new URL(`data:application/javascript;base64,${s}`), {
                  workerData: a,
                  execArgv: [],
                  env: { ...process.env, NODE_OPTIONS: void 0 },
                });
                (process.on('exit', () => {
                  e.terminate();
                }),
                  e.once('error', (e) => {
                    u('Worker error', e);
                  }),
                  e.once('exit', (e) => {
                    u('Worker exit', e);
                  }),
                  e.unref());
              } catch (e) {
                i.debug.error('Failed to start worker', e);
              }
            },
            (e) => {
              i.debug.error('Failed to start inspector', e);
            }
          );
        },
        processEvent: (e, t) =>
          (function (e, t) {
            if (
              t.originalException &&
              'object' == typeof t.originalException &&
              a.LOCAL_VARIABLES_KEY in t.originalException &&
              Array.isArray(t.originalException[a.LOCAL_VARIABLES_KEY])
            ) {
              for (let n of e.exception?.values || [])
                !(function (e, t) {
                  let n = (e.stacktrace?.frames || []).filter((e) => 'new Promise' !== e.function);
                  for (let e = 0; e < n.length; e++) {
                    let r = n.length - e - 1,
                      i = t[e],
                      o = n[r];
                    if (!o || !i) break;
                    void 0 !== i.vars &&
                      !1 !== o.in_app &&
                      a.functionNamesMatch(o.function, i.function) &&
                      (o.vars = i.vars);
                  }
                })(n, t.originalException[a.LOCAL_VARIABLES_KEY]);
              t.originalException[a.LOCAL_VARIABLES_KEY] = void 0;
            }
            return e;
          })(e, t),
      };
    });
    ((n.base64WorkerScript = s), (n.localVariablesAsyncIntegration = l));
  },
  21153,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(73417),
      o = e.r(7721),
      a = e.r(2620);
    function s(e) {
      if (void 0 !== e)
        return e.slice(-10).reduce((e, t) => `${e},${t.function},${t.lineno},${t.colno}`, '');
    }
    function u(e, t) {
      if (void 0 !== t) return s(e(t, 1));
    }
    function l(e) {
      let t = [],
        n = !1;
      function r(r) {
        ((t = []), n || ((n = !0), e(r)));
      }
      return (
        t.push(r),
        {
          add: function (e) {
            t.push(e);
          },
          next: function (e) {
            let n = t.pop() || r;
            try {
              n(e);
            } catch {
              r(e);
            }
          },
        }
      );
    }
    class c {
      constructor(e) {
        this._session = e;
      }
      static async create(t) {
        return t || new c(new (await e.A(34177)).Session());
      }
      configureAndConnect(e, t) {
        (this._session.connect(),
          this._session.on('Debugger.paused', (t) => {
            e(t, () => {
              this._session.post('Debugger.resume');
            });
          }),
          this._session.post('Debugger.enable'),
          this._session.post('Debugger.setPauseOnExceptions', { state: t ? 'all' : 'uncaught' }));
      }
      setPauseOnExceptions(e) {
        this._session.post('Debugger.setPauseOnExceptions', { state: e ? 'all' : 'uncaught' });
      }
      getLocalVariables(e, t) {
        this._getProperties(e, (e) => {
          let { add: n, next: r } = l(t);
          for (let t of e)
            if (t.value?.objectId && 'Array' === t.value.className) {
              let e = t.value.objectId;
              n((n) => this._unrollArray(e, t.name, n, r));
            } else if (t.value?.objectId && 'Object' === t.value.className) {
              let e = t.value.objectId;
              n((n) => this._unrollObject(e, t.name, n, r));
            } else t.value && n((e) => this._unrollOther(t, e, r));
          r({});
        });
      }
      _getProperties(e, t) {
        this._session.post('Runtime.getProperties', { objectId: e, ownProperties: !0 }, (e, n) => {
          e ? t([]) : t(n.result);
        });
      }
      _unrollArray(e, t, n, r) {
        this._getProperties(e, (e) => {
          ((n[t] = e
            .filter((e) => 'length' !== e.name && !isNaN(parseInt(e.name, 10)))
            .sort((e, t) => parseInt(e.name, 10) - parseInt(t.name, 10))
            .map((e) => e.value?.value)),
            r(n));
        });
      }
      _unrollObject(e, t, n, r) {
        this._getProperties(e, (e) => {
          ((n[t] = e
            .map((e) => [e.name, e.value?.value])
            .reduce((e, [t, n]) => ((e[t] = n), e), {})),
            r(n));
        });
      }
      _unrollOther(e, t, n) {
        (e.value &&
          ('value' in e.value
            ? void 0 === e.value.value || null === e.value.value
              ? (t[e.name] = `<${e.value.value}>`)
              : (t[e.name] = e.value.value)
            : 'description' in e.value && 'function' !== e.value.type
              ? (t[e.name] = `<${e.value.description}>`)
              : 'undefined' === e.value.type && (t[e.name] = '<undefined>')),
          n(t));
      }
    }
    let d = r.defineIntegration((e = {}, t) => {
      let n,
        d = new r.LRUMap(20),
        p = !1;
      return {
        name: 'LocalVariables',
        async setupOnce() {
          let s = r.getClient(),
            _ = s?.getOptions();
          return _?.includeLocalVariables
            ? i.NODE_MAJOR < 18
              ? void r.debug.log(
                  'The `LocalVariables` integration is only supported on Node >= v18.'
                )
              : (await o.isDebuggerEnabled())
                ? void r.debug.warn(
                    'Local variables capture has been disabled because the debugger was already enabled'
                  )
                : void c.create(t).then(
                    (t) => {
                      let i = !1 !== e.captureAllExceptions;
                      if (
                        (t.configureAndConnect(
                          (e, r) =>
                            (function (e, { params: { reason: r, data: i, callFrames: o } }, a) {
                              if ('exception' !== r && 'promiseRejection' !== r) return void a();
                              n?.();
                              let s = u(e, i.description);
                              if (void 0 == s) return void a();
                              let { add: c, next: p } = l((e) => {
                                (d.set(s, e), a());
                              });
                              for (let e = 0; e < Math.min(o.length, 5); e++) {
                                let { scopeChain: n, functionName: r, this: i } = o[e],
                                  a = n.find((e) => 'local' === e.type),
                                  s =
                                    'global' !== i.className && i.className
                                      ? `${i.className}.${r}`
                                      : r;
                                if (a?.object.objectId === void 0)
                                  c((t) => {
                                    ((t[e] = { function: s }), p(t));
                                  });
                                else {
                                  let n = a.object.objectId;
                                  c((r) =>
                                    t.getLocalVariables(n, (t) => {
                                      ((r[e] = { function: s, vars: t }), p(r));
                                    })
                                  );
                                }
                              }
                              p([]);
                            })(_.stackParser, e, r),
                          i
                        ),
                        i)
                      ) {
                        let i = e.maxExceptionsPerSecond || 50;
                        n = a.createRateLimiter(
                          i,
                          () => {
                            (r.debug.log('Local variables rate-limit lifted.'),
                              t.setPauseOnExceptions(!0));
                          },
                          (e) => {
                            (r.debug.log(
                              `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${e} seconds.`
                            ),
                              t.setPauseOnExceptions(!1));
                          }
                        );
                      }
                      p = !0;
                    },
                    (e) => {
                      r.debug.log('The `LocalVariables` integration failed to start.', e);
                    }
                  )
            : void 0;
        },
        processEvent(e) {
          if (p) {
            for (let t of e.exception?.values || [])
              !(function (e) {
                let t = s(e.stacktrace?.frames);
                if (void 0 === t) return;
                let n = d.remove(t);
                if (void 0 === n) return;
                let r = (e.stacktrace?.frames || []).filter((e) => 'new Promise' !== e.function);
                for (let e = 0; e < r.length; e++) {
                  let t = r.length - e - 1,
                    i = n[e],
                    o = r[t];
                  if (!o || !i) break;
                  void 0 !== i.vars &&
                    !1 !== o.in_app &&
                    a.functionNamesMatch(o.function, i.function) &&
                    (o.vars = i.vars);
                }
              })(t);
          }
          return e;
        },
        _getCachedFramesCount: () => d.size,
        _getFirstCachedFrame: () => d.values()[0],
      };
    });
    ((n.createCallbackList = l),
      (n.hashFrames = s),
      (n.hashFromStack = u),
      (n.localVariablesSyncIntegration = d));
  },
  98155,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(73417),
      i = e.r(78037),
      o = e.r(21153);
    n.localVariablesIntegration = (e = {}) =>
      r.NODE_VERSION.major < 19
        ? o.localVariablesSyncIntegration(e)
        : i.localVariablesAsyncIntegration(e);
  },
  4441,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.isCjs = function () {
        try {
          return void 0 !== t.exports;
        } catch {
          return !1;
        }
      }));
  },
  98937,
  (e, t, n) => {
    let r;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let i = e.r(2157),
      o = e.r(50227),
      a = e.r(4441),
      s = 'undefined' == typeof __SENTRY_SERVER_MODULES__ ? {} : __SENTRY_SERVER_MODULES__;
    function u() {
      return (
        r ||
          (r = {
            ...s,
            ...(function () {
              let e = (function () {
                try {
                  let e = o.join(process.cwd(), 'package.json');
                  return JSON.parse(i.readFileSync(e, 'utf8'));
                } catch {
                  return {};
                }
              })();
              return { ...e.dependencies, ...e.devDependencies };
            })(),
            ...(a.isCjs()
              ? (function () {
                  let t = e.t.main?.paths || [],
                    n = (function () {
                      try {
                        return Object.keys(e.c);
                      } catch {
                        return [];
                      }
                    })(),
                    r = {},
                    a = new Set();
                  return (
                    n.forEach((e) => {
                      let n = e,
                        s = () => {
                          let e = n;
                          if (!(n = o.dirname(e)) || e === n || a.has(e)) return;
                          if (0 > t.indexOf(n)) return s();
                          let u = o.join(e, 'package.json');
                          if ((a.add(e), !i.existsSync(u))) return s();
                          try {
                            let e = JSON.parse(i.readFileSync(u, 'utf8'));
                            r[e.name] = e.version;
                          } catch {}
                        };
                      s();
                    }),
                    r
                  );
                })()
              : {}),
          }),
        r
      );
    }
    n.modulesIntegration = () => ({
      name: 'Modules',
      processEvent: (e) => ((e.modules = { ...e.modules, ...u() }), e),
      getModules: u,
    });
  },
  38347,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(97017);
    n.logAndExitProcess = function (t) {
      r.consoleSandbox(() => {
        console.error(t);
      });
      let n = r.getClient();
      if (void 0 === n) {
        (i.DEBUG_BUILD &&
          r.debug.warn('No NodeClient was defined, we are exiting the process now.'),
          e.g.process.exit(1));
        return;
      }
      let o = n.getOptions(),
        a = o?.shutdownTimeout && o.shutdownTimeout > 0 ? o.shutdownTimeout : 2e3;
      n.close(a).then(
        (t) => {
          (!t &&
            i.DEBUG_BUILD &&
            r.debug.warn(
              'We reached the timeout for emptying the request buffer, still exiting now!'
            ),
            e.g.process.exit(1));
        },
        (e) => {
          i.DEBUG_BUILD && r.debug.error(e);
        }
      );
    };
  },
  48264,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(97017),
      o = e.r(38347),
      a = r.defineIntegration((t = {}) => {
        let n = { exitEvenIfOtherHandlersAreRegistered: !1, ...t };
        return {
          name: 'OnUncaughtException',
          setup(t) {
            e.g.process.on('uncaughtException', s(t, n));
          },
        };
      });
    function s(t, n) {
      let a,
        s = !1,
        u = !1,
        l = !1,
        c = t.getOptions();
      return Object.assign(
        (d) => {
          let p = o.logAndExitProcess;
          n.onFatalError ? (p = n.onFatalError) : c.onFatalError && (p = c.onFatalError);
          let _ = e.g.process
              .listeners('uncaughtException')
              .filter(
                (e) =>
                  'domainUncaughtExceptionClear' !== e.name &&
                  'sentry_tracingErrorCallback' !== e.tag &&
                  !0 !== e._errorHandler
              ).length,
            S = n.exitEvenIfOtherHandlersAreRegistered || 0 === _;
          s
            ? S &&
              (l
                ? (i.DEBUG_BUILD &&
                    r.debug.warn(
                      'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown'
                    ),
                  o.logAndExitProcess(d))
                : u ||
                  ((u = !0),
                  setTimeout(() => {
                    l || ((l = !0), p(a, d));
                  }, 2e3)))
            : ((a = d),
              (s = !0),
              r.getClient() === t &&
                r.captureException(d, {
                  originalException: d,
                  captureContext: { level: 'fatal' },
                  mechanism: { handled: !1, type: 'onuncaughtexception' },
                }),
              !l && S && ((l = !0), p(d)));
        },
        { _errorHandler: !0 }
      );
    }
    ((n.makeErrorHandler = s), (n.onUncaughtExceptionIntegration = a));
  },
  22843,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(38347),
      o = r.defineIntegration((t = {}) => {
        let n = { mode: 'warn', ...t };
        return {
          name: 'OnUnhandledRejection',
          setup(t) {
            e.g.process.on('unhandledRejection', a(t, n));
          },
        };
      });
    function a(e, t) {
      return function (n, o) {
        if (r.getClient() !== e) return;
        let a = 'strict' === t.mode ? 'fatal' : 'error',
          s = n && 'object' == typeof n ? n._sentry_active_span : void 0;
        ((s ? (e) => r.withActiveSpan(s, e) : (e) => e())(() => {
          r.captureException(n, {
            originalException: o,
            captureContext: { extra: { unhandledPromiseRejection: !0 }, level: a },
            mechanism: { handled: !1, type: 'onunhandledrejection' },
          });
        }),
          (function (e, t) {
            let n =
              'This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). The promise rejected with the reason:';
            'warn' === t
              ? r.consoleSandbox(() => {
                  (console.warn(n),
                    console.error(e && 'object' == typeof e && 'stack' in e ? e.stack : e));
                })
              : 'strict' === t &&
                (r.consoleSandbox(() => {
                  console.warn(n);
                }),
                i.logAndExitProcess(e));
          })(n, t.mode));
      };
    }
    ((n.makeUnhandledPromiseHandler = a), (n.onUnhandledRejectionIntegration = o));
  },
  18397,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(12057),
      i = e.r(25127),
      o = e.r(48009),
      a = e.r(73417),
      s = e.r(7721),
      { isPromise: u } = r.types,
      l =
        'LyohIEBzZW50cnkvbm9kZS1jb3JlIDEwLjEwLjAgKDYwYmFlOGEpIHwgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9zZW50cnktamF2YXNjcmlwdCAqLwppbXBvcnR7U2Vzc2lvbiBhcyB0fWZyb20ibm9kZTppbnNwZWN0b3IiO2ltcG9ydHt3b3JrZXJEYXRhIGFzIG4scGFyZW50UG9ydCBhcyBlfWZyb20ibm9kZTp3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIHIsc2VwIGFzIG99ZnJvbSJub2RlOnBhdGgiO2ltcG9ydCphcyBzIGZyb20ibm9kZTpodHRwIjtpbXBvcnQqYXMgaSBmcm9tIm5vZGU6aHR0cHMiO2ltcG9ydHtSZWFkYWJsZSBhcyBjfWZyb20ibm9kZTpzdHJlYW0iO2ltcG9ydHtjcmVhdGVHemlwIGFzIHV9ZnJvbSJub2RlOnpsaWIiO2ltcG9ydCphcyBhIGZyb20ibm9kZTpuZXQiO2ltcG9ydCphcyBmIGZyb20ibm9kZTp0bHMiO2NvbnN0IGg9InVuZGVmaW5lZCI9PXR5cGVvZiBfX1NFTlRSWV9ERUJVR19ffHxfX1NFTlRSWV9ERUJVR19fLHA9Z2xvYmFsVGhpcyxsPSIxMC4xMC4wIjtmdW5jdGlvbiBkKCl7cmV0dXJuIG0ocCkscH1mdW5jdGlvbiBtKHQpe2NvbnN0IG49dC5fX1NFTlRSWV9fPXQuX19TRU5UUllfX3x8e307cmV0dXJuIG4udmVyc2lvbj1uLnZlcnNpb258fGwsbltsXT1uW2xdfHx7fX1mdW5jdGlvbiBnKHQsbixlPXApe2NvbnN0IHI9ZS5fX1NFTlRSWV9fPWUuX19TRU5UUllfX3x8e30sbz1yW2xdPXJbbF18fHt9O3JldHVybiBvW3RdfHwob1t0XT1uKCkpfWNvbnN0IHk9e307ZnVuY3Rpb24gYih0KXtpZighKCJjb25zb2xlImluIHApKXJldHVybiB0KCk7Y29uc3Qgbj1wLmNvbnNvbGUsZT17fSxyPU9iamVjdC5rZXlzKHkpO3IuZm9yRWFjaCh0PT57Y29uc3Qgcj15W3RdO2VbdF09blt0XSxuW3RdPXJ9KTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e3IuZm9yRWFjaCh0PT57blt0XT1lW3RdfSl9fWZ1bmN0aW9uIHYoKXtyZXR1cm4gdygpLmVuYWJsZWR9ZnVuY3Rpb24gXyh0LC4uLm4pe2gmJnYoKSYmYigoKT0+e3AuY29uc29sZVt0XShgU2VudHJ5IExvZ2dlciBbJHt0fV06YCwuLi5uKX0pfWZ1bmN0aW9uIHcoKXtyZXR1cm4gaD9nKCJsb2dnZXJTZXR0aW5ncyIsKCk9Pih7ZW5hYmxlZDohMX0pKTp7ZW5hYmxlZDohMX19Y29uc3QgUz17ZW5hYmxlOmZ1bmN0aW9uKCl7dygpLmVuYWJsZWQ9ITB9LGRpc2FibGU6ZnVuY3Rpb24oKXt3KCkuZW5hYmxlZD0hMX0saXNFbmFibGVkOnYsbG9nOmZ1bmN0aW9uKC4uLnQpe18oImxvZyIsLi4udCl9LHdhcm46ZnVuY3Rpb24oLi4udCl7Xygid2FybiIsLi4udCl9LGVycm9yOmZ1bmN0aW9uKC4uLnQpe18oImVycm9yIiwuLi50KX19LCQ9L2NhcHR1cmVNZXNzYWdlfGNhcHR1cmVFeGNlcHRpb24vO2Z1bmN0aW9uIEUodCl7cmV0dXJuIHRbdC5sZW5ndGgtMV18fHt9fWNvbnN0IHg9Ijxhbm9ueW1vdXM+Ijtjb25zdCBOPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gQyh0LG4pe3JldHVybiBOLmNhbGwodCk9PT1gW29iamVjdCAke259XWB9ZnVuY3Rpb24gayh0KXtyZXR1cm4gQyh0LCJTdHJpbmciKX1mdW5jdGlvbiBUKHQpe3JldHVybiBDKHQsIk9iamVjdCIpfWZ1bmN0aW9uIGoodCl7cmV0dXJuIEJvb2xlYW4odD8udGhlbiYmImZ1bmN0aW9uIj09dHlwZW9mIHQudGhlbil9ZnVuY3Rpb24gSSh0LG4pe3RyeXtyZXR1cm4gdCBpbnN0YW5jZW9mIG59Y2F0Y2h7cmV0dXJuITF9fWNvbnN0IE89cDtmdW5jdGlvbiBSKHQsbil7Y29uc3QgZT10LHI9W107aWYoIWU/LnRhZ05hbWUpcmV0dXJuIiI7aWYoTy5IVE1MRWxlbWVudCYmZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZlLmRhdGFzZXQpe2lmKGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlDb21wb25lbnQ7aWYoZS5kYXRhc2V0LnNlbnRyeUVsZW1lbnQpcmV0dXJuIGUuZGF0YXNldC5zZW50cnlFbGVtZW50fXIucHVzaChlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Y29uc3Qgbz1uPy5sZW5ndGg/bi5maWx0ZXIodD0+ZS5nZXRBdHRyaWJ1dGUodCkpLm1hcCh0PT5bdCxlLmdldEF0dHJpYnV0ZSh0KV0pOm51bGw7aWYobz8ubGVuZ3RoKW8uZm9yRWFjaCh0PT57ci5wdXNoKGBbJHt0WzBdfT0iJHt0WzFdfSJdYCl9KTtlbHNle2UuaWQmJnIucHVzaChgIyR7ZS5pZH1gKTtjb25zdCB0PWUuY2xhc3NOYW1lO2lmKHQmJmsodCkpe2NvbnN0IG49dC5zcGxpdCgvXHMrLyk7Zm9yKGNvbnN0IHQgb2YgbilyLnB1c2goYC4ke3R9YCl9fWNvbnN0IHM9WyJhcmlhLWxhYmVsIiwidHlwZSIsIm5hbWUiLCJ0aXRsZSIsImFsdCJdO2Zvcihjb25zdCB0IG9mIHMpe2NvbnN0IG49ZS5nZXRBdHRyaWJ1dGUodCk7biYmci5wdXNoKGBbJHt0fT0iJHtufSJdYCl9cmV0dXJuIHIuam9pbigiIil9ZnVuY3Rpb24gQSh0LG49MCl7cmV0dXJuInN0cmluZyIhPXR5cGVvZiB0fHwwPT09bnx8dC5sZW5ndGg8PW4/dDpgJHt0LnNsaWNlKDAsbil9Li4uYH1mdW5jdGlvbiBEKHQpe2lmKGZ1bmN0aW9uKHQpe3N3aXRjaChOLmNhbGwodCkpe2Nhc2UiW29iamVjdCBFcnJvcl0iOmNhc2UiW29iamVjdCBFeGNlcHRpb25dIjpjYXNlIltvYmplY3QgRE9NRXhjZXB0aW9uXSI6Y2FzZSJbb2JqZWN0IFdlYkFzc2VtYmx5LkV4Y2VwdGlvbl0iOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuIEkodCxFcnJvcil9fSh0KSlyZXR1cm57bWVzc2FnZTp0Lm1lc3NhZ2UsbmFtZTp0Lm5hbWUsc3RhY2s6dC5zdGFjaywuLi5VKHQpfTtpZihuPXQsInVuZGVmaW5lZCIhPXR5cGVvZiBFdmVudCYmSShuLEV2ZW50KSl7Y29uc3Qgbj17dHlwZTp0LnR5cGUsdGFyZ2V0OlAodC50YXJnZXQpLGN1cnJlbnRUYXJnZXQ6UCh0LmN1cnJlbnRUYXJnZXQpLC4uLlUodCl9O3JldHVybiJ1bmRlZmluZWQiIT10eXBlb2YgQ3VzdG9tRXZlbnQmJkkodCxDdXN0b21FdmVudCkmJihuLmRldGFpbD10LmRldGFpbCksbn1yZXR1cm4gdDt2YXIgbn1mdW5jdGlvbiBQKHQpe3RyeXtyZXR1cm4gbj10LCJ1bmRlZmluZWQiIT10eXBlb2YgRWxlbWVudCYmSShuLEVsZW1lbnQpP2Z1bmN0aW9uKHQsbj17fSl7aWYoIXQpcmV0dXJuIjx1bmtub3duPiI7dHJ5e2xldCBlPXQ7Y29uc3Qgcj01LG89W107bGV0IHM9MCxpPTA7Y29uc3QgYz0iID4gIix1PWMubGVuZ3RoO2xldCBhO2NvbnN0IGY9QXJyYXkuaXNBcnJheShuKT9uOm4ua2V5QXR0cnMsaD0hQXJyYXkuaXNBcnJheShuKSYmbi5tYXhTdHJpbmdMZW5ndGh8fDgwO2Zvcig7ZSYmcysrPHImJihhPVIoZSxmKSwhKCJodG1sIj09PWF8fHM+MSYmaStvLmxlbmd0aCp1K2EubGVuZ3RoPj1oKSk7KW8ucHVzaChhKSxpKz1hLmxlbmd0aCxlPWUucGFyZW50Tm9kZTtyZXR1cm4gby5yZXZlcnNlKCkuam9pbihjKX1jYXRjaHtyZXR1cm4iPHVua25vd24+In19KHQpOk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1jYXRjaHtyZXR1cm4iPHVua25vd24+In12YXIgbn1mdW5jdGlvbiBVKHQpe2lmKCJvYmplY3QiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2NvbnN0IG49e307Zm9yKGNvbnN0IGUgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSYmKG5bZV09dFtlXSk7cmV0dXJuIG59cmV0dXJue319ZnVuY3Rpb24gTSh0PWZ1bmN0aW9uKCl7Y29uc3QgdD1wO3JldHVybiB0LmNyeXB0b3x8dC5tc0NyeXB0b30oKSl7bGV0IG49KCk9PjE2Kk1hdGgucmFuZG9tKCk7dHJ5e2lmKHQ/LnJhbmRvbVVVSUQpcmV0dXJuIHQucmFuZG9tVVVJRCgpLnJlcGxhY2UoLy0vZywiIik7dD8uZ2V0UmFuZG9tVmFsdWVzJiYobj0oKT0+e2NvbnN0IG49bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuIHQuZ2V0UmFuZG9tVmFsdWVzKG4pLG5bMF19KX1jYXRjaHt9cmV0dXJuKFsxZTddKzFlMys0ZTMrOGUzKzFlMTEpLnJlcGxhY2UoL1swMThdL2csdD0+KHReKDE1Jm4oKSk+PnQvNCkudG9TdHJpbmcoMTYpKX1mdW5jdGlvbiBMKCl7cmV0dXJuIERhdGUubm93KCkvMWUzfWxldCBCO2Z1bmN0aW9uIEcoKXtyZXR1cm4oQj8/KEI9ZnVuY3Rpb24oKXtjb25zdHtwZXJmb3JtYW5jZTp0fT1wO2lmKCF0Py5ub3d8fCF0LnRpbWVPcmlnaW4pcmV0dXJuIEw7Y29uc3Qgbj10LnRpbWVPcmlnaW47cmV0dXJuKCk9PihuK3Qubm93KCkpLzFlM30oKSkpKCl9ZnVuY3Rpb24gSCh0KXtjb25zdCBuPUcoKSxlPXtzaWQ6TSgpLGluaXQ6ITAsdGltZXN0YW1wOm4sc3RhcnRlZDpuLGR1cmF0aW9uOjAsc3RhdHVzOiJvayIsZXJyb3JzOjAsaWdub3JlRHVyYXRpb246ITEsdG9KU09OOigpPT5mdW5jdGlvbih0KXtyZXR1cm57c2lkOmAke3Quc2lkfWAsaW5pdDp0LmluaXQsc3RhcnRlZDpuZXcgRGF0ZSgxZTMqdC5zdGFydGVkKS50b0lTT1N0cmluZygpLHRpbWVzdGFtcDpuZXcgRGF0ZSgxZTMqdC50aW1lc3RhbXApLnRvSVNPU3RyaW5nKCksc3RhdHVzOnQuc3RhdHVzLGVycm9yczp0LmVycm9ycyxkaWQ6Im51bWJlciI9PXR5cGVvZiB0LmRpZHx8InN0cmluZyI9PXR5cGVvZiB0LmRpZD9gJHt0LmRpZH1gOnZvaWQgMCxkdXJhdGlvbjp0LmR1cmF0aW9uLGFibm9ybWFsX21lY2hhbmlzbTp0LmFibm9ybWFsX21lY2hhbmlzbSxhdHRyczp7cmVsZWFzZTp0LnJlbGVhc2UsZW52aXJvbm1lbnQ6dC5lbnZpcm9ubWVudCxpcF9hZGRyZXNzOnQuaXBBZGRyZXNzLHVzZXJfYWdlbnQ6dC51c2VyQWdlbnR9fX0oZSl9O3JldHVybiB0JiZKKGUsdCksZX1mdW5jdGlvbiBKKHQsbj17fSl7aWYobi51c2VyJiYoIXQuaXBBZGRyZXNzJiZuLnVzZXIuaXBfYWRkcmVzcyYmKHQuaXBBZGRyZXNzPW4udXNlci5pcF9hZGRyZXNzKSx0LmRpZHx8bi5kaWR8fCh0LmRpZD1uLnVzZXIuaWR8fG4udXNlci5lbWFpbHx8bi51c2VyLnVzZXJuYW1lKSksdC50aW1lc3RhbXA9bi50aW1lc3RhbXB8fEcoKSxuLmFibm9ybWFsX21lY2hhbmlzbSYmKHQuYWJub3JtYWxfbWVjaGFuaXNtPW4uYWJub3JtYWxfbWVjaGFuaXNtKSxuLmlnbm9yZUR1cmF0aW9uJiYodC5pZ25vcmVEdXJhdGlvbj1uLmlnbm9yZUR1cmF0aW9uKSxuLnNpZCYmKHQuc2lkPTMyPT09bi5zaWQubGVuZ3RoP24uc2lkOk0oKSksdm9pZCAwIT09bi5pbml0JiYodC5pbml0PW4uaW5pdCksIXQuZGlkJiZuLmRpZCYmKHQuZGlkPWAke24uZGlkfWApLCJudW1iZXIiPT10eXBlb2Ygbi5zdGFydGVkJiYodC5zdGFydGVkPW4uc3RhcnRlZCksdC5pZ25vcmVEdXJhdGlvbil0LmR1cmF0aW9uPXZvaWQgMDtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2Ygbi5kdXJhdGlvbil0LmR1cmF0aW9uPW4uZHVyYXRpb247ZWxzZXtjb25zdCBuPXQudGltZXN0YW1wLXQuc3RhcnRlZDt0LmR1cmF0aW9uPW4+PTA/bjowfW4ucmVsZWFzZSYmKHQucmVsZWFzZT1uLnJlbGVhc2UpLG4uZW52aXJvbm1lbnQmJih0LmVudmlyb25tZW50PW4uZW52aXJvbm1lbnQpLCF0LmlwQWRkcmVzcyYmbi5pcEFkZHJlc3MmJih0LmlwQWRkcmVzcz1uLmlwQWRkcmVzcyksIXQudXNlckFnZW50JiZuLnVzZXJBZ2VudCYmKHQudXNlckFnZW50PW4udXNlckFnZW50KSwibnVtYmVyIj09dHlwZW9mIG4uZXJyb3JzJiYodC5lcnJvcnM9bi5lcnJvcnMpLG4uc3RhdHVzJiYodC5zdGF0dXM9bi5zdGF0dXMpfWZ1bmN0aW9uIHoodCxuLGU9Mil7aWYoIW58fCJvYmplY3QiIT10eXBlb2Ygbnx8ZTw9MClyZXR1cm4gbjtpZih0JiYwPT09T2JqZWN0LmtleXMobikubGVuZ3RoKXJldHVybiB0O2NvbnN0IHI9ey4uLnR9O2Zvcihjb25zdCB0IGluIG4pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCkmJihyW3RdPXooclt0XSxuW3RdLGUtMSkpO3JldHVybiByfWZ1bmN0aW9uIEYoKXtyZXR1cm4gTSgpfWZ1bmN0aW9uIFcoKXtyZXR1cm4gTSgpLnN1YnN0cmluZygxNil9Y29uc3QgWT0iX3NlbnRyeVNwYW4iO2Z1bmN0aW9uIEsodCxuKXtuP2Z1bmN0aW9uKHQsbixlKXt0cnl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9KX1jYXRjaHtoJiZTLmxvZyhgRmFpbGVkIHRvIGFkZCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSAiJHtufSIgdG8gb2JqZWN0YCx0KX19KHQsWSxuKTpkZWxldGUgdFtZXX1mdW5jdGlvbiBaKHQpe3JldHVybiB0W1ldfWNsYXNzIFZ7Y29uc3RydWN0b3IoKXt0aGlzLnQ9ITEsdGhpcy5vPVtdLHRoaXMuaT1bXSx0aGlzLnU9W10sdGhpcy5oPVtdLHRoaXMucD17fSx0aGlzLmw9e30sdGhpcy5tPXt9LHRoaXMudj17fSx0aGlzLl89e30sdGhpcy5TPXt0cmFjZUlkOkYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9fWNsb25lKCl7Y29uc3QgdD1uZXcgVjtyZXR1cm4gdC51PVsuLi50aGlzLnVdLHQubD17Li4udGhpcy5sfSx0Lm09ey4uLnRoaXMubX0sdC52PXsuLi50aGlzLnZ9LHRoaXMudi5mbGFncyYmKHQudi5mbGFncz17dmFsdWVzOlsuLi50aGlzLnYuZmxhZ3MudmFsdWVzXX0pLHQucD10aGlzLnAsdC5OPXRoaXMuTix0LkM9dGhpcy5DLHQuaz10aGlzLmssdC5UPXRoaXMuVCx0Lmk9Wy4uLnRoaXMuaV0sdC5oPVsuLi50aGlzLmhdLHQuXz17Li4udGhpcy5ffSx0LlM9ey4uLnRoaXMuU30sdC5qPXRoaXMuaix0Lkk9dGhpcy5JLEsodCxaKHRoaXMpKSx0fXNldENsaWVudCh0KXt0aGlzLmo9dH1zZXRMYXN0RXZlbnRJZCh0KXt0aGlzLkk9dH1nZXRDbGllbnQoKXtyZXR1cm4gdGhpcy5qfWxhc3RFdmVudElkKCl7cmV0dXJuIHRoaXMuSX1hZGRTY29wZUxpc3RlbmVyKHQpe3RoaXMuby5wdXNoKHQpfWFkZEV2ZW50UHJvY2Vzc29yKHQpe3JldHVybiB0aGlzLmkucHVzaCh0KSx0aGlzfXNldFVzZXIodCl7cmV0dXJuIHRoaXMucD10fHx7ZW1haWw6dm9pZCAwLGlkOnZvaWQgMCxpcF9hZGRyZXNzOnZvaWQgMCx1c2VybmFtZTp2b2lkIDB9LHRoaXMuQyYmSih0aGlzLkMse3VzZXI6dH0pLHRoaXMuTygpLHRoaXN9Z2V0VXNlcigpe3JldHVybiB0aGlzLnB9c2V0VGFncyh0KXtyZXR1cm4gdGhpcy5sPXsuLi50aGlzLmwsLi4udH0sdGhpcy5PKCksdGhpc31zZXRUYWcodCxuKXtyZXR1cm4gdGhpcy5sPXsuLi50aGlzLmwsW3RdOm59LHRoaXMuTygpLHRoaXN9c2V0RXh0cmFzKHQpe3JldHVybiB0aGlzLm09ey4uLnRoaXMubSwuLi50fSx0aGlzLk8oKSx0aGlzfXNldEV4dHJhKHQsbil7cmV0dXJuIHRoaXMubT17Li4udGhpcy5tLFt0XTpufSx0aGlzLk8oKSx0aGlzfXNldEZpbmdlcnByaW50KHQpe3JldHVybiB0aGlzLlQ9dCx0aGlzLk8oKSx0aGlzfXNldExldmVsKHQpe3JldHVybiB0aGlzLk49dCx0aGlzLk8oKSx0aGlzfXNldFRyYW5zYWN0aW9uTmFtZSh0KXtyZXR1cm4gdGhpcy5rPXQsdGhpcy5PKCksdGhpc31zZXRDb250ZXh0KHQsbil7cmV0dXJuIG51bGw9PT1uP2RlbGV0ZSB0aGlzLnZbdF06dGhpcy52W3RdPW4sdGhpcy5PKCksdGhpc31zZXRTZXNzaW9uKHQpe3JldHVybiB0P3RoaXMuQz10OmRlbGV0ZSB0aGlzLkMsdGhpcy5PKCksdGhpc31nZXRTZXNzaW9uKCl7cmV0dXJuIHRoaXMuQ311cGRhdGUodCl7aWYoIXQpcmV0dXJuIHRoaXM7Y29uc3Qgbj0iZnVuY3Rpb24iPT10eXBlb2YgdD90KHRoaXMpOnQsZT1uIGluc3RhbmNlb2YgVj9uLmdldFNjb3BlRGF0YSgpOlQobik/dDp2b2lkIDAse3RhZ3M6cixleHRyYTpvLHVzZXI6cyxjb250ZXh0czppLGxldmVsOmMsZmluZ2VycHJpbnQ6dT1bXSxwcm9wYWdhdGlvbkNvbnRleHQ6YX09ZXx8e307cmV0dXJuIHRoaXMubD17Li4udGhpcy5sLC4uLnJ9LHRoaXMubT17Li4udGhpcy5tLC4uLm99LHRoaXMudj17Li4udGhpcy52LC4uLml9LHMmJk9iamVjdC5rZXlzKHMpLmxlbmd0aCYmKHRoaXMucD1zKSxjJiYodGhpcy5OPWMpLHUubGVuZ3RoJiYodGhpcy5UPXUpLGEmJih0aGlzLlM9YSksdGhpc31jbGVhcigpe3JldHVybiB0aGlzLnU9W10sdGhpcy5sPXt9LHRoaXMubT17fSx0aGlzLnA9e30sdGhpcy52PXt9LHRoaXMuTj12b2lkIDAsdGhpcy5rPXZvaWQgMCx0aGlzLlQ9dm9pZCAwLHRoaXMuQz12b2lkIDAsSyh0aGlzLHZvaWQgMCksdGhpcy5oPVtdLHRoaXMuc2V0UHJvcGFnYXRpb25Db250ZXh0KHt0cmFjZUlkOkYoKSxzYW1wbGVSYW5kOk1hdGgucmFuZG9tKCl9KSx0aGlzLk8oKSx0aGlzfWFkZEJyZWFkY3J1bWIodCxuKXtjb25zdCBlPSJudW1iZXIiPT10eXBlb2Ygbj9uOjEwMDtpZihlPD0wKXJldHVybiB0aGlzO2NvbnN0IHI9e3RpbWVzdGFtcDpMKCksLi4udCxtZXNzYWdlOnQubWVzc2FnZT9BKHQubWVzc2FnZSwyMDQ4KTp0Lm1lc3NhZ2V9O3JldHVybiB0aGlzLnUucHVzaChyKSx0aGlzLnUubGVuZ3RoPmUmJih0aGlzLnU9dGhpcy51LnNsaWNlKC1lKSx0aGlzLmo/LnJlY29yZERyb3BwZWRFdmVudCgiYnVmZmVyX292ZXJmbG93IiwibG9nX2l0ZW0iKSksdGhpcy5PKCksdGhpc31nZXRMYXN0QnJlYWRjcnVtYigpe3JldHVybiB0aGlzLnVbdGhpcy51Lmxlbmd0aC0xXX1jbGVhckJyZWFkY3J1bWJzKCl7cmV0dXJuIHRoaXMudT1bXSx0aGlzLk8oKSx0aGlzfWFkZEF0dGFjaG1lbnQodCl7cmV0dXJuIHRoaXMuaC5wdXNoKHQpLHRoaXN9Y2xlYXJBdHRhY2htZW50cygpe3JldHVybiB0aGlzLmg9W10sdGhpc31nZXRTY29wZURhdGEoKXtyZXR1cm57YnJlYWRjcnVtYnM6dGhpcy51LGF0dGFjaG1lbnRzOnRoaXMuaCxjb250ZXh0czp0aGlzLnYsdGFnczp0aGlzLmwsZXh0cmE6dGhpcy5tLHVzZXI6dGhpcy5wLGxldmVsOnRoaXMuTixmaW5nZXJwcmludDp0aGlzLlR8fFtdLGV2ZW50UHJvY2Vzc29yczp0aGlzLmkscHJvcGFnYXRpb25Db250ZXh0OnRoaXMuUyxzZGtQcm9jZXNzaW5nTWV0YWRhdGE6dGhpcy5fLHRyYW5zYWN0aW9uTmFtZTp0aGlzLmssc3BhbjpaKHRoaXMpfX1zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEodCl7cmV0dXJuIHRoaXMuXz16KHRoaXMuXyx0LDIpLHRoaXN9c2V0UHJvcGFnYXRpb25Db250ZXh0KHQpe3JldHVybiB0aGlzLlM9dCx0aGlzfWdldFByb3BhZ2F0aW9uQ29udGV4dCgpe3JldHVybiB0aGlzLlN9Y2FwdHVyZUV4Y2VwdGlvbih0LG4pe2NvbnN0IGU9bj8uZXZlbnRfaWR8fE0oKTtpZighdGhpcy5qKXJldHVybiBoJiZTLndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBleGNlcHRpb24hIiksZTtjb25zdCByPW5ldyBFcnJvcigiU2VudHJ5IHN5bnRoZXRpY0V4Y2VwdGlvbiIpO3JldHVybiB0aGlzLmouY2FwdHVyZUV4Y2VwdGlvbih0LHtvcmlnaW5hbEV4Y2VwdGlvbjp0LHN5bnRoZXRpY0V4Y2VwdGlvbjpyLC4uLm4sZXZlbnRfaWQ6ZX0sdGhpcyksZX1jYXB0dXJlTWVzc2FnZSh0LG4sZSl7Y29uc3Qgcj1lPy5ldmVudF9pZHx8TSgpO2lmKCF0aGlzLmopcmV0dXJuIGgmJlMud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIG1lc3NhZ2UhIikscjtjb25zdCBvPW5ldyBFcnJvcih0KTtyZXR1cm4gdGhpcy5qLmNhcHR1cmVNZXNzYWdlKHQsbix7b3JpZ2luYWxFeGNlcHRpb246dCxzeW50aGV0aWNFeGNlcHRpb246bywuLi5lLGV2ZW50X2lkOnJ9LHRoaXMpLHJ9Y2FwdHVyZUV2ZW50KHQsbil7Y29uc3QgZT1uPy5ldmVudF9pZHx8TSgpO3JldHVybiB0aGlzLmo/KHRoaXMuai5jYXB0dXJlRXZlbnQodCx7Li4ubixldmVudF9pZDplfSx0aGlzKSxlKTooaCYmUy53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgZXZlbnQhIiksZSl9Tygpe3RoaXMudHx8KHRoaXMudD0hMCx0aGlzLm8uZm9yRWFjaCh0PT57dCh0aGlzKX0pLHRoaXMudD0hMSl9fWNsYXNzIHF7Y29uc3RydWN0b3IodCxuKXtsZXQgZSxyO2U9dHx8bmV3IFYscj1ufHxuZXcgVix0aGlzLlI9W3tzY29wZTplfV0sdGhpcy5BPXJ9d2l0aFNjb3BlKHQpe2NvbnN0IG49dGhpcy5EKCk7bGV0IGU7dHJ5e2U9dChuKX1jYXRjaCh0KXt0aHJvdyB0aGlzLlAoKSx0fXJldHVybiBqKGUpP2UudGhlbih0PT4odGhpcy5QKCksdCksdD0+e3Rocm93IHRoaXMuUCgpLHR9KToodGhpcy5QKCksZSl9Z2V0Q2xpZW50KCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5jbGllbnR9Z2V0U2NvcGUoKXtyZXR1cm4gdGhpcy5nZXRTdGFja1RvcCgpLnNjb3BlfWdldElzb2xhdGlvblNjb3BlKCl7cmV0dXJuIHRoaXMuQX1nZXRTdGFja1RvcCgpe3JldHVybiB0aGlzLlJbdGhpcy5SLmxlbmd0aC0xXX1EKCl7Y29uc3QgdD10aGlzLmdldFNjb3BlKCkuY2xvbmUoKTtyZXR1cm4gdGhpcy5SLnB1c2goe2NsaWVudDp0aGlzLmdldENsaWVudCgpLHNjb3BlOnR9KSx0fVAoKXtyZXR1cm4hKHRoaXMuUi5sZW5ndGg8PTEpJiYhIXRoaXMuUi5wb3AoKX19ZnVuY3Rpb24gUSgpe2NvbnN0IHQ9bShkKCkpO3JldHVybiB0LnN0YWNrPXQuc3RhY2t8fG5ldyBxKGcoImRlZmF1bHRDdXJyZW50U2NvcGUiLCgpPT5uZXcgViksZygiZGVmYXVsdElzb2xhdGlvblNjb3BlIiwoKT0+bmV3IFYpKX1mdW5jdGlvbiBYKHQpe3JldHVybiBRKCkud2l0aFNjb3BlKHQpfWZ1bmN0aW9uIHR0KHQsbil7Y29uc3QgZT1RKCk7cmV0dXJuIGUud2l0aFNjb3BlKCgpPT4oZS5nZXRTdGFja1RvcCgpLnNjb3BlPXQsbih0KSkpfWZ1bmN0aW9uIG50KHQpe3JldHVybiBRKCkud2l0aFNjb3BlKCgpPT50KFEoKS5nZXRJc29sYXRpb25TY29wZSgpKSl9ZnVuY3Rpb24gZXQodCl7Y29uc3Qgbj1tKHQpO3JldHVybiBuLmFjcz9uLmFjczp7d2l0aElzb2xhdGlvblNjb3BlOm50LHdpdGhTY29wZTpYLHdpdGhTZXRTY29wZTp0dCx3aXRoU2V0SXNvbGF0aW9uU2NvcGU6KHQsbik9Pm50KG4pLGdldEN1cnJlbnRTY29wZTooKT0+USgpLmdldFNjb3BlKCksZ2V0SXNvbGF0aW9uU2NvcGU6KCk9PlEoKS5nZXRJc29sYXRpb25TY29wZSgpfX1mdW5jdGlvbiBydCgpe3JldHVybiBldChkKCkpLmdldEN1cnJlbnRTY29wZSgpLmdldENsaWVudCgpfWZ1bmN0aW9uIG90KHQpe3JldHVybntzY29wZTp0Ll9zZW50cnlTY29wZSxpc29sYXRpb25TY29wZTp0Ll9zZW50cnlJc29sYXRpb25TY29wZX19Y29uc3Qgc3Q9L15zZW50cnktLztmdW5jdGlvbiBpdCh0KXtjb25zdCBuPWZ1bmN0aW9uKHQpe2lmKCF0fHwhayh0KSYmIUFycmF5LmlzQXJyYXkodCkpcmV0dXJuO2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQucmVkdWNlKCh0LG4pPT57Y29uc3QgZT1jdChuKTtyZXR1cm4gT2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW24sZV0pPT57dFtuXT1lfSksdH0se30pO3JldHVybiBjdCh0KX0odCk7aWYoIW4pcmV0dXJuO2NvbnN0IGU9T2JqZWN0LmVudHJpZXMobikucmVkdWNlKCh0LFtuLGVdKT0+e2lmKG4ubWF0Y2goc3QpKXt0W24uc2xpY2UoNyldPWV9cmV0dXJuIHR9LHt9KTtyZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RoPjA/ZTp2b2lkIDB9ZnVuY3Rpb24gY3QodCl7cmV0dXJuIHQuc3BsaXQoIiwiKS5tYXAodD0+dC5zcGxpdCgiPSIpLm1hcCh0PT57dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodC50cmltKCkpfWNhdGNoe3JldHVybn19KSkucmVkdWNlKCh0LFtuLGVdKT0+KG4mJmUmJih0W25dPWUpLHQpLHt9KX1jb25zdCB1dD0vXm8oXGQrKVwuLztmdW5jdGlvbiBhdCh0LG49ITEpe2NvbnN0e2hvc3Q6ZSxwYXRoOnIscGFzczpvLHBvcnQ6cyxwcm9qZWN0SWQ6aSxwcm90b2NvbDpjLHB1YmxpY0tleTp1fT10O3JldHVybmAke2N9Oi8vJHt1fSR7biYmbz9gOiR7b31gOiIifUAke2V9JHtzP2A6JHtzfWA6IiJ9LyR7cj9gJHtyfS9gOnJ9JHtpfWB9ZnVuY3Rpb24gZnQodCl7Y29uc3Qgbj10LmdldE9wdGlvbnMoKSx7aG9zdDplfT10LmdldERzbigpfHx7fTtsZXQgcjtyZXR1cm4gbi5vcmdJZD9yPVN0cmluZyhuLm9yZ0lkKTplJiYocj1mdW5jdGlvbih0KXtjb25zdCBuPXQubWF0Y2godXQpO3JldHVybiBuPy5bMV19KGUpKSxyfWZ1bmN0aW9uIGh0KHQpe2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZSxpc1JlbW90ZTpyfT10LnNwYW5Db250ZXh0KCksbz1yP246bXQodCkucGFyZW50X3NwYW5faWQscz1vdCh0KS5zY29wZTtyZXR1cm57cGFyZW50X3NwYW5faWQ6byxzcGFuX2lkOnI/cz8uZ2V0UHJvcGFnYXRpb25Db250ZXh0KCkucHJvcGFnYXRpb25TcGFuSWR8fFcoKTpuLHRyYWNlX2lkOmV9fWZ1bmN0aW9uIHB0KHQpe3JldHVybiB0JiZ0Lmxlbmd0aD4wP3QubWFwKCh7Y29udGV4dDp7c3BhbklkOnQsdHJhY2VJZDpuLHRyYWNlRmxhZ3M6ZSwuLi5yfSxhdHRyaWJ1dGVzOm99KT0+KHtzcGFuX2lkOnQsdHJhY2VfaWQ6bixzYW1wbGVkOjE9PT1lLGF0dHJpYnV0ZXM6bywuLi5yfSkpOnZvaWQgMH1mdW5jdGlvbiBsdCh0KXtyZXR1cm4ibnVtYmVyIj09dHlwZW9mIHQ/ZHQodCk6QXJyYXkuaXNBcnJheSh0KT90WzBdK3RbMV0vMWU5OnQgaW5zdGFuY2VvZiBEYXRlP2R0KHQuZ2V0VGltZSgpKTpHKCl9ZnVuY3Rpb24gZHQodCl7cmV0dXJuIHQ+OTk5OTk5OTk5OT90LzFlMzp0fWZ1bmN0aW9uIG10KHQpe2lmKGZ1bmN0aW9uKHQpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0LmdldFNwYW5KU09OfSh0KSlyZXR1cm4gdC5nZXRTcGFuSlNPTigpO2NvbnN0e3NwYW5JZDpuLHRyYWNlSWQ6ZX09dC5zcGFuQ29udGV4dCgpO2lmKGZ1bmN0aW9uKHQpe2NvbnN0IG49dDtyZXR1cm4hIShuLmF0dHJpYnV0ZXMmJm4uc3RhcnRUaW1lJiZuLm5hbWUmJm4uZW5kVGltZSYmbi5zdGF0dXMpfSh0KSl7Y29uc3R7YXR0cmlidXRlczpyLHN0YXJ0VGltZTpvLG5hbWU6cyxlbmRUaW1lOmksc3RhdHVzOmMsbGlua3M6dX09dDtyZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsZGF0YTpyLGRlc2NyaXB0aW9uOnMscGFyZW50X3NwYW5faWQ6InBhcmVudFNwYW5JZCJpbiB0P3QucGFyZW50U3BhbklkOiJwYXJlbnRTcGFuQ29udGV4dCJpbiB0P3QucGFyZW50U3BhbkNvbnRleHQ/LnNwYW5JZDp2b2lkIDAsc3RhcnRfdGltZXN0YW1wOmx0KG8pLHRpbWVzdGFtcDpsdChpKXx8dm9pZCAwLHN0YXR1czpndChjKSxvcDpyWyJzZW50cnkub3AiXSxvcmlnaW46clsic2VudHJ5Lm9yaWdpbiJdLGxpbmtzOnB0KHUpfX1yZXR1cm57c3Bhbl9pZDpuLHRyYWNlX2lkOmUsc3RhcnRfdGltZXN0YW1wOjAsZGF0YTp7fX19ZnVuY3Rpb24gZ3QodCl7aWYodCYmMCE9PXQuY29kZSlyZXR1cm4gMT09PXQuY29kZT8ib2siOnQubWVzc2FnZXx8InVua25vd25fZXJyb3IifWZ1bmN0aW9uIHl0KHQpe3JldHVybiB0Ll9zZW50cnlSb290U3Bhbnx8dH1mdW5jdGlvbiBidCh0KXtjb25zdCBuPXJ0KCk7aWYoIW4pcmV0dXJue307Y29uc3QgZT15dCh0KSxyPW10KGUpLG89ci5kYXRhLHM9ZS5zcGFuQ29udGV4dCgpLnRyYWNlU3RhdGUsaT1zPy5nZXQoInNlbnRyeS5zYW1wbGVfcmF0ZSIpPz9vWyJzZW50cnkuc2FtcGxlX3JhdGUiXT8/b1sic2VudHJ5LnByZXZpb3VzX3RyYWNlX3NhbXBsZV9yYXRlIl07ZnVuY3Rpb24gYyh0KXtyZXR1cm4ibnVtYmVyIiE9dHlwZW9mIGkmJiJzdHJpbmciIT10eXBlb2YgaXx8KHQuc2FtcGxlX3JhdGU9YCR7aX1gKSx0fWNvbnN0IHU9ZS5fZnJvemVuRHNjO2lmKHUpcmV0dXJuIGModSk7Y29uc3QgYT1zPy5nZXQoInNlbnRyeS5kc2MiKSxmPWEmJml0KGEpO2lmKGYpcmV0dXJuIGMoZik7Y29uc3QgaD1mdW5jdGlvbih0LG4pe2NvbnN0IGU9bi5nZXRPcHRpb25zKCkse3B1YmxpY0tleTpyfT1uLmdldERzbigpfHx7fSxvPXtlbnZpcm9ubWVudDplLmVudmlyb25tZW50fHwicHJvZHVjdGlvbiIscmVsZWFzZTplLnJlbGVhc2UscHVibGljX2tleTpyLHRyYWNlX2lkOnQsb3JnX2lkOmZ0KG4pfTtyZXR1cm4gbi5lbWl0KCJjcmVhdGVEc2MiLG8pLG99KHQuc3BhbkNvbnRleHQoKS50cmFjZUlkLG4pLHA9b1sic2VudHJ5LnNvdXJjZSJdLGw9ci5kZXNjcmlwdGlvbjtyZXR1cm4idXJsIiE9PXAmJmwmJihoLnRyYW5zYWN0aW9uPWwpLGZ1bmN0aW9uKCl7aWYoImJvb2xlYW4iPT10eXBlb2YgX19TRU5UUllfVFJBQ0lOR19fJiYhX19TRU5UUllfVFJBQ0lOR19fKXJldHVybiExO2NvbnN0IHQ9cnQoKT8uZ2V0T3B0aW9ucygpO3JldHVybiEoIXR8fG51bGw9PXQudHJhY2VzU2FtcGxlUmF0ZSYmIXQudHJhY2VzU2FtcGxlcil9KCkmJihoLnNhbXBsZWQ9U3RyaW5nKGZ1bmN0aW9uKHQpe2NvbnN0e3RyYWNlRmxhZ3M6bn09dC5zcGFuQ29udGV4dCgpO3JldHVybiAxPT09bn0oZSkpLGguc2FtcGxlX3JhbmQ9cz8uZ2V0KCJzZW50cnkuc2FtcGxlX3JhbmQiKT8/b3QoZSkuc2NvcGU/LmdldFByb3BhZ2F0aW9uQ29udGV4dCgpLnNhbXBsZVJhbmQudG9TdHJpbmcoKSksYyhoKSxuLmVtaXQoImNyZWF0ZURzYyIsaCxlKSxofWZ1bmN0aW9uIHZ0KHQsbj0xMDAsZT0xLzApe3RyeXtyZXR1cm4gX3QoIiIsdCxuLGUpfWNhdGNoKHQpe3JldHVybntFUlJPUjpgKipub24tc2VyaWFsaXphYmxlKiogKCR7dH0pYH19fWZ1bmN0aW9uIF90KHQsbixlPTEvMCxyPTEvMCxvPWZ1bmN0aW9uKCl7Y29uc3QgdD1uZXcgV2Vha1NldDtmdW5jdGlvbiBuKG4pe3JldHVybiEhdC5oYXMobil8fCh0LmFkZChuKSwhMSl9ZnVuY3Rpb24gZShuKXt0LmRlbGV0ZShuKX1yZXR1cm5bbixlXX0oKSl7Y29uc3RbcyxpXT1vO2lmKG51bGw9PW58fFsiYm9vbGVhbiIsInN0cmluZyJdLmluY2x1ZGVzKHR5cGVvZiBuKXx8Im51bWJlciI9PXR5cGVvZiBuJiZOdW1iZXIuaXNGaW5pdGUobikpcmV0dXJuIG47Y29uc3QgYz1mdW5jdGlvbih0LG4pe3RyeXtpZigiZG9tYWluIj09PXQmJm4mJiJvYmplY3QiPT10eXBlb2YgbiYmbi5VKXJldHVybiJbRG9tYWluXSI7aWYoImRvbWFpbkVtaXR0ZXIiPT09dClyZXR1cm4iW0RvbWFpbkVtaXR0ZXJdIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbCYmbj09PWdsb2JhbClyZXR1cm4iW0dsb2JhbF0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZuPT09d2luZG93KXJldHVybiJbV2luZG93XSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudCYmbj09PWRvY3VtZW50KXJldHVybiJbRG9jdW1lbnRdIjtpZigib2JqZWN0Ij09dHlwZW9mKGU9bikmJm51bGwhPT1lJiYoZS5fX2lzVnVlfHxlLk0pKXJldHVybiJbVnVlVmlld01vZGVsXSI7aWYoZnVuY3Rpb24odCl7cmV0dXJuIFQodCkmJiJuYXRpdmVFdmVudCJpbiB0JiYicHJldmVudERlZmF1bHQiaW4gdCYmInN0b3BQcm9wYWdhdGlvbiJpbiB0fShuKSlyZXR1cm4iW1N5bnRoZXRpY0V2ZW50XSI7aWYoIm51bWJlciI9PXR5cGVvZiBuJiYhTnVtYmVyLmlzRmluaXRlKG4pKXJldHVybmBbJHtufV1gO2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBuKXJldHVybmBbRnVuY3Rpb246ICR7ZnVuY3Rpb24odCl7dHJ5e3JldHVybiB0JiYiZnVuY3Rpb24iPT10eXBlb2YgdCYmdC5uYW1lfHx4fWNhdGNoe3JldHVybiB4fX0obil9XWA7aWYoInN5bWJvbCI9PXR5cGVvZiBuKXJldHVybmBbJHtTdHJpbmcobil9XWA7aWYoImJpZ2ludCI9PXR5cGVvZiBuKXJldHVybmBbQmlnSW50OiAke1N0cmluZyhuKX1dYDtjb25zdCByPWZ1bmN0aW9uKHQpe2NvbnN0IG49T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO3JldHVybiBuPy5jb25zdHJ1Y3Rvcj9uLmNvbnN0cnVjdG9yLm5hbWU6Im51bGwgcHJvdG90eXBlIn0obik7cmV0dXJuL15IVE1MKFx3KilFbGVtZW50JC8udGVzdChyKT9gW0hUTUxFbGVtZW50OiAke3J9XWA6YFtvYmplY3QgJHtyfV1gfWNhdGNoKHQpe3JldHVybmAqKm5vbi1zZXJpYWxpemFibGUqKiAoJHt0fSlgfXZhciBlfSh0LG4pO2lmKCFjLnN0YXJ0c1dpdGgoIltvYmplY3QgIikpcmV0dXJuIGM7aWYobi5fX3NlbnRyeV9za2lwX25vcm1hbGl6YXRpb25fXylyZXR1cm4gbjtjb25zdCB1PSJudW1iZXIiPT10eXBlb2Ygbi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX18/bi5fX3NlbnRyeV9vdmVycmlkZV9ub3JtYWxpemF0aW9uX2RlcHRoX186ZTtpZigwPT09dSlyZXR1cm4gYy5yZXBsYWNlKCJvYmplY3QgIiwiIik7aWYocyhuKSlyZXR1cm4iW0NpcmN1bGFyIH5dIjtjb25zdCBhPW47aWYoYSYmImZ1bmN0aW9uIj09dHlwZW9mIGEudG9KU09OKXRyeXtyZXR1cm4gX3QoIiIsYS50b0pTT04oKSx1LTEscixvKX1jYXRjaHt9Y29uc3QgZj1BcnJheS5pc0FycmF5KG4pP1tdOnt9O2xldCBoPTA7Y29uc3QgcD1EKG4pO2Zvcihjb25zdCB0IGluIHApe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCx0KSljb250aW51ZTtpZihoPj1yKXtmW3RdPSJbTWF4UHJvcGVydGllcyB+XSI7YnJlYWt9Y29uc3Qgbj1wW3RdO2ZbdF09X3QodCxuLHUtMSxyLG8pLGgrK31yZXR1cm4gaShuKSxmfWZ1bmN0aW9uIHd0KHQsbil7Y29uc3QgZT1uLnJlcGxhY2UoL1xcL2csIi8iKS5yZXBsYWNlKC9bfFxce30oKVtcXV4kKyo/Ll0vZywiXFwkJiIpO2xldCByPXQ7dHJ5e3I9ZGVjb2RlVVJJKHQpfWNhdGNoe31yZXR1cm4gci5yZXBsYWNlKC9cXC9nLCIvIikucmVwbGFjZSgvd2VicGFjazpcLz8vZywiIikucmVwbGFjZShuZXcgUmVnRXhwKGAoZmlsZTovLyk/Lyoke2V9LypgLCJpZyIpLCJhcHA6Ly8vIil9ZnVuY3Rpb24gU3QodCxuPVtdKXtyZXR1cm5bdCxuXX1mdW5jdGlvbiAkdCh0LG4pe2NvbnN0IGU9dFsxXTtmb3IoY29uc3QgdCBvZiBlKXtpZihuKHQsdFswXS50eXBlKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBFdCh0KXtjb25zdCBuPW0ocCk7cmV0dXJuIG4uZW5jb2RlUG9seWZpbGw/bi5lbmNvZGVQb2x5ZmlsbCh0KToobmV3IFRleHRFbmNvZGVyKS5lbmNvZGUodCl9ZnVuY3Rpb24geHQodCl7Y29uc3RbbixlXT10O2xldCByPUpTT04uc3RyaW5naWZ5KG4pO2Z1bmN0aW9uIG8odCl7InN0cmluZyI9PXR5cGVvZiByP3I9InN0cmluZyI9PXR5cGVvZiB0P3IrdDpbRXQociksdF06ci5wdXNoKCJzdHJpbmciPT10eXBlb2YgdD9FdCh0KTp0KX1mb3IoY29uc3QgdCBvZiBlKXtjb25zdFtuLGVdPXQ7aWYobyhgXG4ke0pTT04uc3RyaW5naWZ5KG4pfVxuYCksInN0cmluZyI9PXR5cGVvZiBlfHxlIGluc3RhbmNlb2YgVWludDhBcnJheSlvKGUpO2Vsc2V7bGV0IHQ7dHJ5e3Q9SlNPTi5zdHJpbmdpZnkoZSl9Y2F0Y2h7dD1KU09OLnN0cmluZ2lmeSh2dChlKSl9byh0KX19cmV0dXJuInN0cmluZyI9PXR5cGVvZiByP3I6ZnVuY3Rpb24odCl7Y29uc3Qgbj10LnJlZHVjZSgodCxuKT0+dCtuLmxlbmd0aCwwKSxlPW5ldyBVaW50OEFycmF5KG4pO2xldCByPTA7Zm9yKGNvbnN0IG4gb2YgdCllLnNldChuLHIpLHIrPW4ubGVuZ3RoO3JldHVybiBlfShyKX1jb25zdCBOdD17c2Vzc2lvbjoic2Vzc2lvbiIsc2Vzc2lvbnM6InNlc3Npb24iLGF0dGFjaG1lbnQ6ImF0dGFjaG1lbnQiLHRyYW5zYWN0aW9uOiJ0cmFuc2FjdGlvbiIsZXZlbnQ6ImVycm9yIixjbGllbnRfcmVwb3J0OiJpbnRlcm5hbCIsdXNlcl9yZXBvcnQ6ImRlZmF1bHQiLHByb2ZpbGU6InByb2ZpbGUiLHByb2ZpbGVfY2h1bms6InByb2ZpbGUiLHJlcGxheV9ldmVudDoicmVwbGF5IixyZXBsYXlfcmVjb3JkaW5nOiJyZXBsYXkiLGNoZWNrX2luOiJtb25pdG9yIixmZWVkYmFjazoiZmVlZGJhY2siLHNwYW46InNwYW4iLHJhd19zZWN1cml0eToic2VjdXJpdHkiLGxvZzoibG9nX2l0ZW0ifTtmdW5jdGlvbiBDdCh0KXtpZighdD8uc2RrKXJldHVybjtjb25zdHtuYW1lOm4sdmVyc2lvbjplfT10LnNkaztyZXR1cm57bmFtZTpuLHZlcnNpb246ZX19ZnVuY3Rpb24ga3QodCxuLGUscil7Y29uc3Qgbz1DdChlKSxzPXQudHlwZSYmInJlcGxheV9ldmVudCIhPT10LnR5cGU/dC50eXBlOiJldmVudCI7IWZ1bmN0aW9uKHQsbil7aWYoIW4pcmV0dXJuIHQ7Y29uc3QgZT10LnNka3x8e307dC5zZGs9ey4uLmUsbmFtZTplLm5hbWV8fG4ubmFtZSx2ZXJzaW9uOmUudmVyc2lvbnx8bi52ZXJzaW9uLGludGVncmF0aW9uczpbLi4udC5zZGs/LmludGVncmF0aW9uc3x8W10sLi4ubi5pbnRlZ3JhdGlvbnN8fFtdXSxwYWNrYWdlczpbLi4udC5zZGs/LnBhY2thZ2VzfHxbXSwuLi5uLnBhY2thZ2VzfHxbXV0sc2V0dGluZ3M6dC5zZGs/LnNldHRpbmdzfHxuLnNldHRpbmdzP3suLi50LnNkaz8uc2V0dGluZ3MsLi4ubi5zZXR0aW5nc306dm9pZCAwfX0odCxlPy5zZGspO2NvbnN0IGk9ZnVuY3Rpb24odCxuLGUscil7Y29uc3Qgbz10LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT8uZHluYW1pY1NhbXBsaW5nQ29udGV4dDtyZXR1cm57ZXZlbnRfaWQ6dC5ldmVudF9pZCxzZW50X2F0OihuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSwuLi5uJiZ7c2RrOm59LC4uLiEhZSYmciYme2RzbjphdChyKX0sLi4ubyYme3RyYWNlOm99fX0odCxvLHIsbik7ZGVsZXRlIHQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhO3JldHVybiBTdChpLFtbe3R5cGU6c30sdF1dKX1jb25zdCBUdD0iX19TRU5UUllfU1VQUFJFU1NfVFJBQ0lOR19fIjtmdW5jdGlvbiBqdCh0KXtjb25zdCBuPWV0KGQoKSk7cmV0dXJuIG4uc3VwcHJlc3NUcmFjaW5nP24uc3VwcHJlc3NUcmFjaW5nKHQpOmZ1bmN0aW9uKC4uLnQpe2NvbnN0IG49ZXQoZCgpKTtpZigyPT09dC5sZW5ndGgpe2NvbnN0W2Uscl09dDtyZXR1cm4gZT9uLndpdGhTZXRTY29wZShlLHIpOm4ud2l0aFNjb3BlKHIpfXJldHVybiBuLndpdGhTY29wZSh0WzBdKX0obj0+e24uc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHtbVHRdOiEwfSk7Y29uc3QgZT10KCk7cmV0dXJuIG4uc2V0U0RLUHJvY2Vzc2luZ01ldGFkYXRhKHtbVHRdOnZvaWQgMH0pLGV9KX1mdW5jdGlvbiBJdCh0KXtyZXR1cm4gbmV3IE90KG49PntuKHQpfSl9Y2xhc3MgT3R7Y29uc3RydWN0b3IodCl7dGhpcy5MPTAsdGhpcy5CPVtdLHRoaXMuRyh0KX10aGVuKHQsbil7cmV0dXJuIG5ldyBPdCgoZSxyKT0+e3RoaXMuQi5wdXNoKFshMSxuPT57aWYodCl0cnl7ZSh0KG4pKX1jYXRjaCh0KXtyKHQpfWVsc2UgZShuKX0sdD0+e2lmKG4pdHJ5e2Uobih0KSl9Y2F0Y2godCl7cih0KX1lbHNlIHIodCl9XSksdGhpcy5IKCl9KX1jYXRjaCh0KXtyZXR1cm4gdGhpcy50aGVuKHQ9PnQsdCl9ZmluYWxseSh0KXtyZXR1cm4gbmV3IE90KChuLGUpPT57bGV0IHIsbztyZXR1cm4gdGhpcy50aGVuKG49PntvPSExLHI9bix0JiZ0KCl9LG49PntvPSEwLHI9bix0JiZ0KCl9KS50aGVuKCgpPT57bz9lKHIpOm4ocil9KX0pfUgoKXtpZigwPT09dGhpcy5MKXJldHVybjtjb25zdCB0PXRoaXMuQi5zbGljZSgpO3RoaXMuQj1bXSx0LmZvckVhY2godD0+e3RbMF18fCgxPT09dGhpcy5MJiZ0WzFdKHRoaXMuSiksMj09PXRoaXMuTCYmdFsyXSh0aGlzLkopLHRbMF09ITApfSl9Ryh0KXtjb25zdCBuPSh0LG4pPT57MD09PXRoaXMuTCYmKGoobik/bi50aGVuKGUscik6KHRoaXMuTD10LHRoaXMuSj1uLHRoaXMuSCgpKSl9LGU9dD0+e24oMSx0KX0scj10PT57bigyLHQpfTt0cnl7dChlLHIpfWNhdGNoKHQpe3IodCl9fX1mdW5jdGlvbiBSdCh0LG4pe2NvbnN0e2ZpbmdlcnByaW50OmUsc3BhbjpyLGJyZWFkY3J1bWJzOm8sc2RrUHJvY2Vzc2luZ01ldGFkYXRhOnN9PW47IWZ1bmN0aW9uKHQsbil7Y29uc3R7ZXh0cmE6ZSx0YWdzOnIsdXNlcjpvLGNvbnRleHRzOnMsbGV2ZWw6aSx0cmFuc2FjdGlvbk5hbWU6Y309bjtPYmplY3Qua2V5cyhlKS5sZW5ndGgmJih0LmV4dHJhPXsuLi5lLC4uLnQuZXh0cmF9KTtPYmplY3Qua2V5cyhyKS5sZW5ndGgmJih0LnRhZ3M9ey4uLnIsLi4udC50YWdzfSk7T2JqZWN0LmtleXMobykubGVuZ3RoJiYodC51c2VyPXsuLi5vLC4uLnQudXNlcn0pO09iamVjdC5rZXlzKHMpLmxlbmd0aCYmKHQuY29udGV4dHM9ey4uLnMsLi4udC5jb250ZXh0c30pO2kmJih0LmxldmVsPWkpO2MmJiJ0cmFuc2FjdGlvbiIhPT10LnR5cGUmJih0LnRyYW5zYWN0aW9uPWMpfSh0LG4pLHImJmZ1bmN0aW9uKHQsbil7dC5jb250ZXh0cz17dHJhY2U6aHQobiksLi4udC5jb250ZXh0c30sdC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE9e2R5bmFtaWNTYW1wbGluZ0NvbnRleHQ6YnQobiksLi4udC5zZGtQcm9jZXNzaW5nTWV0YWRhdGF9O2NvbnN0IGU9eXQobikscj1tdChlKS5kZXNjcmlwdGlvbjtyJiYhdC50cmFuc2FjdGlvbiYmInRyYW5zYWN0aW9uIj09PXQudHlwZSYmKHQudHJhbnNhY3Rpb249cil9KHQsciksZnVuY3Rpb24odCxuKXt0LmZpbmdlcnByaW50PXQuZmluZ2VycHJpbnQ/QXJyYXkuaXNBcnJheSh0LmZpbmdlcnByaW50KT90LmZpbmdlcnByaW50Olt0LmZpbmdlcnByaW50XTpbXSxuJiYodC5maW5nZXJwcmludD10LmZpbmdlcnByaW50LmNvbmNhdChuKSk7dC5maW5nZXJwcmludC5sZW5ndGh8fGRlbGV0ZSB0LmZpbmdlcnByaW50fSh0LGUpLGZ1bmN0aW9uKHQsbil7Y29uc3QgZT1bLi4udC5icmVhZGNydW1ic3x8W10sLi4ubl07dC5icmVhZGNydW1icz1lLmxlbmd0aD9lOnZvaWQgMH0odCxvKSxmdW5jdGlvbih0LG4pe3Quc2RrUHJvY2Vzc2luZ01ldGFkYXRhPXsuLi50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSwuLi5ufX0odCxzKX1jb25zdCBBdD1TeW1ib2wuZm9yKCJTZW50cnlCdWZmZXJGdWxsRXJyb3IiKTtmdW5jdGlvbiBEdCh0KXtjb25zdCBuPVtdO2Z1bmN0aW9uIGUodCl7cmV0dXJuIG4uc3BsaWNlKG4uaW5kZXhPZih0KSwxKVswXXx8UHJvbWlzZS5yZXNvbHZlKHZvaWQgMCl9cmV0dXJueyQ6bixhZGQ6ZnVuY3Rpb24ocil7aWYoISh2b2lkIDA9PT10fHxuLmxlbmd0aDx0KSlyZXR1cm4gbz1BdCxuZXcgT3QoKHQsbik9PntuKG8pfSk7dmFyIG87Y29uc3Qgcz1yKCk7cmV0dXJuLTE9PT1uLmluZGV4T2YocykmJm4ucHVzaChzKSxzLnRoZW4oKCk9PmUocykpLnRoZW4obnVsbCwoKT0+ZShzKS50aGVuKG51bGwsKCk9Pnt9KSksc30sZHJhaW46ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBPdCgoZSxyKT0+e2xldCBvPW4ubGVuZ3RoO2lmKCFvKXJldHVybiBlKCEwKTtjb25zdCBzPXNldFRpbWVvdXQoKCk9Pnt0JiZ0PjAmJmUoITEpfSx0KTtuLmZvckVhY2godD0+e0l0KHQpLnRoZW4oKCk9PnstLW98fChjbGVhclRpbWVvdXQocyksZSghMCkpfSxyKX0pfSl9fX1mdW5jdGlvbiBQdCh0LHtzdGF0dXNDb2RlOm4saGVhZGVyczplfSxyPURhdGUubm93KCkpe2NvbnN0IG89ey4uLnR9LHM9ZT8uWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdLGk9ZT8uWyJyZXRyeS1hZnRlciJdO2lmKHMpZm9yKGNvbnN0IHQgb2Ygcy50cmltKCkuc3BsaXQoIiwiKSl7Y29uc3RbbixlLCwsc109dC5zcGxpdCgiOiIsNSksaT1wYXJzZUludChuLDEwKSxjPTFlMyooaXNOYU4oaSk/NjA6aSk7aWYoZSlmb3IoY29uc3QgdCBvZiBlLnNwbGl0KCI7IikpIm1ldHJpY19idWNrZXQiPT09dCYmcyYmIXMuc3BsaXQoIjsiKS5pbmNsdWRlcygiY3VzdG9tIil8fChvW3RdPXIrYyk7ZWxzZSBvLmFsbD1yK2N9ZWxzZSBpP28uYWxsPXIrZnVuY3Rpb24odCxuPURhdGUubm93KCkpe2NvbnN0IGU9cGFyc2VJbnQoYCR7dH1gLDEwKTtpZighaXNOYU4oZSkpcmV0dXJuIDFlMyplO2NvbnN0IHI9RGF0ZS5wYXJzZShgJHt0fWApO3JldHVybiBpc05hTihyKT82ZTQ6ci1ufShpLHIpOjQyOT09PW4mJihvLmFsbD1yKzZlNCk7cmV0dXJuIG99ZnVuY3Rpb24gVXQodCxuLGU9RHQodC5idWZmZXJTaXplfHw2NCkpe2xldCByPXt9O3JldHVybntzZW5kOmZ1bmN0aW9uKHQpe2NvbnN0IG89W107aWYoJHQodCwodCxuKT0+e2NvbnN0IGU9ZnVuY3Rpb24odCl7cmV0dXJuIE50W3RdfShuKTsoZnVuY3Rpb24odCxuLGU9RGF0ZS5ub3coKSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbbl18fHQuYWxsfHwwfSh0LG4pPmV9KShyLGUpfHxvLnB1c2godCl9KSwwPT09by5sZW5ndGgpcmV0dXJuIEl0KHt9KTtjb25zdCBzPVN0KHRbMF0sbyksaT10PT57JHQocywodCxuKT0+e30pfTtyZXR1cm4gZS5hZGQoKCk9Pm4oe2JvZHk6eHQocyl9KS50aGVuKHQ9Pih2b2lkIDAhPT10LnN0YXR1c0NvZGUmJih0LnN0YXR1c0NvZGU8MjAwfHx0LnN0YXR1c0NvZGU+PTMwMCkmJmgmJlMud2FybihgU2VudHJ5IHJlc3BvbmRlZCB3aXRoIHN0YXR1cyBjb2RlICR7dC5zdGF0dXNDb2RlfSB0byBzZW50IGV2ZW50LmApLHI9UHQocix0KSx0KSx0PT57dGhyb3cgaSgpLGgmJlMuZXJyb3IoIkVuY291bnRlcmVkIGVycm9yIHJ1bm5pbmcgdHJhbnNwb3J0IHJlcXVlc3Q6Iix0KSx0fSkpLnRoZW4odD0+dCx0PT57aWYodD09PUF0KXJldHVybiBoJiZTLmVycm9yKCJTa2lwcGVkIHNlbmRpbmcgZXZlbnQgYmVjYXVzZSBidWZmZXIgaXMgZnVsbC4iKSxpKCksSXQoe30pO3Rocm93IHR9KX0sZmx1c2g6dD0+ZS5kcmFpbih0KX19Y29uc3QgTXQ9L14oXFMrOlxcfFwvPykoW1xzXFNdKj8pKCg/OlwuezEsMn18W14vXFxdKz98KShcLlteLi9cXF0qfCkpKD86Wy9cXF0qKSQvO2Z1bmN0aW9uIEx0KHQpe2NvbnN0IG49ZnVuY3Rpb24odCl7Y29uc3Qgbj10Lmxlbmd0aD4xMDI0P2A8dHJ1bmNhdGVkPiR7dC5zbGljZSgtMTAyNCl9YDp0LGU9TXQuZXhlYyhuKTtyZXR1cm4gZT9lLnNsaWNlKDEpOltdfSh0KSxlPW5bMF18fCIiO2xldCByPW5bMV07cmV0dXJuIGV8fHI/KHImJihyPXIuc2xpY2UoMCxyLmxlbmd0aC0xKSksZStyKToiLiJ9ZnVuY3Rpb24gQnQodCxuPSExKXtyZXR1cm4hKG58fHQmJiF0LnN0YXJ0c1dpdGgoIi8iKSYmIXQubWF0Y2goL15bQS1aXTovKSYmIXQuc3RhcnRzV2l0aCgiLiIpJiYhdC5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSkmJnZvaWQgMCE9PXQmJiF0LmluY2x1ZGVzKCJub2RlX21vZHVsZXMvIil9Y29uc3QgR3Q9U3ltYm9sKCJBZ2VudEJhc2VJbnRlcm5hbFN0YXRlIik7Y2xhc3MgSHQgZXh0ZW5kcyBzLkFnZW50e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXNbR3RdPXt9fWlzU2VjdXJlRW5kcG9pbnQodCl7aWYodCl7aWYoImJvb2xlYW4iPT10eXBlb2YgdC5zZWN1cmVFbmRwb2ludClyZXR1cm4gdC5zZWN1cmVFbmRwb2ludDtpZigic3RyaW5nIj09dHlwZW9mIHQucHJvdG9jb2wpcmV0dXJuImh0dHBzOiI9PT10LnByb3RvY29sfWNvbnN0e3N0YWNrOm59PW5ldyBFcnJvcjtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIG4mJm4uc3BsaXQoIlxuIikuc29tZSh0PT4tMSE9PXQuaW5kZXhPZigiKGh0dHBzLmpzOiIpfHwtMSE9PXQuaW5kZXhPZigibm9kZTpodHRwczoiKSl9Y3JlYXRlU29ja2V0KHQsbixlKXtjb25zdCByPXsuLi5uLHNlY3VyZUVuZHBvaW50OnRoaXMuaXNTZWN1cmVFbmRwb2ludChuKX07UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+dGhpcy5jb25uZWN0KHQscikpLnRoZW4obz0+e2lmKG8gaW5zdGFuY2VvZiBzLkFnZW50KXJldHVybiBvLmFkZFJlcXVlc3QodCxyKTt0aGlzW0d0XS5jdXJyZW50U29ja2V0PW8sc3VwZXIuY3JlYXRlU29ja2V0KHQsbixlKX0sZSl9Y3JlYXRlQ29ubmVjdGlvbigpe2NvbnN0IHQ9dGhpc1tHdF0uY3VycmVudFNvY2tldDtpZih0aGlzW0d0XS5jdXJyZW50U29ja2V0PXZvaWQgMCwhdCl0aHJvdyBuZXcgRXJyb3IoIk5vIHNvY2tldCB3YXMgcmV0dXJuZWQgaW4gdGhlIGBjb25uZWN0KClgIGZ1bmN0aW9uIik7cmV0dXJuIHR9Z2V0IGRlZmF1bHRQb3J0KCl7cmV0dXJuIHRoaXNbR3RdLmRlZmF1bHRQb3J0Pz8oImh0dHBzOiI9PT10aGlzLnByb3RvY29sPzQ0Mzo4MCl9c2V0IGRlZmF1bHRQb3J0KHQpe3RoaXNbR3RdJiYodGhpc1tHdF0uZGVmYXVsdFBvcnQ9dCl9Z2V0IHByb3RvY29sKCl7cmV0dXJuIHRoaXNbR3RdLnByb3RvY29sPz8odGhpcy5pc1NlY3VyZUVuZHBvaW50KCk/Imh0dHBzOiI6Imh0dHA6Iil9c2V0IHByb3RvY29sKHQpe3RoaXNbR3RdJiYodGhpc1tHdF0ucHJvdG9jb2w9dCl9fWZ1bmN0aW9uIEp0KC4uLnQpe1MubG9nKCJbaHR0cHMtcHJveHktYWdlbnQ6cGFyc2UtcHJveHktcmVzcG9uc2VdIiwuLi50KX1mdW5jdGlvbiB6dCh0KXtyZXR1cm4gbmV3IFByb21pc2UoKG4sZSk9PntsZXQgcj0wO2NvbnN0IG89W107ZnVuY3Rpb24gcygpe2NvbnN0IGM9dC5yZWFkKCk7Yz9mdW5jdGlvbihjKXtvLnB1c2goYykscis9Yy5sZW5ndGg7Y29uc3QgdT1CdWZmZXIuY29uY2F0KG8sciksYT11LmluZGV4T2YoIlxyXG5cclxuIik7aWYoLTE9PT1hKXJldHVybiBKdCgiaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4iKSx2b2lkIHMoKTtjb25zdCBmPXUuc3ViYXJyYXkoMCxhKS50b1N0cmluZygiYXNjaWkiKS5zcGxpdCgiXHJcbiIpLGg9Zi5zaGlmdCgpO2lmKCFoKXJldHVybiB0LmRlc3Ryb3koKSxlKG5ldyBFcnJvcigiTm8gaGVhZGVyIHJlY2VpdmVkIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZSIpKTtjb25zdCBwPWguc3BsaXQoIiAiKSxsPSsocFsxXXx8MCksZD1wLnNsaWNlKDIpLmpvaW4oIiAiKSxtPXt9O2Zvcihjb25zdCBuIG9mIGYpe2lmKCFuKWNvbnRpbnVlO2NvbnN0IHI9bi5pbmRleE9mKCI6Iik7aWYoLTE9PT1yKXJldHVybiB0LmRlc3Ryb3koKSxlKG5ldyBFcnJvcihgSW52YWxpZCBoZWFkZXIgZnJvbSBwcm94eSBDT05ORUNUIHJlc3BvbnNlOiAiJHtufSJgKSk7Y29uc3Qgbz1uLnNsaWNlKDAscikudG9Mb3dlckNhc2UoKSxzPW4uc2xpY2UocisxKS50cmltU3RhcnQoKSxpPW1bb107InN0cmluZyI9PXR5cGVvZiBpP21bb109W2ksc106QXJyYXkuaXNBcnJheShpKT9pLnB1c2gocyk6bVtvXT1zfUp0KCJnb3QgcHJveHkgc2VydmVyIHJlc3BvbnNlOiAlbyAlbyIsaCxtKSxpKCksbih7Y29ubmVjdDp7c3RhdHVzQ29kZTpsLHN0YXR1c1RleHQ6ZCxoZWFkZXJzOm19LGJ1ZmZlcmVkOnV9KX0oYyk6dC5vbmNlKCJyZWFkYWJsZSIscyl9ZnVuY3Rpb24gaSgpe3QucmVtb3ZlTGlzdGVuZXIoImVuZCIsYyksdC5yZW1vdmVMaXN0ZW5lcigiZXJyb3IiLHUpLHQucmVtb3ZlTGlzdGVuZXIoInJlYWRhYmxlIixzKX1mdW5jdGlvbiBjKCl7aSgpLEp0KCJvbmVuZCIpLGUobmV3IEVycm9yKCJQcm94eSBjb25uZWN0aW9uIGVuZGVkIGJlZm9yZSByZWNlaXZpbmcgQ09OTkVDVCByZXNwb25zZSIpKX1mdW5jdGlvbiB1KHQpe2koKSxKdCgib25lcnJvciAlbyIsdCksZSh0KX10Lm9uKCJlcnJvciIsdSksdC5vbigiZW5kIixjKSxzKCl9KX1mdW5jdGlvbiBGdCguLi50KXtTLmxvZygiW2h0dHBzLXByb3h5LWFnZW50XSIsLi4udCl9Y2xhc3MgV3QgZXh0ZW5kcyBIdHtzdGF0aWMgX19pbml0U3RhdGljKCl7dGhpcy5wcm90b2NvbHM9WyJodHRwIiwiaHR0cHMiXX1jb25zdHJ1Y3Rvcih0LG4pe3N1cGVyKG4pLHRoaXMub3B0aW9ucz17fSx0aGlzLnByb3h5PSJzdHJpbmciPT10eXBlb2YgdD9uZXcgVVJMKHQpOnQsdGhpcy5wcm94eUhlYWRlcnM9bj8uaGVhZGVycz8/e30sRnQoIkNyZWF0aW5nIG5ldyBIdHRwc1Byb3h5QWdlbnQgaW5zdGFuY2U6ICVvIix0aGlzLnByb3h5LmhyZWYpO2NvbnN0IGU9KHRoaXMucHJveHkuaG9zdG5hbWV8fHRoaXMucHJveHkuaG9zdCkucmVwbGFjZSgvXlxbfFxdJC9nLCIiKSxyPXRoaXMucHJveHkucG9ydD9wYXJzZUludCh0aGlzLnByb3h5LnBvcnQsMTApOiJodHRwczoiPT09dGhpcy5wcm94eS5wcm90b2NvbD80NDM6ODA7dGhpcy5jb25uZWN0T3B0cz17QUxQTlByb3RvY29sczpbImh0dHAvMS4xIl0sLi4ubj9LdChuLCJoZWFkZXJzIik6bnVsbCxob3N0OmUscG9ydDpyfX1hc3luYyBjb25uZWN0KHQsbil7Y29uc3R7cHJveHk6ZX09dGhpcztpZighbi5ob3N0KXRocm93IG5ldyBUeXBlRXJyb3IoJ05vICJob3N0IiBwcm92aWRlZCcpO2xldCByO2lmKCJodHRwczoiPT09ZS5wcm90b2NvbCl7RnQoIkNyZWF0aW5nIGB0bHMuU29ja2V0YDogJW8iLHRoaXMuY29ubmVjdE9wdHMpO2NvbnN0IHQ9dGhpcy5jb25uZWN0T3B0cy5zZXJ2ZXJuYW1lfHx0aGlzLmNvbm5lY3RPcHRzLmhvc3Q7cj1mLmNvbm5lY3Qoey4uLnRoaXMuY29ubmVjdE9wdHMsc2VydmVybmFtZTp0JiZhLmlzSVAodCk/dm9pZCAwOnR9KX1lbHNlIEZ0KCJDcmVhdGluZyBgbmV0LlNvY2tldGA6ICVvIix0aGlzLmNvbm5lY3RPcHRzKSxyPWEuY29ubmVjdCh0aGlzLmNvbm5lY3RPcHRzKTtjb25zdCBvPSJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLnByb3h5SGVhZGVycz90aGlzLnByb3h5SGVhZGVycygpOnsuLi50aGlzLnByb3h5SGVhZGVyc30scz1hLmlzSVB2NihuLmhvc3QpP2BbJHtuLmhvc3R9XWA6bi5ob3N0O2xldCBpPWBDT05ORUNUICR7c306JHtuLnBvcnR9IEhUVFAvMS4xXHJcbmA7aWYoZS51c2VybmFtZXx8ZS5wYXNzd29yZCl7Y29uc3QgdD1gJHtkZWNvZGVVUklDb21wb25lbnQoZS51c2VybmFtZSl9OiR7ZGVjb2RlVVJJQ29tcG9uZW50KGUucGFzc3dvcmQpfWA7b1siUHJveHktQXV0aG9yaXphdGlvbiJdPWBCYXNpYyAke0J1ZmZlci5mcm9tKHQpLnRvU3RyaW5nKCJiYXNlNjQiKX1gfW8uSG9zdD1gJHtzfToke24ucG9ydH1gLG9bIlByb3h5LUNvbm5lY3Rpb24iXXx8KG9bIlByb3h5LUNvbm5lY3Rpb24iXT10aGlzLmtlZXBBbGl2ZT8iS2VlcC1BbGl2ZSI6ImNsb3NlIik7Zm9yKGNvbnN0IHQgb2YgT2JqZWN0LmtleXMobykpaSs9YCR7dH06ICR7b1t0XX1cclxuYDtjb25zdCBjPXp0KHIpO3Iud3JpdGUoYCR7aX1cclxuYCk7Y29uc3R7Y29ubmVjdDp1LGJ1ZmZlcmVkOmh9PWF3YWl0IGM7aWYodC5lbWl0KCJwcm94eUNvbm5lY3QiLHUpLHRoaXMuZW1pdCgicHJveHlDb25uZWN0Iix1LHQpLDIwMD09PXUuc3RhdHVzQ29kZSl7aWYodC5vbmNlKCJzb2NrZXQiLFl0KSxuLnNlY3VyZUVuZHBvaW50KXtGdCgiVXBncmFkaW5nIHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUyIpO2NvbnN0IHQ9bi5zZXJ2ZXJuYW1lfHxuLmhvc3Q7cmV0dXJuIGYuY29ubmVjdCh7Li4uS3QobiwiaG9zdCIsInBhdGgiLCJwb3J0Iiksc29ja2V0OnIsc2VydmVybmFtZTphLmlzSVAodCk/dm9pZCAwOnR9KX1yZXR1cm4gcn1yLmRlc3Ryb3koKTtjb25zdCBwPW5ldyBhLlNvY2tldCh7d3JpdGFibGU6ITF9KTtyZXR1cm4gcC5yZWFkYWJsZT0hMCx0Lm9uY2UoInNvY2tldCIsdD0+e0Z0KCJSZXBsYXlpbmcgcHJveHkgYnVmZmVyIGZvciBmYWlsZWQgcmVxdWVzdCIpLHQucHVzaChoKSx0LnB1c2gobnVsbCl9KSxwfX1mdW5jdGlvbiBZdCh0KXt0LnJlc3VtZSgpfWZ1bmN0aW9uIEt0KHQsLi4ubil7Y29uc3QgZT17fTtsZXQgcjtmb3IociBpbiB0KW4uaW5jbHVkZXMocil8fChlW3JdPXRbcl0pO3JldHVybiBlfVd0Ll9faW5pdFN0YXRpYygpO2Z1bmN0aW9uIFp0KHQpe3JldHVybiB0LnJlcGxhY2UoL15bQS1aXTovLCIiKS5yZXBsYWNlKC9cXC9nLCIvIil9Y29uc3QgVnQ9bjtsZXQgcXQsUXQ9MCxYdD17fTtmdW5jdGlvbiB0bih0KXtWdC5kZWJ1ZyYmY29uc29sZS5sb2coYFtBTlIgV29ya2VyXSAke3R9YCl9dmFyIG5uLGVuLHJuO2NvbnN0IG9uPWZ1bmN0aW9uKHQpe2xldCBuO3RyeXtuPW5ldyBVUkwodC51cmwpfWNhdGNoKG4pe3JldHVybiBiKCgpPT57Y29uc29sZS53YXJuKCJbQHNlbnRyeS9ub2RlXTogSW52YWxpZCBkc24gb3IgdHVubmVsIG9wdGlvbiwgd2lsbCBub3Qgc2VuZCBhbnkgZXZlbnRzLiBUaGUgdHVubmVsIG9wdGlvbiBtdXN0IGJlIGEgZnVsbCBVUkwgd2hlbiB1c2VkLiIpfSksVXQodCwoKT0+UHJvbWlzZS5yZXNvbHZlKHt9KSl9Y29uc3QgZT0iaHR0cHM6Ij09PW4ucHJvdG9jb2wscj1mdW5jdGlvbih0LG4pe2NvbnN0e25vX3Byb3h5OmV9PXByb2Nlc3MuZW52LHI9ZT8uc3BsaXQoIiwiKS5zb21lKG49PnQuaG9zdC5lbmRzV2l0aChuKXx8dC5ob3N0bmFtZS5lbmRzV2l0aChuKSk7cmV0dXJuIHI/dm9pZCAwOm59KG4sdC5wcm94eXx8KGU/cHJvY2Vzcy5lbnYuaHR0cHNfcHJveHk6dm9pZCAwKXx8cHJvY2Vzcy5lbnYuaHR0cF9wcm94eSksbz1lP2k6cyxhPXZvaWQgMCE9PXQua2VlcEFsaXZlJiZ0LmtlZXBBbGl2ZSxmPXI/bmV3IFd0KHIpOm5ldyBvLkFnZW50KHtrZWVwQWxpdmU6YSxtYXhTb2NrZXRzOjMwLHRpbWVvdXQ6MmUzfSksaD1mdW5jdGlvbih0LG4sZSl7Y29uc3R7aG9zdG5hbWU6cixwYXRobmFtZTpvLHBvcnQ6cyxwcm90b2NvbDppLHNlYXJjaDphfT1uZXcgVVJMKHQudXJsKTtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIG5ldyBQcm9taXNlKChoLHApPT57anQoKCk9PntsZXQgbD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGMoe3JlYWQoKXt0aGlzLnB1c2godCksdGhpcy5wdXNoKG51bGwpfX0pfShmLmJvZHkpO2NvbnN0IGQ9ey4uLnQuaGVhZGVyc307Zi5ib2R5Lmxlbmd0aD4zMjc2OCYmKGRbImNvbnRlbnQtZW5jb2RpbmciXT0iZ3ppcCIsbD1sLnBpcGUodSgpKSk7Y29uc3QgbT1uLnJlcXVlc3Qoe21ldGhvZDoiUE9TVCIsYWdlbnQ6ZSxoZWFkZXJzOmQsaG9zdG5hbWU6cixwYXRoOmAke299JHthfWAscG9ydDpzLHByb3RvY29sOmksY2E6dC5jYUNlcnRzfSx0PT57dC5vbigiZGF0YSIsKCk9Pnt9KSx0Lm9uKCJlbmQiLCgpPT57fSksdC5zZXRFbmNvZGluZygidXRmOCIpO2NvbnN0IG49dC5oZWFkZXJzWyJyZXRyeS1hZnRlciJdPz9udWxsLGU9dC5oZWFkZXJzWyJ4LXNlbnRyeS1yYXRlLWxpbWl0cyJdPz9udWxsO2goe3N0YXR1c0NvZGU6dC5zdGF0dXNDb2RlLGhlYWRlcnM6eyJyZXRyeS1hZnRlciI6biwieC1zZW50cnktcmF0ZS1saW1pdHMiOkFycmF5LmlzQXJyYXkoZSk/ZVswXXx8bnVsbDplfX0pfSk7bS5vbigiZXJyb3IiLHApLGwucGlwZShtKX0pfSl9fSh0LHQuaHR0cE1vZHVsZT8/byxmKTtyZXR1cm4gVXQodCxoKX0oe3VybDoobm49VnQuZHNuLGVuPVZ0LnR1bm5lbCxybj1WdC5zZGtNZXRhZGF0YS5zZGssZW58fGAke2Z1bmN0aW9uKHQpe3JldHVybmAke2Z1bmN0aW9uKHQpe2NvbnN0IG49dC5wcm90b2NvbD9gJHt0LnByb3RvY29sfTpgOiIiLGU9dC5wb3J0P2A6JHt0LnBvcnR9YDoiIjtyZXR1cm5gJHtufS8vJHt0Lmhvc3R9JHtlfSR7dC5wYXRoP2AvJHt0LnBhdGh9YDoiIn0vYXBpL2B9KHQpfSR7dC5wcm9qZWN0SWR9L2VudmVsb3BlL2B9KG5uKX0/JHtmdW5jdGlvbih0LG4pe2NvbnN0IGU9e3NlbnRyeV92ZXJzaW9uOiI3In07cmV0dXJuIHQucHVibGljS2V5JiYoZS5zZW50cnlfa2V5PXQucHVibGljS2V5KSxuJiYoZS5zZW50cnlfY2xpZW50PWAke24ubmFtZX0vJHtuLnZlcnNpb259YCksbmV3IFVSTFNlYXJjaFBhcmFtcyhlKS50b1N0cmluZygpfShubixybil9YCl9KTthc3luYyBmdW5jdGlvbiBzbigpe2lmKHF0KXt0bigiU2VuZGluZyBhYm5vcm1hbCBzZXNzaW9uIiksSihxdCx7c3RhdHVzOiJhYm5vcm1hbCIsYWJub3JtYWxfbWVjaGFuaXNtOiJhbnJfZm9yZWdyb3VuZCIscmVsZWFzZTpWdC5yZWxlYXNlLGVudmlyb25tZW50OlZ0LmVudmlyb25tZW50fSk7Y29uc3QgdD1mdW5jdGlvbih0LG4sZSxyKXtjb25zdCBvPUN0KGUpO3JldHVybiBTdCh7c2VudF9hdDoobmV3IERhdGUpLnRvSVNPU3RyaW5nKCksLi4ubyYme3NkazpvfSwuLi4hIXImJm4mJntkc246YXQobil9fSxbImFnZ3JlZ2F0ZXMiaW4gdD9be3R5cGU6InNlc3Npb25zIn0sdF06W3t0eXBlOiJzZXNzaW9uIn0sdC50b0pTT04oKV1dKX0ocXQsVnQuZHNuLFZ0LnNka01ldGFkYXRhLFZ0LnR1bm5lbCk7dG4oSlNPTi5zdHJpbmdpZnkodCkpLGF3YWl0IG9uLnNlbmQodCk7dHJ5e2U/LnBvc3RNZXNzYWdlKCJzZXNzaW9uLWVuZGVkIil9Y2F0Y2h7fX19ZnVuY3Rpb24gY24odCl7aWYoIXQpcmV0dXJuO2NvbnN0IG49ZnVuY3Rpb24odCl7aWYoIXQubGVuZ3RoKXJldHVybltdO2NvbnN0IG49QXJyYXkuZnJvbSh0KTtyZXR1cm4vc2VudHJ5V3JhcHBlZC8udGVzdChFKG4pLmZ1bmN0aW9ufHwiIikmJm4ucG9wKCksbi5yZXZlcnNlKCksJC50ZXN0KEUobikuZnVuY3Rpb258fCIiKSYmKG4ucG9wKCksJC50ZXN0KEUobikuZnVuY3Rpb258fCIiKSYmbi5wb3AoKSksbi5zbGljZSgwLDUwKS5tYXAodD0+KHsuLi50LGZpbGVuYW1lOnQuZmlsZW5hbWV8fEUobikuZmlsZW5hbWUsZnVuY3Rpb246dC5mdW5jdGlvbnx8Ij8ifSkpfSh0KTtpZihWdC5hcHBSb290UGF0aClmb3IoY29uc3QgdCBvZiBuKXQuZmlsZW5hbWUmJih0LmZpbGVuYW1lPXd0KHQuZmlsZW5hbWUsVnQuYXBwUm9vdFBhdGgpKTtyZXR1cm4gbn1hc3luYyBmdW5jdGlvbiB1bih0LG4pe2lmKFF0Pj1WdC5tYXhBbnJFdmVudHMpcmV0dXJuO1F0Kz0xLGF3YWl0IHNuKCksdG4oIlNlbmRpbmcgZXZlbnQiKTtjb25zdCBlPXtldmVudF9pZDpNKCksY29udGV4dHM6VnQuY29udGV4dHMscmVsZWFzZTpWdC5yZWxlYXNlLGVudmlyb25tZW50OlZ0LmVudmlyb25tZW50LGRpc3Q6VnQuZGlzdCxwbGF0Zm9ybToibm9kZSIsbGV2ZWw6ImVycm9yIixleGNlcHRpb246e3ZhbHVlczpbe3R5cGU6IkFwcGxpY2F0aW9uTm90UmVzcG9uZGluZyIsdmFsdWU6YEFwcGxpY2F0aW9uIE5vdCBSZXNwb25kaW5nIGZvciBhdCBsZWFzdCAke1Z0LmFuclRocmVzaG9sZH0gbXNgLHN0YWNrdHJhY2U6e2ZyYW1lczpjbih0KX0sbWVjaGFuaXNtOnt0eXBlOiJBTlIifX1dfSx0YWdzOlZ0LnN0YXRpY1RhZ3N9O24mJmZ1bmN0aW9uKHQsbil7aWYoUnQodCxuKSwhdC5jb250ZXh0cz8udHJhY2Upe2NvbnN0e3RyYWNlSWQ6ZSxwYXJlbnRTcGFuSWQ6cixwcm9wYWdhdGlvblNwYW5JZDpvfT1uLnByb3BhZ2F0aW9uQ29udGV4dDt0LmNvbnRleHRzPXt0cmFjZTp7dHJhY2VfaWQ6ZSxzcGFuX2lkOm98fFcoKSxwYXJlbnRfc3Bhbl9pZDpyfSwuLi50LmNvbnRleHRzfX19KGUsbiksZnVuY3Rpb24odCl7aWYoMD09PU9iamVjdC5rZXlzKFh0KS5sZW5ndGgpcmV0dXJuO2NvbnN0IG49VnQuYXBwUm9vdFBhdGg/e306WHQ7aWYoVnQuYXBwUm9vdFBhdGgpZm9yKGNvbnN0W3QsZV1vZiBPYmplY3QuZW50cmllcyhYdCkpblt3dCh0LFZ0LmFwcFJvb3RQYXRoKV09ZTtjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0IHIgb2YgdC5leGNlcHRpb24/LnZhbHVlc3x8W10pZm9yKGNvbnN0IHQgb2Ygci5zdGFja3RyYWNlPy5mcmFtZXN8fFtdKXtjb25zdCByPXQuYWJzX3BhdGh8fHQuZmlsZW5hbWU7ciYmbltyXSYmZS5zZXQocixuW3JdKX1pZihlLnNpemU+MCl7Y29uc3Qgbj1bXTtmb3IoY29uc3RbdCxyXW9mIGUuZW50cmllcygpKW4ucHVzaCh7dHlwZToic291cmNlbWFwIixjb2RlX2ZpbGU6dCxkZWJ1Z19pZDpyfSk7dC5kZWJ1Z19tZXRhPXtpbWFnZXM6bn19fShlKTtjb25zdCByPWt0KGUsVnQuZHNuLFZ0LnNka01ldGFkYXRhLFZ0LnR1bm5lbCk7dG4oSlNPTi5zdHJpbmdpZnkocikpLGF3YWl0IG9uLnNlbmQociksYXdhaXQgb24uZmx1c2goMmUzKSxRdD49VnQubWF4QW5yRXZlbnRzJiZzZXRUaW1lb3V0KCgpPT57cHJvY2Vzcy5leGl0KDApfSw1ZTMpfWxldCBhbjtpZih0bigiU3RhcnRlZCIpLFZ0LmNhcHR1cmVTdGFja1RyYWNlKXt0bigiQ29ubmVjdGluZyB0byBkZWJ1Z2dlciIpO2NvbnN0IG49bmV3IHQ7bi5jb25uZWN0VG9NYWluVGhyZWFkKCksdG4oIkNvbm5lY3RlZCB0byBkZWJ1Z2dlciIpO2NvbnN0IGU9bmV3IE1hcDtuLm9uKCJEZWJ1Z2dlci5zY3JpcHRQYXJzZWQiLHQ9PntlLnNldCh0LnBhcmFtcy5zY3JpcHRJZCx0LnBhcmFtcy51cmwpfSksbi5vbigiRGVidWdnZXIucGF1c2VkIix0PT57aWYoIm90aGVyIj09PXQucGFyYW1zLnJlYXNvbil0cnl7dG4oIkRlYnVnZ2VyIHBhdXNlZCIpO2NvbnN0IHM9Wy4uLnQucGFyYW1zLmNhbGxGcmFtZXNdLGk9VnQuYXBwUm9vdFBhdGg/ZnVuY3Rpb24odD0ocHJvY2Vzcy5hcmd2WzFdP0x0KHByb2Nlc3MuYXJndlsxXSk6cHJvY2Vzcy5jd2QoKSksbj0iXFwiPT09byl7Y29uc3QgZT1uP1p0KHQpOnQ7cmV0dXJuIHQ9PntpZighdClyZXR1cm47Y29uc3Qgbz1uP1p0KHQpOnQ7bGV0e2RpcjpzLGJhc2U6aSxleHQ6Y309ci5wYXJzZShvKTsiLmpzIiE9PWMmJiIubWpzIiE9PWMmJiIuY2pzIiE9PWN8fChpPWkuc2xpY2UoMCwtMSpjLmxlbmd0aCkpO2NvbnN0IHU9ZGVjb2RlVVJJQ29tcG9uZW50KGkpO3N8fChzPSIuIik7Y29uc3QgYT1zLmxhc3RJbmRleE9mKCIvbm9kZV9tb2R1bGVzIik7aWYoYT4tMSlyZXR1cm5gJHtzLnNsaWNlKGErMTQpLnJlcGxhY2UoL1wvL2csIi4iKX06JHt1fWA7aWYocy5zdGFydHNXaXRoKGUpKXtjb25zdCB0PXMuc2xpY2UoZS5sZW5ndGgrMSkucmVwbGFjZSgvXC8vZywiLiIpO3JldHVybiB0P2Ake3R9OiR7dX1gOnV9cmV0dXJuIHV9fShWdC5hcHBSb290UGF0aCk6KCk9Pnt9LGM9cy5tYXAodD0+ZnVuY3Rpb24odCxuLGUpe2NvbnN0IHI9bj9uLnJlcGxhY2UoL15maWxlOlwvXC8vLCIiKTp2b2lkIDAsbz10LmxvY2F0aW9uLmNvbHVtbk51bWJlcj90LmxvY2F0aW9uLmNvbHVtbk51bWJlcisxOnZvaWQgMCxzPXQubG9jYXRpb24ubGluZU51bWJlcj90LmxvY2F0aW9uLmxpbmVOdW1iZXIrMTp2b2lkIDA7cmV0dXJue2ZpbGVuYW1lOnIsbW9kdWxlOmUociksZnVuY3Rpb246dC5mdW5jdGlvbk5hbWV8fCI/Iixjb2xubzpvLGxpbmVubzpzLGluX2FwcDpyP0J0KHIpOnZvaWQgMH19KHQsZS5nZXQodC5sb2NhdGlvbi5zY3JpcHRJZCksaSkpLHU9c2V0VGltZW91dCgoKT0+e3VuKGMpLnRoZW4obnVsbCwoKT0+e3RuKCJTZW5kaW5nIEFOUiBldmVudCBmYWlsZWQuIil9KX0sNWUzKTtuLnBvc3QoIlJ1bnRpbWUuZXZhbHVhdGUiLHtleHByZXNzaW9uOiJnbG9iYWwuX19TRU5UUllfR0VUX1NDT1BFU19fKCk7IixzaWxlbnQ6ITAscmV0dXJuQnlWYWx1ZTohMH0sKHQsZSk9Pnt0JiZ0bihgRXJyb3IgZXhlY3V0aW5nIHNjcmlwdDogJyR7dC5tZXNzYWdlfSdgKSxjbGVhclRpbWVvdXQodSk7Y29uc3Qgcj1lPy5yZXN1bHQ/ZS5yZXN1bHQudmFsdWU6dm9pZCAwO24ucG9zdCgiRGVidWdnZXIucmVzdW1lIiksbi5wb3N0KCJEZWJ1Z2dlci5kaXNhYmxlIiksdW4oYyxyKS50aGVuKG51bGwsKCk9Pnt0bigiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSl9KX1jYXRjaCh0KXt0aHJvdyBuLnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpLG4ucG9zdCgiRGVidWdnZXIuZGlzYWJsZSIpLHR9fSksYW49KCk9Pnt0cnl7bi5wb3N0KCJEZWJ1Z2dlci5lbmFibGUiLCgpPT57bi5wb3N0KCJEZWJ1Z2dlci5wYXVzZSIpfSl9Y2F0Y2h7fX19Y29uc3R7cG9sbDpmbn09ZnVuY3Rpb24odCxuLGUscil7Y29uc3Qgbz10KCk7bGV0IHM9ITEsaT0hMDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCk9Pntjb25zdCB0PW8uZ2V0VGltZU1zKCk7ITE9PT1zJiZ0Pm4rZSYmKHM9ITAsaSYmcigpKSx0PG4rZSYmKHM9ITEpfSwyMCkse3BvbGw6KCk9PntvLnJlc2V0KCl9LGVuYWJsZWQ6dD0+e2k9dH19fShmdW5jdGlvbigpe2xldCB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJue2dldFRpbWVNczooKT0+e2NvbnN0W24sZV09cHJvY2Vzcy5ocnRpbWUodCk7cmV0dXJuIE1hdGguZmxvb3IoMWUzKm4rZS8xZTYpfSxyZXNldDooKT0+e3Q9cHJvY2Vzcy5ocnRpbWUoKX19fSxWdC5wb2xsSW50ZXJ2YWwsVnQuYW5yVGhyZXNob2xkLGZ1bmN0aW9uKCl7dG4oIldhdGNoZG9nIHRpbWVvdXQiKSxhbj8odG4oIlBhdXNpbmcgZGVidWdnZXIgdG8gY2FwdHVyZSBzdGFjayB0cmFjZSIpLGFuKCkpOih0bigiQ2FwdHVyaW5nIGV2ZW50IHdpdGhvdXQgYSBzdGFjayB0cmFjZSIpLHVuKCkudGhlbihudWxsLCgpPT57dG4oIlNlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZCBvbiB3YXRjaGRvZyB0aW1lb3V0LiIpfSkpfSk7ZT8ub24oIm1lc3NhZ2UiLHQ9Pnt0LnNlc3Npb24mJihxdD1IKHQuc2Vzc2lvbikpLHQuZGVidWdJbWFnZXMmJihYdD10LmRlYnVnSW1hZ2VzKSxmbigpfSk7';
    function c(e, ...t) {
      o.debug.log(`[ANR] ${e}`, ...t);
    }
    function d() {
      let e = o.getGlobalScope().getScopeData();
      return (
        o.mergeScopeData(e, o.getIsolationScope().getScopeData()),
        o.mergeScopeData(e, o.getCurrentScope().getScopeData()),
        (e.attachments = []),
        (e.eventProcessors = []),
        e
      );
    }
    async function p(e) {
      let t = { message: 'ANR' },
        n = {};
      for (let r of e.getEventProcessors()) {
        if (null === t) break;
        t = await r(t, n);
      }
      return t?.contexts || {};
    }
    async function _(t, n) {
      let r = t.getDsn();
      if (!r) return () => {};
      let a = await p(t);
      (delete a.app?.app_memory, delete a.device?.free_memory);
      let s = t.getOptions(),
        u = t.getSdkMetadata() || {};
      u.sdk && (u.sdk.integrations = s.integrations.map((e) => e.name));
      let d = {
        debug: o.debug.isEnabled(),
        dsn: r,
        tunnel: s.tunnel,
        environment: s.environment || 'production',
        release: s.release,
        dist: s.dist,
        sdkMetadata: u,
        appRootPath: n.appRootPath,
        pollInterval: n.pollInterval || 50,
        anrThreshold: n.anrThreshold || 5e3,
        captureStackTrace: !!n.captureStackTrace,
        maxAnrEvents: n.maxAnrEvents || 1,
        staticTags: n.staticTags || {},
        contexts: a,
      };
      if (d.captureStackTrace) {
        let t = await e.A(34177);
        t.url() || t.open(0);
      }
      let _ = new i.Worker(new URL(`data:application/javascript;base64,${l}`), {
        workerData: d,
        execArgv: [],
        env: { ...process.env, NODE_OPTIONS: void 0 },
      });
      process.on('exit', () => {
        _.terminate();
      });
      let S = setInterval(() => {
        try {
          let e = o.getIsolationScope().getSession(),
            t = e ? { ...e, toJSON: void 0 } : void 0;
          _.postMessage({ session: t, debugImages: o.getFilenameToDebugIdMap(s.stackParser) });
        } catch {}
      }, d.pollInterval);
      return (
        S.unref(),
        _.on('message', (e) => {
          'session-ended' === e &&
            (c('ANR event sent from ANR worker. Clearing session in this thread.'),
            o.getIsolationScope().setSession(void 0));
        }),
        _.once('error', (e) => {
          (clearInterval(S), c('ANR worker error', e));
        }),
        _.once('exit', (e) => {
          (clearInterval(S), c('ANR worker exit', e));
        }),
        _.unref(),
        () => {
          (_.terminate(), clearInterval(S));
        }
      );
    }
    ((n.anrIntegration = o.defineIntegration((e = {}) => {
      let t, n;
      if (a.NODE_VERSION.major < 16 || (16 === a.NODE_VERSION.major && a.NODE_VERSION.minor < 17))
        throw Error('ANR detection requires Node 16.17.0 or later');
      return (
        (o.GLOBAL_OBJ.__SENTRY_GET_SCOPES__ = d),
        {
          name: 'Anr',
          startWorker: () => {
            !t && n && (t = _(n, e));
          },
          stopWorker: () => {
            t &&
              t.then((e) => {
                (e(), (t = void 0));
              });
          },
          async setup(t) {
            ((n = t),
              e.captureStackTrace &&
                (await s.isDebuggerEnabled()) &&
                (o.debug.warn(
                  'ANR captureStackTrace has been disabled because the debugger was already enabled'
                ),
                (e.captureStackTrace = !1)),
              setImmediate(() => this.startWorker()));
          },
        }
      );
    })),
      (n.base64WorkerScript = l),
      (n.disableAnrDetectionForCallback = function (e) {
        let t = o.getClient()?.getIntegrationByName('Anr');
        if (!t) return e();
        t.stopWorker();
        let n = e();
        return u(n) ? n.finally(() => t.startWorker()) : (t.startWorker(), n);
      }));
  },
  22089,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(47299),
      i = e.r(48009),
      o = 'Spotlight',
      a = i.defineIntegration((e = {}) => {
        let t = { sidecarUrl: e.sidecarUrl || 'http://localhost:8969/stream' };
        return {
          name: o,
          setup(e) {
            try {
              i.debug.warn(
                "[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?"
              );
            } catch {}
            !(function (e, t) {
              let n = (function (e) {
                try {
                  return new URL(`${e}`);
                } catch {
                  i.debug.warn(`[Spotlight] Invalid sidecar URL: ${e}`);
                  return;
                }
              })(t.sidecarUrl);
              if (!n) return;
              let o = 0;
              e.on('beforeEnvelope', (e) => {
                if (o > 3)
                  return void i.debug.warn(
                    '[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests'
                  );
                let t = i.serializeEnvelope(e);
                i.suppressTracing(() => {
                  let e = r.request(
                    {
                      method: 'POST',
                      path: n.pathname,
                      hostname: n.hostname,
                      port: n.port,
                      headers: { 'Content-Type': 'application/x-sentry-envelope' },
                    },
                    (e) => {
                      (e.statusCode && e.statusCode >= 200 && e.statusCode < 400 && (o = 0),
                        e.on('data', () => {}),
                        e.on('end', () => {}),
                        e.setEncoding('utf8'));
                    }
                  );
                  (e.on('error', () => {
                    (o++, i.debug.warn('[Spotlight] Failed to send envelope to Spotlight Sidecar'));
                  }),
                    e.write(t),
                    e.end());
                });
              });
            })(e, t);
          },
        };
      });
    ((n.INTEGRATION_NAME = o), (n.spotlightIntegration = a));
  },
  53861,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(12057);
    n.systemErrorIntegration = e.r(48009).defineIntegration((e = {}) => ({
      name: 'NodeSystemError',
      processEvent: (t, n, i) => {
        if (
          !(function (e) {
            return (
              e instanceof Error &&
              'errno' in e &&
              'number' == typeof e.errno &&
              r.getSystemErrorMap().has(e.errno)
            );
          })(n.originalException)
        )
          return t;
        let o = n.originalException,
          a = { ...o };
        for (let n of (i.getOptions().sendDefaultPii ||
          !0 === e.includePaths ||
          (delete a.path, delete a.dest),
        (t.contexts = { ...t.contexts, node_system_error: a }),
        t.exception?.values || []))
          n.value &&
            (o.path &&
              n.value.includes(o.path) &&
              (n.value = n.value.replace(`'${o.path}'`, '').trim()),
            o.dest &&
              n.value.includes(o.dest) &&
              (n.value = n.value.replace(`'${o.dest}'`, '').trim()));
        return t;
      },
    }));
  },
  48148,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(77652),
      i = e.r(48009);
    n.childProcessIntegration = i.defineIntegration((e = {}) => ({
      name: 'ChildProcess',
      setup() {
        (r.channel('child_process').subscribe((t) => {
          var n, r;
          let o, a;
          t &&
            'object' == typeof t &&
            'process' in t &&
            ((n = t.process),
            (r = e),
            (a = !1),
            n
              .on('spawn', () => {
                if ('/usr/bin/sw_vers' === n.spawnfile) {
                  a = !0;
                  return;
                }
                ((o = { spawnfile: n.spawnfile }),
                  r.includeChildProcessArgs && (o.spawnargs = n.spawnargs));
              })
              .on('exit', (e) => {
                a ||
                  ((a = !0),
                  null !== e &&
                    0 !== e &&
                    i.addBreadcrumb({
                      category: 'child_process',
                      message: `Child process exited with code '${e}'`,
                      level: 0 === e ? 'info' : 'warning',
                      data: o,
                    }));
              })
              .on('error', (e) => {
                a ||
                  ((a = !0),
                  i.addBreadcrumb({
                    category: 'child_process',
                    message: `Child process errored with '${e.message}'`,
                    level: 'error',
                    data: o,
                  }));
              }));
        }),
          r.channel('worker_threads').subscribe((t) => {
            var n, r;
            let o;
            t &&
              'object' == typeof t &&
              'worker' in t &&
              ((n = t.worker),
              (r = e),
              n
                .on('online', () => {
                  o = n.threadId;
                })
                .on('error', (e) => {
                  !1 !== r.captureWorkerErrors
                    ? i.captureException(e, {
                        mechanism: {
                          type: 'instrument',
                          handled: !1,
                          data: { threadId: String(o) },
                        },
                      })
                    : i.addBreadcrumb({
                        category: 'worker_thread',
                        message: `Worker thread errored with '${e.message}'`,
                        level: 'error',
                        data: { threadId: o },
                      });
                }));
          }));
      },
    }));
  },
  91655,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(36442),
      i = ['trace', 'debug', 'info', 'warn', 'error', 'fatal'],
      o = Symbol.for('level'),
      a = Symbol.for('message'),
      s = Symbol.for('splat'),
      u = {
        silly: 'trace',
        debug: 'debug',
        verbose: 'debug',
        http: 'debug',
        info: 'info',
        notice: 'info',
        warn: 'warn',
        warning: 'warn',
        error: 'error',
        emerg: 'fatal',
        alert: 'fatal',
        crit: 'fatal',
      };
    n.createSentryWinstonTransport = function (e, t) {
      return class extends e {
        constructor(e) {
          (super(e), (this._levels = new Set(t?.levels ?? i)));
        }
        log(e, t) {
          try {
            var n;
            if (
              (setImmediate(() => {
                this.emit('logged', e);
              }),
              (n = e),
              'object' != typeof n || null == n)
            )
              return;
            let t = e[o],
              { level: i, message: l, timestamp: c, ...d } = e;
            ((d[o] = void 0), (d[a] = void 0), (d[s] = void 0));
            let p = u[t] ?? 'info';
            this._levels.has(p) &&
              r.captureLog(p, l, { ...d, 'sentry.origin': 'auto.logging.winston' });
          } catch {}
          t && t();
        }
      };
    };
  },
  35389,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AbstractAsyncHooksContextManager = void 0));
    let r = e.r(27699),
      i = ['addListener', 'on', 'once', 'prependListener', 'prependOnceListener'];
    class o {
      bind(e, t) {
        return t instanceof r.EventEmitter
          ? this._bindEventEmitter(e, t)
          : 'function' == typeof t
            ? this._bindFunction(e, t)
            : t;
      }
      _bindFunction(e, t) {
        let n = this,
          r = function (...r) {
            return n.with(e, () => t.apply(this, r));
          };
        return (
          Object.defineProperty(r, 'length', {
            enumerable: !1,
            configurable: !0,
            writable: !1,
            value: t.length,
          }),
          r
        );
      }
      _bindEventEmitter(e, t) {
        return (
          void 0 !== this._getPatchMap(t) ||
            (this._createPatchMap(t),
            i.forEach((n) => {
              void 0 !== t[n] && (t[n] = this._patchAddListener(t, t[n], e));
            }),
            'function' == typeof t.removeListener &&
              (t.removeListener = this._patchRemoveListener(t, t.removeListener)),
            'function' == typeof t.off && (t.off = this._patchRemoveListener(t, t.off)),
            'function' == typeof t.removeAllListeners &&
              (t.removeAllListeners = this._patchRemoveAllListeners(t, t.removeAllListeners))),
          t
        );
      }
      _patchRemoveListener(e, t) {
        let n = this;
        return function (r, i) {
          let o = n._getPatchMap(e)?.[r];
          if (void 0 === o) return t.call(this, r, i);
          let a = o.get(i);
          return t.call(this, r, a || i);
        };
      }
      _patchRemoveAllListeners(e, t) {
        let n = this;
        return function (r) {
          let i = n._getPatchMap(e);
          return (
            void 0 !== i &&
              (0 == arguments.length ? n._createPatchMap(e) : void 0 !== i[r] && delete i[r]),
            t.apply(this, arguments)
          );
        };
      }
      _patchAddListener(e, t, n) {
        let r = this;
        return function (i, o) {
          if (r._wrapped) return t.call(this, i, o);
          let a = r._getPatchMap(e);
          void 0 === a && (a = r._createPatchMap(e));
          let s = a[i];
          void 0 === s && ((s = new WeakMap()), (a[i] = s));
          let u = r.bind(n, o);
          (s.set(o, u), (r._wrapped = !0));
          try {
            return t.call(this, i, u);
          } finally {
            r._wrapped = !1;
          }
        };
      }
      _createPatchMap(e) {
        let t = Object.create(null);
        return ((e[this._kOtListeners] = t), t);
      }
      _getPatchMap(e) {
        return e[this._kOtListeners];
      }
      _kOtListeners = Symbol('OtListeners');
      _wrapped = !1;
    }
    n.AbstractAsyncHooksContextManager = o;
  },
  16361,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.AsyncHooksContextManager = void 0));
    let r = e.r(52305),
      i = e.r(10430),
      o = e.r(35389);
    class a extends o.AbstractAsyncHooksContextManager {
      _asyncHook;
      _contexts = new Map();
      _stack = [];
      constructor() {
        (super(),
          (this._asyncHook = i.createHook({
            init: this._init.bind(this),
            before: this._before.bind(this),
            after: this._after.bind(this),
            destroy: this._destroy.bind(this),
            promiseResolve: this._destroy.bind(this),
          })));
      }
      active() {
        return this._stack[this._stack.length - 1] ?? r.ROOT_CONTEXT;
      }
      with(e, t, n, ...r) {
        this._enterContext(e);
        try {
          return t.call(n, ...r);
        } finally {
          this._exitContext();
        }
      }
      enable() {
        return (this._asyncHook.enable(), this);
      }
      disable() {
        return (this._asyncHook.disable(), this._contexts.clear(), (this._stack = []), this);
      }
      _init(e, t) {
        if ('TIMERWRAP' === t) return;
        let n = this._stack[this._stack.length - 1];
        void 0 !== n && this._contexts.set(e, n);
      }
      _destroy(e) {
        this._contexts.delete(e);
      }
      _before(e) {
        let t = this._contexts.get(e);
        void 0 !== t && this._enterContext(t);
      }
      _after() {
        this._exitContext();
      }
      _enterContext(e) {
        this._stack.push(e);
      }
      _exitContext() {
        this._stack.pop();
      }
    }
    n.AsyncHooksContextManager = a;
  },
  99887,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AsyncLocalStorageContextManager = void 0));
    let r = e.r(52305),
      i = e.r(10430),
      o = e.r(35389);
    class a extends o.AbstractAsyncHooksContextManager {
      _asyncLocalStorage;
      constructor() {
        (super(), (this._asyncLocalStorage = new i.AsyncLocalStorage()));
      }
      active() {
        return this._asyncLocalStorage.getStore() ?? r.ROOT_CONTEXT;
      }
      with(e, t, n, ...r) {
        let i = null == n ? t : t.bind(n);
        return this._asyncLocalStorage.run(e, i, ...r);
      }
      enable() {
        return this;
      }
      disable() {
        return (this._asyncLocalStorage.disable(), this);
      }
    }
    n.AsyncLocalStorageContextManager = a;
  },
  22134,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AsyncLocalStorageContextManager = n.AsyncHooksContextManager = void 0));
    var r = e.r(16361);
    Object.defineProperty(n, 'AsyncHooksContextManager', {
      enumerable: !0,
      get: function () {
        return r.AsyncHooksContextManager;
      },
    });
    var i = e.r(99887);
    Object.defineProperty(n, 'AsyncLocalStorageContextManager', {
      enumerable: !0,
      get: function () {
        return i.AsyncLocalStorageContextManager;
      },
    });
  },
  94633,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(22134);
    n.SentryContextManager = e.r(52780).wrapContextManagerClass(r.AsyncLocalStorageContextManager);
  },
  17090,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(48009);
    n.setupOpenTelemetryLogger = function () {
      (r.diag.disable(),
        r.diag.setLogger(
          {
            error: i.debug.error,
            warn: i.debug.warn,
            info: i.debug.log,
            debug: i.debug.log,
            verbose: i.debug.log,
          },
          r.DiagLogLevel.DEBUG
        ));
    };
  },
  92621,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.processSessionIntegration = r.defineIntegration(() => ({
      name: 'ProcessSession',
      setupOnce() {
        (r.startSession(),
          process.on('beforeExit', () => {
            let e = r.getIsolationScope().getSession();
            e?.status !== 'ok' && r.endSession();
          }));
      },
    }));
  },
  6239,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(47299);
    e.r(43698);
    let i = Symbol('AgentBaseInternalState');
    class o extends r.Agent {
      constructor(e) {
        (super(e), (this[i] = {}));
      }
      isSecureEndpoint(e) {
        if (e) {
          if ('boolean' == typeof e.secureEndpoint) return e.secureEndpoint;
          if ('string' == typeof e.protocol) return 'https:' === e.protocol;
        }
        let { stack: t } = Error();
        return (
          'string' == typeof t &&
          t
            .split('\n')
            .some((e) => -1 !== e.indexOf('(https.js:') || -1 !== e.indexOf('node:https:'))
        );
      }
      createSocket(e, t, n) {
        let o = { ...t, secureEndpoint: this.isSecureEndpoint(t) };
        Promise.resolve()
          .then(() => this.connect(e, o))
          .then((a) => {
            if (a instanceof r.Agent) return a.addRequest(e, o);
            ((this[i].currentSocket = a), super.createSocket(e, t, n));
          }, n);
      }
      createConnection() {
        let e = this[i].currentSocket;
        if (((this[i].currentSocket = void 0), !e))
          throw Error('No socket was returned in the `connect()` function');
        return e;
      }
      get defaultPort() {
        return this[i].defaultPort ?? ('https:' === this.protocol ? 443 : 80);
      }
      set defaultPort(e) {
        this[i] && (this[i].defaultPort = e);
      }
      get protocol() {
        return this[i].protocol ?? (this.isSecureEndpoint() ? 'https:' : 'http:');
      }
      set protocol(e) {
        this[i] && (this[i].protocol = e);
      }
    }
    n.Agent = o;
  },
  54463,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    function i(...e) {
      r.debug.log('[https-proxy-agent:parse-proxy-response]', ...e);
    }
    n.parseProxyResponse = function (e) {
      return new Promise((t, n) => {
        let r = 0,
          o = [];
        function a() {
          let u = e.read();
          u
            ? (function (u) {
                (o.push(u), (r += u.length));
                let l = Buffer.concat(o, r),
                  c = l.indexOf('\r\n\r\n');
                if (-1 === c) {
                  (i('have not received end of HTTP headers yet...'), a());
                  return;
                }
                let d = l.subarray(0, c).toString('ascii').split('\r\n'),
                  p = d.shift();
                if (!p)
                  return (e.destroy(), n(Error('No header received from proxy CONNECT response')));
                let _ = p.split(' '),
                  S = +(_[1] || 0),
                  E = _.slice(2).join(' '),
                  T = {};
                for (let t of d) {
                  if (!t) continue;
                  let r = t.indexOf(':');
                  if (-1 === r)
                    return (
                      e.destroy(),
                      n(Error(`Invalid header from proxy CONNECT response: "${t}"`))
                    );
                  let i = t.slice(0, r).toLowerCase(),
                    o = t.slice(r + 1).trimStart(),
                    a = T[i];
                  'string' == typeof a
                    ? (T[i] = [a, o])
                    : Array.isArray(a)
                      ? a.push(o)
                      : (T[i] = o);
                }
                (i('got proxy server response: %o %o', p, T),
                  s(),
                  t({ connect: { statusCode: S, statusText: E, headers: T }, buffered: l }));
              })(u)
            : e.once('readable', a);
        }
        function s() {
          (e.removeListener('end', u),
            e.removeListener('error', l),
            e.removeListener('readable', a));
        }
        function u() {
          (s(), i('onend'), n(Error('Proxy connection ended before receiving CONNECT response')));
        }
        function l(e) {
          (s(), i('onerror %o', e), n(e));
        }
        (e.on('error', l), e.on('end', u), a());
      });
    };
  },
  52670,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(61095),
      i = e.r(85560),
      o = e.r(48009),
      a = e.r(6239),
      s = e.r(54463);
    function u(...e) {
      o.debug.log('[https-proxy-agent]', ...e);
    }
    class l extends a.Agent {
      static __initStatic() {
        this.protocols = ['http', 'https'];
      }
      constructor(e, t) {
        (super(t),
          (this.options = {}),
          (this.proxy = 'string' == typeof e ? new URL(e) : e),
          (this.proxyHeaders = t?.headers ?? {}),
          u('Creating new HttpsProxyAgent instance: %o', this.proxy.href));
        let n = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ''),
          r = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : 'https:' === this.proxy.protocol
              ? 443
              : 80;
        this.connectOpts = {
          ALPNProtocols: ['http/1.1'],
          ...(t ? d(t, 'headers') : null),
          host: n,
          port: r,
        };
      }
      async connect(e, t) {
        let n,
          { proxy: o } = this;
        if (!t.host) throw TypeError('No "host" provided');
        if ('https:' === o.protocol) {
          u('Creating `tls.Socket`: %o', this.connectOpts);
          let e = this.connectOpts.servername || this.connectOpts.host;
          n = i.connect({ ...this.connectOpts, servername: e && r.isIP(e) ? void 0 : e });
        } else
          (u('Creating `net.Socket`: %o', this.connectOpts), (n = r.connect(this.connectOpts)));
        let a =
            'function' == typeof this.proxyHeaders ? this.proxyHeaders() : { ...this.proxyHeaders },
          l = r.isIPv6(t.host) ? `[${t.host}]` : t.host,
          p = `CONNECT ${l}:${t.port} HTTP/1.1\r
`;
        if (o.username || o.password) {
          let e = `${decodeURIComponent(o.username)}:${decodeURIComponent(o.password)}`;
          a['Proxy-Authorization'] = `Basic ${Buffer.from(e).toString('base64')}`;
        }
        for (let e of ((a.Host = `${l}:${t.port}`),
        a['Proxy-Connection'] || (a['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close'),
        Object.keys(a)))
          p += `${e}: ${a[e]}\r
`;
        let _ = s.parseProxyResponse(n);
        n.write(`${p}\r
`);
        let { connect: S, buffered: E } = await _;
        if ((e.emit('proxyConnect', S), this.emit('proxyConnect', S, e), 200 === S.statusCode)) {
          if ((e.once('socket', c), t.secureEndpoint)) {
            u('Upgrading socket connection to TLS');
            let e = t.servername || t.host;
            return i.connect({
              ...d(t, 'host', 'path', 'port'),
              socket: n,
              servername: r.isIP(e) ? void 0 : e,
            });
          }
          return n;
        }
        n.destroy();
        let T = new r.Socket({ writable: !1 });
        return (
          (T.readable = !0),
          e.once('socket', (e) => {
            (u('Replaying proxy buffer for failed request'), e.push(E), e.push(null));
          }),
          T
        );
      }
    }
    function c(e) {
      e.resume();
    }
    function d(e, ...t) {
      let n,
        r = {};
      for (n in e) t.includes(n) || (r[n] = e[n]);
      return r;
    }
    (l.__initStatic(), (n.HttpsProxyAgent = l));
  },
  93950,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(47299),
      i = e.r(43698),
      o = e.r(81111),
      a = e.r(27028),
      s = e.r(48009),
      u = e.r(52670);
    n.makeNodeTransport = function (e) {
      let t;
      try {
        t = new URL(e.url);
      } catch (t) {
        return (
          s.consoleSandbox(() => {
            console.warn(
              '[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.'
            );
          }),
          s.createTransport(e, () => Promise.resolve({}))
        );
      }
      let n = 'https:' === t.protocol,
        l = (function (e, t) {
          let { no_proxy: n } = process.env;
          if (!n?.split(',').some((t) => e.host.endsWith(t) || e.hostname.endsWith(t))) return t;
        })(t, e.proxy || (n ? process.env.https_proxy : void 0) || process.env.http_proxy),
        c = n ? i : r,
        d = void 0 !== e.keepAlive && e.keepAlive,
        p = l
          ? new u.HttpsProxyAgent(l)
          : new c.Agent({ keepAlive: d, maxSockets: 30, timeout: 2e3 }),
        _ = (function (e, t, n) {
          let { hostname: r, pathname: i, port: u, protocol: l, search: c } = new URL(e.url);
          return function (d) {
            return new Promise((p, _) => {
              s.suppressTracing(() => {
                var s;
                let S =
                    ((s = d.body),
                    new o.Readable({
                      read() {
                        (this.push(s), this.push(null));
                      },
                    })),
                  E = { ...e.headers };
                d.body.length > 32768 &&
                  ((E['content-encoding'] = 'gzip'), (S = S.pipe(a.createGzip())));
                let T = t.request(
                  {
                    method: 'POST',
                    agent: n,
                    headers: E,
                    hostname: r,
                    path: `${i}${c}`,
                    port: u,
                    protocol: l,
                    ca: e.caCerts,
                  },
                  (e) => {
                    (e.on('data', () => {}), e.on('end', () => {}), e.setEncoding('utf8'));
                    let t = e.headers['retry-after'] ?? null,
                      n = e.headers['x-sentry-rate-limits'] ?? null;
                    p({
                      statusCode: e.statusCode,
                      headers: {
                        'retry-after': t,
                        'x-sentry-rate-limits': Array.isArray(n) ? n[0] || null : n,
                      },
                    });
                  }
                );
                (T.on('error', _), S.pipe(T));
              });
            });
          };
        })(e, e.httpModule ?? c, p);
      return s.createTransport(e, _);
    };
  },
  47313,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = new Set(['false', 'f', 'n', 'no', 'off', '0']),
      i = new Set(['true', 't', 'y', 'yes', 'on', '1']);
    ((n.FALSY_ENV_VALUES = r),
      (n.TRUTHY_ENV_VALUES = i),
      (n.envToBool = function (e, t) {
        let n = String(e).toLowerCase();
        return !r.has(n) && (!!i.has(n) || (t?.strict ? null : !!e));
      }));
  },
  27078,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(50227),
      i = e.r(48009);
    function o(e) {
      return e.replace(/^[A-Z]:/, '').replace(/\\/g, '/');
    }
    n.createGetModuleFromFilename = function (
      e = process.argv[1] ? i.dirname(process.argv[1]) : process.cwd(),
      t = '\\' === r.sep
    ) {
      let n = t ? o(e) : e;
      return (e) => {
        if (!e) return;
        let i = t ? o(e) : e,
          { dir: a, base: s, ext: u } = r.posix.parse(i);
        ('.js' === u || '.mjs' === u || '.cjs' === u) && (s = s.slice(0, -1 * u.length));
        let l = decodeURIComponent(s);
        a || (a = '.');
        let c = a.lastIndexOf('/node_modules');
        if (c > -1) return `${a.slice(c + 14).replace(/\//g, '.')}:${l}`;
        if (a.startsWith(n)) {
          let e = a.slice(n.length + 1).replace(/\//g, '.');
          return e ? `${e}:${l}` : l;
        }
        return l;
      };
    };
  },
  94136,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(27078);
    ((n.defaultStackParser = r.createStackParser(
      r.nodeStackLineParser(i.createGetModuleFromFilename())
    )),
      (n.getSentryRelease = function (e) {
        if (process.env.SENTRY_RELEASE) return process.env.SENTRY_RELEASE;
        if (r.GLOBAL_OBJ.SENTRY_RELEASE?.id) return r.GLOBAL_OBJ.SENTRY_RELEASE.id;
        let t =
            process.env.GITHUB_SHA ||
            process.env.CI_MERGE_REQUEST_SOURCE_BRANCH_SHA ||
            process.env.CI_BUILD_REF ||
            process.env.CI_COMMIT_SHA ||
            process.env.BITBUCKET_COMMIT,
          n =
            process.env.APPVEYOR_PULL_REQUEST_HEAD_COMMIT ||
            process.env.APPVEYOR_REPO_COMMIT ||
            process.env.CODEBUILD_RESOLVED_SOURCE_VERSION ||
            process.env.AWS_COMMIT_ID ||
            process.env.BUILD_SOURCEVERSION ||
            process.env.GIT_CLONE_COMMIT_HASH ||
            process.env.BUDDY_EXECUTION_REVISION ||
            process.env.BUILDKITE_COMMIT ||
            process.env.CIRCLE_SHA1 ||
            process.env.CIRRUS_CHANGE_IN_REPO ||
            process.env.CF_REVISION ||
            process.env.CM_COMMIT ||
            process.env.CF_PAGES_COMMIT_SHA ||
            process.env.DRONE_COMMIT_SHA ||
            process.env.FC_GIT_COMMIT_SHA ||
            process.env.HEROKU_TEST_RUN_COMMIT_VERSION ||
            process.env.HEROKU_SLUG_COMMIT ||
            process.env.RAILWAY_GIT_COMMIT_SHA ||
            process.env.RENDER_GIT_COMMIT ||
            process.env.SEMAPHORE_GIT_SHA ||
            process.env.TRAVIS_PULL_REQUEST_SHA ||
            process.env.VERCEL_GIT_COMMIT_SHA ||
            process.env.VERCEL_GITHUB_COMMIT_SHA ||
            process.env.VERCEL_GITLAB_COMMIT_SHA ||
            process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
            process.env.ZEIT_GITHUB_COMMIT_SHA ||
            process.env.ZEIT_GITLAB_COMMIT_SHA ||
            process.env.ZEIT_BITBUCKET_COMMIT_SHA,
          i =
            process.env.CI_COMMIT_ID ||
            process.env.SOURCE_COMMIT ||
            process.env.SOURCE_VERSION ||
            process.env.GIT_COMMIT ||
            process.env.COMMIT_REF ||
            process.env.BUILD_VCS_NUMBER ||
            process.env.CI_COMMIT_SHA;
        return t || n || i || e;
      }));
  },
  36237,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(60526),
      i = e.r(52305),
      o = e.r(75235),
      a = e.r(48009),
      s = e.r(52780),
      u = e.r(37702),
      l = e.r(97017);
    class c extends a.ServerRuntimeClient {
      constructor(t) {
        let n =
            !1 === t.includeServerName
              ? void 0
              : t.serverName || e.g.process.env.SENTRY_NAME || r.hostname(),
          i = {
            ...t,
            platform: 'node',
            runtime: { name: 'node', version: e.g.process.version },
            serverName: n,
          };
        (t.openTelemetryInstrumentations &&
          o.registerInstrumentations({ instrumentations: t.openTelemetryInstrumentations }),
          a.applySdkMetadata(i, 'node'),
          a.debug.log(
            `Initializing Sentry: process: ${process.pid}, thread: ${u.isMainThread ? 'main' : `worker-${u.threadId}`}.`
          ),
          super(i),
          this.getOptions().enableLogs &&
            ((this._logOnExitFlushListener = () => {
              a._INTERNAL_flushLogsBuffer(this);
            }),
            n &&
              this.on('beforeCaptureLog', (e) => {
                e.attributes = { ...e.attributes, 'server.address': n };
              }),
            process.on('beforeExit', this._logOnExitFlushListener)));
      }
      get tracer() {
        if (this._tracer) return this._tracer;
        let e = a.SDK_VERSION,
          t = i.trace.getTracer('@sentry/node', e);
        return ((this._tracer = t), t);
      }
      async flush(e) {
        return (
          await this.traceProvider?.forceFlush(),
          this.getOptions().sendClientReports && this._flushOutcomes(),
          super.flush(e)
        );
      }
      close(e) {
        return (
          this._clientReportInterval && clearInterval(this._clientReportInterval),
          this._clientReportOnExitFlushListener &&
            process.off('beforeExit', this._clientReportOnExitFlushListener),
          this._logOnExitFlushListener && process.off('beforeExit', this._logOnExitFlushListener),
          super
            .close(e)
            .then((e) => (this.traceProvider ? this.traceProvider.shutdown().then(() => e) : e))
        );
      }
      startClientReportTracking() {
        let e = this.getOptions();
        e.sendClientReports &&
          ((this._clientReportOnExitFlushListener = () => {
            this._flushOutcomes();
          }),
          (this._clientReportInterval = setInterval(() => {
            (l.DEBUG_BUILD && a.debug.log('Flushing client reports based on interval.'),
              this._flushOutcomes());
          }, e.clientReportFlushInterval ?? 6e4).unref()),
          process.on('beforeExit', this._clientReportOnExitFlushListener));
      }
      _getTraceInfoFromScope(e) {
        return e ? s.getTraceContextForScope(this, e) : [void 0, void 0];
      }
    }
    n.NodeClient = c;
  },
  95241,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(85397),
      o = e.r(62562);
    var a = 'undefined' != typeof document ? document.currentScript : null;
    n.maybeInitializeEsmLoader = function () {
      let [t = 0, n = 0] = process.versions.node.split('.').map(Number);
      if (t >= 21 || (20 === t && n >= 6) || (18 === t && n >= 19)) {
        if (!r.GLOBAL_OBJ._sentryEsmLoaderHookRegistered)
          try {
            let { addHookMessagePort: t } = i.createAddHookMessageChannel();
            o.default.register(
              'import-in-the-middle/hook.mjs',
              'undefined' == typeof document
                ? e
                    .r(92509)
                    .pathToFileURL(
                      '/ROOT/node_modules/.pnpm/@sentry+node-core@10.10.0_@opentelemetry+api@1.9.0_@opentelemetry+context-async-hooks@2_613ea5654a336b5ff6f1308c87dcead1/node_modules/@sentry/node-core/build/cjs/sdk/esmLoader.js'
                    ).href
                : (a && 'SCRIPT' === a.tagName.toUpperCase() && a.src) ||
                    new URL('sdk/esmLoader.js', document.baseURI).href,
              { data: { addHookMessagePort: t, include: [] }, transferList: [t] }
            );
          } catch (e) {
            r.debug.warn('Failed to register ESM hook', e);
          }
      } else
        r.consoleSandbox(() => {
          console.warn(
            `[Sentry] You are using Node.js v${process.versions.node} in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.`
          );
        });
    };
  },
  49687,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(52780),
      o = e.r(97017),
      a = e.r(48148),
      s = e.r(22185),
      u = e.r(60221),
      l = e.r(1094),
      c = e.r(98155),
      d = e.r(98937),
      p = e.r(84761),
      _ = e.r(48264),
      S = e.r(22843),
      E = e.r(92621),
      T = e.r(22089),
      m = e.r(53861),
      g = e.r(93950),
      f = e.r(4441),
      h = e.r(47313),
      A = e.r(94136),
      R = e.r(36237),
      y = e.r(95241);
    function I() {
      return [
        r.inboundFiltersIntegration(),
        r.functionToStringIntegration(),
        r.linkedErrorsIntegration(),
        r.requestDataIntegration(),
        m.systemErrorIntegration(),
        r.consoleIntegration(),
        l.httpIntegration(),
        p.nativeNodeFetchIntegration(),
        _.onUncaughtExceptionIntegration(),
        S.onUnhandledRejectionIntegration(),
        u.contextLinesIntegration(),
        c.localVariablesIntegration(),
        s.nodeContextIntegration(),
        a.childProcessIntegration(),
        E.processSessionIntegration(),
        d.modulesIntegration(),
      ];
    }
    function b(e = {}, t) {
      let n = (function (e, t) {
        let n = (function (e) {
            if (void 0 !== e) return e;
            let t = A.getSentryRelease();
            if (void 0 !== t) return t;
          })(e.release),
          i =
            e.spotlight ??
            h.envToBool(process.env.SENTRY_SPOTLIGHT, { strict: !0 }) ??
            process.env.SENTRY_SPOTLIGHT,
          o = (function (e) {
            if (void 0 !== e) return e;
            let t = process.env.SENTRY_TRACES_SAMPLE_RATE;
            if (!t) return;
            let n = parseFloat(t);
            return isFinite(n) ? n : void 0;
          })(e.tracesSampleRate),
          a = {
            ...e,
            dsn: e.dsn ?? process.env.SENTRY_DSN,
            environment: e.environment ?? process.env.SENTRY_ENVIRONMENT,
            sendClientReports: e.sendClientReports ?? !0,
            transport: e.transport ?? g.makeNodeTransport,
            stackParser: r.stackParserFromStackParserOptions(e.stackParser || A.defaultStackParser),
            release: n,
            tracesSampleRate: o,
            spotlight: i,
            debug: h.envToBool(e.debug ?? process.env.SENTRY_DEBUG),
          },
          s = e.integrations,
          u = e.defaultIntegrations ?? t(a);
        return {
          ...a,
          integrations: r.getIntegrationsToSetup({ defaultIntegrations: u, integrations: s }),
        };
      })(e, t);
      (!0 === n.debug &&
        (o.DEBUG_BUILD
          ? r.debug.enable()
          : r.consoleSandbox(() => {
              console.warn(
                '[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.'
              );
            })),
        f.isCjs() || !1 === n.registerEsmLoaderHooks || y.maybeInitializeEsmLoader(),
        i.setOpenTelemetryContextAsyncContextStrategy(),
        r.getCurrentScope().update(n.initialScope),
        n.spotlight &&
          !n.integrations.some(({ name: e }) => e === T.INTEGRATION_NAME) &&
          n.integrations.push(
            T.spotlightIntegration({
              sidecarUrl: 'string' == typeof n.spotlight ? n.spotlight : void 0,
            })
          ),
        r.applySdkMetadata(n, 'node-core'));
      let a = new R.NodeClient(n);
      return (
        r.getCurrentScope().setClient(a),
        a.init(),
        r.debug.log(`Running in ${f.isCjs() ? 'CommonJS' : 'ESM'} mode.`),
        a.startClientReportTracking(),
        (function () {
          if (!1 !== h.envToBool(process.env.SENTRY_USE_ENVIRONMENT)) {
            let e = process.env.SENTRY_TRACE,
              t = process.env.SENTRY_BAGGAGE,
              n = r.propagationContextFromHeaders(e, t);
            r.getCurrentScope().setPropagationContext(n);
          }
        })(),
        i.enhanceDscWithOpenTelemetryRootSpanName(a),
        i.setupEventContextTrace(a),
        a
      );
    }
    ((n.getDefaultIntegrations = I),
      (n.init = function (e = {}) {
        return b(e, I);
      }),
      (n.initWithoutDefaultIntegrations = function (e = {}) {
        return b(e, () => []);
      }),
      (n.validateOpenTelemetrySetup = function () {
        if (!o.DEBUG_BUILD) return;
        let e = i.openTelemetrySetupCheck(),
          t = ['SentryContextManager', 'SentryPropagator'];
        for (let n of (r.hasSpansEnabled() && t.push('SentrySpanProcessor'), t))
          e.includes(n) ||
            r.debug.error(
              `You have to set up the ${n}. Without this, the OpenTelemetry & Sentry integration will not work properly.`
            );
        e.includes('SentrySampler') ||
          r.debug.warn(
            'You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected. If you use a custom sampler, make sure to use `wrapSamplingDecision`.'
          );
      }));
  },
  36665,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(52780);
    n.setIsolationScope = function (e) {
      let t = i.getScopesFromContext(r.context.active());
      t && (t.isolationScope = e);
    };
  },
  89198,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.addOriginToSpan = function (e, t) {
      e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, t);
    };
  },
  38726,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(4441);
    n.createMissingInstrumentationContext = (e) => ({ package: e, 'javascript.is_cjs': r.isCjs() });
  },
  42649,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(75235),
      i = e.r(48009),
      o = e.r(4441),
      a = e.r(38726);
    n.ensureIsWrapped = function (e, t) {
      let n = i.getClient()?.getOptions();
      !n?.disableInstrumentationWarnings &&
        !r.isWrapped(e) &&
        i.isEnabled() &&
        i.hasSpansEnabled(n) &&
        (i.consoleSandbox(() => {
          o.isCjs()
            ? console.warn(
                `[Sentry] ${t} is not instrumented. This is likely because you required/imported ${t} before calling \`Sentry.init()\`.`
              )
            : console.warn(
                `[Sentry] ${t} is not instrumented. Please make sure to initialize Sentry in a separate file that you \`--import\` when running node, see: https://docs.sentry.io/platforms/javascript/guides/${t}/install/esm/.`
              );
        }),
        i
          .getGlobalScope()
          .setContext('missing_instrumentation', a.createMissingInstrumentationContext(t)));
    };
  },
  83697,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = [
      ['january', '1'],
      ['february', '2'],
      ['march', '3'],
      ['april', '4'],
      ['may', '5'],
      ['june', '6'],
      ['july', '7'],
      ['august', '8'],
      ['september', '9'],
      ['october', '10'],
      ['november', '11'],
      ['december', '12'],
      ['jan', '1'],
      ['feb', '2'],
      ['mar', '3'],
      ['apr', '4'],
      ['may', '5'],
      ['jun', '6'],
      ['jul', '7'],
      ['aug', '8'],
      ['sep', '9'],
      ['oct', '10'],
      ['nov', '11'],
      ['dec', '12'],
      ['sunday', '0'],
      ['monday', '1'],
      ['tuesday', '2'],
      ['wednesday', '3'],
      ['thursday', '4'],
      ['friday', '5'],
      ['saturday', '6'],
      ['sun', '0'],
      ['mon', '1'],
      ['tue', '2'],
      ['wed', '3'],
      ['thu', '4'],
      ['fri', '5'],
      ['sat', '6'],
    ];
    n.replaceCronNames = function (e) {
      return r.reduce((e, [t, n]) => e.replace(RegExp(t, 'gi'), n), e);
    };
  },
  30366,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(83697),
      o = 'Automatic instrumentation of CronJob only supports crontab string';
    n.instrumentCron = function (e, t) {
      let n = !1;
      return new Proxy(e, {
        construct(e, a) {
          let [s, u, l, c, d, ...p] = a;
          if ('string' != typeof s) throw Error(o);
          if (n) throw Error(`A job named '${t}' has already been scheduled`);
          n = !0;
          let _ = i.replaceCronNames(s);
          return new e(
            s,
            async function (e, n) {
              return r.withMonitor(
                t,
                async () => {
                  try {
                    await u(e, n);
                  } catch (e) {
                    throw (r.captureException(e), e);
                  }
                },
                { schedule: { type: 'crontab', value: _ }, timezone: d || void 0 }
              );
            },
            l,
            c,
            d,
            ...p
          );
        },
        get: (e, a) =>
          'from' === a
            ? (a) => {
                let { cronTime: s, onTick: u, timeZone: l } = a;
                if ('string' != typeof s) throw Error(o);
                if (n) throw Error(`A job named '${t}' has already been scheduled`);
                n = !0;
                let c = i.replaceCronNames(s);
                return (
                  (a.onTick = async (e, n) =>
                    r.withMonitor(
                      t,
                      async () => {
                        try {
                          await u(e, n);
                        } catch (e) {
                          throw (r.captureException(e), e);
                        }
                      },
                      { schedule: { type: 'crontab', value: c }, timezone: l || void 0 }
                    )),
                  e.from(a)
                );
              }
            : e[a],
      });
    };
  },
  3616,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(83697);
    n.instrumentNodeCron = function (e) {
      return new Proxy(e, {
        get: (e, t) =>
          'schedule' === t && e.schedule
            ? new Proxy(e.schedule, {
                apply(e, t, n) {
                  let [o, a, s] = n,
                    u = s?.name,
                    l = s?.timezone;
                  if (!u)
                    throw Error(
                      'Missing "name" for scheduled job. A name is required for Sentry check-in monitoring.'
                    );
                  let c = async () =>
                    r.withMonitor(
                      u,
                      async () => {
                        try {
                          return await a();
                        } catch (e) {
                          throw (r.captureException(e), e);
                        }
                      },
                      { schedule: { type: 'crontab', value: i.replaceCronNames(o) }, timezone: l }
                    );
                  return e.apply(t, [o, c, s]);
                },
              })
            : e[t],
      });
    };
  },
  23096,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(83697);
    n.instrumentNodeSchedule = function (e) {
      return new Proxy(e, {
        get: (e, t) =>
          'scheduleJob' === t
            ? new Proxy(e.scheduleJob, {
                apply(e, t, n) {
                  let [o, a, s] = n;
                  if ('string' != typeof o || 'string' != typeof a || 'function' != typeof s)
                    throw Error(
                      "Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string"
                    );
                  async function u() {
                    return r.withMonitor(
                      o,
                      async () => {
                        await s?.();
                      },
                      { schedule: { type: 'crontab', value: i.replaceCronNames(a) } }
                    );
                  }
                  return e.apply(t, [o, a, u]);
                },
              })
            : e[t],
      });
    };
  },
  74602,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(30366),
      i = e.r(3616),
      o = e.r(23096);
    n.cron = {
      instrumentCron: r.instrumentCron,
      instrumentNodeCron: i.instrumentNodeCron,
      instrumentNodeSchedule: o.instrumentNodeSchedule,
    };
  },
  15527,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(66227),
      i = e.r(1094),
      o = e.r(77945),
      a = e.r(84761),
      s = e.r(84314),
      u = e.r(22185),
      l = e.r(60221),
      c = e.r(98155),
      d = e.r(98937),
      p = e.r(48264),
      _ = e.r(22843),
      S = e.r(18397),
      E = e.r(22089),
      T = e.r(53861),
      m = e.r(48148),
      g = e.r(91655),
      f = e.r(94633),
      h = e.r(17090),
      A = e.r(20503),
      R = e.r(49687),
      y = e.r(36665),
      I = e.r(94136),
      b = e.r(27078),
      N = e.r(89198),
      O = e.r(64077),
      v = e.r(4441),
      C = e.r(42649),
      P = e.r(38726),
      M = e.r(47313),
      L = e.r(93950),
      U = e.r(36237),
      D = e.r(74602),
      x = e.r(73417),
      w = e.r(52780),
      k = e.r(48009);
    ((n.logger = r),
      (n.httpIntegration = i.httpIntegration),
      (n.SentryHttpInstrumentation = o.SentryHttpInstrumentation),
      (n.nativeNodeFetchIntegration = a.nativeNodeFetchIntegration),
      (n.SentryNodeFetchInstrumentation = s.SentryNodeFetchInstrumentation),
      (n.nodeContextIntegration = u.nodeContextIntegration),
      (n.contextLinesIntegration = l.contextLinesIntegration),
      (n.localVariablesIntegration = c.localVariablesIntegration),
      (n.modulesIntegration = d.modulesIntegration),
      (n.onUncaughtExceptionIntegration = p.onUncaughtExceptionIntegration),
      (n.onUnhandledRejectionIntegration = _.onUnhandledRejectionIntegration),
      (n.anrIntegration = S.anrIntegration),
      (n.disableAnrDetectionForCallback = S.disableAnrDetectionForCallback),
      (n.spotlightIntegration = E.spotlightIntegration),
      (n.systemErrorIntegration = T.systemErrorIntegration),
      (n.childProcessIntegration = m.childProcessIntegration),
      (n.createSentryWinstonTransport = g.createSentryWinstonTransport),
      (n.SentryContextManager = f.SentryContextManager),
      (n.setupOpenTelemetryLogger = h.setupOpenTelemetryLogger),
      (n.INSTRUMENTED = A.INSTRUMENTED),
      (n.generateInstrumentOnce = A.generateInstrumentOnce),
      (n.instrumentWhenWrapped = A.instrumentWhenWrapped),
      (n.getDefaultIntegrations = R.getDefaultIntegrations),
      (n.init = R.init),
      (n.initWithoutDefaultIntegrations = R.initWithoutDefaultIntegrations),
      (n.validateOpenTelemetrySetup = R.validateOpenTelemetrySetup),
      (n.setIsolationScope = y.setIsolationScope),
      (n.defaultStackParser = I.defaultStackParser),
      (n.getSentryRelease = I.getSentryRelease),
      (n.createGetModuleFromFilename = b.createGetModuleFromFilename),
      (n.addOriginToSpan = N.addOriginToSpan),
      (n.getRequestUrl = O.getRequestUrl),
      (n.isCjs = v.isCjs),
      (n.ensureIsWrapped = C.ensureIsWrapped),
      (n.createMissingInstrumentationContext = P.createMissingInstrumentationContext),
      (n.envToBool = M.envToBool),
      (n.makeNodeTransport = L.makeNodeTransport),
      (n.NodeClient = U.NodeClient),
      (n.cron = D.cron),
      (n.NODE_VERSION = x.NODE_VERSION),
      (n.setNodeAsyncContextStrategy = w.setOpenTelemetryContextAsyncContextStrategy),
      (n.SDK_VERSION = k.SDK_VERSION),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_OP = k.SEMANTIC_ATTRIBUTE_SENTRY_OP),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = k.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = k.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = k.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE),
      (n.Scope = k.Scope),
      (n.addBreadcrumb = k.addBreadcrumb),
      (n.addEventProcessor = k.addEventProcessor),
      (n.addIntegration = k.addIntegration),
      (n.captureCheckIn = k.captureCheckIn),
      (n.captureConsoleIntegration = k.captureConsoleIntegration),
      (n.captureEvent = k.captureEvent),
      (n.captureException = k.captureException),
      (n.captureFeedback = k.captureFeedback),
      (n.captureMessage = k.captureMessage),
      (n.captureSession = k.captureSession),
      (n.close = k.close),
      (n.consoleIntegration = k.consoleIntegration),
      (n.consoleLoggingIntegration = k.consoleLoggingIntegration),
      (n.continueTrace = k.continueTrace),
      (n.createTransport = k.createTransport),
      (n.dedupeIntegration = k.dedupeIntegration),
      (n.endSession = k.endSession),
      (n.eventFiltersIntegration = k.eventFiltersIntegration),
      (n.extraErrorDataIntegration = k.extraErrorDataIntegration),
      (n.featureFlagsIntegration = k.featureFlagsIntegration),
      (n.flush = k.flush),
      (n.functionToStringIntegration = k.functionToStringIntegration),
      (n.getActiveSpan = k.getActiveSpan),
      (n.getClient = k.getClient),
      (n.getCurrentScope = k.getCurrentScope),
      (n.getGlobalScope = k.getGlobalScope),
      (n.getIsolationScope = k.getIsolationScope),
      (n.getRootSpan = k.getRootSpan),
      (n.getSpanDescendants = k.getSpanDescendants),
      (n.getSpanStatusFromHttpCode = k.getSpanStatusFromHttpCode),
      (n.getTraceData = k.getTraceData),
      (n.getTraceMetaTags = k.getTraceMetaTags),
      (n.inboundFiltersIntegration = k.inboundFiltersIntegration),
      (n.instrumentSupabaseClient = k.instrumentSupabaseClient),
      (n.isEnabled = k.isEnabled),
      (n.isInitialized = k.isInitialized),
      (n.lastEventId = k.lastEventId),
      (n.linkedErrorsIntegration = k.linkedErrorsIntegration),
      (n.parameterize = k.parameterize),
      (n.profiler = k.profiler),
      (n.requestDataIntegration = k.requestDataIntegration),
      (n.rewriteFramesIntegration = k.rewriteFramesIntegration),
      (n.setContext = k.setContext),
      (n.setCurrentClient = k.setCurrentClient),
      (n.setExtra = k.setExtra),
      (n.setExtras = k.setExtras),
      (n.setHttpStatus = k.setHttpStatus),
      (n.setMeasurement = k.setMeasurement),
      (n.setTag = k.setTag),
      (n.setTags = k.setTags),
      (n.setUser = k.setUser),
      (n.spanToBaggageHeader = k.spanToBaggageHeader),
      (n.spanToJSON = k.spanToJSON),
      (n.spanToTraceHeader = k.spanToTraceHeader),
      (n.startInactiveSpan = k.startInactiveSpan),
      (n.startNewTrace = k.startNewTrace),
      (n.startSession = k.startSession),
      (n.startSpan = k.startSpan),
      (n.startSpanManual = k.startSpanManual),
      (n.supabaseIntegration = k.supabaseIntegration),
      (n.suppressTracing = k.suppressTracing),
      (n.trpcMiddleware = k.trpcMiddleware),
      (n.updateSpanName = k.updateSpanName),
      (n.withActiveSpan = k.withActiveSpan),
      (n.withIsolationScope = k.withIsolationScope),
      (n.withMonitor = k.withMonitor),
      (n.withScope = k.withScope),
      (n.wrapMcpServerWithSentry = k.wrapMcpServerWithSentry),
      (n.zodErrorsIntegration = k.zodErrorsIntegration));
  },
  23569,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(55521),
      o = e.r(48009),
      a = e.r(15527),
      s = 'Http',
      u = '@opentelemetry_sentry-patched/instrumentation-http',
      l = a.generateInstrumentOnce(`${s}.sentry`, (e) => new a.SentryHttpInstrumentation(e)),
      c = a.generateInstrumentOnce(s, (e) => {
        let t = new i.HttpInstrumentation({ ...e, disableIncomingRequestInstrumentation: !0 });
        try {
          ((t._diag = r.diag.createComponentLogger({ namespace: u })), (t.instrumentationName = u));
        } catch {}
        return t;
      });
    function d(e, t = {}) {
      return 'boolean' == typeof e.spans
        ? e.spans
        : !t.skipOpenTelemetrySetup && (!!o.hasSpansEnabled(t) || !(a.NODE_VERSION.major >= 22));
    }
    let p = o.defineIntegration((e = {}) => {
      let t = e.dropSpansForIncomingRequestStatusCodes ?? [
        [401, 404],
        [300, 399],
      ];
      return {
        name: s,
        setupOnce() {
          let t = o.getClient()?.getOptions() || {},
            n = d(e, t),
            r = e.disableIncomingRequestSpans ?? !o.hasSpansEnabled(t);
          (l({
            ...e,
            disableIncomingRequestSpans: r,
            ignoreSpansForIncomingRequests: e.ignoreIncomingRequests,
            propagateTraceInOutgoingRequests: !n,
          }),
            n &&
              c(
                (function (e = {}) {
                  return {
                    ignoreOutgoingRequestHook: (t) => {
                      let n = a.getRequestUrl(t);
                      if (!n) return !1;
                      let r = e.ignoreOutgoingRequests;
                      return !!r?.(n, t);
                    },
                    requireParentforOutgoingSpans: !1,
                    requestHook: (t, n) => {
                      (a.addOriginToSpan(t, 'auto.http.otel.http'),
                        e.instrumentation?.requestHook?.(t, n));
                    },
                    responseHook: (t, n) => {
                      e.instrumentation?.responseHook?.(t, n);
                    },
                    applyCustomAttributesOnSpan: (t, n, r) => {
                      e.instrumentation?.applyCustomAttributesOnSpan?.(t, n, r);
                    },
                  };
                })(e)
              ));
        },
        processEvent(e) {
          if ('transaction' === e.type) {
            let n = e.contexts?.trace?.data?.['http.response.status_code'];
            if (
              'number' == typeof n &&
              t.some((e) => {
                if ('number' == typeof e) return e === n;
                let [t, r] = e;
                return n >= t && n <= r;
              })
            )
              return null;
          }
          return e;
        },
      };
    });
    ((n._shouldUseOtelHttpInstrumentation = d),
      (n.httpIntegration = p),
      (n.instrumentOtelHttp = c),
      (n.instrumentSentryHttp = l));
  },
  43176,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.14.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-undici'));
  },
  82249,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SemanticAttributes = void 0),
      (n.SemanticAttributes = {
        HTTP_CONNECTION_STATE: 'http.connection.state',
        ERROR_TYPE: 'error.type',
        HTTP_REQUEST_BODY_SIZE: 'http.request.body.size',
        HTTP_REQUEST_METHOD: 'http.request.method',
        HTTP_REQUEST_METHOD_ORIGINAL: 'http.request.method_original',
        HTTP_REQUEST_RESEND_COUNT: 'http.request.resend_count',
        HTTP_RESPONSE_BODY_SIZE: 'http.response.body.size',
        HTTP_RESPONSE_STATUS_CODE: 'http.response.status_code',
        HTTP_ROUTE: 'http.route',
        NETWORK_PEER_ADDRESS: 'network.peer.address',
        NETWORK_PEER_PORT: 'network.peer.port',
        NETWORK_PROTOCOL_NAME: 'network.protocol.name',
        NETWORK_PROTOCOL_VERSION: 'network.protocol.version',
        SERVER_ADDRESS: 'server.address',
        SERVER_PORT: 'server.port',
        URL_FULL: 'url.full',
        URL_PATH: 'url.path',
        URL_QUERY: 'url.query',
        URL_SCHEME: 'url.scheme',
        USER_AGENT_ORIGINAL: 'user_agent.original',
      }));
  },
  95792,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.UndiciInstrumentation = void 0));
    let r = e.r(54993),
      i = e.r(92509),
      o = e.r(75235),
      a = e.r(52305),
      s = e.r(43176),
      u = e.r(82249),
      l = e.r(88540);
    class c extends o.InstrumentationBase {
      _recordFromReq = new WeakMap();
      constructor(e = {}) {
        super(s.PACKAGE_NAME, s.PACKAGE_VERSION, e);
      }
      init() {}
      disable() {
        (super.disable(),
          this._channelSubs.forEach((e) => e.unsubscribe()),
          (this._channelSubs.length = 0));
      }
      enable() {
        (super.enable(),
          (this._channelSubs = this._channelSubs || []),
          this._channelSubs.length > 0 ||
            (this.subscribeToChannel('undici:request:create', this.onRequestCreated.bind(this)),
            this.subscribeToChannel('undici:client:sendHeaders', this.onRequestHeaders.bind(this)),
            this.subscribeToChannel('undici:request:headers', this.onResponseHeaders.bind(this)),
            this.subscribeToChannel('undici:request:trailers', this.onDone.bind(this)),
            this.subscribeToChannel('undici:request:error', this.onError.bind(this))));
      }
      _updateMetricInstruments() {
        this._httpClientDurationHistogram = this.meter.createHistogram(
          'http.client.request.duration',
          {
            description: 'Measures the duration of outbound HTTP requests.',
            unit: 's',
            valueType: a.ValueType.DOUBLE,
            advice: {
              explicitBucketBoundaries: [
                0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10,
              ],
            },
          }
        );
      }
      subscribeToChannel(e, t) {
        let n,
          [i, o] = process.version
            .replace('v', '')
            .split('.')
            .map((e) => Number(e));
        if (i > 18 || (18 === i && o >= 19))
          (r.subscribe?.(e, t), (n = () => r.unsubscribe?.(e, t)));
        else {
          let i = r.channel(e);
          (i.subscribe(t), (n = () => i.unsubscribe(t)));
        }
        this._channelSubs.push({ name: e, unsubscribe: n });
      }
      parseRequestHeaders(e) {
        let t = new Map();
        if (Array.isArray(e.headers))
          for (let n = 0; n < e.headers.length; n += 2) {
            let r = e.headers[n],
              i = e.headers[n + 1];
            'string' == typeof r && t.set(r.toLowerCase(), i);
          }
        else if ('string' == typeof e.headers)
          for (let n of e.headers.split('\r\n')) {
            if (!n) continue;
            let e = n.indexOf(':');
            if (-1 === e) continue;
            let r = n.substring(0, e).toLowerCase(),
              i = n.substring(e + 1).trim(),
              o = t.get(r);
            o && Array.isArray(o) ? o.push(i) : o ? t.set(r, [o, i]) : t.set(r, i);
          }
        return t;
      }
      onRequestCreated({ request: e }) {
        let t,
          n,
          r = this.getConfig(),
          s = !1 !== r.enabled;
        if (
          (0, o.safeExecuteInTheMiddle)(
            () => !s || 'CONNECT' === e.method || r.ignoreRequestHook?.(e),
            (e) => e && this._diag.error('caught ignoreRequestHook error: ', e),
            !0
          )
        )
          return;
        let c = (0, l.hrTime)();
        try {
          t = new i.URL(e.path, e.origin);
        } catch (e) {
          this._diag.warn('could not determine url.full:', e);
          return;
        }
        let d = t.protocol.replace(':', ''),
          p = this.getRequestMethod(e.method),
          _ = {
            [u.SemanticAttributes.HTTP_REQUEST_METHOD]: p,
            [u.SemanticAttributes.HTTP_REQUEST_METHOD_ORIGINAL]: e.method,
            [u.SemanticAttributes.URL_FULL]: t.toString(),
            [u.SemanticAttributes.URL_PATH]: t.pathname,
            [u.SemanticAttributes.URL_QUERY]: t.search,
            [u.SemanticAttributes.URL_SCHEME]: d,
          },
          S = t.hostname,
          E = t.port || { https: '443', http: '80' }[d];
        ((_[u.SemanticAttributes.SERVER_ADDRESS] = S),
          E && !isNaN(Number(E)) && (_[u.SemanticAttributes.SERVER_PORT] = Number(E)));
        let T = this.parseRequestHeaders(e).get('user-agent');
        if (T) {
          let e = Array.isArray(T) ? T[T.length - 1] : T;
          _[u.SemanticAttributes.USER_AGENT_ORIGINAL] = e;
        }
        let m = (0, o.safeExecuteInTheMiddle)(
          () => r.startSpanHook?.(e),
          (e) => e && this._diag.error('caught startSpanHook error: ', e),
          !0
        );
        m &&
          Object.entries(m).forEach(([e, t]) => {
            _[e] = t;
          });
        let g = a.context.active(),
          f = a.trace.getSpan(g);
        ((n =
          !r.requireParentforSpans || (f && a.trace.isSpanContextValid(f.spanContext()))
            ? this.tracer.startSpan(
                '_OTHER' === p ? 'HTTP' : p,
                { kind: a.SpanKind.CLIENT, attributes: _ },
                g
              )
            : a.trace.wrapSpanContext(a.INVALID_SPAN_CONTEXT)),
          (0, o.safeExecuteInTheMiddle)(
            () => r.requestHook?.(n, e),
            (e) => e && this._diag.error('caught requestHook error: ', e),
            !0
          ));
        let h = a.trace.setSpan(a.context.active(), n),
          A = {};
        a.propagation.inject(h, A);
        let R = Object.entries(A);
        for (let t = 0; t < R.length; t++) {
          let [n, r] = R[t];
          'function' == typeof e.addHeader
            ? e.addHeader(n, r)
            : 'string' == typeof e.headers
              ? (e.headers += `${n}: ${r}\r
`)
              : Array.isArray(e.headers) && e.headers.push(n, r);
        }
        this._recordFromReq.set(e, { span: n, attributes: _, startTime: c });
      }
      onRequestHeaders({ request: e, socket: t }) {
        let n = this._recordFromReq.get(e);
        if (!n) return;
        let r = this.getConfig(),
          { span: i } = n,
          { remoteAddress: o, remotePort: a } = t,
          s = {
            [u.SemanticAttributes.NETWORK_PEER_ADDRESS]: o,
            [u.SemanticAttributes.NETWORK_PEER_PORT]: a,
          };
        if (r.headersToSpanAttributes?.requestHeaders) {
          let t = new Set(r.headersToSpanAttributes.requestHeaders.map((e) => e.toLowerCase()));
          for (let [n, r] of this.parseRequestHeaders(e).entries())
            if (t.has(n)) {
              let e = Array.isArray(r) ? r.join(', ') : r;
              s[`http.request.header.${n}`] = e;
            }
        }
        i.setAttributes(s);
      }
      onResponseHeaders({ request: e, response: t }) {
        let n = this._recordFromReq.get(e);
        if (!n) return;
        let { span: r, attributes: i } = n,
          s = { [u.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE]: t.statusCode },
          l = this.getConfig();
        (0, o.safeExecuteInTheMiddle)(
          () => l.responseHook?.(r, { request: e, response: t }),
          (e) => e && this._diag.error('caught responseHook error: ', e),
          !0
        );
        let c = new Set();
        l.headersToSpanAttributes?.responseHeaders &&
          l.headersToSpanAttributes?.responseHeaders.forEach((e) => c.add(e.toLowerCase()));
        for (let e = 0; e < t.headers.length; e += 2) {
          let n = t.headers[e].toString().toLowerCase(),
            r = t.headers[e + 1];
          if (
            (c.has(n) && (s[`http.response.header.${n}`] = r.toString()), 'content-length' === n)
          ) {
            let e = Number(r.toString());
            isNaN(e) || (s['http.response.header.content-length'] = e);
          }
        }
        (r.setAttributes(s),
          r.setStatus({
            code: t.statusCode >= 400 ? a.SpanStatusCode.ERROR : a.SpanStatusCode.UNSET,
          }),
          (n.attributes = Object.assign(i, s)));
      }
      onDone({ request: e }) {
        let t = this._recordFromReq.get(e);
        if (!t) return;
        let { span: n, attributes: r, startTime: i } = t;
        (n.end(), this._recordFromReq.delete(e), this.recordRequestDuration(r, i));
      }
      onError({ request: e, error: t }) {
        let n = this._recordFromReq.get(e);
        if (!n) return;
        let { span: r, attributes: i, startTime: o } = n;
        (r.recordException(t),
          r.setStatus({ code: a.SpanStatusCode.ERROR, message: t.message }),
          r.end(),
          this._recordFromReq.delete(e),
          (i[u.SemanticAttributes.ERROR_TYPE] = t.message),
          this.recordRequestDuration(i, o));
      }
      recordRequestDuration(e, t) {
        let n = {};
        [
          u.SemanticAttributes.HTTP_RESPONSE_STATUS_CODE,
          u.SemanticAttributes.HTTP_REQUEST_METHOD,
          u.SemanticAttributes.SERVER_ADDRESS,
          u.SemanticAttributes.SERVER_PORT,
          u.SemanticAttributes.URL_SCHEME,
          u.SemanticAttributes.ERROR_TYPE,
        ].forEach((t) => {
          t in e && (n[t] = e[t]);
        });
        let r = (0, l.hrTimeToMilliseconds)((0, l.hrTimeDuration)(t, (0, l.hrTime)())) / 1e3;
        this._httpClientDurationHistogram.record(r, n);
      }
      getRequestMethod(e) {
        return e.toUpperCase() in
          {
            CONNECT: !0,
            OPTIONS: !0,
            HEAD: !0,
            GET: !0,
            POST: !0,
            PUT: !0,
            PATCH: !0,
            DELETE: !0,
            TRACE: !0,
          }
          ? e.toUpperCase()
          : '_OTHER';
      }
    }
    n.UndiciInstrumentation = c;
  },
  28121,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.UndiciInstrumentation = void 0));
    var r = e.r(95792);
    Object.defineProperty(n, 'UndiciInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.UndiciInstrumentation;
      },
    });
  },
  45750,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(28121),
      i = e.r(48009),
      o = e.r(15527),
      a = 'NodeFetch',
      s = o.generateInstrumentOnce(a, r.UndiciInstrumentation, (e) =>
        (function (e = {}) {
          return {
            requireParentforSpans: !1,
            ignoreRequestHook: (t) => {
              let n = (function (e, t = '/') {
                  let n = `${e}`;
                  return n.endsWith('/') && t.startsWith('/')
                    ? `${n}${t.slice(1)}`
                    : n.endsWith('/') || t.startsWith('/')
                      ? `${n}${t}`
                      : `${n}/${t.slice(1)}`;
                })(t.origin, t.path),
                r = e.ignoreOutgoingRequests;
              return !!(r && n && r(n));
            },
            startSpanHook: () => ({
              [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.node_fetch',
            }),
          };
        })(e)
      ),
      u = o.generateInstrumentOnce(`${a}.sentry`, o.SentryNodeFetchInstrumentation, (e) => e);
    n.nativeNodeFetchIntegration = i.defineIntegration((e = {}) => ({
      name: 'NodeFetch',
      setupOnce() {
        ((function (e, t = {}) {
          return 'boolean' == typeof e.spans
            ? e.spans
            : !t.skipOpenTelemetrySetup && i.hasSpansEnabled(t);
        })(e, i.getClient()?.getOptions()) && s(e),
          u(e));
      },
    }));
  },
  86599,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.23.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-fs'));
  },
  86033,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SYNC_FUNCTIONS = n.CALLBACK_FUNCTIONS = n.PROMISE_FUNCTIONS = void 0),
      (n.PROMISE_FUNCTIONS = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'copyFile',
        'cp',
        'lchown',
        'link',
        'lstat',
        'lutimes',
        'mkdir',
        'mkdtemp',
        'open',
        'opendir',
        'readdir',
        'readFile',
        'readlink',
        'realpath',
        'rename',
        'rm',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
      ]),
      (n.CALLBACK_FUNCTIONS = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'copyFile',
        'cp',
        'exists',
        'lchown',
        'link',
        'lstat',
        'lutimes',
        'mkdir',
        'mkdtemp',
        'open',
        'opendir',
        'readdir',
        'readFile',
        'readlink',
        'realpath',
        'realpath.native',
        'rename',
        'rm',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
      ]),
      (n.SYNC_FUNCTIONS = [
        'accessSync',
        'appendFileSync',
        'chmodSync',
        'chownSync',
        'copyFileSync',
        'cpSync',
        'existsSync',
        'lchownSync',
        'linkSync',
        'lstatSync',
        'lutimesSync',
        'mkdirSync',
        'mkdtempSync',
        'opendirSync',
        'openSync',
        'readdirSync',
        'readFileSync',
        'readlinkSync',
        'realpathSync',
        'realpathSync.native',
        'renameSync',
        'rmdirSync',
        'rmSync',
        'statSync',
        'symlinkSync',
        'truncateSync',
        'unlinkSync',
        'utimesSync',
        'writeFileSync',
      ]));
  },
  5296,
  (e, t, n) => {
    'use strict';
    function r(e) {
      let t = e.split('.');
      if (!(t.length > 1)) return [e];
      if (2 !== t.length) throw Error(`Invalid member function name ${e}`);
      return t;
    }
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.indexFs = n.splitTwoLevels = void 0),
      (n.splitTwoLevels = r),
      (n.indexFs = function (e, t) {
        if (!t) throw Error(JSON.stringify({ member: t }));
        let [n, i] = r(t);
        return i
          ? { objectToPatch: e[n], functionNameToPatch: i }
          : { objectToPatch: e, functionNameToPatch: n };
      }));
  },
  13994,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.FsInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(75235),
      a = e.r(86599),
      s = e.r(86033),
      u = e.r(24361),
      l = e.r(5296);
    function c(e, t) {
      return Object.assign(e, t);
    }
    class d extends o.InstrumentationBase {
      constructor(e = {}) {
        super(a.PACKAGE_NAME, a.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new o.InstrumentationNodeModuleDefinition(
            'fs',
            ['*'],
            (e) => {
              for (let t of s.SYNC_FUNCTIONS) {
                let { objectToPatch: n, functionNameToPatch: r } = (0, l.indexFs)(e, t);
                ((0, o.isWrapped)(n[r]) && this._unwrap(n, r),
                  this._wrap(n, r, this._patchSyncFunction.bind(this, t)));
              }
              for (let t of s.CALLBACK_FUNCTIONS) {
                let { objectToPatch: n, functionNameToPatch: r } = (0, l.indexFs)(e, t);
                if (((0, o.isWrapped)(n[r]) && this._unwrap(n, r), 'exists' === t)) {
                  this._wrap(n, r, this._patchExistsCallbackFunction.bind(this, t));
                  continue;
                }
                this._wrap(n, r, this._patchCallbackFunction.bind(this, t));
              }
              for (let t of s.PROMISE_FUNCTIONS)
                ((0, o.isWrapped)(e.promises[t]) && this._unwrap(e.promises, t),
                  this._wrap(e.promises, t, this._patchPromiseFunction.bind(this, t)));
              return e;
            },
            (e) => {
              if (void 0 !== e) {
                for (let t of s.SYNC_FUNCTIONS) {
                  let { objectToPatch: n, functionNameToPatch: r } = (0, l.indexFs)(e, t);
                  (0, o.isWrapped)(n[r]) && this._unwrap(n, r);
                }
                for (let t of s.CALLBACK_FUNCTIONS) {
                  let { objectToPatch: n, functionNameToPatch: r } = (0, l.indexFs)(e, t);
                  (0, o.isWrapped)(n[r]) && this._unwrap(n, r);
                }
                for (let t of s.PROMISE_FUNCTIONS)
                  (0, o.isWrapped)(e.promises[t]) && this._unwrap(e.promises, t);
              }
            }
          ),
          new o.InstrumentationNodeModuleDefinition(
            'fs/promises',
            ['*'],
            (e) => {
              for (let t of s.PROMISE_FUNCTIONS)
                ((0, o.isWrapped)(e[t]) && this._unwrap(e, t),
                  this._wrap(e, t, this._patchPromiseFunction.bind(this, t)));
              return e;
            },
            (e) => {
              if (void 0 !== e)
                for (let t of s.PROMISE_FUNCTIONS) (0, o.isWrapped)(e[t]) && this._unwrap(e, t);
            }
          ),
        ];
      }
      _patchSyncFunction(e, t) {
        let n = this;
        return c(function (...o) {
          let a = r.context.active();
          if (!n._shouldTrace(a)) return t.apply(this, o);
          if (!1 === n._runCreateHook(e, { args: o }))
            return r.context.with((0, i.suppressTracing)(a), t, this, ...o);
          let s = n.tracer.startSpan(`fs ${e}`);
          try {
            let u = r.context.with((0, i.suppressTracing)(r.trace.setSpan(a, s)), t, this, ...o);
            return (n._runEndHook(e, { args: o, span: s }), u);
          } catch (t) {
            throw (
              s.recordException(t),
              s.setStatus({ message: t.message, code: r.SpanStatusCode.ERROR }),
              n._runEndHook(e, { args: o, span: s, error: t }),
              t
            );
          } finally {
            s.end();
          }
        }, t);
      }
      _patchCallbackFunction(e, t) {
        let n = this;
        return c(function (...o) {
          let a = r.context.active();
          if (!n._shouldTrace(a)) return t.apply(this, o);
          if (!1 === n._runCreateHook(e, { args: o }))
            return r.context.with((0, i.suppressTracing)(a), t, this, ...o);
          let s = o.length - 1,
            u = o[s];
          if ('function' != typeof u) return t.apply(this, o);
          {
            let l = n.tracer.startSpan(`fs ${e}`);
            o[s] = r.context.bind(a, function (t) {
              return (
                t &&
                  (l.recordException(t),
                  l.setStatus({ message: t.message, code: r.SpanStatusCode.ERROR })),
                n._runEndHook(e, { args: o, span: l, error: t }),
                l.end(),
                u.apply(this, arguments)
              );
            });
            try {
              return r.context.with((0, i.suppressTracing)(r.trace.setSpan(a, l)), t, this, ...o);
            } catch (t) {
              throw (
                l.recordException(t),
                l.setStatus({ message: t.message, code: r.SpanStatusCode.ERROR }),
                n._runEndHook(e, { args: o, span: l, error: t }),
                l.end(),
                t
              );
            }
          }
        }, t);
      }
      _patchExistsCallbackFunction(e, t) {
        let n = this,
          o = c(function (...o) {
            let a = r.context.active();
            if (!n._shouldTrace(a)) return t.apply(this, o);
            if (!1 === n._runCreateHook(e, { args: o }))
              return r.context.with((0, i.suppressTracing)(a), t, this, ...o);
            let s = o.length - 1,
              u = o[s];
            if ('function' != typeof u) return t.apply(this, o);
            {
              let l = n.tracer.startSpan(`fs ${e}`);
              o[s] = r.context.bind(a, function () {
                return (n._runEndHook(e, { args: o, span: l }), l.end(), u.apply(this, arguments));
              });
              try {
                return r.context.with((0, i.suppressTracing)(r.trace.setSpan(a, l)), t, this, ...o);
              } catch (t) {
                throw (
                  l.recordException(t),
                  l.setStatus({ message: t.message, code: r.SpanStatusCode.ERROR }),
                  n._runEndHook(e, { args: o, span: l, error: t }),
                  l.end(),
                  t
                );
              }
            }
          }, t),
          a = function (e) {
            return new Promise((t) => o(e, t));
          };
        return (
          Object.defineProperty(a, 'name', { value: e }),
          Object.defineProperty(o, u.promisify.custom, { value: a }),
          o
        );
      }
      _patchPromiseFunction(e, t) {
        let n = this;
        return c(async function (...o) {
          let a = r.context.active();
          if (!n._shouldTrace(a)) return t.apply(this, o);
          if (!1 === n._runCreateHook(e, { args: o }))
            return r.context.with((0, i.suppressTracing)(a), t, this, ...o);
          let s = n.tracer.startSpan(`fs ${e}`);
          try {
            let u = await r.context.with(
              (0, i.suppressTracing)(r.trace.setSpan(a, s)),
              t,
              this,
              ...o
            );
            return (n._runEndHook(e, { args: o, span: s }), u);
          } catch (t) {
            throw (
              s.recordException(t),
              s.setStatus({ message: t.message, code: r.SpanStatusCode.ERROR }),
              n._runEndHook(e, { args: o, span: s, error: t }),
              t
            );
          } finally {
            s.end();
          }
        }, t);
      }
      _runCreateHook(...e) {
        let { createHook: t } = this.getConfig();
        if ('function' == typeof t)
          try {
            return t(...e);
          } catch (e) {
            this._diag.error('caught createHook error', e);
          }
        return !0;
      }
      _runEndHook(...e) {
        let { endHook: t } = this.getConfig();
        if ('function' == typeof t)
          try {
            t(...e);
          } catch (e) {
            this._diag.error('caught endHook error', e);
          }
      }
      _shouldTrace(e) {
        if ((0, i.isTracingSuppressed)(e)) return !1;
        let { requireParentSpan: t } = this.getConfig();
        return (!t || null != r.trace.getSpan(e)) && !0;
      }
    }
    n.FsInstrumentation = d;
  },
  70336,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.FsInstrumentation = void 0));
    var r = e.r(13994);
    Object.defineProperty(n, 'FsInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.FsInstrumentation;
      },
    });
  },
  64631,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(70336),
      i = e.r(48009),
      o = e.r(15527),
      a = 'FileSystem',
      s = i.defineIntegration((e = {}) => ({
        name: a,
        setupOnce() {
          o.generateInstrumentOnce(
            a,
            () =>
              new r.FsInstrumentation({
                requireParentSpan: !0,
                endHook(t, { args: n, span: r, error: o }) {
                  (r.updateName(`fs.${t}`),
                    r.setAttributes({
                      [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'file',
                      [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.file.fs',
                    }),
                    e.recordErrorMessagesAsSpanAttributes &&
                      ('string' == typeof n[0] && _.includes(t)
                        ? r.setAttribute('path_argument', n[0])
                        : 'string' == typeof n[0] && 'string' == typeof n[1] && p.includes(t)
                          ? (r.setAttribute('target_argument', n[0]),
                            r.setAttribute('path_argument', n[1]))
                          : 'string' == typeof n[0] && d.includes(t)
                            ? r.setAttribute('prefix_argument', n[0])
                            : 'string' == typeof n[0] && 'string' == typeof n[1] && c.includes(t)
                              ? (r.setAttribute('existing_path_argument', n[0]),
                                r.setAttribute('new_path_argument', n[1]))
                              : 'string' == typeof n[0] && 'string' == typeof n[1] && l.includes(t)
                                ? (r.setAttribute('src_argument', n[0]),
                                  r.setAttribute('dest_argument', n[1]))
                                : 'string' == typeof n[0] &&
                                  'string' == typeof n[1] &&
                                  u.includes(t) &&
                                  (r.setAttribute('old_path_argument', n[0]),
                                  r.setAttribute('new_path_argument', n[1]))),
                    o &&
                      e.recordErrorMessagesAsSpanAttributes &&
                      r.setAttribute('fs_error', o.message));
                },
              })
          )();
        },
      })),
      u = ['rename', 'renameSync'],
      l = ['copyFile', 'cp', 'copyFileSync', 'cpSync'],
      c = ['link', 'linkSync'],
      d = ['mkdtemp', 'mkdtempSync'],
      p = ['symlink', 'symlinkSync'],
      _ = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'exists',
        'mkdir',
        'lchown',
        'lstat',
        'lutimes',
        'open',
        'opendir',
        'readdir',
        'readFile',
        'readlink',
        'realpath',
        'realpath.native',
        'rm',
        'rmdir',
        'stat',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
        'accessSync',
        'appendFileSync',
        'chmodSync',
        'chownSync',
        'existsSync',
        'lchownSync',
        'lstatSync',
        'lutimesSync',
        'opendirSync',
        'mkdirSync',
        'openSync',
        'readdirSync',
        'readFileSync',
        'readlinkSync',
        'realpathSync',
        'realpathSync.native',
        'rmdirSync',
        'rmSync',
        'statSync',
        'truncateSync',
        'unlinkSync',
        'utimesSync',
        'writeFileSync',
      ];
    n.fsIntegration = s;
  },
  15099,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ExpressLayerType = void 0),
      (function (e) {
        ((e.ROUTER = 'router'),
          (e.MIDDLEWARE = 'middleware'),
          (e.REQUEST_HANDLER = 'request_handler'));
      })(n.ExpressLayerType || (n.ExpressLayerType = {})));
  },
  50807,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.EXPRESS_TYPE = 'express.type'), (e.EXPRESS_NAME = 'express.name'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  89688,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n._LAYERS_STORE_PROPERTY = n.kLayerPatched = void 0),
      (n.kLayerPatched = Symbol('express-layer-patched')),
      (n._LAYERS_STORE_PROPERTY = '__ot_middlewares'));
  },
  80304,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.getActualMatchedRoute =
        n.getConstructedRoute =
        n.getLayerPath =
        n.asErrorAndMessage =
        n.isLayerIgnored =
        n.getLayerMetadata =
        n.getRouterPath =
        n.storeLayerPath =
          void 0));
    let r = e.r(15099),
      i = e.r(50807),
      o = e.r(89688);
    ((n.storeLayerPath = (e, t) =>
      (!1 === Array.isArray(e[o._LAYERS_STORE_PROPERTY]) &&
        Object.defineProperty(e, o._LAYERS_STORE_PROPERTY, { enumerable: !1, value: [] }),
      void 0 === t)
        ? { isLayerPathStored: !1 }
        : (e[o._LAYERS_STORE_PROPERTY].push(t), { isLayerPathStored: !0 })),
      (n.getRouterPath = (e, t) => {
        let r = t.handle?.stack?.[0];
        return r?.route?.path
          ? `${e}${r.route.path}`
          : r?.handle?.stack
            ? (0, n.getRouterPath)(e, r)
            : e;
      }),
      (n.getLayerMetadata = (e, t, o) => {
        if ('router' === t.name) {
          let a = (0, n.getRouterPath)('', t) || o || e || '/';
          return {
            attributes: {
              [i.AttributeNames.EXPRESS_NAME]: a,
              [i.AttributeNames.EXPRESS_TYPE]: r.ExpressLayerType.ROUTER,
            },
            name: `router - ${a}`,
          };
        }
        return 'bound dispatch' === t.name || 'handle' === t.name
          ? {
              attributes: {
                [i.AttributeNames.EXPRESS_NAME]: (e || o) ?? 'request handler',
                [i.AttributeNames.EXPRESS_TYPE]: r.ExpressLayerType.REQUEST_HANDLER,
              },
              name: `request handler${t.path ? ` - ${e || o}` : ''}`,
            }
          : {
              attributes: {
                [i.AttributeNames.EXPRESS_NAME]: t.name,
                [i.AttributeNames.EXPRESS_TYPE]: r.ExpressLayerType.MIDDLEWARE,
              },
              name: `middleware - ${t.name}`,
            };
      }));
    let a = (e, t) => {
      if ('string' == typeof t) return t === e;
      if (t instanceof RegExp) return t.test(e);
      if ('function' == typeof t) return t(e);
      throw TypeError('Pattern is in unsupported datatype');
    };
    ((n.isLayerIgnored = (e, t, n) => {
      if (Array.isArray(n?.ignoreLayersType) && n?.ignoreLayersType?.includes(t)) return !0;
      if (!1 === Array.isArray(n?.ignoreLayers)) return !1;
      try {
        for (let t of n.ignoreLayers) if (a(e, t)) return !0;
      } catch (e) {}
      return !1;
    }),
      (n.asErrorAndMessage = (e) => (e instanceof Error ? [e, e.message] : [String(e), String(e)])),
      (n.getLayerPath = (e) => {
        let t = e[0];
        return Array.isArray(t) ? t.map((e) => s(e) || '').join(',') : s(t);
      }));
    let s = (e) =>
      'string' == typeof e
        ? e
        : e instanceof RegExp || 'number' == typeof e
          ? e.toString()
          : void 0;
    function u(e) {
      let t = (
        Array.isArray(e[o._LAYERS_STORE_PROPERTY]) ? e[o._LAYERS_STORE_PROPERTY] : []
      ).filter((e) => '/' !== e && '/*' !== e);
      return 1 === t.length && '*' === t[0] ? '*' : t.join('').replace(/\/{2,}/g, '/');
    }
    ((n.getConstructedRoute = u),
      (n.getActualMatchedRoute = function (e) {
        var t;
        let n = Array.isArray(e[o._LAYERS_STORE_PROPERTY]) ? e[o._LAYERS_STORE_PROPERTY] : [];
        if (0 === n.length) return;
        if (n.every((e) => '/' === e)) return '/' === e.originalUrl ? '/' : void 0;
        let r = u(e);
        if (
          '*' === r ||
          (r.includes('/') &&
            (r.includes(',') || r.includes('\\') || r.includes('*') || r.includes('[')))
        )
          return r;
        let i = r.startsWith('/') ? r : `/${r}`;
        return i.length > 0 &&
          (e.originalUrl === i ||
            e.originalUrl.startsWith(i) ||
            (t = i).includes(':') ||
            t.includes('*'))
          ? i
          : void 0;
      }));
  },
  59388,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.52.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-express'));
  },
  94913,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ExpressInstrumentation = void 0));
    let r = e.r(88540),
      i = e.r(52305),
      o = e.r(15099),
      a = e.r(50807),
      s = e.r(80304),
      u = e.r(59388),
      l = e.r(75235),
      c = e.r(81964),
      d = e.r(89688);
    class p extends l.InstrumentationBase {
      constructor(e = {}) {
        super(u.PACKAGE_NAME, u.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new l.InstrumentationNodeModuleDefinition(
            'express',
            ['>=4.0.0 <6'],
            (e) => {
              let t = 'function' == typeof e?.Router?.prototype?.route,
                n = t ? e.Router.prototype : e.Router;
              return (
                (0, l.isWrapped)(n.route) && this._unwrap(n, 'route'),
                this._wrap(n, 'route', this._getRoutePatch()),
                (0, l.isWrapped)(n.use) && this._unwrap(n, 'use'),
                this._wrap(n, 'use', this._getRouterUsePatch()),
                (0, l.isWrapped)(e.application.use) && this._unwrap(e.application, 'use'),
                this._wrap(e.application, 'use', this._getAppUsePatch(t)),
                e
              );
            },
            (e) => {
              if (void 0 === e) return;
              let t =
                'function' == typeof e?.Router?.prototype?.route ? e.Router.prototype : e.Router;
              (this._unwrap(t, 'route'),
                this._unwrap(t, 'use'),
                this._unwrap(e.application, 'use'));
            }
          ),
        ];
      }
      _getRoutePatch() {
        let e = this;
        return function (t) {
          return function (...n) {
            let r = t.apply(this, n),
              i = this.stack[this.stack.length - 1];
            return (e._applyPatch(i, (0, s.getLayerPath)(n)), r);
          };
        };
      }
      _getRouterUsePatch() {
        let e = this;
        return function (t) {
          return function (...n) {
            let r = t.apply(this, n),
              i = this.stack[this.stack.length - 1];
            return (e._applyPatch(i, (0, s.getLayerPath)(n)), r);
          };
        };
      }
      _getAppUsePatch(e) {
        let t = this;
        return function (n) {
          return function (...r) {
            let i = e ? this.router : this._router,
              o = n.apply(this, r);
            if (i) {
              let e = i.stack[i.stack.length - 1];
              t._applyPatch(e, (0, s.getLayerPath)(r));
            }
            return o;
          };
        };
      }
      _applyPatch(e, t) {
        let n = this;
        !0 !== e[d.kLayerPatched] &&
          ((e[d.kLayerPatched] = !0),
          this._wrap(e, 'handle', (u) => {
            if (4 === u.length) return u;
            let p = function (p, _) {
              let { isLayerPathStored: S } = (0, s.storeLayerPath)(p, t),
                E = (0, s.getConstructedRoute)(p),
                T = (0, s.getActualMatchedRoute)(p),
                m = { [c.ATTR_HTTP_ROUTE]: T },
                g = (0, s.getLayerMetadata)(E, e, t),
                f = g.attributes[a.AttributeNames.EXPRESS_TYPE],
                h = (0, r.getRPCMetadata)(i.context.active());
              if (
                (h?.type === r.RPCType.HTTP && (h.route = T),
                (0, s.isLayerIgnored)(g.name, f, n.getConfig()))
              )
                return (
                  f === o.ExpressLayerType.MIDDLEWARE && p[d._LAYERS_STORE_PROPERTY].pop(),
                  u.apply(this, arguments)
                );
              if (void 0 === i.trace.getSpan(i.context.active())) return u.apply(this, arguments);
              let A = n._getSpanName({ request: p, layerType: f, route: E }, g.name),
                R = n.tracer.startSpan(A, { attributes: Object.assign(m, g.attributes) }),
                y = i.context.active(),
                I = i.trace.setSpan(y, R),
                { requestHook: b } = n.getConfig();
              b &&
                (0, l.safeExecuteInTheMiddle)(
                  () => b(R, { request: p, layerType: f, route: E }),
                  (e) => {
                    e && i.diag.error('express instrumentation: request hook failed', e);
                  },
                  !0
                );
              let N = !1;
              g.attributes[a.AttributeNames.EXPRESS_TYPE] === o.ExpressLayerType.ROUTER &&
                (R.end(), (N = !0), (I = y));
              let O = () => {
                  !1 === N && ((N = !0), R.end());
                },
                v = Array.from(arguments),
                C = v.findIndex((e) => 'function' == typeof e);
              C >= 0 &&
                (arguments[C] = function () {
                  let e = arguments[0],
                    t = ![void 0, null, 'route', 'router'].includes(e);
                  if (!N && t) {
                    let [t, n] = (0, s.asErrorAndMessage)(e);
                    (R.recordException(t),
                      R.setStatus({ code: i.SpanStatusCode.ERROR, message: n }));
                  }
                  (!1 === N && ((N = !0), p.res?.removeListener('finish', O), R.end()),
                    !(p.route && t) && S && p[d._LAYERS_STORE_PROPERTY].pop());
                  let n = v[C];
                  return i.context.bind(y, n).apply(this, arguments);
                });
              try {
                return i.context.bind(I, u).apply(this, arguments);
              } catch (n) {
                let [e, t] = (0, s.asErrorAndMessage)(n);
                throw (
                  R.recordException(e),
                  R.setStatus({ code: i.SpanStatusCode.ERROR, message: t }),
                  n
                );
              } finally {
                N || _.once('finish', O);
              }
            };
            for (let e in u)
              Object.defineProperty(p, e, {
                get: () => u[e],
                set(t) {
                  u[e] = t;
                },
              });
            return p;
          }));
      }
      _getSpanName(e, t) {
        let { spanNameHook: n } = this.getConfig();
        if (!(n instanceof Function)) return t;
        try {
          return n(e, t) ?? t;
        } catch (e) {
          return (
            i.diag.error('express instrumentation: error calling span name rewrite hook', e),
            t
          );
        }
      }
    }
    n.ExpressInstrumentation = p;
  },
  10578,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = n.ExpressLayerType = n.ExpressInstrumentation = void 0));
    var r = e.r(94913);
    Object.defineProperty(n, 'ExpressInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.ExpressInstrumentation;
      },
    });
    var i = e.r(15099);
    Object.defineProperty(n, 'ExpressLayerType', {
      enumerable: !0,
      get: function () {
        return i.ExpressLayerType;
      },
    });
    var o = e.r(50807);
    Object.defineProperty(n, 'AttributeNames', {
      enumerable: !0,
      get: function () {
        return o.AttributeNames;
      },
    });
  },
  59589,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEBUG_BUILD = 'undefined' == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__));
  },
  50219,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(10578),
      i = e.r(48009),
      o = e.r(15527),
      a = e.r(59589),
      s = 'Express',
      u = o.generateInstrumentOnce(
        s,
        () =>
          new r.ExpressInstrumentation({
            requestHook: (e) =>
              (function (e) {
                o.addOriginToSpan(e, 'auto.http.otel.express');
                let t = i.spanToJSON(e).data,
                  n = t['express.type'];
                n && e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_OP, `${n}.express`);
                let r = t['express.name'];
                'string' == typeof r && e.updateName(r);
              })(e),
            spanNameHook: (e, t) =>
              (function (e, t) {
                if (i.getIsolationScope() === i.getDefaultIsolationScope())
                  return (
                    a.DEBUG_BUILD &&
                      i.debug.warn(
                        'Isolation scope is still default isolation scope - skipping setting transactionName'
                      ),
                    t
                  );
                if ('request_handler' === e.layerType) {
                  let t = e.request,
                    n = t.method ? t.method.toUpperCase() : 'GET';
                  i.getIsolationScope().setTransactionName(`${n} ${e.route}`);
                }
                return t;
              })(e, t),
          })
      ),
      l = i.defineIntegration(() => ({
        name: s,
        setupOnce() {
          u();
        },
      }));
    function c(e) {
      return function (t, n, r, o) {
        let a = i.httpRequestToRequestData(n);
        (i.getIsolationScope().setSDKProcessingMetadata({ normalizedRequest: a }),
          (
            e?.shouldHandleError ||
            function (e) {
              return (
                (function (e) {
                  let t = e.status || e.statusCode || e.status_code || e.output?.statusCode;
                  return t ? parseInt(t, 10) : 500;
                })(e) >= 500
              );
            }
          )(t) &&
            (r.sentry = i.captureException(t, { mechanism: { type: 'middleware', handled: !1 } })),
          o(t));
      };
    }
    ((n.expressErrorHandler = c),
      (n.expressIntegration = l),
      (n.instrumentExpress = u),
      (n.setupExpressErrorHandler = function (e, t) {
        (e.use(function (e, t, n) {
          let r = i.httpRequestToRequestData(e);
          (i.getIsolationScope().setSDKProcessingMetadata({ normalizedRequest: r }), n());
        }),
          e.use(c(t)),
          o.ensureIsWrapped(e.use, 'express'));
      }));
  },
  82754,
  (e, t, n) => {
    'use strict';
    function r(e, t, n) {
      (e instanceof RegExp && (e = i(e, n)), t instanceof RegExp && (t = i(t, n)));
      var r = o(e, t, n);
      return (
        r && {
          start: r[0],
          end: r[1],
          pre: n.slice(0, r[0]),
          body: n.slice(r[0] + e.length, r[1]),
          post: n.slice(r[1] + t.length),
        }
      );
    }
    function i(e, t) {
      var n = t.match(e);
      return n ? n[0] : null;
    }
    function o(e, t, n) {
      var r,
        i,
        o,
        a,
        s,
        u = n.indexOf(e),
        l = n.indexOf(t, u + 1),
        c = u;
      if (u >= 0 && l > 0) {
        if (e === t) return [u, l];
        for (r = [], o = n.length; c >= 0 && !s; )
          (c == u
            ? (r.push(c), (u = n.indexOf(e, c + 1)))
            : 1 == r.length
              ? (s = [r.pop(), l])
              : ((i = r.pop()) < o && ((o = i), (a = l)), (l = n.indexOf(t, c + 1))),
            (c = u < l && u >= 0 ? u : l));
        r.length && (s = [o, a]);
      }
      return s;
    }
    ((t.exports = r), (r.range = o));
  },
  41169,
  (e, t, n) => {
    var r = e.r(82754);
    t.exports = function (e) {
      return e
        ? ('{}' === e.substr(0, 2) && (e = '\\{\\}' + e.substr(2)),
          (function e(t, n) {
            var i = [],
              o = r('{', '}', t);
            if (!o) return [t];
            var s = o.pre,
              u = o.post.length ? e(o.post, !1) : [''];
            if (/\$$/.test(o.pre))
              for (var c = 0; c < u.length; c++) {
                var E = s + '{' + o.body + '}' + u[c];
                i.push(E);
              }
            else {
              var T = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(o.body),
                m = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(o.body),
                g = T || m,
                f = o.body.indexOf(',') >= 0;
              if (!g && !f)
                return o.post.match(/,(?!,).*\}/)
                  ? e((t = o.pre + '{' + o.body + a + o.post))
                  : [t];
              if (g) h = o.body.split(/\.\./);
              else if (
                1 ===
                  (h = (function e(t) {
                    if (!t) return [''];
                    var n = [],
                      i = r('{', '}', t);
                    if (!i) return t.split(',');
                    var o = i.pre,
                      a = i.body,
                      s = i.post,
                      u = o.split(',');
                    u[u.length - 1] += '{' + a + '}';
                    var l = e(s);
                    return (
                      s.length && ((u[u.length - 1] += l.shift()), u.push.apply(u, l)),
                      n.push.apply(n, u),
                      n
                    );
                  })(o.body)).length &&
                1 === (h = e(h[0], !1).map(d)).length
              )
                return u.map(function (e) {
                  return o.pre + h[0] + e;
                });
              if (g) {
                var h,
                  A,
                  R,
                  y = l(h[0]),
                  I = l(h[1]),
                  b = Math.max(h[0].length, h[1].length),
                  N = 3 == h.length ? Math.abs(l(h[2])) : 1,
                  O = _;
                I < y && ((N *= -1), (O = S));
                var v = h.some(p);
                A = [];
                for (var C = y; O(C, I); C += N) {
                  if (m) '\\' === (R = String.fromCharCode(C)) && (R = '');
                  else if (((R = String(C)), v)) {
                    var P = b - R.length;
                    if (P > 0) {
                      var M = Array(P + 1).join('0');
                      R = C < 0 ? '-' + M + R.slice(1) : M + R;
                    }
                  }
                  A.push(R);
                }
              } else {
                A = [];
                for (var L = 0; L < h.length; L++) A.push.apply(A, e(h[L], !1));
              }
              for (var L = 0; L < A.length; L++)
                for (var c = 0; c < u.length; c++) {
                  var E = s + A[L] + u[c];
                  (!n || g || E) && i.push(E);
                }
            }
            return i;
          })(
            e
              .split('\\\\')
              .join(i)
              .split('\\{')
              .join(o)
              .split('\\}')
              .join(a)
              .split('\\,')
              .join(s)
              .split('\\.')
              .join(u),
            !0
          ).map(c))
        : [];
    };
    var i = '\0SLASH' + Math.random() + '\0',
      o = '\0OPEN' + Math.random() + '\0',
      a = '\0CLOSE' + Math.random() + '\0',
      s = '\0COMMA' + Math.random() + '\0',
      u = '\0PERIOD' + Math.random() + '\0';
    function l(e) {
      return parseInt(e, 10) == e ? parseInt(e, 10) : e.charCodeAt(0);
    }
    function c(e) {
      return e
        .split(i)
        .join('\\')
        .split(o)
        .join('{')
        .split(a)
        .join('}')
        .split(s)
        .join(',')
        .split(u)
        .join('.');
    }
    function d(e) {
      return '{' + e + '}';
    }
    function p(e) {
      return /^-?0\d/.test(e);
    }
    function _(e, t) {
      return e <= t;
    }
    function S(e, t) {
      return e >= t;
    }
  },
  6883,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.assertValidPattern = void 0),
      (n.assertValidPattern = (e) => {
        if ('string' != typeof e) throw TypeError('invalid pattern');
        if (e.length > 65536) throw TypeError('pattern is too long');
      }));
  },
  4904,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.parseClass = void 0));
    let r = {
        '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', !0],
        '[:alpha:]': ['\\p{L}\\p{Nl}', !0],
        '[:ascii:]': ['\\x00-\\x7f', !1],
        '[:blank:]': ['\\p{Zs}\\t', !0],
        '[:cntrl:]': ['\\p{Cc}', !0],
        '[:digit:]': ['\\p{Nd}', !0],
        '[:graph:]': ['\\p{Z}\\p{C}', !0, !0],
        '[:lower:]': ['\\p{Ll}', !0],
        '[:print:]': ['\\p{C}', !0],
        '[:punct:]': ['\\p{P}', !0],
        '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', !0],
        '[:upper:]': ['\\p{Lu}', !0],
        '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', !0],
        '[:xdigit:]': ['A-Fa-f0-9', !1],
      },
      i = (e) => e.replace(/[[\]\\-]/g, '\\$&'),
      o = (e) => e.join('');
    n.parseClass = (e, t) => {
      if ('[' !== e.charAt(t)) throw Error('not in a brace expression');
      let n = [],
        a = [],
        s = t + 1,
        u = !1,
        l = !1,
        c = !1,
        d = !1,
        p = t,
        _ = '';
      e: for (; s < e.length; ) {
        let o = e.charAt(s);
        if (('!' === o || '^' === o) && s === t + 1) {
          ((d = !0), s++);
          continue;
        }
        if (']' === o && u && !c) {
          p = s + 1;
          break;
        }
        if (((u = !0), '\\' === o && !c)) {
          ((c = !0), s++);
          continue;
        }
        if ('[' === o && !c) {
          for (let [i, [o, u, c]] of Object.entries(r))
            if (e.startsWith(i, s)) {
              if (_) return ['$.', !1, e.length - t, !0];
              ((s += i.length), c ? a.push(o) : n.push(o), (l = l || u));
              continue e;
            }
        }
        if (((c = !1), _)) {
          (o > _ ? n.push(i(_) + '-' + i(o)) : o === _ && n.push(i(o)), (_ = ''), s++);
          continue;
        }
        if (e.startsWith('-]', s + 1)) {
          (n.push(i(o + '-')), (s += 2));
          continue;
        }
        if (e.startsWith('-', s + 1)) {
          ((_ = o), (s += 2));
          continue;
        }
        (n.push(i(o)), s++);
      }
      if (p < s) return ['', !1, 0, !1];
      if (!n.length && !a.length) return ['$.', !1, e.length - t, !0];
      if (0 === a.length && 1 === n.length && /^\\?.$/.test(n[0]) && !d)
        return [
          (2 === n[0].length ? n[0].slice(-1) : n[0]).replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'),
          !1,
          p - t,
          !1,
        ];
      let S = '[' + (d ? '^' : '') + o(n) + ']',
        E = '[' + (d ? '' : '^') + o(a) + ']';
      return [n.length && a.length ? '(' + S + '|' + E + ')' : n.length ? S : E, l, p - t, !0];
    };
  },
  18280,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.unescape = void 0),
      (n.unescape = (e, { windowsPathsNoEscape: t = !1 } = {}) =>
        t
          ? e.replace(/\[([^\/\\])\]/g, '$1')
          : e.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1')));
  },
  72851,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.AST = void 0));
    let r = e.r(4904),
      i = e.r(18280),
      o = new Set(['!', '?', '+', '*', '@']),
      a = (e) => o.has(e),
      s = '(?!\\.)',
      u = new Set(['[', '.']),
      l = new Set(['..', '.']),
      c = new Set('().*{}+?[]^$\\!'),
      d = (e) => e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'),
      p = '[^/]',
      _ = p + '*?',
      S = p + '+?';
    class E {
      type;
      #e;
      #t;
      #n = !1;
      #r = [];
      #i;
      #o;
      #a;
      #s = !1;
      #u;
      #l;
      #c = !1;
      constructor(e, t, n = {}) {
        ((this.type = e),
          e && (this.#t = !0),
          (this.#i = t),
          (this.#e = this.#i ? this.#i.#e : this),
          (this.#u = this.#e === this ? n : this.#e.#u),
          (this.#a = this.#e === this ? [] : this.#e.#a),
          '!' !== e || this.#e.#s || this.#a.push(this),
          (this.#o = this.#i ? this.#i.#r.length : 0));
      }
      get hasMagic() {
        if (void 0 !== this.#t) return this.#t;
        for (let e of this.#r)
          if ('string' != typeof e && (e.type || e.hasMagic)) return (this.#t = !0);
        return this.#t;
      }
      toString() {
        return void 0 !== this.#l
          ? this.#l
          : this.type
            ? (this.#l = this.type + '(' + this.#r.map((e) => String(e)).join('|') + ')')
            : (this.#l = this.#r.map((e) => String(e)).join(''));
      }
      #d() {
        let e;
        if (this !== this.#e) throw Error('should only call on root');
        if (this.#s) return this;
        for (this.toString(), this.#s = !0; (e = this.#a.pop()); ) {
          if ('!' !== e.type) continue;
          let t = e,
            n = t.#i;
          for (; n; ) {
            for (let r = t.#o + 1; !n.type && r < n.#r.length; r++)
              for (let t of e.#r) {
                if ('string' == typeof t) throw Error('string part in extglob AST??');
                t.copyIn(n.#r[r]);
              }
            n = (t = n).#i;
          }
        }
        return this;
      }
      push(...e) {
        for (let t of e)
          if ('' !== t) {
            if ('string' != typeof t && !(t instanceof E && t.#i === this))
              throw Error('invalid part: ' + t);
            this.#r.push(t);
          }
      }
      toJSON() {
        let e =
          null === this.type
            ? this.#r.slice().map((e) => ('string' == typeof e ? e : e.toJSON()))
            : [this.type, ...this.#r.map((e) => e.toJSON())];
        return (
          this.isStart() && !this.type && e.unshift([]),
          this.isEnd() && (this === this.#e || (this.#e.#s && this.#i?.type === '!')) && e.push({}),
          e
        );
      }
      isStart() {
        if (this.#e === this) return !0;
        if (!this.#i?.isStart()) return !1;
        if (0 === this.#o) return !0;
        let e = this.#i;
        for (let t = 0; t < this.#o; t++) {
          let n = e.#r[t];
          if (!(n instanceof E && '!' === n.type)) return !1;
        }
        return !0;
      }
      isEnd() {
        if (this.#e === this || this.#i?.type === '!') return !0;
        if (!this.#i?.isEnd()) return !1;
        if (!this.type) return this.#i?.isEnd();
        let e = this.#i ? this.#i.#r.length : 0;
        return this.#o === e - 1;
      }
      copyIn(e) {
        'string' == typeof e ? this.push(e) : this.push(e.clone(this));
      }
      clone(e) {
        let t = new E(this.type, e);
        for (let e of this.#r) t.copyIn(e);
        return t;
      }
      static #p(e, t, n, r) {
        let i = !1,
          o = !1,
          s = -1,
          u = !1;
        if (null === t.type) {
          let l = n,
            c = '';
          for (; l < e.length; ) {
            let n = e.charAt(l++);
            if (i || '\\' === n) {
              ((i = !i), (c += n));
              continue;
            }
            if (o) {
              (l === s + 1
                ? ('^' === n || '!' === n) && (u = !0)
                : ']' !== n || (l === s + 2 && u) || (o = !1),
                (c += n));
              continue;
            }
            if ('[' === n) {
              ((o = !0), (s = l), (u = !1), (c += n));
              continue;
            }
            if (!r.noext && a(n) && '(' === e.charAt(l)) {
              (t.push(c), (c = ''));
              let i = new E(n, t);
              ((l = E.#p(e, i, l, r)), t.push(i));
              continue;
            }
            c += n;
          }
          return (t.push(c), l);
        }
        let l = n + 1,
          c = new E(null, t),
          d = [],
          p = '';
        for (; l < e.length; ) {
          let n = e.charAt(l++);
          if (i || '\\' === n) {
            ((i = !i), (p += n));
            continue;
          }
          if (o) {
            (l === s + 1
              ? ('^' === n || '!' === n) && (u = !0)
              : ']' !== n || (l === s + 2 && u) || (o = !1),
              (p += n));
            continue;
          }
          if ('[' === n) {
            ((o = !0), (s = l), (u = !1), (p += n));
            continue;
          }
          if (a(n) && '(' === e.charAt(l)) {
            (c.push(p), (p = ''));
            let t = new E(n, c);
            (c.push(t), (l = E.#p(e, t, l, r)));
            continue;
          }
          if ('|' === n) {
            (c.push(p), (p = ''), d.push(c), (c = new E(null, t)));
            continue;
          }
          if (')' === n)
            return (
              '' === p && 0 === t.#r.length && (t.#c = !0),
              c.push(p),
              (p = ''),
              t.push(...d, c),
              l
            );
          p += n;
        }
        return ((t.type = null), (t.#t = void 0), (t.#r = [e.substring(n - 1)]), l);
      }
      static fromGlob(e, t = {}) {
        let n = new E(null, void 0, t);
        return (E.#p(e, n, 0, t), n);
      }
      toMMPattern() {
        if (this !== this.#e) return this.#e.toMMPattern();
        let e = this.toString(),
          [t, n, r, i] = this.toRegExpSource();
        return r ||
          this.#t ||
          (this.#u.nocase && !this.#u.nocaseMagicOnly && e.toUpperCase() !== e.toLowerCase())
          ? Object.assign(RegExp(`^${t}$`, (this.#u.nocase ? 'i' : '') + (i ? 'u' : '')), {
              _src: t,
              _glob: e,
            })
          : n;
      }
      get options() {
        return this.#u;
      }
      toRegExpSource(e) {
        let t = e ?? !!this.#u.dot;
        if ((this.#e === this && this.#d(), !this.type)) {
          let n = this.isStart() && this.isEnd(),
            r = this.#r
              .map((t) => {
                let [r, i, o, a] = 'string' == typeof t ? E.#_(t, this.#t, n) : t.toRegExpSource(e);
                return ((this.#t = this.#t || o), (this.#n = this.#n || a), r);
              })
              .join(''),
            o = '';
          if (
            this.isStart() &&
            'string' == typeof this.#r[0] &&
            !(1 === this.#r.length && l.has(this.#r[0]))
          ) {
            let n =
                (t && u.has(r.charAt(0))) ||
                (r.startsWith('\\.') && u.has(r.charAt(2))) ||
                (r.startsWith('\\.\\.') && u.has(r.charAt(4))),
              i = !t && !e && u.has(r.charAt(0));
            o = n ? '(?!(?:^|/)\\.\\.?(?:$|/))' : i ? s : '';
          }
          let a = '';
          return (
            this.isEnd() && this.#e.#s && this.#i?.type === '!' && (a = '(?:$|\\/)'),
            [o + r + a, (0, i.unescape)(r), (this.#t = !!this.#t), this.#n]
          );
        }
        let n = '*' === this.type || '+' === this.type,
          r = '!' === this.type ? '(?:(?!(?:' : '(?:',
          o = this.#S(t);
        if (this.isStart() && this.isEnd() && !o && '!' !== this.type) {
          let e = this.toString();
          return (
            (this.#r = [e]),
            (this.type = null),
            (this.#t = void 0),
            [e, (0, i.unescape)(this.toString()), !1, !1]
          );
        }
        let a = !n || e || t || !s ? '' : this.#S(!0);
        (a === o && (a = ''), a && (o = `(?:${o})(?:${a})*?`));
        return [
          '!' === this.type && this.#c
            ? (this.isStart() && !t ? s : '') + S
            : r +
              o +
              ('!' === this.type
                ? '))' + (!this.isStart() || t || e ? '' : s) + _ + ')'
                : '@' === this.type
                  ? ')'
                  : '?' === this.type
                    ? ')?'
                    : '+' === this.type && a
                      ? ')'
                      : '*' === this.type && a
                        ? ')?'
                        : `)${this.type}`),
          (0, i.unescape)(o),
          (this.#t = !!this.#t),
          this.#n,
        ];
      }
      #S(e) {
        return this.#r
          .map((t) => {
            if ('string' == typeof t) throw Error('string type in extglob ast??');
            let [n, r, i, o] = t.toRegExpSource(e);
            return ((this.#n = this.#n || o), n);
          })
          .filter((e) => !(this.isStart() && this.isEnd()) || !!e)
          .join('|');
      }
      static #_(e, t, n = !1) {
        let o = !1,
          a = '',
          s = !1;
        for (let i = 0; i < e.length; i++) {
          let u = e.charAt(i);
          if (o) {
            ((o = !1), (a += (c.has(u) ? '\\' : '') + u));
            continue;
          }
          if ('\\' === u) {
            i === e.length - 1 ? (a += '\\\\') : (o = !0);
            continue;
          }
          if ('[' === u) {
            let [n, o, u, l] = (0, r.parseClass)(e, i);
            if (u) {
              ((a += n), (s = s || o), (i += u - 1), (t = t || l));
              continue;
            }
          }
          if ('*' === u) {
            (n && '*' === e ? (a += S) : (a += _), (t = !0));
            continue;
          }
          if ('?' === u) {
            ((a += p), (t = !0));
            continue;
          }
          a += d(u);
        }
        return [a, (0, i.unescape)(e), !!t, s];
      }
    }
    n.AST = E;
  },
  88460,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.escape = void 0),
      (n.escape = (e, { windowsPathsNoEscape: t = !1 } = {}) =>
        t ? e.replace(/[?*()[\]]/g, '[$&]') : e.replace(/[?*()[\]\\]/g, '\\$&')));
  },
  40484,
  (e, t, n) => {
    'use strict';
    var r =
      (e.e && e.e.__importDefault) ||
      function (e) {
        return e && e.__esModule ? e : { default: e };
      };
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.unescape =
        n.escape =
        n.AST =
        n.Minimatch =
        n.match =
        n.makeRe =
        n.braceExpand =
        n.defaults =
        n.filter =
        n.GLOBSTAR =
        n.sep =
        n.minimatch =
          void 0));
    let i = r(e.r(41169)),
      o = e.r(6883),
      a = e.r(72851),
      s = e.r(88460),
      u = e.r(18280);
    n.minimatch = (e, t, n = {}) => (
      (0, o.assertValidPattern)(t),
      (!!n.nocomment || '#' !== t.charAt(0)) && new b(t, n).match(e)
    );
    let l = /^\*+([^+@!?\*\[\(]*)$/,
      c = /^\*+\.\*+$/,
      d = (e) => !e.startsWith('.') && e.includes('.'),
      p = (e) => '.' !== e && '..' !== e && e.includes('.'),
      _ = /^\.\*+$/,
      S = (e) => '.' !== e && '..' !== e && e.startsWith('.'),
      E = /^\*+$/,
      T = (e) => 0 !== e.length && !e.startsWith('.'),
      m = (e) => 0 !== e.length && '.' !== e && '..' !== e,
      g = /^\?+([^+@!?\*\[\(]*)?$/,
      f = ([e]) => {
        let t = e.length;
        return (e) => e.length === t && !e.startsWith('.');
      },
      h = ([e]) => {
        let t = e.length;
        return (e) => e.length === t && '.' !== e && '..' !== e;
      },
      A =
        'object' == typeof process && process
          ? ('object' == typeof process.env &&
              process.env &&
              process.env.__MINIMATCH_TESTING_PLATFORM__) ||
            process.platform
          : 'posix',
      R = { win32: { sep: '\\' }, posix: { sep: '/' } };
    ((n.sep = 'win32' === A ? R.win32.sep : R.posix.sep),
      (n.minimatch.sep = n.sep),
      (n.GLOBSTAR = Symbol('globstar **')),
      (n.minimatch.GLOBSTAR = n.GLOBSTAR));
    ((n.filter =
      (e, t = {}) =>
      (r) =>
        (0, n.minimatch)(r, e, t)),
      (n.minimatch.filter = n.filter));
    let y = (e, t = {}) => Object.assign({}, e, t);
    ((n.defaults = (e) => {
      if (!e || 'object' != typeof e || !Object.keys(e).length) return n.minimatch;
      let t = n.minimatch;
      return Object.assign((n, r, i = {}) => t(n, r, y(e, i)), {
        Minimatch: class extends t.Minimatch {
          constructor(t, n = {}) {
            super(t, y(e, n));
          }
          static defaults(n) {
            return t.defaults(y(e, n)).Minimatch;
          }
        },
        AST: class extends t.AST {
          constructor(t, n, r = {}) {
            super(t, n, y(e, r));
          }
          static fromGlob(n, r = {}) {
            return t.AST.fromGlob(n, y(e, r));
          }
        },
        unescape: (n, r = {}) => t.unescape(n, y(e, r)),
        escape: (n, r = {}) => t.escape(n, y(e, r)),
        filter: (n, r = {}) => t.filter(n, y(e, r)),
        defaults: (n) => t.defaults(y(e, n)),
        makeRe: (n, r = {}) => t.makeRe(n, y(e, r)),
        braceExpand: (n, r = {}) => t.braceExpand(n, y(e, r)),
        match: (n, r, i = {}) => t.match(n, r, y(e, i)),
        sep: t.sep,
        GLOBSTAR: n.GLOBSTAR,
      });
    }),
      (n.minimatch.defaults = n.defaults),
      (n.braceExpand = (e, t = {}) =>
        ((0, o.assertValidPattern)(e), t.nobrace || !/\{(?:(?!\{).)*\}/.test(e))
          ? [e]
          : (0, i.default)(e)),
      (n.minimatch.braceExpand = n.braceExpand),
      (n.makeRe = (e, t = {}) => new b(e, t).makeRe()),
      (n.minimatch.makeRe = n.makeRe),
      (n.match = (e, t, n = {}) => {
        let r = new b(t, n);
        return ((e = e.filter((e) => r.match(e))), r.options.nonull && !e.length && e.push(t), e);
      }),
      (n.minimatch.match = n.match));
    let I = /[?*]|[+@!]\(.*?\)|\[|\]/;
    class b {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(e, t = {}) {
        ((0, o.assertValidPattern)(e),
          (t = t || {}),
          (this.options = t),
          (this.pattern = e),
          (this.platform = t.platform || A),
          (this.isWindows = 'win32' === this.platform),
          (this.windowsPathsNoEscape = !!t.windowsPathsNoEscape || !1 === t.allowWindowsEscape),
          this.windowsPathsNoEscape && (this.pattern = this.pattern.replace(/\\/g, '/')),
          (this.preserveMultipleSlashes = !!t.preserveMultipleSlashes),
          (this.regexp = null),
          (this.negate = !1),
          (this.nonegate = !!t.nonegate),
          (this.comment = !1),
          (this.empty = !1),
          (this.partial = !!t.partial),
          (this.nocase = !!this.options.nocase),
          (this.windowsNoMagicRoot =
            void 0 !== t.windowsNoMagicRoot
              ? t.windowsNoMagicRoot
              : !!(this.isWindows && this.nocase)),
          (this.globSet = []),
          (this.globParts = []),
          (this.set = []),
          this.make());
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) return !0;
        for (let e of this.set) for (let t of e) if ('string' != typeof t) return !0;
        return !1;
      }
      debug() {}
      make() {
        let e = this.pattern,
          t = this.options;
        if (!t.nocomment && '#' === e.charAt(0)) {
          this.comment = !0;
          return;
        }
        if (!e) {
          this.empty = !0;
          return;
        }
        (this.parseNegate(),
          (this.globSet = [...new Set(this.braceExpand())]),
          t.debug && (this.debug = (...e) => console.error(...e)),
          this.debug(this.pattern, this.globSet));
        let n = this.globSet.map((e) => this.slashSplit(e));
        ((this.globParts = this.preprocess(n)), this.debug(this.pattern, this.globParts));
        let r = this.globParts.map((e, t, n) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            let t = '' === e[0] && '' === e[1] && ('?' === e[2] || !I.test(e[2])) && !I.test(e[3]),
              n = /^[a-z]:/i.test(e[0]);
            if (t) return [...e.slice(0, 4), ...e.slice(4).map((e) => this.parse(e))];
            if (n) return [e[0], ...e.slice(1).map((e) => this.parse(e))];
          }
          return e.map((e) => this.parse(e));
        });
        if (
          (this.debug(this.pattern, r),
          (this.set = r.filter((e) => -1 === e.indexOf(!1))),
          this.isWindows)
        )
          for (let e = 0; e < this.set.length; e++) {
            let t = this.set[e];
            '' === t[0] &&
              '' === t[1] &&
              '?' === this.globParts[e][2] &&
              'string' == typeof t[3] &&
              /^[a-z]:$/i.test(t[3]) &&
              (t[2] = '?');
          }
        this.debug(this.pattern, this.set);
      }
      preprocess(e) {
        if (this.options.noglobstar)
          for (let t = 0; t < e.length; t++)
            for (let n = 0; n < e[t].length; n++) '**' === e[t][n] && (e[t][n] = '*');
        let { optimizationLevel: t = 1 } = this.options;
        return (
          t >= 2
            ? ((e = this.firstPhasePreProcess(e)), (e = this.secondPhasePreProcess(e)))
            : (e = t >= 1 ? this.levelOneOptimize(e) : this.adjascentGlobstarOptimize(e)),
          e
        );
      }
      adjascentGlobstarOptimize(e) {
        return e.map((e) => {
          let t = -1;
          for (; -1 !== (t = e.indexOf('**', t + 1)); ) {
            let n = t;
            for (; '**' === e[n + 1]; ) n++;
            n !== t && e.splice(t, n - t);
          }
          return e;
        });
      }
      levelOneOptimize(e) {
        return e.map((e) =>
          0 ===
          (e = e.reduce((e, t) => {
            let n = e[e.length - 1];
            return (
              ('**' === t && '**' === n) ||
                ('..' === t && n && '..' !== n && '.' !== n && '**' !== n ? e.pop() : e.push(t)),
              e
            );
          }, [])).length
            ? ['']
            : e
        );
      }
      levelTwoFileOptimize(e) {
        Array.isArray(e) || (e = this.slashSplit(e));
        let t = !1;
        do {
          if (((t = !1), !this.preserveMultipleSlashes)) {
            for (let n = 1; n < e.length - 1; n++) {
              let r = e[n];
              (1 !== n || '' !== r || '' !== e[0]) &&
                ('.' === r || '' === r) &&
                ((t = !0), e.splice(n, 1), n--);
            }
            '.' === e[0] && 2 === e.length && ('.' === e[1] || '' === e[1]) && ((t = !0), e.pop());
          }
          let n = 0;
          for (; -1 !== (n = e.indexOf('..', n + 1)); ) {
            let r = e[n - 1];
            r && '.' !== r && '..' !== r && '**' !== r && ((t = !0), e.splice(n - 1, 2), (n -= 2));
          }
        } while (t);
        return 0 === e.length ? [''] : e;
      }
      firstPhasePreProcess(e) {
        let t = !1;
        do
          for (let n of ((t = !1), e)) {
            let r = -1;
            for (; -1 !== (r = n.indexOf('**', r + 1)); ) {
              let i = r;
              for (; '**' === n[i + 1]; ) i++;
              i > r && n.splice(r + 1, i - r);
              let o = n[r + 1],
                a = n[r + 2],
                s = n[r + 3];
              if ('..' !== o || !a || '.' === a || '..' === a || !s || '.' === s || '..' === s)
                continue;
              ((t = !0), n.splice(r, 1));
              let u = n.slice(0);
              ((u[r] = '**'), e.push(u), r--);
            }
            if (!this.preserveMultipleSlashes) {
              for (let e = 1; e < n.length - 1; e++) {
                let r = n[e];
                (1 !== e || '' !== r || '' !== n[0]) &&
                  ('.' === r || '' === r) &&
                  ((t = !0), n.splice(e, 1), e--);
              }
              '.' === n[0] &&
                2 === n.length &&
                ('.' === n[1] || '' === n[1]) &&
                ((t = !0), n.pop());
            }
            let i = 0;
            for (; -1 !== (i = n.indexOf('..', i + 1)); ) {
              let e = n[i - 1];
              if (e && '.' !== e && '..' !== e && '**' !== e) {
                t = !0;
                let e = 1 === i && '**' === n[i + 1] ? ['.'] : [];
                (n.splice(i - 1, 2, ...e), 0 === n.length && n.push(''), (i -= 2));
              }
            }
          }
        while (t);
        return e;
      }
      secondPhasePreProcess(e) {
        for (let t = 0; t < e.length - 1; t++)
          for (let n = t + 1; n < e.length; n++) {
            let r = this.partsMatch(e[t], e[n], !this.preserveMultipleSlashes);
            if (r) {
              ((e[t] = []), (e[n] = r));
              break;
            }
          }
        return e.filter((e) => e.length);
      }
      partsMatch(e, t, n = !1) {
        let r = 0,
          i = 0,
          o = [],
          a = '';
        for (; r < e.length && i < t.length; )
          if (e[r] === t[i]) (o.push('b' === a ? t[i] : e[r]), r++, i++);
          else if (n && '**' === e[r] && t[i] === e[r + 1]) (o.push(e[r]), r++);
          else if (n && '**' === t[i] && e[r] === t[i + 1]) (o.push(t[i]), i++);
          else if (
            '*' === e[r] &&
            t[i] &&
            (this.options.dot || !t[i].startsWith('.')) &&
            '**' !== t[i]
          ) {
            if ('b' === a) return !1;
            ((a = 'a'), o.push(e[r]), r++, i++);
          } else {
            if (
              '*' !== t[i] ||
              !e[r] ||
              (!this.options.dot && e[r].startsWith('.')) ||
              '**' === e[r] ||
              'a' === a
            )
              return !1;
            ((a = 'b'), o.push(t[i]), r++, i++);
          }
        return e.length === t.length && o;
      }
      parseNegate() {
        if (this.nonegate) return;
        let e = this.pattern,
          t = !1,
          n = 0;
        for (let r = 0; r < e.length && '!' === e.charAt(r); r++) ((t = !t), n++);
        (n && (this.pattern = e.slice(n)), (this.negate = t));
      }
      matchOne(e, t, r = !1) {
        let i = this.options;
        if (this.isWindows) {
          let n = 'string' == typeof e[0] && /^[a-z]:$/i.test(e[0]),
            r = !n && '' === e[0] && '' === e[1] && '?' === e[2] && /^[a-z]:$/i.test(e[3]),
            i = 'string' == typeof t[0] && /^[a-z]:$/i.test(t[0]),
            o =
              !i &&
              '' === t[0] &&
              '' === t[1] &&
              '?' === t[2] &&
              'string' == typeof t[3] &&
              /^[a-z]:$/i.test(t[3]),
            a = r ? 3 : n ? 0 : void 0,
            s = o ? 3 : i ? 0 : void 0;
          if ('number' == typeof a && 'number' == typeof s) {
            let [n, r] = [e[a], t[s]];
            n.toLowerCase() === r.toLowerCase() &&
              ((t[s] = n), s > a ? (t = t.slice(s)) : a > s && (e = e.slice(a)));
          }
        }
        let { optimizationLevel: o = 1 } = this.options;
        (o >= 2 && (e = this.levelTwoFileOptimize(e)),
          this.debug('matchOne', this, { file: e, pattern: t }),
          this.debug('matchOne', e.length, t.length));
        for (var a = 0, s = 0, u = e.length, l = t.length; a < u && s < l; a++, s++) {
          let o;
          this.debug('matchOne loop');
          var c = t[s],
            d = e[a];
          if ((this.debug(t, c, d), !1 === c)) return !1;
          if (c === n.GLOBSTAR) {
            this.debug('GLOBSTAR', [t, c, d]);
            var p = a,
              _ = s + 1;
            if (_ === l) {
              for (this.debug('** at the end'); a < u; a++)
                if ('.' === e[a] || '..' === e[a] || (!i.dot && '.' === e[a].charAt(0))) return !1;
              return !0;
            }
            for (; p < u; ) {
              var S = e[p];
              if (
                (this.debug('\nglobstar while', e, p, t, _, S),
                this.matchOne(e.slice(p), t.slice(_), r))
              )
                return (this.debug('globstar found match!', p, u, S), !0);
              if ('.' === S || '..' === S || (!i.dot && '.' === S.charAt(0))) {
                this.debug('dot detected!', e, p, t, _);
                break;
              }
              (this.debug('globstar swallow a segment, and continue'), p++);
            }
            if (r && (this.debug('\n>>> no match, partial?', e, p, t, _), p === u)) return !0;
            return !1;
          }
          if (
            ('string' == typeof c
              ? ((o = d === c), this.debug('string match', c, d, o))
              : ((o = c.test(d)), this.debug('pattern match', c, d, o)),
            !o)
          )
            return !1;
        }
        if (a === u && s === l) return !0;
        if (a === u) return r;
        if (s === l) return a === u - 1 && '' === e[a];
        throw Error('wtf?');
      }
      braceExpand() {
        return (0, n.braceExpand)(this.pattern, this.options);
      }
      parse(e) {
        let t;
        (0, o.assertValidPattern)(e);
        let r = this.options;
        if ('**' === e) return n.GLOBSTAR;
        if ('' === e) return '';
        let i = null;
        (t = e.match(E))
          ? (i = r.dot ? m : T)
          : (t = e.match(l))
            ? (i = (
                r.nocase
                  ? r.dot
                    ? (e) => ((e = e.toLowerCase()), (t) => t.toLowerCase().endsWith(e))
                    : (e) => (
                        (e = e.toLowerCase()),
                        (t) => !t.startsWith('.') && t.toLowerCase().endsWith(e)
                      )
                  : r.dot
                    ? (e) => (t) => t.endsWith(e)
                    : (e) => (t) => !t.startsWith('.') && t.endsWith(e)
              )(t[1]))
            : (t = e.match(g))
              ? (i = (
                  r.nocase
                    ? r.dot
                      ? ([e, t = '']) => {
                          let n = h([e]);
                          return t
                            ? ((t = t.toLowerCase()), (e) => n(e) && e.toLowerCase().endsWith(t))
                            : n;
                        }
                      : ([e, t = '']) => {
                          let n = f([e]);
                          return t
                            ? ((t = t.toLowerCase()), (e) => n(e) && e.toLowerCase().endsWith(t))
                            : n;
                        }
                    : r.dot
                      ? ([e, t = '']) => {
                          let n = h([e]);
                          return t ? (e) => n(e) && e.endsWith(t) : n;
                        }
                      : ([e, t = '']) => {
                          let n = f([e]);
                          return t ? (e) => n(e) && e.endsWith(t) : n;
                        }
                )(t))
              : (t = e.match(c))
                ? (i = r.dot ? p : d)
                : (t = e.match(_)) && (i = S);
        let s = a.AST.fromGlob(e, this.options).toMMPattern();
        return (i && 'object' == typeof s && Reflect.defineProperty(s, 'test', { value: i }), s);
      }
      makeRe() {
        if (this.regexp || !1 === this.regexp) return this.regexp;
        let e = this.set;
        if (!e.length) return ((this.regexp = !1), this.regexp);
        let t = this.options,
          r = t.noglobstar
            ? '[^/]*?'
            : t.dot
              ? '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?'
              : '(?:(?!(?:\\/|^)\\.).)*?',
          i = new Set(t.nocase ? ['i'] : []),
          o = e
            .map((e) => {
              let t = e.map((e) => {
                if (e instanceof RegExp) for (let t of e.flags.split('')) i.add(t);
                return 'string' == typeof e
                  ? e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
                  : e === n.GLOBSTAR
                    ? n.GLOBSTAR
                    : e._src;
              });
              return (
                t.forEach((e, i) => {
                  let o = t[i + 1],
                    a = t[i - 1];
                  e === n.GLOBSTAR &&
                    a !== n.GLOBSTAR &&
                    (void 0 === a
                      ? void 0 !== o && o !== n.GLOBSTAR
                        ? (t[i + 1] = '(?:\\/|' + r + '\\/)?' + o)
                        : (t[i] = r)
                      : void 0 === o
                        ? (t[i - 1] = a + '(?:\\/|' + r + ')?')
                        : o !== n.GLOBSTAR &&
                          ((t[i - 1] = a + '(?:\\/|\\/' + r + '\\/)' + o),
                          (t[i + 1] = n.GLOBSTAR)));
                }),
                t.filter((e) => e !== n.GLOBSTAR).join('/')
              );
            })
            .join('|'),
          [a, s] = e.length > 1 ? ['(?:', ')'] : ['', ''];
        ((o = '^' + a + o + s + '$'), this.negate && (o = '^(?!' + o + ').+$'));
        try {
          this.regexp = new RegExp(o, [...i].join(''));
        } catch (e) {
          this.regexp = !1;
        }
        return this.regexp;
      }
      slashSplit(e) {
        return this.preserveMultipleSlashes
          ? e.split('/')
          : this.isWindows && /^\/\/[^\/]+/.test(e)
            ? ['', ...e.split(/\/+/)]
            : e.split(/\/+/);
      }
      match(e, t = this.partial) {
        if ((this.debug('match', e, this.pattern), this.comment)) return !1;
        if (this.empty) return '' === e;
        if ('/' === e && t) return !0;
        let n = this.options;
        this.isWindows && (e = e.split('\\').join('/'));
        let r = this.slashSplit(e);
        this.debug(this.pattern, 'split', r);
        let i = this.set;
        this.debug(this.pattern, 'set', i);
        let o = r[r.length - 1];
        if (!o) for (let e = r.length - 2; !o && e >= 0; e--) o = r[e];
        for (let e = 0; e < i.length; e++) {
          let a = i[e],
            s = r;
          if ((n.matchBase && 1 === a.length && (s = [o]), this.matchOne(s, a, t))) {
            if (n.flipNegate) return !0;
            return !this.negate;
          }
        }
        return !n.flipNegate && this.negate;
      }
      static defaults(e) {
        return n.minimatch.defaults(e).Minimatch;
      }
    }
    n.Minimatch = b;
    var N = e.r(72851);
    Object.defineProperty(n, 'AST', {
      enumerable: !0,
      get: function () {
        return N.AST;
      },
    });
    var O = e.r(88460);
    Object.defineProperty(n, 'escape', {
      enumerable: !0,
      get: function () {
        return O.escape;
      },
    });
    var v = e.r(18280);
    (Object.defineProperty(n, 'unescape', {
      enumerable: !0,
      get: function () {
        return v.unescape;
      },
    }),
      (n.minimatch.AST = a.AST),
      (n.minimatch.Minimatch = b),
      (n.minimatch.escape = s.escape),
      (n.minimatch.unescape = u.unescape));
  },
  75185,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(77652),
      i = e.r(52305),
      o = e.r(88540),
      a = e.r(75235),
      s = e.r(81964),
      u = e.r(40484),
      l = '@fastify/otel',
      c = [
        'onRequest',
        'preParsing',
        'preValidation',
        'preHandler',
        'preSerialization',
        'onSend',
        'onResponse',
        'onError',
      ],
      d = {
        HOOK_NAME: 'hook.name',
        FASTIFY_TYPE: 'fastify.type',
        HOOK_CALLBACK_NAME: 'hook.callback.name',
        ROOT: 'fastify.root',
      },
      p = { ROUTE: 'route-hook', INSTANCE: 'hook', HANDLER: 'request-handler' },
      _ = 'anonymous',
      S = Symbol('fastify otel instance'),
      E = Symbol('fastify otel request spans'),
      T = Symbol('fastify otel request context'),
      m = Symbol('fastify otel addhook original'),
      g = Symbol('fastify otel setnotfound original'),
      f = Symbol('fastify otel ignore path');
    class h extends a.InstrumentationBase {
      constructor(e) {
        if (
          (super(l, '0.8.0', e),
          (this.servername = e?.servername ?? process.env.OTEL_SERVICE_NAME ?? 'fastify'),
          (this[f] = null),
          (this._logger = i.diag.createComponentLogger({ namespace: l })),
          e?.ignorePaths != null || null != process.env.OTEL_FASTIFY_IGNORE_PATHS)
        ) {
          let t = e?.ignorePaths ?? process.env.OTEL_FASTIFY_IGNORE_PATHS;
          if (('string' != typeof t || 0 === t.length) && 'function' != typeof t)
            throw TypeError('ignorePaths must be a string or a function');
          let n = u.minimatch;
          this[f] = (e) => ('function' == typeof t ? t(e) : n(e.url, t));
        }
      }
      enable() {
        if (void 0 === this._handleInitialization && this.getConfig().registerOnInitialization) {
          let e = this.plugin();
          ((this._handleInitialization = (t) => {
            t.fastify.register(e);
          }),
            r.default.subscribe('fastify.initialization', this._handleInitialization));
        }
        return super.enable();
      }
      disable() {
        return (
          this._handleInitialization &&
            (r.default.unsubscribe('fastify.initialization', this._handleInitialization),
            (this._handleInitialization = void 0)),
          super.disable()
        );
      }
      init() {
        return [];
      }
      plugin() {
        let e = this;
        return (
          (t[Symbol.for('skip-override')] = !0),
          (t[Symbol.for('fastify.display-name')] = '@fastify/otel'),
          (t[Symbol.for('plugin-meta')] = { fastify: '>=4.0.0 <6', name: '@fastify/otel' }),
          t
        );
        function t(t, n, r) {
          function a(e, t, n, r) {
            let o = e[E];
            (null != o &&
              (t.statusCode < 500 && o.setStatus({ code: i.SpanStatusCode.OK, message: 'OK' }),
              o.setAttributes({ [s.ATTR_HTTP_RESPONSE_STATUS_CODE]: t.statusCode }),
              o.end()),
              (e[E] = null),
              r(null, n));
          }
          function u(e, t, n, r) {
            let o = e[E];
            (null != o &&
              (o.setStatus({ code: i.SpanStatusCode.ERROR, message: n.message }),
              o.recordException(n)),
              r());
          }
          function l(e, t = {}) {
            return function (...n) {
              let r = this[S],
                [o] = n;
              if (!1 === r.isEnabled()) return e.call(this, ...n);
              let a = o[T] ?? i.context.active(),
                s = r.tracer.startSpan(
                  `handler - ${e.name?.length > 0 ? e.name : (this.pluginName ?? _)}`,
                  { attributes: t },
                  a
                );
              return i.context.with(
                i.trace.setSpan(a, s),
                function () {
                  try {
                    let t = e.call(this, ...n);
                    if ('function' == typeof t?.then)
                      return t.then(
                        (e) => (s.end(), e),
                        (e) => (
                          s.setStatus({ code: i.SpanStatusCode.ERROR, message: e.message }),
                          s.recordException(e),
                          s.end(),
                          Promise.reject(e)
                        )
                      );
                    return (s.end(), t);
                  } catch (e) {
                    throw (
                      s.setStatus({ code: i.SpanStatusCode.ERROR, message: e.message }),
                      s.recordException(e),
                      s.end(),
                      e
                    );
                  }
                },
                this
              );
            };
          }
          (t.decorate(S, e),
            t.decorate(m, t.addHook),
            t.decorate(g, t.setNotFoundHandler),
            t.decorateRequest('opentelemetry', function () {
              let t = this[T];
              return {
                span: this[E],
                tracer: e.tracer,
                context: t,
                inject: (e, n) => i.propagation.inject(t, e, n),
                extract: (e, n) => i.propagation.extract(t, e, n),
              };
            }),
            t.decorateRequest(E, null),
            t.decorateRequest(T, null),
            t.addHook('onRoute', function (n) {
              if (e[f]?.(n) === !0)
                return void e._logger.debug(
                  `Ignoring route instrumentation ${n.method} ${n.url} because it matches the ignore path`
                );
              for (let e of c)
                if (null != n[e]) {
                  let r = n[e];
                  if ('function' == typeof r)
                    n[e] = l(r, {
                      [s.ATTR_SERVICE_NAME]: t[S].servername,
                      [d.HOOK_NAME]: `${this.pluginName} - route -> ${e}`,
                      [d.FASTIFY_TYPE]: p.ROUTE,
                      [s.ATTR_HTTP_ROUTE]: n.url,
                      [d.HOOK_CALLBACK_NAME]: r.name?.length > 0 ? r.name : _,
                    });
                  else if (Array.isArray(r)) {
                    let i = [];
                    for (let o of r)
                      i.push(
                        l(o, {
                          [s.ATTR_SERVICE_NAME]: t[S].servername,
                          [d.HOOK_NAME]: `${this.pluginName} - route -> ${e}`,
                          [d.FASTIFY_TYPE]: p.ROUTE,
                          [s.ATTR_HTTP_ROUTE]: n.url,
                          [d.HOOK_CALLBACK_NAME]: o.name?.length > 0 ? o.name : _,
                        })
                      );
                    n[e] = i;
                  }
                }
              (null != n.onSend
                ? (n.onSend = Array.isArray(n.onSend) ? [...n.onSend, a] : [n.onSend, a])
                : (n.onSend = a),
                null != n.onError
                  ? (n.onError = Array.isArray(n.onError) ? [...n.onError, u] : [n.onError, u])
                  : (n.onError = u),
                (n.handler = l(n.handler, {
                  [s.ATTR_SERVICE_NAME]: t[S].servername,
                  [d.HOOK_NAME]: `${this.pluginName} - route-handler`,
                  [d.FASTIFY_TYPE]: p.HANDLER,
                  [s.ATTR_HTTP_ROUTE]: n.url,
                  [d.HOOK_CALLBACK_NAME]: n.handler.name.length > 0 ? n.handler.name : _,
                })));
            }),
            t.addHook('onRequest', function (e, n, r) {
              if (!1 === this[S].isEnabled()) return r();
              if (this[S][f]?.({ url: e.url, method: e.method }) === !0)
                return (
                  this[S]._logger.debug(
                    `Ignoring request ${e.method} ${e.url} because it matches the ignore path`
                  ),
                  r()
                );
              let a = i.context.active();
              null == i.trace.getSpan(a) && (a = i.propagation.extract(a, e.headers));
              let u = o.getRPCMetadata(a);
              null != e.routeOptions.url &&
                u?.type === o.RPCType.HTTP &&
                (u.route = e.routeOptions.url);
              let l = this[S].tracer.startSpan(
                'request',
                {
                  attributes: {
                    [s.ATTR_SERVICE_NAME]: t[S].servername,
                    [d.ROOT]: '@fastify/otel',
                    [s.ATTR_HTTP_ROUTE]: e.url,
                    [s.ATTR_HTTP_REQUEST_METHOD]: e.method,
                  },
                },
                a
              );
              ((e[T] = i.trace.setSpan(a, l)),
                (e[E] = l),
                i.context.with(e[T], () => {
                  r();
                }));
            }),
            t.addHook('onResponse', function (e, t, n) {
              let r = e[E];
              (null != r &&
                (r.setStatus({ code: i.SpanStatusCode.OK, message: 'OK' }),
                r.setAttributes({ [s.ATTR_HTTP_RESPONSE_STATUS_CODE]: 404 }),
                r.end()),
                (e[E] = null),
                n());
            }),
            (t.addHook = function (e, n) {
              let r = this[m];
              return c.includes(e)
                ? r.call(
                    this,
                    e,
                    l(n, {
                      [s.ATTR_SERVICE_NAME]: t[S].servername,
                      [d.HOOK_NAME]: `${this.pluginName} - ${e}`,
                      [d.FASTIFY_TYPE]: p.INSTANCE,
                      [d.HOOK_CALLBACK_NAME]: n.name?.length > 0 ? n.name : _,
                    })
                  )
                : r.call(this, e, n);
            }),
            (t.setNotFoundHandler = function (e, n) {
              let r = this[g];
              'function' == typeof e
                ? ((n = l(e, {
                    [s.ATTR_SERVICE_NAME]: t[S].servername,
                    [d.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
                    [d.FASTIFY_TYPE]: p.INSTANCE,
                    [d.HOOK_CALLBACK_NAME]: e.name?.length > 0 ? e.name : _,
                  })),
                  r.call(this, n))
                : (null != e.preValidation &&
                    (e.preValidation = l(e.preValidation, {
                      [s.ATTR_SERVICE_NAME]: t[S].servername,
                      [d.HOOK_NAME]: `${this.pluginName} - not-found-handler - preValidation`,
                      [d.FASTIFY_TYPE]: p.INSTANCE,
                      [d.HOOK_CALLBACK_NAME]:
                        e.preValidation.name?.length > 0 ? e.preValidation.name : _,
                    })),
                  null != e.preHandler &&
                    (e.preHandler = l(e.preHandler, {
                      [s.ATTR_SERVICE_NAME]: t[S].servername,
                      [d.HOOK_NAME]: `${this.pluginName} - not-found-handler - preHandler`,
                      [d.FASTIFY_TYPE]: p.INSTANCE,
                      [d.HOOK_CALLBACK_NAME]: e.preHandler.name?.length > 0 ? e.preHandler.name : _,
                    })),
                  (n = l(n, {
                    [s.ATTR_SERVICE_NAME]: t[S].servername,
                    [d.HOOK_NAME]: `${this.pluginName} - not-found-handler`,
                    [d.FASTIFY_TYPE]: p.INSTANCE,
                    [d.HOOK_CALLBACK_NAME]: n.name?.length > 0 ? n.name : _,
                  })),
                  r.call(this, e, n));
            }),
            r());
        }
      }
    }
    n.FastifyOtelInstrumentation = h;
  },
  1422,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.FASTIFY_NAME = 'fastify.name'),
          (e.FASTIFY_TYPE = 'fastify.type'),
          (e.HOOK_NAME = 'hook.name'),
          (e.PLUGIN_NAME = 'plugin.name'));
      })(n.AttributeNames || (n.AttributeNames = {})),
      (n.FastifyTypes = void 0),
      (function (e) {
        ((e.MIDDLEWARE = 'middleware'), (e.REQUEST_HANDLER = 'request_handler'));
      })(n.FastifyTypes || (n.FastifyTypes = {})),
      (n.FastifyNames = void 0),
      (function (e) {
        ((e.MIDDLEWARE = 'middleware'), (e.REQUEST_HANDLER = 'request handler'));
      })(n.FastifyNames || (n.FastifyNames = {})));
  },
  32958,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.spanRequestSymbol = Symbol('opentelemetry.instrumentation.fastify.request_active_span')));
  },
  30113,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(32958);
    function o(e) {
      return (
        ('object' == typeof e &&
          e &&
          'function' == typeof Object.getOwnPropertyDescriptor(e, 'then')?.value) ||
        !1
      );
    }
    ((n.endSpan = function (e, t) {
      let n = e[i.spanRequestSymbol] || [];
      n.length &&
        (n.forEach((e) => {
          (t &&
            (e.setStatus({ code: r.SpanStatusCode.ERROR, message: t.message }),
            e.recordException(t)),
            e.end());
        }),
        delete e[i.spanRequestSymbol]);
    }),
      (n.safeExecuteInTheMiddleMaybePromise = function (e, t, n) {
        let r, i;
        try {
          ((i = e()),
            o(i) &&
              i.then(
                (e) => t(void 0, e),
                (e) => t(e)
              ));
        } catch (e) {
          r = e;
        } finally {
          if (!o(i) && (t(r, i), r && 1)) throw r;
          return i;
        }
      }),
      (n.startSpan = function (e, t, n, r = {}) {
        let o = t.startSpan(n, { attributes: r }),
          a = e[i.spanRequestSymbol] || [];
        return (
          a.push(o),
          Object.defineProperty(e, i.spanRequestSymbol, {
            enumerable: !1,
            configurable: !0,
            value: a,
          }),
          o
        );
      }));
  },
  22679,
  (e, t, n) => {
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(75235),
      a = e.r(81964),
      s = e.r(48009),
      u = e.r(1422),
      l = e.r(30113),
      c = 'anonymous',
      d = new Set([
        'onTimeout',
        'onRequest',
        'preParsing',
        'preValidation',
        'preSerialization',
        'preHandler',
        'onSend',
        'onResponse',
        'onError',
      ]);
    class p extends o.InstrumentationBase {
      constructor(e = {}) {
        super('@sentry/instrumentation-fastify-v3', '0.1.0', e);
      }
      init() {
        return [
          new o.InstrumentationNodeModuleDefinition('fastify', ['>=3.0.0 <4'], (e) =>
            this._patchConstructor(e)
          ),
        ];
      }
      _hookOnRequest() {
        let e = this;
        return function (t, n, o) {
          if (!e.isEnabled()) return o();
          e._wrap(n, 'send', e._patchSend());
          let a = i.getRPCMetadata(r.context.active()),
            u = t.routeOptions ? t.routeOptions.url : t.routerPath;
          u && a?.type === i.RPCType.HTTP && (a.route = u);
          let l = t.method || 'GET';
          (s.getIsolationScope().setTransactionName(`${l} ${u}`), o());
        };
      }
      _wrapHandler(e, t, n, i) {
        let o = this;
        return (
          this._diag.debug('Patching fastify route.handler function'),
          function (...a) {
            if (!o.isEnabled()) return n.apply(this, a);
            let s = n.name || e || c,
              d = `${u.FastifyNames.MIDDLEWARE} - ${s}`,
              p = a[1],
              _ = l.startSpan(p, o.tracer, d, {
                [u.AttributeNames.FASTIFY_TYPE]: u.FastifyTypes.MIDDLEWARE,
                [u.AttributeNames.PLUGIN_NAME]: e,
                [u.AttributeNames.HOOK_NAME]: t,
              }),
              S = i && a[a.length - 1];
            return (
              S &&
                (a[a.length - 1] = function (...e) {
                  (l.endSpan(p), S.apply(this, e));
                }),
              r.context.with(r.trace.setSpan(r.context.active(), _), () =>
                l.safeExecuteInTheMiddleMaybePromise(
                  () => n.apply(this, a),
                  (e) => {
                    (e instanceof Error &&
                      (_.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                      _.recordException(e)),
                      i || l.endSpan(p));
                  }
                )
              )
            );
          }
        );
      }
      _wrapAddHook() {
        let e = this;
        return (
          this._diag.debug('Patching fastify server.addHook function'),
          function (t) {
            return function (...n) {
              let r = n[0],
                i = n[1],
                o = this.pluginName;
              if (!d.has(r)) return t.apply(this, n);
              let a =
                'function' == typeof n[n.length - 1] && 'AsyncFunction' !== i.constructor.name;
              return t.apply(this, [r, e._wrapHandler(o, r, i, a)]);
            };
          }
        );
      }
      _patchConstructor(e) {
        let t = this;
        function n(...r) {
          let i = e.fastify.apply(this, r);
          return (
            i.addHook('onRequest', t._hookOnRequest()),
            i.addHook('preHandler', t._hookPreHandler()),
            (function () {
              let e = s.getClient();
              e &&
                e.on('spanStart', (e) => {
                  _(e);
                });
            })(),
            t._wrap(i, 'addHook', t._wrapAddHook()),
            i
          );
        }
        return (
          void 0 !== e.errorCodes && (n.errorCodes = e.errorCodes),
          (n.fastify = n),
          (n.default = n),
          n
        );
      }
      _patchSend() {
        let e = this;
        return (
          this._diag.debug('Patching fastify reply.send function'),
          function (t) {
            return function (...n) {
              let r = n[0];
              return e.isEnabled()
                ? o.safeExecuteInTheMiddle(
                    () => t.apply(this, n),
                    (e) => {
                      (!e && r instanceof Error && (e = r), l.endSpan(this, e));
                    }
                  )
                : t.apply(this, n);
            };
          }
        );
      }
      _hookPreHandler() {
        let e = this;
        return (
          this._diag.debug('Patching fastify preHandler function'),
          function (t, n, i) {
            if (!e.isEnabled()) return i();
            let s = t.routeOptions?.handler || t.context?.handler,
              d = s?.name.startsWith('bound ') ? s.name.substring(6) : s?.name,
              p = `${u.FastifyNames.REQUEST_HANDLER} - ${d || this.pluginName || c}`,
              S = {
                [u.AttributeNames.PLUGIN_NAME]: this.pluginName,
                [u.AttributeNames.FASTIFY_TYPE]: u.FastifyTypes.REQUEST_HANDLER,
                [a.SEMATTRS_HTTP_ROUTE]: t.routeOptions ? t.routeOptions.url : t.routerPath,
              };
            d && (S[u.AttributeNames.FASTIFY_NAME] = d);
            let E = l.startSpan(n, e.tracer, p, S);
            _(E);
            let { requestHook: T } = e.getConfig();
            return (
              T &&
                o.safeExecuteInTheMiddle(
                  () => T(E, { request: t }),
                  (t) => {
                    t && e._diag.error('request hook failed', t);
                  },
                  !0
                ),
              r.context.with(r.trace.setSpan(r.context.active(), E), () => {
                i();
              })
            );
          }
        );
      }
    }
    function _(e) {
      let t = s.spanToJSON(e).data,
        n = t['fastify.type'];
      if (t[s.SEMANTIC_ATTRIBUTE_SENTRY_OP] || !n) return;
      e.setAttributes({
        [s.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.fastify',
        [s.SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${n}.fastify`,
      });
      let r = t['fastify.name'] || t['plugin.name'] || t['hook.name'];
      if ('string' == typeof r) {
        let t = r.replace(/^fastify -> /, '').replace(/^@fastify\/otel -> /, '');
        e.updateName(t);
      }
    }
    n.FastifyInstrumentationV3 = p;
  },
  29482,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(77652),
      i = e.r(48009),
      o = e.r(15527),
      a = e.r(59589),
      s = e.r(75185),
      u = e.r(22679),
      l = 'Fastify',
      c = o.generateInstrumentOnce(`${l}.v3`, () => new u.FastifyInstrumentationV3());
    function d() {
      let e = i.getClient();
      if (e) return e.getIntegrationByName(l);
    }
    function p(e, t, n, r) {
      let o = d()?.getShouldHandleError() || S;
      if (
        ('diagnostics-channel' === r && (this.diagnosticsChannelExists = !0),
        this.diagnosticsChannelExists && 'onError-hook' === r)
      ) {
        a.DEBUG_BUILD &&
          i.debug.warn(
            'Fastify error handler was already registered via diagnostics channel.',
            'You can safely remove `setupFastifyErrorHandler` call and set `shouldHandleError` on the integration options.'
          );
        return;
      }
      o(e, t, n) && i.captureException(e, { mechanism: { handled: !1, type: 'fastify' } });
    }
    let _ = o.generateInstrumentOnce(`${l}.v5`, () => {
      let e = new s.FastifyOtelInstrumentation(),
        t = e.plugin();
      return (
        r.subscribe('fastify.initialization', (e) => {
          let n = e.fastify;
          n?.register(t).after((e) => {
            e
              ? a.DEBUG_BUILD && i.debug.error('Failed to setup Fastify instrumentation', e)
              : ((function () {
                  let e = i.getClient();
                  e &&
                    e.on('spanStart', (e) => {
                      E(e);
                    });
                })(),
                n &&
                  n.addHook('onRequest', async (e, t) => {
                    if (e.opentelemetry) {
                      let { span: t } = e.opentelemetry();
                      t && E(t);
                    }
                    let n = e.routeOptions?.url,
                      r = e.method || 'GET';
                    i.getIsolationScope().setTransactionName(`${r} ${n}`);
                  }));
          });
        }),
        r.subscribe('tracing:fastify.request.handler:error', (e) => {
          let { error: t, request: n, reply: r } = e;
          p.call(p, t, n, r, 'diagnostics-channel');
        }),
        e
      );
    });
    function S(e, t, n) {
      let r = n.statusCode;
      return r >= 500 || r <= 299;
    }
    function E(e) {
      let t = i.spanToJSON(e),
        n = t.description,
        r = t.data,
        o = r['fastify.type'],
        a = 'hook' === o,
        s = o === n?.startsWith('handler -'),
        u = 'request' === n || 'request-handler' === o;
      if (r[i.SEMANTIC_ATTRIBUTE_SENTRY_OP] || (!s && !u && !a)) return;
      e.setAttributes({
        [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.fastify',
        [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${a ? 'hook' : s ? 'middleware' : u ? 'request-handler' : '<unknown>'}.fastify`,
      });
      let l = r['fastify.name'] || r['plugin.name'] || r['hook.name'];
      if ('string' == typeof l) {
        let t = l.replace(/^fastify -> /, '').replace(/^@fastify\/otel -> /, '');
        e.updateName(t);
      }
    }
    ((n.fastifyIntegration = i.defineIntegration((e = {}) =>
      (({ shouldHandleError: e }) => {
        let t;
        return {
          name: l,
          setupOnce() {
            ((t = e || S), c(), _());
          },
          getShouldHandleError: () => t,
          setShouldHandleError(e) {
            t = e;
          },
        };
      })(e)
    )),
      (n.instrumentFastify = _),
      (n.instrumentFastifyV3 = c),
      (n.setupFastifyErrorHandler = function (e, t) {
        t?.shouldHandleError && d()?.setShouldHandleError(t.shouldHandleError);
        let n = Object.assign(
          function (e, t, n) {
            (e.addHook('onError', async (e, t, n) => {
              p.call(p, n, e, t, 'onError-hook');
            }),
              n());
          },
          {
            [Symbol.for('skip-override')]: !0,
            [Symbol.for('fastify.display-name')]: 'sentry-fastify-error-handler',
          }
        );
        e.register(n);
      }));
  },
  42982,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SpanNames = n.TokenKind = n.AllowedOperationTypes = void 0),
      (function (e) {
        ((e.QUERY = 'query'), (e.MUTATION = 'mutation'), (e.SUBSCRIPTION = 'subscription'));
      })(n.AllowedOperationTypes || (n.AllowedOperationTypes = {})),
      (function (e) {
        ((e.SOF = '<SOF>'),
          (e.EOF = '<EOF>'),
          (e.BANG = '!'),
          (e.DOLLAR = '$'),
          (e.AMP = '&'),
          (e.PAREN_L = '('),
          (e.PAREN_R = ')'),
          (e.SPREAD = '...'),
          (e.COLON = ':'),
          (e.EQUALS = '='),
          (e.AT = '@'),
          (e.BRACKET_L = '['),
          (e.BRACKET_R = ']'),
          (e.BRACE_L = '{'),
          (e.PIPE = '|'),
          (e.BRACE_R = '}'),
          (e.NAME = 'Name'),
          (e.INT = 'Int'),
          (e.FLOAT = 'Float'),
          (e.STRING = 'String'),
          (e.BLOCK_STRING = 'BlockString'),
          (e.COMMENT = 'Comment'));
      })(n.TokenKind || (n.TokenKind = {})),
      (function (e) {
        ((e.EXECUTE = 'graphql.execute'),
          (e.PARSE = 'graphql.parse'),
          (e.RESOLVE = 'graphql.resolve'),
          (e.VALIDATE = 'graphql.validate'),
          (e.SCHEMA_VALIDATE = 'graphql.validateSchema'),
          (e.SCHEMA_PARSE = 'graphql.parseSchema'));
      })(n.SpanNames || (n.SpanNames = {})));
  },
  32162,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.SOURCE = 'graphql.source'),
          (e.FIELD_NAME = 'graphql.field.name'),
          (e.FIELD_PATH = 'graphql.field.path'),
          (e.FIELD_TYPE = 'graphql.field.type'),
          (e.OPERATION_TYPE = 'graphql.operation.type'),
          (e.OPERATION_NAME = 'graphql.operation.name'),
          (e.VARIABLES = 'graphql.variables.'),
          (e.ERROR_VALIDATION_NAME = 'graphql.validation.error'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  41221,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.OTEL_GRAPHQL_DATA_SYMBOL = n.OTEL_PATCHED_SYMBOL = void 0),
      (n.OTEL_PATCHED_SYMBOL = Symbol.for('opentelemetry.patched')),
      (n.OTEL_GRAPHQL_DATA_SYMBOL = Symbol.for('opentelemetry.graphql_data')));
  },
  15546,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.OPERATION_NOT_SUPPORTED = void 0),
      e.r(41221),
      (n.OPERATION_NOT_SUPPORTED = 'Operation$operationName$not supported'));
  },
  94589,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.wrapFieldResolver =
        n.wrapFields =
        n.getSourceFromLocation =
        n.getOperation =
        n.endSpan =
        n.addSpanSource =
        n.addInputVariableAttributes =
        n.isPromise =
          void 0));
    let r = e.r(52305),
      i = e.r(42982),
      o = e.r(32162),
      a = e.r(41221),
      s = Object.values(i.AllowedOperationTypes);
    function u(e, t, n, r, i) {
      let a = _(t, n, r, i);
      e.setAttribute(o.AttributeNames.SOURCE, a);
    }
    function l(e, t) {
      return e[a.OTEL_GRAPHQL_DATA_SYMBOL].fields[t.join('.')];
    }
    function c(e, t) {
      for (let n = t.length - 1; n > 0; n--) {
        let r = l(e, t.slice(0, n));
        if (r) return r;
      }
      return { span: e[a.OTEL_GRAPHQL_DATA_SYMBOL].span };
    }
    ((n.isPromise = (e) => 'function' == typeof e?.then),
      (n.addInputVariableAttributes = function (e, t) {
        Object.entries(t).forEach(([t, n]) => {
          !(function e(t, n, r) {
            Array.isArray(r)
              ? r.forEach((r, i) => {
                  e(t, `${n}.${i}`, r);
                })
              : r instanceof Object
                ? Object.entries(r).forEach(([r, i]) => {
                    e(t, `${n}.${r}`, i);
                  })
                : t.setAttribute(`${o.AttributeNames.VARIABLES}${String(n)}`, r);
          })(e, t, n);
        });
      }),
      (n.addSpanSource = u),
      (n.endSpan = function (e, t) {
        (t && e.recordException(t), e.end());
      }),
      (n.getOperation = function (e, t) {
        if (e && Array.isArray(e.definitions))
          if (t)
            return e.definitions
              .filter((e) => -1 !== s.indexOf(e?.operation))
              .find((e) => t === e?.name?.value);
          else return e.definitions.find((e) => -1 !== s.indexOf(e?.operation));
      }));
    function d(e, t) {
      let n = '';
      for (let r = 0; r < t; r++) n += e;
      return n;
    }
    let p = [i.TokenKind.FLOAT, i.TokenKind.STRING, i.TokenKind.INT, i.TokenKind.BLOCK_STRING];
    function _(e, t = !1, n, r) {
      let o = '';
      if (e?.startToken) {
        let a = 'number' == typeof n ? n : e.start,
          s = 'number' == typeof r ? r : e.end,
          u = e.startToken.next,
          l = 1;
        for (; u; ) {
          if (u.start < a || u.end > s) {
            ((u = u.next), (l = u?.line));
            continue;
          }
          let e = u.value || u.kind,
            n = '';
          ((!t && p.indexOf(u.kind) >= 0 && (e = '*'),
          u.kind === i.TokenKind.STRING && (e = `"${e}"`),
          u.kind === i.TokenKind.EOF && (e = ''),
          u.line > l)
            ? ((o += d('\n', u.line - l)), (l = u.line), (n = d(' ', u.column - 1)))
            : u.line === u.prev?.line && (n = d(' ', u.start - (u.prev?.end || 0))),
            (o += n + e),
            u && (u = u.next));
        }
      }
      return o;
    }
    ((n.getSourceFromLocation = _),
      (n.wrapFields = function e(t, n, r) {
        if (!t || 'function' != typeof t.getFields || t[a.OTEL_PATCHED_SYMBOL]) return;
        let i = t.getFields();
        ((t[a.OTEL_PATCHED_SYMBOL] = !0),
          Object.keys(i).forEach((t) => {
            let o = i[t];
            if (o && (o.resolve && (o.resolve = T(n, r, o.resolve)), o.type)) {
              let t = o.type;
              for (; t.ofType; ) t = t.ofType;
              e(t, n, r);
            }
          }));
      }));
    let S = (e, t, n) => {
        n &&
          (e.recordException(t),
          e.setStatus({ code: r.SpanStatusCode.ERROR, message: t.message }),
          e.end());
      },
      E = (e, t) => {
        t && e.end();
      };
    function T(e, t, s, d = !1) {
      if (p[a.OTEL_PATCHED_SYMBOL] || 'function' != typeof s) return s;
      function p(p, _, T, m) {
        let g;
        if (!s) return;
        let f = t();
        if (
          (f.ignoreTrivialResolveSpans &&
            d &&
            (('object' == typeof p && null !== p) || 'function' == typeof p) &&
            'function' != typeof p[m.fieldName]) ||
          !T[a.OTEL_GRAPHQL_DATA_SYMBOL]
        )
          return s.call(this, p, _, T, m);
        let h = (function (e, t) {
            let n = [],
              r = t;
            for (; r; ) {
              let t = r.key;
              (e && 'number' == typeof t && (t = '*'), n.push(String(t)), (r = r.prev));
            }
            return n.reverse();
          })(f.mergeItems, m && m.path),
          A = h.filter((e) => 'string' == typeof e).length,
          R = !1;
        if (f.depth >= 0 && f.depth < A) g = c(T, h);
        else {
          let n = (function (e, t, n, s, d) {
            let p = l(n, d),
              _ = !1;
            if (!p) {
              var S, E, T;
              _ = !0;
              let l = c(n, d);
              ((p = {
                parent: l,
                span: (function (e, t, n, s, l, c) {
                  let d = {
                      [o.AttributeNames.FIELD_NAME]: s.fieldName,
                      [o.AttributeNames.FIELD_PATH]: l.join('.'),
                      [o.AttributeNames.FIELD_TYPE]: s.returnType.toString(),
                    },
                    p = e.startSpan(
                      `${i.SpanNames.RESOLVE} ${d[o.AttributeNames.FIELD_PATH]}`,
                      { attributes: d },
                      c ? r.trace.setSpan(r.context.active(), c) : void 0
                    ),
                    _ = n[a.OTEL_GRAPHQL_DATA_SYMBOL].source,
                    S = s.fieldNodes.find((e) => 'Field' === e.kind);
                  return (S && u(p, _.loc, t().allowValues, S.loc?.start, S.loc?.end), p);
                })(e, t, n, s, d, l.span),
                error: null,
              }),
                (S = n),
                (E = d),
                (T = p),
                (S[a.OTEL_GRAPHQL_DATA_SYMBOL].fields[E.join('.')] = T));
            }
            return { spanAdded: _, field: p };
          })(e, t, T, m, h);
          ((g = n.field), (R = n.spanAdded));
        }
        return r.context.with(r.trace.setSpan(r.context.active(), g.span), () => {
          try {
            let e = s.call(this, p, _, T, m);
            if ((0, n.isPromise)(e))
              return e.then(
                (e) => (E(g.span, R), e),
                (e) => {
                  throw (S(g.span, e, R), e);
                }
              );
            return (E(g.span, R), e);
          } catch (e) {
            throw (S(g.span, e, R), e);
          }
        });
      }
      return ((p[a.OTEL_PATCHED_SYMBOL] = !0), p);
    }
    n.wrapFieldResolver = T;
  },
  26839,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.51.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-graphql'));
  },
  63817,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.GraphQLInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(42982),
      a = e.r(32162),
      s = e.r(41221),
      u = e.r(15546),
      l = e.r(94589),
      c = e.r(26839),
      d = { mergeItems: !1, depth: -1, allowValues: !1, ignoreResolveSpans: !1 },
      p = ['>=14.0.0 <17'];
    class _ extends i.InstrumentationBase {
      constructor(e = {}) {
        super(c.PACKAGE_NAME, c.PACKAGE_VERSION, { ...d, ...e });
      }
      setConfig(e = {}) {
        super.setConfig({ ...d, ...e });
      }
      init() {
        let e = new i.InstrumentationNodeModuleDefinition('graphql', p);
        return (
          e.files.push(this._addPatchingExecute()),
          e.files.push(this._addPatchingParser()),
          e.files.push(this._addPatchingValidate()),
          e
        );
      }
      _addPatchingExecute() {
        return new i.InstrumentationNodeModuleFile(
          'graphql/execution/execute.js',
          p,
          (e) => (
            (0, i.isWrapped)(e.execute) && this._unwrap(e, 'execute'),
            this._wrap(e, 'execute', this._patchExecute(e.defaultFieldResolver)),
            e
          ),
          (e) => {
            e && this._unwrap(e, 'execute');
          }
        );
      }
      _addPatchingParser() {
        return new i.InstrumentationNodeModuleFile(
          'graphql/language/parser.js',
          p,
          (e) => (
            (0, i.isWrapped)(e.parse) && this._unwrap(e, 'parse'),
            this._wrap(e, 'parse', this._patchParse()),
            e
          ),
          (e) => {
            e && this._unwrap(e, 'parse');
          }
        );
      }
      _addPatchingValidate() {
        return new i.InstrumentationNodeModuleFile(
          'graphql/validation/validate.js',
          p,
          (e) => (
            (0, i.isWrapped)(e.validate) && this._unwrap(e, 'validate'),
            this._wrap(e, 'validate', this._patchValidate()),
            e
          ),
          (e) => {
            e && this._unwrap(e, 'validate');
          }
        );
      }
      _patchExecute(e) {
        let t = this;
        return function (n) {
          return function () {
            let o;
            if (arguments.length >= 2) {
              let n = arguments;
              o = t._wrapExecuteArgs(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], e);
            } else {
              let n = arguments[0];
              o = t._wrapExecuteArgs(
                n.schema,
                n.document,
                n.rootValue,
                n.contextValue,
                n.variableValues,
                n.operationName,
                n.fieldResolver,
                n.typeResolver,
                e
              );
            }
            let a = (0, l.getOperation)(o.document, o.operationName),
              u = t._createExecuteSpan(a, o);
            return (
              (o.contextValue[s.OTEL_GRAPHQL_DATA_SYMBOL] = {
                source: o.document ? o.document || o.document[s.OTEL_GRAPHQL_DATA_SYMBOL] : void 0,
                span: u,
                fields: {},
              }),
              r.context.with(r.trace.setSpan(r.context.active(), u), () =>
                (0, i.safeExecuteInTheMiddle)(
                  () => n.apply(this, [o]),
                  (e, n) => {
                    t._handleExecutionResult(u, e, n);
                  }
                )
              )
            );
          };
        };
      }
      _handleExecutionResult(e, t, n) {
        let r = this.getConfig();
        if (void 0 === n || t) return void (0, l.endSpan)(e, t);
        if ((0, l.isPromise)(n))
          n.then(
            (t) => {
              if ('function' != typeof r.responseHook) return void (0, l.endSpan)(e);
              this._executeResponseHook(e, t);
            },
            (t) => {
              (0, l.endSpan)(e, t);
            }
          );
        else {
          if ('function' != typeof r.responseHook) return void (0, l.endSpan)(e);
          this._executeResponseHook(e, n);
        }
      }
      _executeResponseHook(e, t) {
        let { responseHook: n } = this.getConfig();
        n &&
          (0, i.safeExecuteInTheMiddle)(
            () => {
              n(e, t);
            },
            (t) => {
              (t && this._diag.error('Error running response hook', t), (0, l.endSpan)(e, void 0));
            },
            !0
          );
      }
      _patchParse() {
        let e = this;
        return function (t) {
          return function (n, r) {
            return e._parse(this, t, n, r);
          };
        };
      }
      _patchValidate() {
        let e = this;
        return function (t) {
          return function (n, r, i, o, a) {
            return e._validate(this, t, n, r, i, a, o);
          };
        };
      }
      _parse(e, t, n, a) {
        let s = this.getConfig(),
          u = this.tracer.startSpan(o.SpanNames.PARSE);
        return r.context.with(r.trace.setSpan(r.context.active(), u), () =>
          (0, i.safeExecuteInTheMiddle)(
            () => t.call(e, n, a),
            (e, t) => {
              (t &&
                ((0, l.getOperation)(t)
                  ? t.loc && (0, l.addSpanSource)(u, t.loc, s.allowValues)
                  : u.updateName(o.SpanNames.SCHEMA_PARSE)),
                (0, l.endSpan)(u, e));
            }
          )
        );
      }
      _validate(e, t, n, s, u, c, d) {
        let p = this.tracer.startSpan(o.SpanNames.VALIDATE, {});
        return r.context.with(r.trace.setSpan(r.context.active(), p), () =>
          (0, i.safeExecuteInTheMiddle)(
            () => t.call(e, n, s, u, d, c),
            (e, t) => {
              (s.loc || p.updateName(o.SpanNames.SCHEMA_VALIDATE),
                t &&
                  t.length &&
                  p.recordException({
                    name: a.AttributeNames.ERROR_VALIDATION_NAME,
                    message: JSON.stringify(t),
                  }),
                (0, l.endSpan)(p, e));
            }
          )
        );
      }
      _createExecuteSpan(e, t) {
        let n = this.getConfig(),
          r = this.tracer.startSpan(o.SpanNames.EXECUTE, {});
        if (e) {
          let { operation: t, name: n } = e;
          r.setAttribute(a.AttributeNames.OPERATION_TYPE, t);
          let i = n?.value;
          i
            ? (r.setAttribute(a.AttributeNames.OPERATION_NAME, i), r.updateName(`${t} ${i}`))
            : r.updateName(t);
        } else {
          let e = ' ';
          (t.operationName && (e = ` "${t.operationName}" `),
            (e = u.OPERATION_NOT_SUPPORTED.replace('$operationName$', e)),
            r.setAttribute(a.AttributeNames.OPERATION_NAME, e));
        }
        return (
          t.document?.loc && (0, l.addSpanSource)(r, t.document.loc, n.allowValues),
          t.variableValues &&
            n.allowValues &&
            (0, l.addInputVariableAttributes)(r, t.variableValues),
          r
        );
      }
      _wrapExecuteArgs(e, t, n, r, i, o, a, u, c) {
        if ((r || (r = {}), r[s.OTEL_GRAPHQL_DATA_SYMBOL] || this.getConfig().ignoreResolveSpans))
          return {
            schema: e,
            document: t,
            rootValue: n,
            contextValue: r,
            variableValues: i,
            operationName: o,
            fieldResolver: a,
            typeResolver: u,
          };
        let d = null == a,
          p = a ?? c;
        return (
          (a = (0, l.wrapFieldResolver)(this.tracer, () => this.getConfig(), p, d)),
          e &&
            ((0, l.wrapFields)(e.getQueryType(), this.tracer, () => this.getConfig()),
            (0, l.wrapFields)(e.getMutationType(), this.tracer, () => this.getConfig())),
          {
            schema: e,
            document: t,
            rootValue: n,
            contextValue: r,
            variableValues: i,
            operationName: o,
            fieldResolver: a,
            typeResolver: u,
          }
        );
      }
    }
    n.GraphQLInstrumentation = _;
  },
  79148,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.GraphQLInstrumentation = void 0));
    var r = e.r(63817);
    Object.defineProperty(n, 'GraphQLInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.GraphQLInstrumentation;
      },
    });
  },
  9832,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(79148),
      o = e.r(48009),
      a = e.r(15527),
      s = e.r(52780),
      u = 'Graphql',
      l = a.generateInstrumentOnce(u, i.GraphQLInstrumentation, (e) => {
        let t = c(e);
        return {
          ...t,
          responseHook(e, n) {
            (a.addOriginToSpan(e, 'auto.graphql.otel.graphql'),
              n.errors?.length &&
                !o.spanToJSON(e).status &&
                e.setStatus({ code: r.SpanStatusCode.ERROR }));
            let i = o.spanToJSON(e).data,
              u = i['graphql.operation.type'],
              l = i['graphql.operation.name'];
            if (t.useOperationNameForRootSpan && u) {
              let t = o.getRootSpan(e),
                n = o.spanToJSON(t).data[s.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION] || [],
                r = l ? `${u} ${l}` : `${u}`;
              (Array.isArray(n)
                ? (n.push(r), t.setAttribute(s.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, n))
                : 'string' == typeof n
                  ? t.setAttribute(s.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, [n, r])
                  : t.setAttribute(s.SEMANTIC_ATTRIBUTE_SENTRY_GRAPHQL_OPERATION, r),
                o.spanToJSON(t).data['original-description'] ||
                  t.setAttribute('original-description', o.spanToJSON(t).description),
                t.updateName(
                  `${o.spanToJSON(t).data['original-description']} (${(function (e) {
                    if (Array.isArray(e)) {
                      let t = e.slice().sort();
                      return t.length <= 5
                        ? t.join(', ')
                        : `${t.slice(0, 5).join(', ')}, +${t.length - 5}`;
                    }
                    return `${e}`;
                  })(n)})`
                ));
            }
          },
        };
      });
    function c(e) {
      return {
        ignoreResolveSpans: !0,
        ignoreTrivialResolveSpans: !0,
        useOperationNameForRootSpan: !0,
        ...e,
      };
    }
    ((n.graphqlIntegration = o.defineIntegration((e = {}) => ({
      name: u,
      setupOnce() {
        l(c(e));
      },
    }))),
      (n.instrumentGraphql = l));
  },
  8310,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.EVENT_LISTENERS_SET = void 0),
      (n.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.kafkajs.eventListenersSet')));
  },
  53985,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.bufferTextMapGetter = void 0),
      (n.bufferTextMapGetter = {
        get(e, t) {
          if (e) {
            for (let n of Object.keys(e))
              if (n === t || n.toLowerCase() === t) return e[n]?.toString();
          }
        },
        keys: (e) => (e ? Object.keys(e) : []),
      }));
  },
  37681,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.METRIC_MESSAGING_PROCESS_DURATION =
        n.METRIC_MESSAGING_CLIENT_SENT_MESSAGES =
        n.METRIC_MESSAGING_CLIENT_OPERATION_DURATION =
        n.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES =
        n.MESSAGING_SYSTEM_VALUE_KAFKA =
        n.MESSAGING_OPERATION_TYPE_VALUE_SEND =
        n.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE =
        n.MESSAGING_OPERATION_TYPE_VALUE_PROCESS =
        n.ATTR_MESSAGING_SYSTEM =
        n.ATTR_MESSAGING_OPERATION_TYPE =
        n.ATTR_MESSAGING_OPERATION_NAME =
        n.ATTR_MESSAGING_KAFKA_OFFSET =
        n.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE =
        n.ATTR_MESSAGING_KAFKA_MESSAGE_KEY =
        n.ATTR_MESSAGING_DESTINATION_PARTITION_ID =
        n.ATTR_MESSAGING_DESTINATION_NAME =
        n.ATTR_MESSAGING_BATCH_MESSAGE_COUNT =
          void 0),
      (n.ATTR_MESSAGING_BATCH_MESSAGE_COUNT = 'messaging.batch.message_count'),
      (n.ATTR_MESSAGING_DESTINATION_NAME = 'messaging.destination.name'),
      (n.ATTR_MESSAGING_DESTINATION_PARTITION_ID = 'messaging.destination.partition.id'),
      (n.ATTR_MESSAGING_KAFKA_MESSAGE_KEY = 'messaging.kafka.message.key'),
      (n.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE = 'messaging.kafka.message.tombstone'),
      (n.ATTR_MESSAGING_KAFKA_OFFSET = 'messaging.kafka.offset'),
      (n.ATTR_MESSAGING_OPERATION_NAME = 'messaging.operation.name'),
      (n.ATTR_MESSAGING_OPERATION_TYPE = 'messaging.operation.type'),
      (n.ATTR_MESSAGING_SYSTEM = 'messaging.system'),
      (n.MESSAGING_OPERATION_TYPE_VALUE_PROCESS = 'process'),
      (n.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE = 'receive'),
      (n.MESSAGING_OPERATION_TYPE_VALUE_SEND = 'send'),
      (n.MESSAGING_SYSTEM_VALUE_KAFKA = 'kafka'),
      (n.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES = 'messaging.client.consumed.messages'),
      (n.METRIC_MESSAGING_CLIENT_OPERATION_DURATION = 'messaging.client.operation.duration'),
      (n.METRIC_MESSAGING_CLIENT_SENT_MESSAGES = 'messaging.client.sent.messages'),
      (n.METRIC_MESSAGING_PROCESS_DURATION = 'messaging.process.duration'));
  },
  24202,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.13.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-kafkajs'));
  },
  96302,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.KafkaJsInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(8310),
      s = e.r(53985),
      u = e.r(37681),
      l = e.r(24202);
    function c(e, t, n) {
      return (r) => {
        e.add(t, { ...n, ...(r ? { [o.ATTR_ERROR_TYPE]: r } : {}) });
      };
    }
    function d(e, t, n) {
      return (r) => {
        e.record((Date.now() - t) / 1e3, { ...n, ...(r ? { [o.ATTR_ERROR_TYPE]: r } : {}) });
      };
    }
    let p = [0.005, 0.01, 0.025, 0.05, 0.075, 0.1, 0.25, 0.5, 0.75, 1, 2.5, 5, 7.5, 10];
    class _ extends i.InstrumentationBase {
      constructor(e = {}) {
        super(l.PACKAGE_NAME, l.PACKAGE_VERSION, e);
      }
      _updateMetricInstruments() {
        ((this._clientDuration = this.meter.createHistogram(
          u.METRIC_MESSAGING_CLIENT_OPERATION_DURATION,
          { advice: { explicitBucketBoundaries: p } }
        )),
          (this._sentMessages = this.meter.createCounter(u.METRIC_MESSAGING_CLIENT_SENT_MESSAGES)),
          (this._consumedMessages = this.meter.createCounter(
            u.METRIC_MESSAGING_CLIENT_CONSUMED_MESSAGES
          )),
          (this._processDuration = this.meter.createHistogram(u.METRIC_MESSAGING_PROCESS_DURATION, {
            advice: { explicitBucketBoundaries: p },
          })));
      }
      init() {
        let e = (e) => {
          ((0, i.isWrapped)(e?.Kafka?.prototype.producer) &&
            this._unwrap(e.Kafka.prototype, 'producer'),
            (0, i.isWrapped)(e?.Kafka?.prototype.consumer) &&
              this._unwrap(e.Kafka.prototype, 'consumer'));
        };
        return new i.InstrumentationNodeModuleDefinition(
          'kafkajs',
          ['>=0.3.0 <3'],
          (t) => (
            e(t),
            this._wrap(t?.Kafka?.prototype, 'producer', this._getProducerPatch()),
            this._wrap(t?.Kafka?.prototype, 'consumer', this._getConsumerPatch()),
            t
          ),
          e
        );
      }
      _getConsumerPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let r = t.apply(this, n);
            return (
              (0, i.isWrapped)(r.run) && e._unwrap(r, 'run'),
              e._wrap(r, 'run', e._getConsumerRunPatch()),
              e._setKafkaEventListeners(r),
              r
            );
          };
      }
      _setKafkaEventListeners(e) {
        e[a.EVENT_LISTENERS_SET] ||
          (e.events?.REQUEST && e.on(e.events.REQUEST, this._recordClientDurationMetric.bind(this)),
          (e[a.EVENT_LISTENERS_SET] = !0));
      }
      _recordClientDurationMetric(e) {
        let [t, n] = e.payload.broker.split(':');
        this._clientDuration.record(e.payload.duration / 1e3, {
          [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
          [u.ATTR_MESSAGING_OPERATION_NAME]: `${e.payload.apiName}`,
          [o.ATTR_SERVER_ADDRESS]: t,
          [o.ATTR_SERVER_PORT]: Number.parseInt(n, 10),
        });
      }
      _getProducerPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let r = t.apply(this, n);
            return (
              (0, i.isWrapped)(r.sendBatch) && e._unwrap(r, 'sendBatch'),
              e._wrap(r, 'sendBatch', e._getSendBatchPatch()),
              (0, i.isWrapped)(r.send) && e._unwrap(r, 'send'),
              e._wrap(r, 'send', e._getSendPatch()),
              (0, i.isWrapped)(r.transaction) && e._unwrap(r, 'transaction'),
              e._wrap(r, 'transaction', e._getProducerTransactionPatch()),
              e._setKafkaEventListeners(r),
              r
            );
          };
      }
      _getConsumerRunPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let r = n[0];
            return (
              r?.eachMessage &&
                ((0, i.isWrapped)(r.eachMessage) && e._unwrap(r, 'eachMessage'),
                e._wrap(r, 'eachMessage', e._getConsumerEachMessagePatch())),
              r?.eachBatch &&
                ((0, i.isWrapped)(r.eachBatch) && e._unwrap(r, 'eachBatch'),
                e._wrap(r, 'eachBatch', e._getConsumerEachBatchPatch())),
              t.call(this, r)
            );
          };
      }
      _getConsumerEachMessagePatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let i = n[0],
              o = r.propagation.extract(r.ROOT_CONTEXT, i.message.headers, s.bufferTextMapGetter),
              a = e._startConsumerSpan({
                topic: i.topic,
                message: i.message,
                operationType: u.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
                ctx: o,
                attributes: { [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.partition) },
              }),
              l = [
                d(e._processDuration, Date.now(), {
                  [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                  [u.ATTR_MESSAGING_OPERATION_NAME]: 'process',
                  [u.ATTR_MESSAGING_DESTINATION_NAME]: i.topic,
                  [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.partition),
                }),
                c(e._consumedMessages, 1, {
                  [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                  [u.ATTR_MESSAGING_OPERATION_NAME]: 'process',
                  [u.ATTR_MESSAGING_DESTINATION_NAME]: i.topic,
                  [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.partition),
                }),
              ],
              p = r.context.with(r.trace.setSpan(o, a), () => t.apply(this, n));
            return e._endSpansOnPromise([a], l, p);
          };
      }
      _getConsumerEachBatchPatch() {
        return (e) => {
          let t = this;
          return function (...n) {
            let i = n[0],
              o = t._startConsumerSpan({
                topic: i.batch.topic,
                message: void 0,
                operationType: u.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE,
                ctx: r.ROOT_CONTEXT,
                attributes: {
                  [u.ATTR_MESSAGING_BATCH_MESSAGE_COUNT]: i.batch.messages.length,
                  [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.batch.partition),
                },
              });
            return r.context.with(r.trace.setSpan(r.context.active(), o), () => {
              let a = Date.now(),
                l = [],
                p = [
                  c(t._consumedMessages, i.batch.messages.length, {
                    [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                    [u.ATTR_MESSAGING_OPERATION_NAME]: 'process',
                    [u.ATTR_MESSAGING_DESTINATION_NAME]: i.batch.topic,
                    [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.batch.partition),
                  }),
                ];
              i.batch.messages.forEach((e) => {
                let n,
                  o = r.propagation.extract(r.ROOT_CONTEXT, e.headers, s.bufferTextMapGetter),
                  c = r.trace.getSpan(o)?.spanContext();
                (c && (n = { context: c }),
                  l.push(
                    t._startConsumerSpan({
                      topic: i.batch.topic,
                      message: e,
                      operationType: u.MESSAGING_OPERATION_TYPE_VALUE_PROCESS,
                      link: n,
                      attributes: {
                        [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.batch.partition),
                      },
                    })
                  ),
                  p.push(
                    d(t._processDuration, a, {
                      [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                      [u.ATTR_MESSAGING_OPERATION_NAME]: 'process',
                      [u.ATTR_MESSAGING_DESTINATION_NAME]: i.batch.topic,
                      [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(i.batch.partition),
                    })
                  ));
              });
              let _ = e.apply(this, n);
              return (l.unshift(o), t._endSpansOnPromise(l, p, _));
            });
          };
        };
      }
      _getProducerTransactionPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let i = e.tracer.startSpan('transaction'),
              o = t.apply(this, n);
            return (
              o
                .then((t) => {
                  let n = t.send;
                  t.send = function (...t) {
                    return r.context.with(r.trace.setSpan(r.context.active(), i), () =>
                      e
                        ._getSendPatch()(n)
                        .apply(this, t)
                        .catch((e) => {
                          throw (
                            i.setStatus({ code: r.SpanStatusCode.ERROR, message: e?.message }),
                            i.recordException(e),
                            e
                          );
                        })
                    );
                  };
                  let o = t.sendBatch;
                  t.sendBatch = function (...t) {
                    return r.context.with(r.trace.setSpan(r.context.active(), i), () =>
                      e
                        ._getSendBatchPatch()(o)
                        .apply(this, t)
                        .catch((e) => {
                          throw (
                            i.setStatus({ code: r.SpanStatusCode.ERROR, message: e?.message }),
                            i.recordException(e),
                            e
                          );
                        })
                    );
                  };
                  let a = t.commit;
                  t.commit = function (...t) {
                    let n = a.apply(this, t).then(() => {
                      i.setStatus({ code: r.SpanStatusCode.OK });
                    });
                    return e._endSpansOnPromise([i], [], n);
                  };
                  let s = t.abort;
                  t.abort = function (...t) {
                    let n = s.apply(this, t);
                    return e._endSpansOnPromise([i], [], n);
                  };
                })
                .catch((e) => {
                  (i.setStatus({ code: r.SpanStatusCode.ERROR, message: e?.message }),
                    i.recordException(e),
                    i.end());
                }),
              o
            );
          };
      }
      _getSendBatchPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let r = n[0].topicMessages || [],
              i = [],
              o = [];
            r.forEach((t) => {
              t.messages.forEach((n) => {
                (i.push(e._startProducerSpan(t.topic, n)),
                  o.push(
                    c(e._sentMessages, 1, {
                      [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                      [u.ATTR_MESSAGING_OPERATION_NAME]: 'send',
                      [u.ATTR_MESSAGING_DESTINATION_NAME]: t.topic,
                      ...(void 0 !== n.partition
                        ? { [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(n.partition) }
                        : {}),
                    })
                  ));
              });
            });
            let a = t.apply(this, n);
            return e._endSpansOnPromise(i, o, a);
          };
      }
      _getSendPatch() {
        let e = this;
        return (t) =>
          function (...n) {
            let r = n[0],
              i = r.messages.map((t) => e._startProducerSpan(r.topic, t)),
              o = r.messages.map((t) =>
                c(e._sentMessages, 1, {
                  [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                  [u.ATTR_MESSAGING_OPERATION_NAME]: 'send',
                  [u.ATTR_MESSAGING_DESTINATION_NAME]: r.topic,
                  ...(void 0 !== t.partition
                    ? { [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]: String(t.partition) }
                    : {}),
                })
              ),
              a = t.apply(this, n);
            return e._endSpansOnPromise(i, o, a);
          };
      }
      _endSpansOnPromise(e, t, n) {
        return Promise.resolve(n)
          .then((e) => (t.forEach((e) => e()), e))
          .catch((n) => {
            let i,
              a = o.ERROR_TYPE_VALUE_OTHER;
            throw (
              'string' == typeof n || void 0 === n
                ? (i = n)
                : 'object' == typeof n &&
                  Object.prototype.hasOwnProperty.call(n, 'message') &&
                  ((i = n.message), (a = n.constructor.name)),
              t.forEach((e) => e(a)),
              e.forEach((e) => {
                (e.setAttribute(o.ATTR_ERROR_TYPE, a),
                  e.setStatus({ code: r.SpanStatusCode.ERROR, message: i }));
              }),
              n
            );
          })
          .finally(() => {
            e.forEach((e) => e.end());
          });
      }
      _startConsumerSpan({
        topic: e,
        message: t,
        operationType: n,
        ctx: o,
        link: a,
        attributes: s,
      }) {
        let l = n === u.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE ? 'poll' : n,
          c = this.tracer.startSpan(
            `${l} ${e}`,
            {
              kind:
                n === u.MESSAGING_OPERATION_TYPE_VALUE_RECEIVE
                  ? r.SpanKind.CLIENT
                  : r.SpanKind.CONSUMER,
              attributes: {
                ...s,
                [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
                [u.ATTR_MESSAGING_DESTINATION_NAME]: e,
                [u.ATTR_MESSAGING_OPERATION_TYPE]: n,
                [u.ATTR_MESSAGING_OPERATION_NAME]: l,
                [u.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: t?.key ? String(t.key) : void 0,
                [u.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]:
                  (!!t?.key && null === t.value) || void 0,
                [u.ATTR_MESSAGING_KAFKA_OFFSET]: t?.offset,
              },
              links: a ? [a] : [],
            },
            o
          ),
          { consumerHook: d } = this.getConfig();
        return (
          d &&
            t &&
            (0, i.safeExecuteInTheMiddle)(
              () => d(c, { topic: e, message: t }),
              (e) => {
                e && this._diag.error('consumerHook error', e);
              },
              !0
            ),
          c
        );
      }
      _startProducerSpan(e, t) {
        let n = this.tracer.startSpan(`send ${e}`, {
          kind: r.SpanKind.PRODUCER,
          attributes: {
            [u.ATTR_MESSAGING_SYSTEM]: u.MESSAGING_SYSTEM_VALUE_KAFKA,
            [u.ATTR_MESSAGING_DESTINATION_NAME]: e,
            [u.ATTR_MESSAGING_KAFKA_MESSAGE_KEY]: t.key ? String(t.key) : void 0,
            [u.ATTR_MESSAGING_KAFKA_MESSAGE_TOMBSTONE]: (!!t.key && null === t.value) || void 0,
            [u.ATTR_MESSAGING_DESTINATION_PARTITION_ID]:
              void 0 !== t.partition ? String(t.partition) : void 0,
            [u.ATTR_MESSAGING_OPERATION_NAME]: 'send',
            [u.ATTR_MESSAGING_OPERATION_TYPE]: u.MESSAGING_OPERATION_TYPE_VALUE_SEND,
          },
        });
        ((t.headers = t.headers ?? {}),
          r.propagation.inject(r.trace.setSpan(r.context.active(), n), t.headers));
        let { producerHook: o } = this.getConfig();
        return (
          o &&
            (0, i.safeExecuteInTheMiddle)(
              () => o(n, { topic: e, message: t }),
              (e) => {
                e && this._diag.error('producerHook error', e);
              },
              !0
            ),
          n
        );
      }
    }
    n.KafkaJsInstrumentation = _;
  },
  1489,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.KafkaJsInstrumentation = void 0));
    var r = e.r(96302);
    Object.defineProperty(n, 'KafkaJsInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.KafkaJsInstrumentation;
      },
    });
  },
  43523,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(1489),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Kafka',
      s = o.generateInstrumentOnce(
        a,
        () =>
          new r.KafkaJsInstrumentation({
            consumerHook(e) {
              o.addOriginToSpan(e, 'auto.kafkajs.otel.consumer');
            },
            producerHook(e) {
              o.addOriginToSpan(e, 'auto.kafkajs.otel.producer');
            },
          })
      ),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentKafka = s), (n.kafkaIntegration = u));
  },
  50988,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.48.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-lru-memoizer'));
  },
  73399,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.LruMemoizerInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(50988);
    class a extends i.InstrumentationBase {
      constructor(e = {}) {
        super(o.PACKAGE_NAME, o.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new i.InstrumentationNodeModuleDefinition(
            'lru-memoizer',
            ['>=1.3 <3'],
            (e) => {
              let t = function () {
                let t = e.apply(this, arguments);
                return function () {
                  let e = [...arguments],
                    n = e.pop(),
                    i = 'function' == typeof n ? r.context.bind(r.context.active(), n) : n;
                  return (e.push(i), t.apply(this, e));
                };
              };
              return ((t.sync = e.sync), t);
            },
            void 0
          ),
        ];
      }
    }
    n.LruMemoizerInstrumentation = a;
  },
  33151,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.LruMemoizerInstrumentation = void 0));
    var r = e.r(73399);
    Object.defineProperty(n, 'LruMemoizerInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.LruMemoizerInstrumentation;
      },
    });
  },
  54688,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(33151),
      i = e.r(48009),
      o = e.r(15527),
      a = 'LruMemoizer',
      s = o.generateInstrumentOnce(a, () => new r.LruMemoizerInstrumentation()),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentLruMemoizer = s), (n.lruMemoizerIntegration = u));
  },
  81458,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MongodbCommandType = void 0),
      (function (e) {
        ((e.CREATE_INDEXES = 'createIndexes'),
          (e.FIND_AND_MODIFY = 'findAndModify'),
          (e.IS_MASTER = 'isMaster'),
          (e.COUNT = 'count'),
          (e.AGGREGATE = 'aggregate'),
          (e.UNKNOWN = 'unknown'));
      })(n.MongodbCommandType || (n.MongodbCommandType = {})));
  },
  56157,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.56.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-mongodb'));
  },
  70106,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MongoDBInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(81458),
      s = e.r(56157),
      u = { requireParentSpan: !0 };
    class l extends i.InstrumentationBase {
      constructor(e = {}) {
        super(s.PACKAGE_NAME, s.PACKAGE_VERSION, { ...u, ...e });
      }
      setConfig(e = {}) {
        super.setConfig({ ...u, ...e });
      }
      _updateMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter('db.client.connections.usage', {
          description:
            'The number of connections that are currently in state described by the state attribute.',
          unit: '{connection}',
        });
      }
      init() {
        let { v3PatchConnection: e, v3UnpatchConnection: t } = this._getV3ConnectionPatches(),
          { v4PatchConnect: n, v4UnpatchConnect: r } = this._getV4ConnectPatches(),
          {
            v4PatchConnectionCallback: o,
            v4PatchConnectionPromise: a,
            v4UnpatchConnection: s,
          } = this._getV4ConnectionPatches(),
          { v4PatchConnectionPool: u, v4UnpatchConnectionPool: l } =
            this._getV4ConnectionPoolPatches(),
          { v4PatchSessions: c, v4UnpatchSessions: d } = this._getV4SessionsPatches();
        return [
          new i.InstrumentationNodeModuleDefinition('mongodb', ['>=3.3.0 <4'], void 0, void 0, [
            new i.InstrumentationNodeModuleFile(
              'mongodb/lib/core/wireprotocol/index.js',
              ['>=3.3.0 <4'],
              e,
              t
            ),
          ]),
          new i.InstrumentationNodeModuleDefinition('mongodb', ['>=4.0.0 <7'], void 0, void 0, [
            new i.InstrumentationNodeModuleFile(
              'mongodb/lib/cmap/connection.js',
              ['>=4.0.0 <6.4'],
              o,
              s
            ),
            new i.InstrumentationNodeModuleFile(
              'mongodb/lib/cmap/connection.js',
              ['>=6.4.0 <7'],
              a,
              s
            ),
            new i.InstrumentationNodeModuleFile(
              'mongodb/lib/cmap/connection_pool.js',
              ['>=4.0.0 <6.4'],
              u,
              l
            ),
            new i.InstrumentationNodeModuleFile(
              'mongodb/lib/cmap/connect.js',
              ['>=4.0.0 <7'],
              n,
              r
            ),
            new i.InstrumentationNodeModuleFile('mongodb/lib/sessions.js', ['>=4.0.0 <7'], c, d),
          ]),
        ];
      }
      _getV3ConnectionPatches() {
        return {
          v3PatchConnection: (e) => (
            (0, i.isWrapped)(e.insert) && this._unwrap(e, 'insert'),
            this._wrap(e, 'insert', this._getV3PatchOperation('insert')),
            (0, i.isWrapped)(e.remove) && this._unwrap(e, 'remove'),
            this._wrap(e, 'remove', this._getV3PatchOperation('remove')),
            (0, i.isWrapped)(e.update) && this._unwrap(e, 'update'),
            this._wrap(e, 'update', this._getV3PatchOperation('update')),
            (0, i.isWrapped)(e.command) && this._unwrap(e, 'command'),
            this._wrap(e, 'command', this._getV3PatchCommand()),
            (0, i.isWrapped)(e.query) && this._unwrap(e, 'query'),
            this._wrap(e, 'query', this._getV3PatchFind()),
            (0, i.isWrapped)(e.getMore) && this._unwrap(e, 'getMore'),
            this._wrap(e, 'getMore', this._getV3PatchCursor()),
            e
          ),
          v3UnpatchConnection: (e) => {
            void 0 !== e &&
              (this._unwrap(e, 'insert'),
              this._unwrap(e, 'remove'),
              this._unwrap(e, 'update'),
              this._unwrap(e, 'command'),
              this._unwrap(e, 'query'),
              this._unwrap(e, 'getMore'));
          },
        };
      }
      _getV4SessionsPatches() {
        return {
          v4PatchSessions: (e) => (
            (0, i.isWrapped)(e.acquire) && this._unwrap(e, 'acquire'),
            this._wrap(e.ServerSessionPool.prototype, 'acquire', this._getV4AcquireCommand()),
            (0, i.isWrapped)(e.release) && this._unwrap(e, 'release'),
            this._wrap(e.ServerSessionPool.prototype, 'release', this._getV4ReleaseCommand()),
            e
          ),
          v4UnpatchSessions: (e) => {
            void 0 !== e &&
              ((0, i.isWrapped)(e.acquire) && this._unwrap(e, 'acquire'),
              (0, i.isWrapped)(e.release) && this._unwrap(e, 'release'));
          },
        };
      }
      _getV4AcquireCommand() {
        let e = this;
        return (t) =>
          function () {
            let n = this.sessions.length,
              r = t.call(this),
              i = this.sessions.length;
            return (
              n === i
                ? e._connectionsUsage.add(1, { state: 'used', 'pool.name': e._poolName })
                : n - 1 === i &&
                  (e._connectionsUsage.add(-1, { state: 'idle', 'pool.name': e._poolName }),
                  e._connectionsUsage.add(1, { state: 'used', 'pool.name': e._poolName })),
              r
            );
          };
      }
      _getV4ReleaseCommand() {
        let e = this;
        return (t) =>
          function (n) {
            let r = t.call(this, n);
            return (
              e._connectionsUsage.add(-1, { state: 'used', 'pool.name': e._poolName }),
              e._connectionsUsage.add(1, { state: 'idle', 'pool.name': e._poolName }),
              r
            );
          };
      }
      _getV4ConnectionPoolPatches() {
        return {
          v4PatchConnectionPool: (e) => {
            let t = e.ConnectionPool.prototype;
            return (
              (0, i.isWrapped)(t.checkOut) && this._unwrap(t, 'checkOut'),
              this._wrap(t, 'checkOut', this._getV4ConnectionPoolCheckOut()),
              e
            );
          },
          v4UnpatchConnectionPool: (e) => {
            void 0 !== e && this._unwrap(e.ConnectionPool.prototype, 'checkOut');
          },
        };
      }
      _getV4ConnectPatches() {
        return {
          v4PatchConnect: (e) => (
            (0, i.isWrapped)(e.connect) && this._unwrap(e, 'connect'),
            this._wrap(e, 'connect', this._getV4ConnectCommand()),
            e
          ),
          v4UnpatchConnect: (e) => {
            void 0 !== e && this._unwrap(e, 'connect');
          },
        };
      }
      _getV4ConnectionPoolCheckOut() {
        return (e) =>
          function (t) {
            let n = r.context.bind(r.context.active(), t);
            return e.call(this, n);
          };
      }
      _getV4ConnectCommand() {
        let e = this;
        return (t) =>
          function (n, r) {
            if (1 === t.length) {
              let r = t.call(this, n);
              return (
                r &&
                  'function' == typeof r.then &&
                  r.then(
                    () => e.setPoolName(n),
                    () => void 0
                  ),
                r
              );
            }
            return t.call(this, n, function (t, i) {
              if (t || !i) return void r(t, i);
              (e.setPoolName(n), r(t, i));
            });
          };
      }
      _getV4ConnectionPatches() {
        return {
          v4PatchConnectionCallback: (e) => (
            (0, i.isWrapped)(e.Connection.prototype.command) &&
              this._unwrap(e.Connection.prototype, 'command'),
            this._wrap(e.Connection.prototype, 'command', this._getV4PatchCommandCallback()),
            e
          ),
          v4PatchConnectionPromise: (e) => (
            (0, i.isWrapped)(e.Connection.prototype.command) &&
              this._unwrap(e.Connection.prototype, 'command'),
            this._wrap(e.Connection.prototype, 'command', this._getV4PatchCommandPromise()),
            e
          ),
          v4UnpatchConnection: (e) => {
            void 0 !== e && this._unwrap(e.Connection.prototype, 'command');
          },
        };
      }
      _getV3PatchOperation(e) {
        let t = this;
        return (n) =>
          function (i, o, a, s, u) {
            let l = r.trace.getSpan(r.context.active()),
              c = t._checkSkipInstrumentation(l),
              d = 'function' == typeof s ? s : u;
            if (c || 'function' != typeof d || 'object' != typeof a)
              if ('function' == typeof s) return n.call(this, i, o, a, s);
              else return n.call(this, i, o, a, s, u);
            let p = t.tracer.startSpan(`mongodb.${e}`, { kind: r.SpanKind.CLIENT });
            t._populateV3Attributes(p, o, i, a[0], e);
            let _ = t._patchEnd(p, d);
            return 'function' == typeof s ? n.call(this, i, o, a, _) : n.call(this, i, o, a, s, _);
          };
      }
      _getV3PatchCommand() {
        let e = this;
        return (t) =>
          function (n, i, o, s, u) {
            let c = r.trace.getSpan(r.context.active()),
              d = e._checkSkipInstrumentation(c),
              p = 'function' == typeof s ? s : u;
            if (d || 'function' != typeof p || 'object' != typeof o)
              if ('function' == typeof s) return t.call(this, n, i, o, s);
              else return t.call(this, n, i, o, s, u);
            let _ = l._getCommandType(o),
              S = _ === a.MongodbCommandType.UNKNOWN ? 'command' : _,
              E = e.tracer.startSpan(`mongodb.${S}`, { kind: r.SpanKind.CLIENT }),
              T = _ === a.MongodbCommandType.UNKNOWN ? void 0 : _;
            e._populateV3Attributes(E, i, n, o, T);
            let m = e._patchEnd(E, p);
            return 'function' == typeof s ? t.call(this, n, i, o, m) : t.call(this, n, i, o, s, m);
          };
      }
      _getV4PatchCommandCallback() {
        let e = this;
        return (t) =>
          function (n, i, o, a) {
            let s,
              u = r.trace.getSpan(r.context.active()),
              l = e._checkSkipInstrumentation(u),
              c = Object.keys(i)[0];
            if ('object' != typeof i || i.ismaster || i.hello) return t.call(this, n, i, o, a);
            l ||
              ((s = e.tracer.startSpan(`mongodb.${c}`, { kind: r.SpanKind.CLIENT })),
              e._populateV4Attributes(s, this, n, i, c));
            let d = e._patchEnd(s, a, this.id, c);
            return t.call(this, n, i, o, d);
          };
      }
      _getV4PatchCommandPromise() {
        let e = this;
        return (t) =>
          function (...n) {
            let i,
              [o, a] = n,
              s = r.trace.getSpan(r.context.active()),
              u = e._checkSkipInstrumentation(s),
              l = Object.keys(a)[0];
            if ('object' != typeof a || a.ismaster || a.hello) return t.apply(this, n);
            u ||
              ((i = e.tracer.startSpan(`mongodb.${l}`, { kind: r.SpanKind.CLIENT })),
              e._populateV4Attributes(i, this, o, a, l));
            let c = e._patchEnd(i, () => void 0, this.id, l),
              d = t.apply(this, n);
            return (
              d.then(
                (e) => c(null, e),
                (e) => c(e)
              ),
              d
            );
          };
      }
      _getV3PatchFind() {
        let e = this;
        return (t) =>
          function (n, i, o, a, s, u) {
            let l = r.trace.getSpan(r.context.active()),
              c = e._checkSkipInstrumentation(l),
              d = 'function' == typeof s ? s : u;
            if (c || 'function' != typeof d || 'object' != typeof o)
              if ('function' == typeof s) return t.call(this, n, i, o, a, s);
              else return t.call(this, n, i, o, a, s, u);
            let p = e.tracer.startSpan('mongodb.find', { kind: r.SpanKind.CLIENT });
            e._populateV3Attributes(p, i, n, o, 'find');
            let _ = e._patchEnd(p, d);
            return 'function' == typeof s
              ? t.call(this, n, i, o, a, _)
              : t.call(this, n, i, o, a, s, _);
          };
      }
      _getV3PatchCursor() {
        let e = this;
        return (t) =>
          function (n, i, o, a, s, u) {
            let l = r.trace.getSpan(r.context.active()),
              c = e._checkSkipInstrumentation(l),
              d = 'function' == typeof s ? s : u;
            if (c || 'function' != typeof d)
              if ('function' == typeof s) return t.call(this, n, i, o, a, s);
              else return t.call(this, n, i, o, a, s, u);
            let p = e.tracer.startSpan('mongodb.getMore', { kind: r.SpanKind.CLIENT });
            e._populateV3Attributes(p, i, n, o.cmd, 'getMore');
            let _ = e._patchEnd(p, d);
            return 'function' == typeof s
              ? t.call(this, n, i, o, a, _)
              : t.call(this, n, i, o, a, s, _);
          };
      }
      static _getCommandType(e) {
        if (void 0 !== e.createIndexes) return a.MongodbCommandType.CREATE_INDEXES;
        if (void 0 !== e.findandmodify) return a.MongodbCommandType.FIND_AND_MODIFY;
        if (void 0 !== e.ismaster) return a.MongodbCommandType.IS_MASTER;
        if (void 0 !== e.count) return a.MongodbCommandType.COUNT;
        if (void 0 !== e.aggregate) return a.MongodbCommandType.AGGREGATE;
        else return a.MongodbCommandType.UNKNOWN;
      }
      _populateV4Attributes(e, t, n, r, i) {
        let o, a, s;
        if (t) {
          let e = 'string' == typeof t.address ? t.address.split(':') : '';
          2 === e.length && ((o = e[0]), (a = e[1]));
        }
        ((s = r?.documents && r.documents[0] ? r.documents[0] : r?.cursors ? r.cursors : r),
          this._addAllSpanAttributes(e, n.db, n.collection, o, a, s, i));
      }
      _populateV3Attributes(e, t, n, r, i) {
        let o, a;
        if (
          n &&
          n.s &&
          ((o = n.s.options?.host ?? n.s.host),
          (a = (n.s.options?.port ?? n.s.port)?.toString()),
          null == o || null == a)
        ) {
          let e = n.description?.address;
          if (e) {
            let t = e.split(':');
            ((o = t[0]), (a = t[1]));
          }
        }
        let [s, u] = t.toString().split('.'),
          l = r?.query ?? r?.q ?? r;
        this._addAllSpanAttributes(e, s, u, o, a, l, i);
      }
      _addAllSpanAttributes(e, t, n, r, a, s, u) {
        if (
          (e.setAttributes({
            [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_MONGODB,
            [o.SEMATTRS_DB_NAME]: t,
            [o.SEMATTRS_DB_MONGODB_COLLECTION]: n,
            [o.SEMATTRS_DB_OPERATION]: u,
            [o.SEMATTRS_DB_CONNECTION_STRING]: `mongodb://${r}:${a}/${t}`,
          }),
          r && a)
        ) {
          e.setAttribute(o.SEMATTRS_NET_PEER_NAME, r);
          let t = parseInt(a, 10);
          isNaN(t) || e.setAttribute(o.SEMATTRS_NET_PEER_PORT, t);
        }
        if (!s) return;
        let { dbStatementSerializer: l } = this.getConfig(),
          c = 'function' == typeof l ? l : this._defaultDbStatementSerializer.bind(this);
        (0, i.safeExecuteInTheMiddle)(
          () => {
            let t = c(s);
            e.setAttribute(o.SEMATTRS_DB_STATEMENT, t);
          },
          (e) => {
            e && this._diag.error('Error running dbStatementSerializer hook', e);
          },
          !0
        );
      }
      _defaultDbStatementSerializer(e) {
        let { enhancedDatabaseReporting: t } = this.getConfig();
        return JSON.stringify(t ? e : this._scrubStatement(e));
      }
      _scrubStatement(e) {
        return Array.isArray(e)
          ? e.map((e) => this._scrubStatement(e))
          : 'object' == typeof e && null !== e
            ? Object.fromEntries(Object.entries(e).map(([e, t]) => [e, this._scrubStatement(t)]))
            : '?';
      }
      _handleExecutionResult(e, t) {
        let { responseHook: n } = this.getConfig();
        'function' == typeof n &&
          (0, i.safeExecuteInTheMiddle)(
            () => {
              n(e, { data: t });
            },
            (e) => {
              e && this._diag.error('Error running response hook', e);
            },
            !0
          );
      }
      _patchEnd(e, t, n, i) {
        let o = r.context.active(),
          a = this;
        return function (...n) {
          let s = n[0];
          if (e) {
            if (s instanceof Error)
              e?.setStatus({ code: r.SpanStatusCode.ERROR, message: s.message });
            else {
              let t = n[1];
              a._handleExecutionResult(e, t);
            }
            e.end();
          }
          return r.context.with(
            o,
            () => (
              'endSessions' === i &&
                a._connectionsUsage.add(-1, { state: 'idle', 'pool.name': a._poolName }),
              t.apply(this, n)
            )
          );
        };
      }
      setPoolName(e) {
        let t = e.hostAddress?.host,
          n = e.hostAddress?.port,
          r = e.dbName,
          i = `mongodb://${t}:${n}/${r}`;
        this._poolName = i;
      }
      _checkSkipInstrumentation(e) {
        return !0 === this.getConfig().requireParentSpan && void 0 === e;
      }
    }
    n.MongoDBInstrumentation = l;
  },
  61933,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MongodbCommandType = void 0),
      (function (e) {
        ((e.CREATE_INDEXES = 'createIndexes'),
          (e.FIND_AND_MODIFY = 'findAndModify'),
          (e.IS_MASTER = 'isMaster'),
          (e.COUNT = 'count'),
          (e.UNKNOWN = 'unknown'));
      })(n.MongodbCommandType || (n.MongodbCommandType = {})));
  },
  3550,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MongodbCommandType = n.MongoDBInstrumentation = void 0));
    var r = e.r(70106);
    Object.defineProperty(n, 'MongoDBInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.MongoDBInstrumentation;
      },
    });
    var i = e.r(61933);
    Object.defineProperty(n, 'MongodbCommandType', {
      enumerable: !0,
      get: function () {
        return i.MongodbCommandType;
      },
    });
  },
  65441,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(3550),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Mongo',
      s = o.generateInstrumentOnce(
        a,
        () =>
          new r.MongoDBInstrumentation({
            dbStatementSerializer: u,
            responseHook(e) {
              o.addOriginToSpan(e, 'auto.db.otel.mongo');
            },
          })
      );
    function u(e) {
      return JSON.stringify(
        (function e(t) {
          var n, r;
          let i;
          return Array.isArray(t)
            ? t.map((t) => e(t))
            : 'object' != typeof (n = t) ||
                null === n ||
                ((r = n), (i = !1), 'undefined' != typeof Buffer && (i = Buffer.isBuffer(r)), i)
              ? '?'
              : Object.entries(t)
                  .map(([t, n]) => [t, e(n)])
                  .reduce((e, t) => (Array.isArray(t) && (e[t[0]] = t[1]), e), {});
        })(e)
      );
    }
    let l = i.defineIntegration(() => ({
      name: a,
      setupOnce() {
        s();
      },
    }));
    ((n._defaultDbStatementSerializer = u), (n.instrumentMongo = s), (n.mongoIntegration = l));
  },
  67322,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.handleCallbackResponse =
        n.handlePromiseResponse =
        n.getAttributesFromCollection =
          void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964);
    function a(e, t = {}) {
      (e.recordException(t),
        e.setStatus({
          code: r.SpanStatusCode.ERROR,
          message: `${t.message} ${
            t.code
              ? `
Mongoose Error Code: ${t.code}`
              : ''
          }`,
        }));
    }
    function s(e, t, n, o) {
      n &&
        (0, i.safeExecuteInTheMiddle)(
          () => n(e, { moduleVersion: o, response: t }),
          (e) => {
            e && r.diag.error('mongoose instrumentation: responseHook error', e);
          },
          !0
        );
    }
    ((n.getAttributesFromCollection = function (e) {
      return {
        [o.SEMATTRS_DB_MONGODB_COLLECTION]: e.name,
        [o.SEMATTRS_DB_NAME]: e.conn.name,
        [o.SEMATTRS_DB_USER]: e.conn.user,
        [o.SEMATTRS_NET_PEER_NAME]: e.conn.host,
        [o.SEMATTRS_NET_PEER_PORT]: e.conn.port,
      };
    }),
      (n.handlePromiseResponse = function (e, t, n, r) {
        return e instanceof Promise
          ? e
              .then((e) => (s(t, e, n, r), e))
              .catch((e) => {
                throw (a(t, e), e);
              })
              .finally(() => t.end())
          : (s(t, e, n, r), t.end(), e);
      }),
      (n.handleCallbackResponse = function (e, t, n, r, i, o, u) {
        let l = 0;
        return (
          2 === i.length ? (l = 1) : 3 === i.length && (l = 2),
          (i[l] = (t, n) => (t ? a(r, t) : s(r, n, o, u), r.end(), e(t, n))),
          t.apply(n, i)
        );
      }));
  },
  95026,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.50.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-mongoose'));
  },
  92663,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MongooseInstrumentation = n._STORED_PARENT_SPAN = void 0));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(67322),
      a = e.r(75235),
      s = e.r(95026),
      u = e.r(81964),
      l = [
        'deleteOne',
        'deleteMany',
        'find',
        'findOne',
        'estimatedDocumentCount',
        'countDocuments',
        'distinct',
        'where',
        '$where',
        'findOneAndUpdate',
        'findOneAndDelete',
        'findOneAndReplace',
      ],
      c = ['remove', 'count', 'findOneAndRemove', ...l],
      d = ['count', 'findOneAndRemove', ...l],
      p = [...l];
    function _(e) {
      return e ? (e.startsWith('6.') || e.startsWith('5.') ? c : e.startsWith('7.') ? d : p) : l;
    }
    function S(e) {
      return (e && (e.startsWith('5.') || e.startsWith('6.'))) || !1;
    }
    n._STORED_PARENT_SPAN = Symbol('stored-parent-span');
    class E extends a.InstrumentationBase {
      constructor(e = {}) {
        super(s.PACKAGE_NAME, s.PACKAGE_VERSION, e);
      }
      init() {
        return new a.InstrumentationNodeModuleDefinition(
          'mongoose',
          ['>=5.9.7 <9'],
          this.patch.bind(this),
          this.unpatch.bind(this)
        );
      }
      patch(e, t) {
        let n = 'Module' === e[Symbol.toStringTag] ? e.default : e;
        return (
          this._wrap(n.Model.prototype, 'save', this.patchOnModelMethods('save', t)),
          (n.Model.prototype.$save = n.Model.prototype.save),
          S(t) && this._wrap(n.Model.prototype, 'remove', this.patchOnModelMethods('remove', t)),
          this._wrap(n.Query.prototype, 'exec', this.patchQueryExec(t)),
          this._wrap(n.Aggregate.prototype, 'exec', this.patchAggregateExec(t)),
          _(t).forEach((e) => {
            this._wrap(n.Query.prototype, e, this.patchAndCaptureSpanContext(e));
          }),
          this._wrap(n.Model, 'aggregate', this.patchModelAggregate()),
          this._wrap(n.Model, 'insertMany', this.patchModelStatic('insertMany', t)),
          this._wrap(n.Model, 'bulkWrite', this.patchModelStatic('bulkWrite', t)),
          n
        );
      }
      unpatch(e, t) {
        let n = 'Module' === e[Symbol.toStringTag] ? e.default : e,
          r = _(t);
        (this._unwrap(n.Model.prototype, 'save'),
          (n.Model.prototype.$save = n.Model.prototype.save),
          S(t) && this._unwrap(n.Model.prototype, 'remove'),
          this._unwrap(n.Query.prototype, 'exec'),
          this._unwrap(n.Aggregate.prototype, 'exec'),
          r.forEach((e) => {
            this._unwrap(n.Query.prototype, e);
          }),
          this._unwrap(n.Model, 'aggregate'),
          this._unwrap(n.Model, 'insertMany'),
          this._unwrap(n.Model, 'bulkWrite'));
      }
      patchAggregateExec(e) {
        let t = this;
        return (i) =>
          function (o) {
            if (t.getConfig().requireParentSpan && void 0 === r.trace.getSpan(r.context.active()))
              return i.apply(this, arguments);
            let a = this[n._STORED_PARENT_SPAN],
              s = {},
              { dbStatementSerializer: l } = t.getConfig();
            l &&
              (s[u.SEMATTRS_DB_STATEMENT] = l('aggregate', {
                options: this.options,
                aggregatePipeline: this._pipeline,
              }));
            let c = t._startSpan(this._model.collection, this._model?.modelName, 'aggregate', s, a);
            return t._handleResponse(c, i, this, arguments, o, e);
          };
      }
      patchQueryExec(e) {
        let t = this;
        return (i) =>
          function (o) {
            if (t.getConfig().requireParentSpan && void 0 === r.trace.getSpan(r.context.active()))
              return i.apply(this, arguments);
            let a = this[n._STORED_PARENT_SPAN],
              s = {},
              { dbStatementSerializer: l } = t.getConfig();
            l &&
              (s[u.SEMATTRS_DB_STATEMENT] = l(this.op, {
                condition: this._conditions,
                updates: this._update,
                options: this.options,
                fields: this._fields,
              }));
            let c = t._startSpan(this.mongooseCollection, this.model.modelName, this.op, s, a);
            return t._handleResponse(c, i, this, arguments, o, e);
          };
      }
      patchOnModelMethods(e, t) {
        let n = this;
        return (i) =>
          function (o, a) {
            if (n.getConfig().requireParentSpan && void 0 === r.trace.getSpan(r.context.active()))
              return i.apply(this, arguments);
            let s = { document: this };
            !o || o instanceof Function || (s.options = o);
            let l = {},
              { dbStatementSerializer: c } = n.getConfig();
            c && (l[u.SEMATTRS_DB_STATEMENT] = c(e, s));
            let d = n._startSpan(this.constructor.collection, this.constructor.modelName, e, l);
            return (
              o instanceof Function && ((a = o), (o = void 0)),
              n._handleResponse(d, i, this, arguments, a, t)
            );
          };
      }
      patchModelStatic(e, t) {
        let n = this;
        return (i) =>
          function (o, a, s) {
            if (n.getConfig().requireParentSpan && void 0 === r.trace.getSpan(r.context.active()))
              return i.apply(this, arguments);
            'function' == typeof a && ((s = a), (a = void 0));
            let l = {};
            switch (e) {
              case 'insertMany':
                l.documents = o;
                break;
              case 'bulkWrite':
                l.operations = o;
                break;
              default:
                l.document = o;
            }
            void 0 !== a && (l.options = a);
            let c = {},
              { dbStatementSerializer: d } = n.getConfig();
            d && (c[u.SEMATTRS_DB_STATEMENT] = d(e, l));
            let p = n._startSpan(this.collection, this.modelName, e, c);
            return n._handleResponse(p, i, this, arguments, s, t);
          };
      }
      patchModelAggregate() {
        let e = this;
        return (t) =>
          function () {
            let i = r.trace.getSpan(r.context.active()),
              o = e._callOriginalFunction(() => t.apply(this, arguments));
            return (o && (o[n._STORED_PARENT_SPAN] = i), o);
          };
      }
      patchAndCaptureSpanContext(e) {
        let t = this;
        return (e) =>
          function () {
            return (
              (this[n._STORED_PARENT_SPAN] = r.trace.getSpan(r.context.active())),
              t._callOriginalFunction(() => e.apply(this, arguments))
            );
          };
      }
      _startSpan(e, t, n, i, a) {
        return this.tracer.startSpan(
          `mongoose.${t}.${n}`,
          {
            kind: r.SpanKind.CLIENT,
            attributes: {
              ...i,
              ...(0, o.getAttributesFromCollection)(e),
              [u.SEMATTRS_DB_OPERATION]: n,
              [u.SEMATTRS_DB_SYSTEM]: 'mongoose',
            },
          },
          a ? r.trace.setSpan(r.context.active(), a) : void 0
        );
      }
      _handleResponse(e, t, n, r, i, a) {
        let s = this;
        if (i instanceof Function)
          return s._callOriginalFunction(() =>
            (0, o.handleCallbackResponse)(i, t, n, e, r, s.getConfig().responseHook, a)
          );
        {
          let i = s._callOriginalFunction(() => t.apply(n, r));
          return (0, o.handlePromiseResponse)(i, e, s.getConfig().responseHook, a);
        }
      }
      _callOriginalFunction(e) {
        return this.getConfig().suppressInternalInstrumentation
          ? r.context.with((0, i.suppressTracing)(r.context.active()), e)
          : e();
      }
    }
    n.MongooseInstrumentation = E;
  },
  51679,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.MongooseInstrumentation = void 0));
    var r = e.r(92663);
    Object.defineProperty(n, 'MongooseInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.MongooseInstrumentation;
      },
    });
  },
  25332,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(51679),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Mongoose',
      s = o.generateInstrumentOnce(
        a,
        () =>
          new r.MongooseInstrumentation({
            responseHook(e) {
              o.addOriginToSpan(e, 'auto.db.otel.mongoose');
            },
          })
      ),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentMongoose = s), (n.mongooseIntegration = u));
  },
  71392,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      ((n.AttributeNames || (n.AttributeNames = {})).MYSQL_VALUES = 'db.mysql.values'));
  },
  55288,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.getPoolName =
        n.arrayStringifyHelper =
        n.getSpanName =
        n.getDbValues =
        n.getDbStatement =
        n.getConnectionAttributes =
          void 0));
    let r = e.r(81964);
    function i(e, t, n) {
      let r = `jdbc:mysql://${e || 'localhost'}`;
      return ('number' == typeof t && (r += `:${t}`), 'string' == typeof n && (r += `/${n}`), r);
    }
    function o(e) {
      return e ? `[${e.toString()}]` : '';
    }
    ((n.getConnectionAttributes = function (e) {
      let {
          host: t,
          port: n,
          database: o,
          user: a,
        } = (function (e) {
          let { host: t, port: n, database: r, user: i } = (e && e.connectionConfig) || e || {};
          return { host: t, port: n, database: r, user: i };
        })(e),
        s = parseInt(n, 10);
      return isNaN(s)
        ? {
            [r.SEMATTRS_NET_PEER_NAME]: t,
            [r.SEMATTRS_DB_CONNECTION_STRING]: i(t, n, o),
            [r.SEMATTRS_DB_NAME]: o,
            [r.SEMATTRS_DB_USER]: a,
          }
        : {
            [r.SEMATTRS_NET_PEER_NAME]: t,
            [r.SEMATTRS_NET_PEER_PORT]: s,
            [r.SEMATTRS_DB_CONNECTION_STRING]: i(t, n, o),
            [r.SEMATTRS_DB_NAME]: o,
            [r.SEMATTRS_DB_USER]: a,
          };
    }),
      (n.getDbStatement = function (e) {
        return 'string' == typeof e ? e : e.sql;
      }),
      (n.getDbValues = function (e, t) {
        return 'string' == typeof e ? o(t) : o(t || e.values);
      }),
      (n.getSpanName = function (e) {
        let t = 'object' == typeof e ? e.sql : e,
          n = t?.indexOf(' ');
        return 'number' == typeof n && -1 !== n ? t?.substring(0, n) : t;
      }),
      (n.arrayStringifyHelper = o),
      (n.getPoolName = function (e) {
        let t = e.config.connectionConfig,
          n = '';
        return (
          (n += t.host ? `host: '${t.host}', ` : ''),
          (n += t.port ? `port: ${t.port}, ` : ''),
          (n += t.database ? `database: '${t.database}', ` : ''),
          (n += t.user ? `user: '${t.user}'` : ''),
          t.user || (n = n.substring(0, n.length - 2)),
          n.trim()
        );
      }));
  },
  50978,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.49.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-mysql'));
  },
  11583,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MySQLInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(71392),
      s = e.r(55288),
      u = e.r(50978);
    class l extends i.InstrumentationBase {
      static COMMON_ATTRIBUTES = { [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_MYSQL };
      constructor(e = {}) {
        (super(u.PACKAGE_NAME, u.PACKAGE_VERSION, e), this._setMetricInstruments());
      }
      setMeterProvider(e) {
        (super.setMeterProvider(e), this._setMetricInstruments());
      }
      _setMetricInstruments() {
        this._connectionsUsage = this.meter.createUpDownCounter('db.client.connections.usage', {
          description:
            'The number of connections that are currently in state described by the state attribute.',
          unit: '{connection}',
        });
      }
      init() {
        return [
          new i.InstrumentationNodeModuleDefinition(
            'mysql',
            ['>=2.0.0 <3'],
            (e) => (
              (0, i.isWrapped)(e.createConnection) && this._unwrap(e, 'createConnection'),
              this._wrap(e, 'createConnection', this._patchCreateConnection()),
              (0, i.isWrapped)(e.createPool) && this._unwrap(e, 'createPool'),
              this._wrap(e, 'createPool', this._patchCreatePool()),
              (0, i.isWrapped)(e.createPoolCluster) && this._unwrap(e, 'createPoolCluster'),
              this._wrap(e, 'createPoolCluster', this._patchCreatePoolCluster()),
              e
            ),
            (e) => {
              void 0 !== e &&
                (this._unwrap(e, 'createConnection'),
                this._unwrap(e, 'createPool'),
                this._unwrap(e, 'createPoolCluster'));
            }
          ),
        ];
      }
      _patchCreateConnection() {
        return (e) => {
          let t = this;
          return function (n) {
            let r = e(...arguments);
            return (t._wrap(r, 'query', t._patchQuery(r)), r);
          };
        };
      }
      _patchCreatePool() {
        return (e) => {
          let t = this;
          return function (n) {
            let r = e(...arguments);
            return (
              t._wrap(r, 'query', t._patchQuery(r)),
              t._wrap(r, 'getConnection', t._patchGetConnection(r)),
              t._wrap(r, 'end', t._patchPoolEnd(r)),
              t._setPoolcallbacks(r, t, ''),
              r
            );
          };
        };
      }
      _patchPoolEnd(e) {
        return (t) => {
          let n = this;
          return function (r) {
            let i = e._allConnections.length,
              o = e._freeConnections.length,
              a = (0, s.getPoolName)(e);
            (n._connectionsUsage.add(-(i - o), { state: 'used', name: a }),
              n._connectionsUsage.add(-o, { state: 'idle', name: a }),
              t.apply(e, arguments));
          };
        };
      }
      _patchCreatePoolCluster() {
        return (e) => {
          let t = this;
          return function (n) {
            let r = e(...arguments);
            return (
              t._wrap(r, 'getConnection', t._patchGetConnection(r)),
              t._wrap(r, 'add', t._patchAdd(r)),
              r
            );
          };
        };
      }
      _patchAdd(e) {
        return (t) => {
          let n = this;
          return function (r, i) {
            if (!n._enabled) return (n._unwrap(e, 'add'), t.apply(e, arguments));
            t.apply(e, arguments);
            let o = e._nodes;
            if (o) {
              let t = o['object' == typeof r ? 'CLUSTER::' + e._lastId : String(r)].pool;
              n._setPoolcallbacks(t, n, r);
            }
          };
        };
      }
      _patchGetConnection(e) {
        return (t) => {
          let n = this;
          return function (r, i, o) {
            if (!n._enabled) return (n._unwrap(e, 'getConnection'), t.apply(e, arguments));
            if (1 == arguments.length && 'function' == typeof r) {
              let i = n._getConnectionCallbackPatchFn(r);
              return t.call(e, i);
            }
            if (2 == arguments.length && 'function' == typeof i) {
              let o = n._getConnectionCallbackPatchFn(i);
              return t.call(e, r, o);
            }
            if (3 == arguments.length && 'function' == typeof o) {
              let a = n._getConnectionCallbackPatchFn(o);
              return t.call(e, r, i, a);
            }
            return t.apply(e, arguments);
          };
        };
      }
      _getConnectionCallbackPatchFn(e) {
        let t = this,
          n = r.context.active();
        return function (o, a) {
          (a && !(0, i.isWrapped)(a.query) && t._wrap(a, 'query', t._patchQuery(a)),
            'function' == typeof e && r.context.with(n, e, this, o, a));
        };
      }
      _patchQuery(e) {
        return (t) => {
          let n = this;
          return function (i, u, c) {
            if (!n._enabled) return (n._unwrap(e, 'query'), t.apply(e, arguments));
            let d = n.tracer.startSpan((0, s.getSpanName)(i), {
              kind: r.SpanKind.CLIENT,
              attributes: { ...l.COMMON_ATTRIBUTES, ...(0, s.getConnectionAttributes)(e.config) },
            });
            if (
              (d.setAttribute(o.SEMATTRS_DB_STATEMENT, (0, s.getDbStatement)(i)),
              n.getConfig().enhancedDatabaseReporting)
            ) {
              let e;
              (Array.isArray(u) ? (e = u) : arguments[2] && (e = [u]),
                d.setAttribute(a.AttributeNames.MYSQL_VALUES, (0, s.getDbValues)(i, e)));
            }
            let p = Array.from(arguments).findIndex((e) => 'function' == typeof e),
              _ = r.context.active();
            if (-1 !== p)
              return (
                n._wrap(arguments, p, n._patchCallbackQuery(d, _)),
                r.context.with(r.trace.setSpan(r.context.active(), d), () => t.apply(e, arguments))
              );
            {
              let n = r.context.with(r.trace.setSpan(r.context.active(), d), () =>
                t.apply(e, arguments)
              );
              return (
                r.context.bind(_, n),
                n
                  .on('error', (e) =>
                    d.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message })
                  )
                  .on('end', () => {
                    d.end();
                  })
              );
            }
          };
        };
      }
      _patchCallbackQuery(e, t) {
        return (n) =>
          function (i, o, a) {
            return (
              i && e.setStatus({ code: r.SpanStatusCode.ERROR, message: i.message }),
              e.end(),
              r.context.with(t, () => n(...arguments))
            );
          };
      }
      _setPoolcallbacks(e, t, n) {
        let r = n || (0, s.getPoolName)(e);
        (e.on('connection', (e) => {
          t._connectionsUsage.add(1, { state: 'idle', name: r });
        }),
          e.on('acquire', (e) => {
            (t._connectionsUsage.add(-1, { state: 'idle', name: r }),
              t._connectionsUsage.add(1, { state: 'used', name: r }));
          }),
          e.on('release', (e) => {
            (t._connectionsUsage.add(-1, { state: 'used', name: r }),
              t._connectionsUsage.add(1, { state: 'idle', name: r }));
          }));
      }
    }
    n.MySQLInstrumentation = l;
  },
  49895,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.MySQLInstrumentation = void 0));
    var r = e.r(11583);
    Object.defineProperty(n, 'MySQLInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.MySQLInstrumentation;
      },
    });
  },
  46988,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(49895),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Mysql',
      s = o.generateInstrumentOnce(a, () => new r.MySQLInstrumentation({})),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentMysql = s), (n.mysqlIntegration = u));
  },
  94570,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.addSqlCommenterComment = void 0));
    let r = e.r(52305),
      i = e.r(88540);
    n.addSqlCommenterComment = function (e, t) {
      if (
        'string' != typeof t ||
        0 === t.length ||
        (function (e) {
          let t = e.indexOf('--');
          return t >= 0 || (!(0 > e.indexOf('/*')) && t < e.indexOf('*/'));
        })(t)
      )
        return t;
      let n = new i.W3CTraceContextPropagator(),
        o = {};
      n.inject(r.trace.setSpan(r.ROOT_CONTEXT, e), o, r.defaultTextMapSetter);
      let a = Object.keys(o).sort();
      if (0 === a.length) return t;
      let s = a
        .map((e) => {
          let t = encodeURIComponent(o[e]).replace(
            /[!'()*]/g,
            (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`
          );
          return `${e}='${t}'`;
        })
        .join(',');
      return `${t} /*${s}*/`;
    };
  },
  57182,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.getConnectionPrototypeToInstrument =
        n.once =
        n.getSpanName =
        n.getDbStatement =
        n.getConnectionAttributes =
          void 0));
    let r = e.r(81964);
    function i(e, t, n) {
      let r = `jdbc:mysql://${e || 'localhost'}`;
      return ('number' == typeof t && (r += `:${t}`), 'string' == typeof n && (r += `/${n}`), r);
    }
    function o(e) {
      return e.replace(/\b\d+\b/g, '?').replace(/(["'])(?:(?=(\\?))\2.)*?\1/g, '?');
    }
    ((n.getConnectionAttributes = function (e) {
      let {
          host: t,
          port: n,
          database: o,
          user: a,
        } = (function (e) {
          let { host: t, port: n, database: r, user: i } = (e && e.connectionConfig) || e || {};
          return { host: t, port: n, database: r, user: i };
        })(e),
        s = parseInt(n, 10);
      return isNaN(s)
        ? {
            [r.SEMATTRS_NET_PEER_NAME]: t,
            [r.SEMATTRS_DB_CONNECTION_STRING]: i(t, n, o),
            [r.SEMATTRS_DB_NAME]: o,
            [r.SEMATTRS_DB_USER]: a,
          }
        : {
            [r.SEMATTRS_NET_PEER_NAME]: t,
            [r.SEMATTRS_NET_PEER_PORT]: s,
            [r.SEMATTRS_DB_CONNECTION_STRING]: i(t, n, o),
            [r.SEMATTRS_DB_NAME]: o,
            [r.SEMATTRS_DB_USER]: a,
          };
    }),
      (n.getDbStatement = function (e, t, n, r = !1, i = o) {
        let [a, s] = 'string' == typeof e ? [e, n] : [e.sql, 'values' in e ? n || e.values : n];
        try {
          if (r) return i(a);
          if (t && s) return t(a, s);
          return a;
        } catch (e) {
          return 'Could not determine the query due to an error in masking or formatting';
        }
      }),
      (n.getSpanName = function (e) {
        let t = 'object' == typeof e ? e.sql : e,
          n = t?.indexOf(' ');
        return 'number' == typeof n && -1 !== n ? t?.substring(0, n) : t;
      }),
      (n.once = (e) => {
        let t = !1;
        return (...n) => {
          if (!t) return ((t = !0), e(...n));
        };
      }),
      (n.getConnectionPrototypeToInstrument = function (e) {
        let t = e.prototype,
          n = Object.getPrototypeOf(t);
        return 'function' == typeof n?.query && 'function' == typeof n?.execute ? n : t;
      }));
  },
  76880,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.50.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-mysql2'));
  },
  85864,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.MySQL2Instrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(94570),
      s = e.r(57182),
      u = e.r(76880),
      l = ['>=1.4.2 <4'];
    class c extends i.InstrumentationBase {
      static COMMON_ATTRIBUTES = { [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_MYSQL };
      constructor(e = {}) {
        super(u.PACKAGE_NAME, u.PACKAGE_VERSION, e);
      }
      init() {
        let e;
        function t(t) {
          !e && t.format && (e = t.format);
        }
        let n = (t) => {
            ((0, i.isWrapped)(t.query) && this._unwrap(t, 'query'),
              this._wrap(t, 'query', this._patchQuery(e, !1)),
              (0, i.isWrapped)(t.execute) && this._unwrap(t, 'execute'),
              this._wrap(t, 'execute', this._patchQuery(e, !0)));
          },
          r = (e) => {
            (this._unwrap(e, 'query'), this._unwrap(e, 'execute'));
          };
        return [
          new i.InstrumentationNodeModuleDefinition(
            'mysql2',
            l,
            (e) => (t(e), e),
            () => {},
            [
              new i.InstrumentationNodeModuleFile(
                'mysql2/promise.js',
                l,
                (e) => (t(e), e),
                () => {}
              ),
              new i.InstrumentationNodeModuleFile(
                'mysql2/lib/connection.js',
                l,
                (e) => (n((0, s.getConnectionPrototypeToInstrument)(e)), e),
                (e) => {
                  void 0 !== e && r((0, s.getConnectionPrototypeToInstrument)(e));
                }
              ),
            ]
          ),
        ];
      }
      _patchQuery(e, t) {
        return (n) => {
          let u = this;
          return function (l, d, p) {
            let _;
            Array.isArray(d) ? (_ = d) : arguments[2] && (_ = [d]);
            let { maskStatement: S, maskStatementHook: E, responseHook: T } = u.getConfig(),
              m = u.tracer.startSpan((0, s.getSpanName)(l), {
                kind: r.SpanKind.CLIENT,
                attributes: {
                  ...c.COMMON_ATTRIBUTES,
                  ...(0, s.getConnectionAttributes)(this.config),
                  [o.SEMATTRS_DB_STATEMENT]: (0, s.getDbStatement)(l, e, _, S, E),
                },
              });
            !t &&
              u.getConfig().addSqlCommenterCommentToQueries &&
              (arguments[0] = l =
                'string' == typeof l
                  ? (0, a.addSqlCommenterComment)(m, l)
                  : Object.assign(l, { sql: (0, a.addSqlCommenterComment)(m, l.sql) }));
            let g = (0, s.once)((e, t) => {
              (e
                ? m.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message })
                : 'function' == typeof T &&
                  (0, i.safeExecuteInTheMiddle)(
                    () => {
                      T(m, { queryResults: t });
                    },
                    (e) => {
                      e && u._diag.warn('Failed executing responseHook', e);
                    },
                    !0
                  ),
                m.end());
            });
            if (1 == arguments.length) {
              'function' == typeof l.onResult && u._wrap(l, 'onResult', u._patchCallbackQuery(g));
              let e = n.apply(this, arguments);
              return (
                e
                  .once('error', (e) => {
                    g(e);
                  })
                  .once('result', (e) => {
                    g(void 0, e);
                  }),
                e
              );
            }
            return (
              'function' == typeof arguments[1]
                ? u._wrap(arguments, 1, u._patchCallbackQuery(g))
                : 'function' == typeof arguments[2] &&
                  u._wrap(arguments, 2, u._patchCallbackQuery(g)),
              n.apply(this, arguments)
            );
          };
        };
      }
      _patchCallbackQuery(e) {
        return (t) =>
          function (n, r, i) {
            return (e(n, r), t(...arguments));
          };
      }
    }
    n.MySQL2Instrumentation = c;
  },
  23235,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.MySQL2Instrumentation = void 0));
    var r = e.r(85864);
    Object.defineProperty(n, 'MySQL2Instrumentation', {
      enumerable: !0,
      get: function () {
        return r.MySQL2Instrumentation;
      },
    });
  },
  63268,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23235),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Mysql2',
      s = o.generateInstrumentOnce(
        a,
        () =>
          new r.MySQL2Instrumentation({
            responseHook(e) {
              o.addOriginToSpan(e, 'auto.db.otel.mysql2');
            },
          })
      ),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentMysql2 = s), (n.mysql2Integration = u));
  },
  73680,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.endSpan = void 0));
    let r = e.r(52305);
    n.endSpan = (e, t) => {
      (t &&
        (e.recordException(t), e.setStatus({ code: r.SpanStatusCode.ERROR, message: t.message })),
        e.end());
    };
  },
  42010,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.defaultDbStatementSerializer = void 0));
    let r = [
      { regex: /^ECHO/i, args: 0 },
      { regex: /^(LPUSH|MSET|PFA|PUBLISH|RPUSH|SADD|SET|SPUBLISH|XADD|ZADD)/i, args: 1 },
      { regex: /^(HSET|HMSET|LSET|LINSERT)/i, args: 2 },
      {
        regex:
          /^(ACL|BIT|B[LRZ]|CLIENT|CLUSTER|CONFIG|COMMAND|DECR|DEL|EVAL|EX|FUNCTION|GEO|GET|HINCR|HMGET|HSCAN|INCR|L[TRLM]|MEMORY|P[EFISTU]|RPOP|S[CDIMORSU]|XACK|X[CDGILPRT]|Z[CDILMPRS])/i,
        args: -1,
      },
    ];
    n.defaultDbStatementSerializer = (e, t) => {
      if (Array.isArray(t) && t.length) {
        let n = r.find(({ regex: t }) => t.test(e))?.args ?? 0,
          i = n >= 0 ? t.slice(0, n) : t;
        return (
          t.length > i.length && i.push(`[${t.length - n} other arguments]`),
          `${e} ${i.join(' ')}`
        );
      }
      return e;
    };
  },
  45937,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.51.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-ioredis'));
  },
  63497,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.IORedisInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(75235),
      s = e.r(73680),
      u = e.r(42010),
      l = e.r(45937),
      c = { requireParentSpan: !0 };
    class d extends i.InstrumentationBase {
      constructor(e = {}) {
        super(l.PACKAGE_NAME, l.PACKAGE_VERSION, { ...c, ...e });
      }
      setConfig(e = {}) {
        super.setConfig({ ...c, ...e });
      }
      init() {
        return [
          new i.InstrumentationNodeModuleDefinition(
            'ioredis',
            ['>=2.0.0 <6'],
            (e, t) => {
              let n = 'Module' === e[Symbol.toStringTag] ? e.default : e;
              return (
                (0, i.isWrapped)(n.prototype.sendCommand) &&
                  this._unwrap(n.prototype, 'sendCommand'),
                this._wrap(n.prototype, 'sendCommand', this._patchSendCommand(t)),
                (0, i.isWrapped)(n.prototype.connect) && this._unwrap(n.prototype, 'connect'),
                this._wrap(n.prototype, 'connect', this._patchConnection()),
                e
              );
            },
            (e) => {
              if (void 0 === e) return;
              let t = 'Module' === e[Symbol.toStringTag] ? e.default : e;
              (this._unwrap(t.prototype, 'sendCommand'), this._unwrap(t.prototype, 'connect'));
            }
          ),
        ];
      }
      _patchSendCommand(e) {
        return (t) => this._traceSendCommand(t, e);
      }
      _patchConnection() {
        return (e) => this._traceConnection(e);
      }
      _traceSendCommand(e, t) {
        let n = this;
        return function (i) {
          if (arguments.length < 1 || 'object' != typeof i) return e.apply(this, arguments);
          let l = n.getConfig(),
            c = l.dbStatementSerializer || u.defaultDbStatementSerializer,
            d = void 0 === r.trace.getSpan(r.context.active());
          if (!0 === l.requireParentSpan && d) return e.apply(this, arguments);
          let p = n.tracer.startSpan(i.name, {
              kind: r.SpanKind.CLIENT,
              attributes: {
                [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_REDIS,
                [o.SEMATTRS_DB_STATEMENT]: c(i.name, i.args),
              },
            }),
            { requestHook: _ } = l;
          _ &&
            (0, a.safeExecuteInTheMiddle)(
              () => _(p, { moduleVersion: t, cmdName: i.name, cmdArgs: i.args }),
              (e) => {
                e && r.diag.error('ioredis instrumentation: request hook failed', e);
              },
              !0
            );
          let { host: S, port: E } = this.options;
          p.setAttributes({
            [o.SEMATTRS_NET_PEER_NAME]: S,
            [o.SEMATTRS_NET_PEER_PORT]: E,
            [o.SEMATTRS_DB_CONNECTION_STRING]: `redis://${S}:${E}`,
          });
          try {
            let t = e.apply(this, arguments),
              n = i.resolve;
            i.resolve = function (e) {
              ((0, a.safeExecuteInTheMiddle)(
                () => l.responseHook?.(p, i.name, i.args, e),
                (e) => {
                  e && r.diag.error('ioredis instrumentation: response hook failed', e);
                },
                !0
              ),
                (0, s.endSpan)(p, null),
                n(e));
            };
            let o = i.reject;
            return (
              (i.reject = function (e) {
                ((0, s.endSpan)(p, e), o(e));
              }),
              t
            );
          } catch (e) {
            throw ((0, s.endSpan)(p, e), e);
          }
        };
      }
      _traceConnection(e) {
        let t = this;
        return function () {
          let n = void 0 === r.trace.getSpan(r.context.active());
          if (!0 === t.getConfig().requireParentSpan && n) return e.apply(this, arguments);
          let i = t.tracer.startSpan('connect', {
              kind: r.SpanKind.CLIENT,
              attributes: {
                [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_REDIS,
                [o.SEMATTRS_DB_STATEMENT]: 'connect',
              },
            }),
            { host: a, port: u } = this.options;
          i.setAttributes({
            [o.SEMATTRS_NET_PEER_NAME]: a,
            [o.SEMATTRS_NET_PEER_PORT]: u,
            [o.SEMATTRS_DB_CONNECTION_STRING]: `redis://${a}:${u}`,
          });
          try {
            let t = e.apply(this, arguments);
            return ((0, s.endSpan)(i, null), t);
          } catch (e) {
            throw ((0, s.endSpan)(i, e), e);
          }
        };
      }
    }
    n.IORedisInstrumentation = d;
  },
  54265,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.IORedisInstrumentation = void 0));
    var r = e.r(63497);
    Object.defineProperty(n, 'IORedisInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.IORedisInstrumentation;
      },
    });
  },
  47505,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.51.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-redis'));
  },
  65455,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.getTracedCreateStreamTrace = n.getTracedCreateClient = n.endSpan = void 0));
    let r = e.r(52305);
    ((n.endSpan = (e, t) => {
      (t && e.setStatus({ code: r.SpanStatusCode.ERROR, message: t.message }), e.end());
    }),
      (n.getTracedCreateClient = (e) =>
        function () {
          let t = e.apply(this, arguments);
          return r.context.bind(r.context.active(), t);
        }),
      (n.getTracedCreateStreamTrace = (e) =>
        function () {
          return (
            Object.prototype.hasOwnProperty.call(this, 'stream') ||
              Object.defineProperty(this, 'stream', {
                get() {
                  return this._patched_redis_stream;
                },
                set(e) {
                  (r.context.bind(r.context.active(), e), (this._patched_redis_stream = e));
                },
              }),
            e.apply(this, arguments)
          );
        }));
  },
  48450,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.RedisInstrumentationV2_V3 = void 0));
    let r = e.r(75235),
      i = e.r(65455),
      o = e.r(47505),
      a = e.r(52305),
      s = e.r(81964),
      u = e.r(42010);
    class l extends r.InstrumentationBase {
      static COMPONENT = 'redis';
      constructor(e = {}) {
        super(o.PACKAGE_NAME, o.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new r.InstrumentationNodeModuleDefinition(
            'redis',
            ['>=2.6.0 <4'],
            (e) => (
              (0, r.isWrapped)(e.RedisClient.prototype.internal_send_command) &&
                this._unwrap(e.RedisClient.prototype, 'internal_send_command'),
              this._wrap(
                e.RedisClient.prototype,
                'internal_send_command',
                this._getPatchInternalSendCommand()
              ),
              (0, r.isWrapped)(e.RedisClient.prototype.create_stream) &&
                this._unwrap(e.RedisClient.prototype, 'create_stream'),
              this._wrap(e.RedisClient.prototype, 'create_stream', this._getPatchCreateStream()),
              (0, r.isWrapped)(e.createClient) && this._unwrap(e, 'createClient'),
              this._wrap(e, 'createClient', this._getPatchCreateClient()),
              e
            ),
            (e) => {
              void 0 !== e &&
                (this._unwrap(e.RedisClient.prototype, 'internal_send_command'),
                this._unwrap(e.RedisClient.prototype, 'create_stream'),
                this._unwrap(e, 'createClient'));
            }
          ),
        ];
      }
      _getPatchInternalSendCommand() {
        let e = this;
        return function (t) {
          return function (n) {
            if (1 != arguments.length || 'object' != typeof n) return t.apply(this, arguments);
            let o = e.getConfig(),
              c = void 0 === a.trace.getSpan(a.context.active());
            if (!0 === o.requireParentSpan && c) return t.apply(this, arguments);
            let d = o?.dbStatementSerializer || u.defaultDbStatementSerializer,
              p = e.tracer.startSpan(`${l.COMPONENT}-${n.command}`, {
                kind: a.SpanKind.CLIENT,
                attributes: {
                  [s.SEMATTRS_DB_SYSTEM]: s.DBSYSTEMVALUES_REDIS,
                  [s.SEMATTRS_DB_STATEMENT]: d(n.command, n.args),
                },
              });
            (this.connection_options &&
              p.setAttributes({
                [s.SEMATTRS_NET_PEER_NAME]: this.connection_options.host,
                [s.SEMATTRS_NET_PEER_PORT]: this.connection_options.port,
              }),
              this.address &&
                p.setAttribute(s.SEMATTRS_DB_CONNECTION_STRING, `redis://${this.address}`));
            let _ = arguments[0].callback;
            if (_) {
              let t = a.context.active();
              arguments[0].callback = function (s, u) {
                if (o?.responseHook) {
                  let t = o.responseHook;
                  (0, r.safeExecuteInTheMiddle)(
                    () => {
                      t(p, n.command, n.args, u);
                    },
                    (t) => {
                      t && e._diag.error('Error executing responseHook', t);
                    },
                    !0
                  );
                }
                return ((0, i.endSpan)(p, s), a.context.with(t, _, this, ...arguments));
              };
            }
            try {
              return t.apply(this, arguments);
            } catch (e) {
              throw ((0, i.endSpan)(p, e), e);
            }
          };
        };
      }
      _getPatchCreateClient() {
        return function (e) {
          return (0, i.getTracedCreateClient)(e);
        };
      }
      _getPatchCreateStream() {
        return function (e) {
          return (0, i.getTracedCreateStreamTrace)(e);
        };
      }
    }
    n.RedisInstrumentationV2_V3 = l;
  },
  41493,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.getClientAttributes = void 0));
    let r = e.r(81964);
    n.getClientAttributes = function (e, t) {
      return {
        [r.SEMATTRS_DB_SYSTEM]: r.DBSYSTEMVALUES_REDIS,
        [r.SEMATTRS_NET_PEER_NAME]: t?.socket?.host,
        [r.SEMATTRS_NET_PEER_PORT]: t?.socket?.port,
        [r.SEMATTRS_DB_CONNECTION_STRING]: (function (e, t) {
          if ('string' == typeof t && t)
            try {
              let e = new URL(t);
              return (
                e.searchParams.delete('user_pwd'),
                (e.username = ''),
                (e.password = ''),
                e.href
              );
            } catch (t) {
              e.error('failed to sanitize redis connection url', t);
            }
        })(e, t?.url),
      };
    };
  },
  45732,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.RedisInstrumentationV4 = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(41493),
      a = e.r(42010),
      s = e.r(47505),
      u = e.r(81964),
      l = Symbol('opentelemetry.instrumentation.redis.open_spans'),
      c = Symbol('opentelemetry.instrumentation.redis.multi_command_options');
    class d extends i.InstrumentationBase {
      static COMPONENT = 'redis';
      constructor(e = {}) {
        super(s.PACKAGE_NAME, s.PACKAGE_VERSION, e);
      }
      init() {
        return [
          this._getInstrumentationNodeModuleDefinition('@redis/client'),
          this._getInstrumentationNodeModuleDefinition('@node-redis/client'),
        ];
      }
      _getInstrumentationNodeModuleDefinition(e) {
        let t = new i.InstrumentationNodeModuleFile(
            `${e}/dist/lib/commander.js`,
            ['^1.0.0'],
            (e, t) => {
              let n = e.transformCommandArguments;
              if (!n)
                return (
                  this._diag.error(
                    'internal instrumentation error, missing transformCommandArguments function'
                  ),
                  e
                );
              let r = t?.startsWith('1.0.') ? 'extendWithCommands' : 'attachCommands';
              return (
                (0, i.isWrapped)(e?.[r]) && this._unwrap(e, r),
                this._wrap(e, r, this._getPatchExtendWithCommands(n)),
                e
              );
            },
            (e) => {
              ((0, i.isWrapped)(e?.extendWithCommands) && this._unwrap(e, 'extendWithCommands'),
                (0, i.isWrapped)(e?.attachCommands) && this._unwrap(e, 'attachCommands'));
            }
          ),
          n = new i.InstrumentationNodeModuleFile(
            `${e}/dist/lib/client/multi-command.js`,
            ['^1.0.0'],
            (e) => {
              let t = e?.default?.prototype;
              return (
                (0, i.isWrapped)(t?.exec) && this._unwrap(t, 'exec'),
                this._wrap(t, 'exec', this._getPatchMultiCommandsExec()),
                (0, i.isWrapped)(t?.addCommand) && this._unwrap(t, 'addCommand'),
                this._wrap(t, 'addCommand', this._getPatchMultiCommandsAddCommand()),
                e
              );
            },
            (e) => {
              let t = e?.default?.prototype;
              ((0, i.isWrapped)(t?.exec) && this._unwrap(t, 'exec'),
                (0, i.isWrapped)(t?.addCommand) && this._unwrap(t, 'addCommand'));
            }
          ),
          r = new i.InstrumentationNodeModuleFile(
            `${e}/dist/lib/client/index.js`,
            ['^1.0.0'],
            (e) => {
              let t = e?.default?.prototype;
              return (
                t?.multi &&
                  ((0, i.isWrapped)(t?.multi) && this._unwrap(t, 'multi'),
                  this._wrap(t, 'multi', this._getPatchRedisClientMulti())),
                t?.MULTI &&
                  ((0, i.isWrapped)(t?.MULTI) && this._unwrap(t, 'MULTI'),
                  this._wrap(t, 'MULTI', this._getPatchRedisClientMulti())),
                (0, i.isWrapped)(t?.sendCommand) && this._unwrap(t, 'sendCommand'),
                this._wrap(t, 'sendCommand', this._getPatchRedisClientSendCommand()),
                this._wrap(t, 'connect', this._getPatchedClientConnect()),
                e
              );
            },
            (e) => {
              let t = e?.default?.prototype;
              ((0, i.isWrapped)(t?.multi) && this._unwrap(t, 'multi'),
                (0, i.isWrapped)(t?.MULTI) && this._unwrap(t, 'MULTI'),
                (0, i.isWrapped)(t?.sendCommand) && this._unwrap(t, 'sendCommand'));
            }
          );
        return new i.InstrumentationNodeModuleDefinition(
          e,
          ['^1.0.0'],
          (e) => e,
          () => {},
          [t, n, r]
        );
      }
      _getPatchExtendWithCommands(e) {
        let t = this;
        return function (n) {
          return function (r) {
            if (r?.BaseClass?.name !== 'RedisClient') return n.apply(this, arguments);
            let i = r.executor;
            return (
              (r.executor = function (n, r) {
                let o = e(n, r).args;
                return t._traceClientCommand(i, this, arguments, o);
              }),
              n.apply(this, arguments)
            );
          };
        };
      }
      _getPatchMultiCommandsExec() {
        let e = this;
        return function (t) {
          return function () {
            let n = t.apply(this, arguments);
            return 'function' != typeof n?.then
              ? (e._diag.error('got non promise result when patching RedisClientMultiCommand.exec'),
                n)
              : n
                  .then((t) => {
                    let n = this[l];
                    return (e._endSpansWithRedisReplies(n, t), t);
                  })
                  .catch((t) => {
                    let n = this[l];
                    if (n) {
                      let r =
                        'MultiErrorReply' === t.constructor.name
                          ? t.replies
                          : Array(n.length).fill(t);
                      e._endSpansWithRedisReplies(n, r);
                    } else e._diag.error('cannot find open spans to end for redis multi command');
                    return Promise.reject(t);
                  });
          };
        };
      }
      _getPatchMultiCommandsAddCommand() {
        let e = this;
        return function (t) {
          return function (n) {
            return e._traceClientCommand(t, this, arguments, n);
          };
        };
      }
      _getPatchRedisClientMulti() {
        return function (e) {
          return function () {
            let t = e.apply(this, arguments);
            return ((t[c] = this.options), t);
          };
        };
      }
      _getPatchRedisClientSendCommand() {
        let e = this;
        return function (t) {
          return function (n) {
            return e._traceClientCommand(t, this, arguments, n);
          };
        };
      }
      _getPatchedClientConnect() {
        let e = this;
        return function (t) {
          return function () {
            let n = this.options,
              i = (0, o.getClientAttributes)(e._diag, n),
              a = e.tracer.startSpan(`${d.COMPONENT}-connect`, {
                kind: r.SpanKind.CLIENT,
                attributes: i,
              });
            return r.context
              .with(r.trace.setSpan(r.context.active(), a), () => t.apply(this))
              .then((e) => (a.end(), e))
              .catch(
                (e) => (
                  a.recordException(e),
                  a.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                  a.end(),
                  Promise.reject(e)
                )
              );
          };
        };
      }
      _traceClientCommand(e, t, n, i) {
        if (void 0 === r.trace.getSpan(r.context.active()) && this.getConfig().requireParentSpan)
          return e.apply(t, n);
        let s = t.options || t[c],
          p = i[0],
          _ = i.slice(1),
          S = this.getConfig().dbStatementSerializer || a.defaultDbStatementSerializer,
          E = (0, o.getClientAttributes)(this._diag, s);
        try {
          let e = S(p, _);
          null != e && (E[u.SEMATTRS_DB_STATEMENT] = e);
        } catch (e) {
          this._diag.error('dbStatementSerializer throw an exception', e, { commandName: p });
        }
        let T = this.tracer.startSpan(`${d.COMPONENT}-${p}`, {
            kind: r.SpanKind.CLIENT,
            attributes: E,
          }),
          m = r.context.with(r.trace.setSpan(r.context.active(), T), () => e.apply(t, n));
        return (
          'function' == typeof m?.then
            ? m.then(
                (e) => {
                  this._endSpanWithResponse(T, p, _, e, void 0);
                },
                (e) => {
                  this._endSpanWithResponse(T, p, _, null, e);
                }
              )
            : ((m[l] = m[l] || []), m[l].push({ span: T, commandName: p, commandArgs: _ })),
          m
        );
      }
      _endSpansWithRedisReplies(e, t) {
        if (!e) return this._diag.error('cannot find open spans to end for redis multi command');
        if (t.length !== e.length)
          return this._diag.error(
            'number of multi command spans does not match response from redis'
          );
        for (let n = 0; n < e.length; n++) {
          let { span: r, commandName: i, commandArgs: o } = e[n],
            a = t[n],
            [s, u] = a instanceof Error ? [null, a] : [a, void 0];
          this._endSpanWithResponse(r, i, o, s, u);
        }
      }
      _endSpanWithResponse(e, t, n, i, o) {
        let { responseHook: a } = this.getConfig();
        if (!o && a)
          try {
            a(e, t, n, i);
          } catch (e) {
            this._diag.error('responseHook throw an exception', e);
          }
        (o &&
          (e.recordException(o),
          e.setStatus({ code: r.SpanStatusCode.ERROR, message: o?.message })),
          e.end());
      }
    }
    n.RedisInstrumentationV4 = d;
  },
  13110,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.RedisInstrumentation = void 0));
    let r = e.r(75235),
      i = e.r(47505),
      o = e.r(48450),
      a = e.r(45732),
      s = { requireParentSpan: !1 };
    class u extends r.InstrumentationBase {
      instrumentationV2_V3;
      instrumentationV4;
      initialized = !1;
      constructor(e = {}) {
        (super(i.PACKAGE_NAME, i.PACKAGE_VERSION, { ...s, ...e }),
          (this.instrumentationV2_V3 = new o.RedisInstrumentationV2_V3(this.getConfig())),
          (this.instrumentationV4 = new a.RedisInstrumentationV4(this.getConfig())),
          (this.initialized = !0));
      }
      setConfig(e = {}) {
        let t = { ...s, ...e };
        (super.setConfig(t),
          this.initialized &&
            (this.instrumentationV2_V3.setConfig(t), this.instrumentationV4.setConfig(t)));
      }
      init() {}
      setTracerProvider(e) {
        (super.setTracerProvider(e),
          this.initialized &&
            (this.instrumentationV2_V3.setTracerProvider(e),
            this.instrumentationV4.setTracerProvider(e)));
      }
      enable() {
        (super.enable(),
          this.initialized &&
            (this.instrumentationV2_V3.enable(), this.instrumentationV4.enable()));
      }
      disable() {
        (super.disable(),
          this.initialized &&
            (this.instrumentationV2_V3.disable(), this.instrumentationV4.disable()));
      }
    }
    n.RedisInstrumentation = u;
  },
  1746,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.RedisInstrumentation = void 0));
    var r = e.r(13110);
    Object.defineProperty(n, 'RedisInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.RedisInstrumentation;
      },
    });
  },
  22807,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = ['get', 'set', 'setex'],
      i = ['get', 'mget'],
      o = ['set', 'setex'];
    function a(e, t) {
      return e.includes(t.toLowerCase());
    }
    function s(e) {
      return a(i, e) ? 'cache.get' : a(o, e) ? 'cache.put' : void 0;
    }
    function u(e) {
      let t = [],
        n = (e) => {
          e.forEach((e) => {
            Array.isArray(e) ? n(e) : t.push(e);
          });
        };
      return (n(e), t);
    }
    ((n.GET_COMMANDS = i),
      (n.SET_COMMANDS = o),
      (n.calculateCacheItemSize = function (e) {
        let t = (e) => {
          try {
            if (Buffer.isBuffer(e)) return e.byteLength;
            if ('string' == typeof e) return e.length;
            if ('number' == typeof e) return e.toString().length;
            else if (null == e) return 0;
            return JSON.stringify(e).length;
          } catch {
            return;
          }
        };
        return Array.isArray(e)
          ? e.reduce((e, n) => {
              let r = t(n);
              return 'number' == typeof r ? (void 0 !== e ? e + r : r) : e;
            }, 0)
          : t(e);
      }),
      (n.getCacheKeySafely = function (e, t) {
        try {
          if (0 === t.length) return;
          let n = (e) =>
              'string' == typeof e || 'number' == typeof e || Buffer.isBuffer(e)
                ? [e.toString()]
                : Array.isArray(e)
                  ? u(e.map((e) => n(e)))
                  : ['<unknown>'],
            i = t[0];
          if (a(r, e) && null != i) return n(i);
          return u(t.map((e) => n(e)));
        } catch {
          return;
        }
      }),
      (n.getCacheOperation = s),
      (n.isInCommands = a),
      (n.shouldConsiderForCache = function (e, t, n) {
        if (!s(e)) return !1;
        for (let e of t)
          if (
            (function (e, t) {
              return t.some((t) => e.startsWith(t));
            })(e, n)
          )
            return !0;
        return !1;
      }));
  },
  20176,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(54265),
      i = e.r(1746),
      o = e.r(48009),
      a = e.r(15527),
      s = e.r(22807),
      u = 'Redis',
      l = {},
      c = (e, t, n, r) => {
        e.setAttribute(o.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.redis');
        let i = s.getCacheKeySafely(t, n),
          a = s.getCacheOperation(t);
        if (!i || !a || !l.cachePrefixes || !s.shouldConsiderForCache(t, i, l.cachePrefixes))
          return;
        let u = o.spanToJSON(e).data['net.peer.name'],
          c = o.spanToJSON(e).data['net.peer.port'];
        c && u && e.setAttributes({ 'network.peer.address': u, 'network.peer.port': c });
        let d = s.calculateCacheItemSize(r);
        (d && e.setAttribute(o.SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE, d),
          s.isInCommands(s.GET_COMMANDS, t) &&
            void 0 !== d &&
            e.setAttribute(o.SEMANTIC_ATTRIBUTE_CACHE_HIT, d > 0),
          e.setAttributes({
            [o.SEMANTIC_ATTRIBUTE_SENTRY_OP]: a,
            [o.SEMANTIC_ATTRIBUTE_CACHE_KEY]: i,
          }));
        let p = i.join(', ');
        e.updateName(o.truncate(p, 1024));
      },
      d = a.generateInstrumentOnce(
        `${u}.IORedis`,
        () => new r.IORedisInstrumentation({ responseHook: c })
      ),
      p = a.generateInstrumentOnce(
        `${u}.Redis`,
        () => new i.RedisInstrumentation({ responseHook: c })
      ),
      _ = Object.assign(
        () => {
          (d(), p());
        },
        { id: u }
      ),
      S = o.defineIntegration((e = {}) => ({
        name: u,
        setupOnce() {
          ((l = e), _());
        },
      }));
    ((n.instrumentRedis = _), (n.redisIntegration = S));
  },
  92365,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.EVENT_LISTENERS_SET = void 0),
      (n.EVENT_LISTENERS_SET = Symbol('opentelemetry.instrumentation.pg.eventListenersSet')));
  },
  56481,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.PG_VALUES = 'db.postgresql.values'),
          (e.PG_PLAN = 'db.postgresql.plan'),
          (e.IDLE_TIMEOUT_MILLIS = 'db.postgresql.idle.timeout.millis'),
          (e.MAX_CLIENT = 'db.postgresql.max.client'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  8259,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.METRIC_DB_CLIENT_OPERATION_DURATION =
        n.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS =
        n.METRIC_DB_CLIENT_CONNECTION_COUNT =
        n.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE =
        n.DB_CLIENT_CONNECTION_STATE_VALUE_USED =
        n.ATTR_DB_OPERATION_NAME =
        n.ATTR_DB_NAMESPACE =
        n.ATTR_DB_CLIENT_CONNECTION_STATE =
        n.ATTR_DB_CLIENT_CONNECTION_POOL_NAME =
          void 0),
      (n.ATTR_DB_CLIENT_CONNECTION_POOL_NAME = 'db.client.connection.pool.name'),
      (n.ATTR_DB_CLIENT_CONNECTION_STATE = 'db.client.connection.state'),
      (n.ATTR_DB_NAMESPACE = 'db.namespace'),
      (n.ATTR_DB_OPERATION_NAME = 'db.operation.name'),
      (n.DB_CLIENT_CONNECTION_STATE_VALUE_USED = 'used'),
      (n.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE = 'idle'),
      (n.METRIC_DB_CLIENT_CONNECTION_COUNT = 'db.client.connection.count'),
      (n.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS = 'db.client.connection.pending_requests'),
      (n.METRIC_DB_CLIENT_OPERATION_DURATION = 'db.client.operation.duration'));
  },
  49962,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SpanNames = void 0),
      (function (e) {
        ((e.QUERY_PREFIX = 'pg.query'),
          (e.CONNECT = 'pg.connect'),
          (e.POOL_CONNECT = 'pg-pool.connect'));
      })(n.SpanNames || (n.SpanNames = {})));
  },
  71201,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.isObjectWithTextString =
        n.getErrorMessage =
        n.patchClientConnectCallback =
        n.patchCallbackPGPool =
        n.updateCounter =
        n.getPoolName =
        n.patchCallback =
        n.handleExecutionResult =
        n.handleConfigQuery =
        n.shouldSkipInstrumentation =
        n.getSemanticAttributesFromPool =
        n.getSemanticAttributesFromConnection =
        n.getConnectionString =
        n.parseAndMaskConnectionString =
        n.parseNormalizedOperationName =
        n.getQuerySpanName =
          void 0));
    let r = e.r(52305),
      i = e.r(56481),
      o = e.r(81964),
      a = e.r(8259),
      s = e.r(75235),
      u = e.r(49962);
    function l(e, t) {
      if (!t) return u.SpanNames.QUERY_PREFIX;
      let n = 'string' == typeof t.name && t.name ? t.name : c(t.text);
      return `${u.SpanNames.QUERY_PREFIX}:${n}${e ? ` ${e}` : ''}`;
    }
    function c(e) {
      let t = e.indexOf(' '),
        n = -1 === t ? e : e.slice(0, t);
      return (n = n.toUpperCase()).endsWith(';') ? n.slice(0, -1) : n;
    }
    function d(e) {
      try {
        let t = new URL(e);
        return ((t.username = ''), (t.password = ''), t.toString());
      } catch (e) {
        return 'postgresql://localhost:5432/';
      }
    }
    function p(e) {
      if ('connectionString' in e && e.connectionString) return d(e.connectionString);
      let t = e.host || 'localhost',
        n = e.port || 5432,
        r = e.database || '';
      return `postgresql://${t}:${n}/${r}`;
    }
    function _(e) {
      if (Number.isInteger(e)) return e;
    }
    function S(e) {
      return {
        [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_POSTGRESQL,
        [o.SEMATTRS_DB_NAME]: e.database,
        [o.SEMATTRS_DB_CONNECTION_STRING]: p(e),
        [o.SEMATTRS_NET_PEER_NAME]: e.host,
        [o.SEMATTRS_NET_PEER_PORT]: _(e.port),
        [o.SEMATTRS_DB_USER]: e.user,
      };
    }
    function E(e, t, n) {
      'function' == typeof e.responseHook &&
        (0, s.safeExecuteInTheMiddle)(
          () => {
            e.responseHook(t, { data: n });
          },
          (e) => {
            e && r.diag.error('Error running response hook', e);
          },
          !0
        );
    }
    ((n.getQuerySpanName = l),
      (n.parseNormalizedOperationName = c),
      (n.parseAndMaskConnectionString = d),
      (n.getConnectionString = p),
      (n.getSemanticAttributesFromConnection = S),
      (n.getSemanticAttributesFromPool = function (e) {
        let t;
        try {
          t = e.connectionString ? new URL(e.connectionString) : void 0;
        } catch (e) {
          t = void 0;
        }
        return {
          [o.SEMATTRS_DB_SYSTEM]: o.DBSYSTEMVALUES_POSTGRESQL,
          [o.SEMATTRS_DB_NAME]: t?.pathname.slice(1) ?? e.database,
          [o.SEMATTRS_DB_CONNECTION_STRING]: p(e),
          [o.SEMATTRS_NET_PEER_NAME]: t?.hostname ?? e.host,
          [o.SEMATTRS_NET_PEER_PORT]: Number(t?.port) || _(e.port),
          [o.SEMATTRS_DB_USER]: t?.username ?? e.user,
          [i.AttributeNames.IDLE_TIMEOUT_MILLIS]: e.idleTimeoutMillis,
          [i.AttributeNames.MAX_CLIENT]: e.maxClient,
        };
      }),
      (n.shouldSkipInstrumentation = function (e) {
        return !0 === e.requireParentSpan && void 0 === r.trace.getSpan(r.context.active());
      }),
      (n.handleConfigQuery = function (e, t, n) {
        let { connectionParameters: a } = this,
          s = l(a.database, n),
          u = e.startSpan(s, { kind: r.SpanKind.CLIENT, attributes: S(a) });
        if (!n) return u;
        if (
          (n.text && u.setAttribute(o.SEMATTRS_DB_STATEMENT, n.text),
          t.enhancedDatabaseReporting && Array.isArray(n.values))
        )
          try {
            let e = n.values.map((e) =>
              null == e
                ? 'null'
                : e instanceof Buffer
                  ? e.toString()
                  : 'object' != typeof e
                    ? e.toString()
                    : 'function' == typeof e.toPostgres
                      ? e.toPostgres()
                      : JSON.stringify(e)
            );
            u.setAttribute(i.AttributeNames.PG_VALUES, e);
          } catch (e) {
            r.diag.error('failed to stringify ', n.values, e);
          }
        return ('string' == typeof n.name && u.setAttribute(i.AttributeNames.PG_PLAN, n.name), u);
      }),
      (n.handleExecutionResult = E),
      (n.patchCallback = function (e, t, n, i, a) {
        return function (s, u) {
          (s
            ? (Object.prototype.hasOwnProperty.call(s, 'code') && (i[o.ATTR_ERROR_TYPE] = s.code),
              t.setStatus({ code: r.SpanStatusCode.ERROR, message: s.message }))
            : E(e, t, u),
            a(),
            t.end(),
            n.call(this, s, u));
        };
      }),
      (n.getPoolName = function (e) {
        let t = '';
        return (t +=
          (e?.host ? `${e.host}` : 'unknown_host') +
          ':' +
          (e?.port ? `${e.port}` : 'unknown_port') +
          '/' +
          (e?.database ? `${e.database}` : 'unknown_database')).trim();
      }),
      (n.updateCounter = function (e, t, n, r, i) {
        let o = t.totalCount,
          s = t.waitingCount,
          u = t.idleCount,
          l = o - u;
        return (
          n.add(l - i.used, {
            [a.ATTR_DB_CLIENT_CONNECTION_STATE]: a.DB_CLIENT_CONNECTION_STATE_VALUE_USED,
            [a.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: e,
          }),
          n.add(u - i.idle, {
            [a.ATTR_DB_CLIENT_CONNECTION_STATE]: a.DB_CLIENT_CONNECTION_STATE_VALUE_IDLE,
            [a.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: e,
          }),
          r.add(s - i.pending, { [a.ATTR_DB_CLIENT_CONNECTION_POOL_NAME]: e }),
          { used: l, idle: u, pending: s }
        );
      }),
      (n.patchCallbackPGPool = function (e, t) {
        return function (n, i, o) {
          (n && e.setStatus({ code: r.SpanStatusCode.ERROR, message: n.message }),
            e.end(),
            t.call(this, n, i, o));
        };
      }),
      (n.patchClientConnectCallback = function (e, t) {
        return function (n) {
          (n && e.setStatus({ code: r.SpanStatusCode.ERROR, message: n.message }),
            e.end(),
            t.apply(this, arguments));
        };
      }),
      (n.getErrorMessage = function (e) {
        return 'object' == typeof e && null !== e && 'message' in e ? String(e.message) : void 0;
      }),
      (n.isObjectWithTextString = function (e) {
        return 'object' == typeof e && 'string' == typeof e?.text;
      }));
  },
  12221,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.55.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-pg'));
  },
  13091,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PgInstrumentation = void 0));
    let r = e.r(75235),
      i = e.r(52305),
      o = e.r(92365),
      a = e.r(71201),
      s = e.r(94570),
      u = e.r(12221),
      l = e.r(49962),
      c = e.r(88540),
      d = e.r(81964),
      p = e.r(8259);
    function _(e) {
      return 'Module' === e[Symbol.toStringTag] ? e.default : e;
    }
    class S extends r.InstrumentationBase {
      _connectionsCounter = { used: 0, idle: 0, pending: 0 };
      constructor(e = {}) {
        super(u.PACKAGE_NAME, u.PACKAGE_VERSION, e);
      }
      _updateMetricInstruments() {
        ((this._operationDuration = this.meter.createHistogram(
          p.METRIC_DB_CLIENT_OPERATION_DURATION,
          {
            description: 'Duration of database client operations.',
            unit: 's',
            valueType: i.ValueType.DOUBLE,
            advice: { explicitBucketBoundaries: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10] },
          }
        )),
          (this._connectionsCounter = { idle: 0, pending: 0, used: 0 }),
          (this._connectionsCount = this.meter.createUpDownCounter(
            p.METRIC_DB_CLIENT_CONNECTION_COUNT,
            {
              description:
                'The number of connections that are currently in state described by the state attribute.',
              unit: '{connection}',
            }
          )),
          (this._connectionPendingRequests = this.meter.createUpDownCounter(
            p.METRIC_DB_CLIENT_CONNECTION_PENDING_REQUESTS,
            {
              description: 'The number of current pending requests for an open connection.',
              unit: '{connection}',
            }
          )));
      }
      init() {
        let e = ['>=8.0.3 <9'],
          t = new r.InstrumentationNodeModuleFile(
            'pg/lib/native/client.js',
            e,
            this._patchPgClient.bind(this),
            this._unpatchPgClient.bind(this)
          ),
          n = new r.InstrumentationNodeModuleFile(
            'pg/lib/client.js',
            e,
            this._patchPgClient.bind(this),
            this._unpatchPgClient.bind(this)
          );
        return [
          new r.InstrumentationNodeModuleDefinition(
            'pg',
            e,
            (e) => {
              let t = _(e);
              return (this._patchPgClient(t.Client), e);
            },
            (e) => {
              let t = _(e);
              return (this._unpatchPgClient(t.Client), e);
            },
            [n, t]
          ),
          new r.InstrumentationNodeModuleDefinition(
            'pg-pool',
            ['>=2.0.0 <4'],
            (e) => {
              let t = _(e);
              return (
                (0, r.isWrapped)(t.prototype.connect) && this._unwrap(t.prototype, 'connect'),
                this._wrap(t.prototype, 'connect', this._getPoolConnectPatch()),
                t
              );
            },
            (e) => {
              let t = _(e);
              (0, r.isWrapped)(t.prototype.connect) && this._unwrap(t.prototype, 'connect');
            }
          ),
        ];
      }
      _patchPgClient(e) {
        if (!e) return;
        let t = _(e);
        return (
          (0, r.isWrapped)(t.prototype.query) && this._unwrap(t.prototype, 'query'),
          (0, r.isWrapped)(t.prototype.connect) && this._unwrap(t.prototype, 'connect'),
          this._wrap(t.prototype, 'query', this._getClientQueryPatch()),
          this._wrap(t.prototype, 'connect', this._getClientConnectPatch()),
          e
        );
      }
      _unpatchPgClient(e) {
        let t = _(e);
        return (
          (0, r.isWrapped)(t.prototype.query) && this._unwrap(t.prototype, 'query'),
          (0, r.isWrapped)(t.prototype.connect) && this._unwrap(t.prototype, 'connect'),
          e
        );
      }
      _getClientConnectPatch() {
        let e = this;
        return (t) =>
          function (n) {
            if (a.shouldSkipInstrumentation(e.getConfig())) return t.call(this, n);
            let r = e.tracer.startSpan(l.SpanNames.CONNECT, {
              kind: i.SpanKind.CLIENT,
              attributes: a.getSemanticAttributesFromConnection(this),
            });
            if (n) {
              let e = i.trace.getSpan(i.context.active());
              ((n = a.patchClientConnectCallback(r, n)),
                e && (n = i.context.bind(i.context.active(), n)));
            }
            let o = i.context.with(i.trace.setSpan(i.context.active(), r), () => t.call(this, n));
            return E(r, o);
          };
      }
      recordOperationDuration(e, t) {
        let n = {};
        [
          d.SEMATTRS_DB_SYSTEM,
          p.ATTR_DB_NAMESPACE,
          d.ATTR_ERROR_TYPE,
          d.ATTR_SERVER_PORT,
          d.ATTR_SERVER_ADDRESS,
          p.ATTR_DB_OPERATION_NAME,
        ].forEach((t) => {
          t in e && (n[t] = e[t]);
        });
        let r = (0, c.hrTimeToMilliseconds)((0, c.hrTimeDuration)(t, (0, c.hrTime)())) / 1e3;
        this._operationDuration.record(r, n);
      }
      _getClientQueryPatch() {
        let e = this;
        return (t) => (
          this._diag.debug('Patching pg.Client.prototype.query'),
          function (...n) {
            let o;
            if (a.shouldSkipInstrumentation(e.getConfig())) return t.apply(this, n);
            let u = (0, c.hrTime)(),
              l = n[0],
              _ = 'string' == typeof l,
              S = a.isObjectWithTextString(l),
              E = _ ? { text: l, values: Array.isArray(n[1]) ? n[1] : void 0 } : S ? l : void 0,
              T = {
                [d.SEMATTRS_DB_SYSTEM]: d.DBSYSTEMVALUES_POSTGRESQL,
                [p.ATTR_DB_NAMESPACE]: this.database,
                [d.ATTR_SERVER_PORT]: this.connectionParameters.port,
                [d.ATTR_SERVER_ADDRESS]: this.connectionParameters.host,
              };
            E?.text && (T[p.ATTR_DB_OPERATION_NAME] = a.parseNormalizedOperationName(E?.text));
            let m = () => {
                e.recordOperationDuration(T, u);
              },
              g = e.getConfig(),
              f = a.handleConfigQuery.call(this, e.tracer, g, E);
            if (
              (g.addSqlCommenterCommentToQueries &&
                (_
                  ? (n[0] = (0, s.addSqlCommenterComment)(f, l))
                  : !S ||
                    'name' in l ||
                    (n[0] = { ...l, text: (0, s.addSqlCommenterComment)(f, l.text) })),
              n.length > 0)
            ) {
              let t = i.trace.getSpan(i.context.active());
              if ('function' == typeof n[n.length - 1])
                ((n[n.length - 1] = a.patchCallback(g, f, n[n.length - 1], T, m)),
                  t && (n[n.length - 1] = i.context.bind(i.context.active(), n[n.length - 1])));
              else if ('function' == typeof E?.callback) {
                let r = a.patchCallback(e.getConfig(), f, E.callback, T, m);
                (t && (r = i.context.bind(i.context.active(), r)), (n[0].callback = r));
              }
            }
            let { requestHook: h } = g;
            'function' == typeof h &&
              E &&
              (0, r.safeExecuteInTheMiddle)(
                () => {
                  let { database: e, host: t, port: n, user: r } = this.connectionParameters;
                  h(f, {
                    connection: { database: e, host: t, port: n, user: r },
                    query: { text: E.text, values: E.values, name: E.name },
                  });
                },
                (t) => {
                  t && e._diag.error('Error running query hook', t);
                },
                !0
              );
            try {
              o = t.apply(this, n);
            } catch (e) {
              throw (
                f.setStatus({ code: i.SpanStatusCode.ERROR, message: a.getErrorMessage(e) }),
                f.end(),
                e
              );
            }
            return o instanceof Promise
              ? o
                  .then(
                    (t) =>
                      new Promise((n) => {
                        (a.handleExecutionResult(e.getConfig(), f, t), m(), f.end(), n(t));
                      })
                  )
                  .catch(
                    (e) =>
                      new Promise((t, n) => {
                        (f.setStatus({ code: i.SpanStatusCode.ERROR, message: e.message }),
                          m(),
                          f.end(),
                          n(e));
                      })
                  )
              : o;
          }
        );
      }
      _setPoolConnectEventListeners(e) {
        if (e[o.EVENT_LISTENERS_SET]) return;
        let t = a.getPoolName(e.options);
        (e.on('connect', () => {
          this._connectionsCounter = a.updateCounter(
            t,
            e,
            this._connectionsCount,
            this._connectionPendingRequests,
            this._connectionsCounter
          );
        }),
          e.on('acquire', () => {
            this._connectionsCounter = a.updateCounter(
              t,
              e,
              this._connectionsCount,
              this._connectionPendingRequests,
              this._connectionsCounter
            );
          }),
          e.on('remove', () => {
            this._connectionsCounter = a.updateCounter(
              t,
              e,
              this._connectionsCount,
              this._connectionPendingRequests,
              this._connectionsCounter
            );
          }),
          e.on('release', () => {
            this._connectionsCounter = a.updateCounter(
              t,
              e,
              this._connectionsCount,
              this._connectionPendingRequests,
              this._connectionsCounter
            );
          }),
          (e[o.EVENT_LISTENERS_SET] = !0));
      }
      _getPoolConnectPatch() {
        let e = this;
        return (t) =>
          function (n) {
            if (a.shouldSkipInstrumentation(e.getConfig())) return t.call(this, n);
            let r = e.tracer.startSpan(l.SpanNames.POOL_CONNECT, {
              kind: i.SpanKind.CLIENT,
              attributes: a.getSemanticAttributesFromPool(this.options),
            });
            if ((e._setPoolConnectEventListeners(this), n)) {
              let e = i.trace.getSpan(i.context.active());
              ((n = a.patchCallbackPGPool(r, n)), e && (n = i.context.bind(i.context.active(), n)));
            }
            let o = i.context.with(i.trace.setSpan(i.context.active(), r), () => t.call(this, n));
            return E(r, o);
          };
      }
    }
    function E(e, t) {
      return t instanceof Promise
        ? i.context.bind(
            i.context.active(),
            t
              .then((t) => (e.end(), t))
              .catch(
                (t) => (
                  e.setStatus({ code: i.SpanStatusCode.ERROR, message: a.getErrorMessage(t) }),
                  e.end(),
                  Promise.reject(t)
                )
              )
          )
        : t;
    }
    n.PgInstrumentation = S;
  },
  29681,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = n.PgInstrumentation = void 0));
    var r = e.r(13091);
    Object.defineProperty(n, 'PgInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.PgInstrumentation;
      },
    });
    var i = e.r(56481);
    Object.defineProperty(n, 'AttributeNames', {
      enumerable: !0,
      get: function () {
        return i.AttributeNames;
      },
    });
  },
  75094,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(29681),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Postgres',
      s = o.generateInstrumentOnce(
        a,
        () =>
          new r.PgInstrumentation({
            requireParentSpan: !0,
            requestHook(e) {
              o.addOriginToSpan(e, 'auto.db.otel.postgres');
            },
          })
      ),
      u = i.defineIntegration(() => ({
        name: a,
        setupOnce() {
          s();
        },
      }));
    ((n.instrumentPostgres = s), (n.postgresIntegration = u));
  },
  91480,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(81964),
      a = e.r(48009),
      s = e.r(15527),
      u = 'PostgresJs',
      l = ['>=3.0.0 <4'],
      c = s.generateInstrumentOnce(
        u,
        (e) => new d({ requireParentSpan: e?.requireParentSpan ?? !0, requestHook: e?.requestHook })
      );
    class d extends i.InstrumentationBase {
      constructor(e) {
        super('sentry-postgres-js', a.SDK_VERSION, e);
      }
      init() {
        let e = new i.InstrumentationNodeModuleDefinition('postgres', l);
        return (
          ['src', 'cf/src', 'cjs/src'].forEach((t) => {
            (e.files.push(
              new i.InstrumentationNodeModuleFile(
                `postgres/${t}/connection.js`,
                ['*'],
                this._patchConnection.bind(this),
                this._unwrap.bind(this)
              )
            ),
              e.files.push(
                new i.InstrumentationNodeModuleFile(
                  `postgres/${t}/query.js`,
                  l,
                  this._patchQuery.bind(this),
                  this._unwrap.bind(this)
                )
              ));
          }),
          [e]
        );
      }
      _shouldCreateSpans() {
        let e = this.getConfig();
        return void 0 !== r.trace.getSpan(r.context.active()) || !e.requireParentSpan;
      }
      _patchReject(e, t) {
        return new Proxy(e, {
          apply: (e, n, r) => {
            t.setStatus({ code: a.SPAN_STATUS_ERROR, message: r?.[0]?.message || 'unknown_error' });
            let i = Reflect.apply(e, n, r);
            return (
              t.setAttribute(o.ATTR_DB_RESPONSE_STATUS_CODE, r?.[0]?.code || 'Unknown error'),
              t.setAttribute(o.ATTR_ERROR_TYPE, r?.[0]?.name || 'Unknown error'),
              t.end(),
              i
            );
          },
        });
      }
      _patchResolve(e, t) {
        return new Proxy(e, {
          apply: (e, n, r) => {
            let i = Reflect.apply(e, n, r),
              a = r?.[0]?.command;
            return (a && t.setAttribute(o.ATTR_DB_OPERATION_NAME, a), t.end(), i);
          },
        });
      }
      _patchQuery(e) {
        return (
          (e.Query.prototype.handle = new Proxy(e.Query.prototype.handle, {
            apply: async (e, t, n) => {
              if (!this._shouldCreateSpans()) return Reflect.apply(e, t, n);
              let r = this._sanitizeSqlQuery(t.strings?.[0]);
              return a.startSpanManual({ name: r || 'postgresjs.query', op: 'db' }, (l) => {
                let c = a.getCurrentScope().getScopeData().contexts.postgresjsConnection;
                s.addOriginToSpan(l, 'auto.db.otel.postgres');
                let { requestHook: d } = this.getConfig();
                d &&
                  i.safeExecuteInTheMiddle(
                    () => d(l, r, c),
                    (e) => {
                      e && a.debug.error(`Error in requestHook for ${u} integration:`, e);
                    }
                  );
                let p = c?.ATTR_DB_NAMESPACE || '<unknown database>',
                  _ = c?.ATTR_SERVER_ADDRESS || '<unknown host>',
                  S = c?.ATTR_SERVER_PORT || '<unknown port>';
                (l.setAttribute(o.ATTR_DB_SYSTEM_NAME, 'postgres'),
                  l.setAttribute(o.ATTR_DB_NAMESPACE, p),
                  l.setAttribute(o.ATTR_SERVER_ADDRESS, _),
                  l.setAttribute(o.ATTR_SERVER_PORT, S),
                  l.setAttribute(o.ATTR_DB_QUERY_TEXT, r),
                  (t.resolve = this._patchResolve(t.resolve, l)),
                  (t.reject = this._patchReject(t.reject, l)));
                try {
                  return Reflect.apply(e, t, n);
                } catch (e) {
                  throw (l.setStatus({ code: a.SPAN_STATUS_ERROR }), l.end(), e);
                }
              });
            },
          })),
          e
        );
      }
      _patchConnection(e) {
        return new Proxy(e, {
          apply: (e, t, n) => {
            let r = n[0]?.database || '<unknown database>',
              i = n[0]?.host?.[0] || '<unknown host>',
              o = n[0]?.port?.[0] || '<unknown port>';
            return (
              a
                .getCurrentScope()
                .setContext('postgresjsConnection', {
                  ATTR_DB_NAMESPACE: r,
                  ATTR_SERVER_ADDRESS: i,
                  ATTR_SERVER_PORT: o,
                }),
              Reflect.apply(e, t, n)
            );
          },
        });
      }
      _sanitizeSqlQuery(e) {
        return e
          ? e
              .replace(/\s+/g, ' ')
              .trim()
              .substring(0, 1024)
              .replace(/--.*?(\r?\n|$)/g, '')
              .replace(/\/\*[\s\S]*?\*\//g, '')
              .replace(/;\s*$/, '')
              .replace(/\b\d+\b/g, '?')
              .replace(/\s+/g, ' ')
              .replace(/\bIN\b\s*\(\s*\?(?:\s*,\s*\?)*\s*\)/g, 'IN (?)')
          : 'Unknown SQL Query';
      }
    }
    let p = a.defineIntegration(() => ({
      name: u,
      setupOnce() {
        c();
      },
    }));
    ((n.PostgresJsInstrumentation = d),
      (n.instrumentPostgresJs = c),
      (n.postgresJsIntegration = p));
  },
  86229,
  (e, t, n) => {
    'use strict';
    t.exports = {
      MAX_LENGTH: 256,
      MAX_SAFE_COMPONENT_LENGTH: 16,
      MAX_SAFE_BUILD_LENGTH: 250,
      MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 0x1fffffffffffff,
      RELEASE_TYPES: ['major', 'premajor', 'minor', 'preminor', 'patch', 'prepatch', 'prerelease'],
      SEMVER_SPEC_VERSION: '2.0.0',
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2,
    };
  },
  41873,
  (e, t, n) => {
    'use strict';
    t.exports =
      'object' == typeof process &&
      process.env &&
      process.env.NODE_DEBUG &&
      /\bsemver\b/i.test(process.env.NODE_DEBUG)
        ? (...e) => console.error('SEMVER', ...e)
        : () => {};
  },
  13920,
  (e, t, n) => {
    'use strict';
    let { MAX_SAFE_COMPONENT_LENGTH: r, MAX_SAFE_BUILD_LENGTH: i, MAX_LENGTH: o } = e.r(86229),
      a = e.r(41873),
      s = ((n = t.exports = {}).re = []),
      u = (n.safeRe = []),
      l = (n.src = []),
      c = (n.safeSrc = []),
      d = (n.t = {}),
      p = 0,
      _ = '[a-zA-Z0-9-]',
      S = [
        ['\\s', 1],
        ['\\d', o],
        [_, i],
      ],
      E = (e, t, n) => {
        let r = ((e) => {
            for (let [t, n] of S)
              e = e.split(`${t}*`).join(`${t}{0,${n}}`).split(`${t}+`).join(`${t}{1,${n}}`);
            return e;
          })(t),
          i = p++;
        (a(e, i, t),
          (d[e] = i),
          (l[i] = t),
          (c[i] = r),
          (s[i] = new RegExp(t, n ? 'g' : void 0)),
          (u[i] = new RegExp(r, n ? 'g' : void 0)));
      };
    (E('NUMERICIDENTIFIER', '0|[1-9]\\d*'),
      E('NUMERICIDENTIFIERLOOSE', '\\d+'),
      E('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${_}*`),
      E(
        'MAINVERSION',
        `(${l[d.NUMERICIDENTIFIER]})\\.(${l[d.NUMERICIDENTIFIER]})\\.(${l[d.NUMERICIDENTIFIER]})`
      ),
      E(
        'MAINVERSIONLOOSE',
        `(${l[d.NUMERICIDENTIFIERLOOSE]})\\.(${l[d.NUMERICIDENTIFIERLOOSE]})\\.(${l[d.NUMERICIDENTIFIERLOOSE]})`
      ),
      E('PRERELEASEIDENTIFIER', `(?:${l[d.NONNUMERICIDENTIFIER]}|${l[d.NUMERICIDENTIFIER]})`),
      E(
        'PRERELEASEIDENTIFIERLOOSE',
        `(?:${l[d.NONNUMERICIDENTIFIER]}|${l[d.NUMERICIDENTIFIERLOOSE]})`
      ),
      E('PRERELEASE', `(?:-(${l[d.PRERELEASEIDENTIFIER]}(?:\\.${l[d.PRERELEASEIDENTIFIER]})*))`),
      E(
        'PRERELEASELOOSE',
        `(?:-?(${l[d.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${l[d.PRERELEASEIDENTIFIERLOOSE]})*))`
      ),
      E('BUILDIDENTIFIER', `${_}+`),
      E('BUILD', `(?:\\+(${l[d.BUILDIDENTIFIER]}(?:\\.${l[d.BUILDIDENTIFIER]})*))`),
      E('FULLPLAIN', `v?${l[d.MAINVERSION]}${l[d.PRERELEASE]}?${l[d.BUILD]}?`),
      E('FULL', `^${l[d.FULLPLAIN]}$`),
      E('LOOSEPLAIN', `[v=\\s]*${l[d.MAINVERSIONLOOSE]}${l[d.PRERELEASELOOSE]}?${l[d.BUILD]}?`),
      E('LOOSE', `^${l[d.LOOSEPLAIN]}$`),
      E('GTLT', '((?:<|>)?=?)'),
      E('XRANGEIDENTIFIERLOOSE', `${l[d.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),
      E('XRANGEIDENTIFIER', `${l[d.NUMERICIDENTIFIER]}|x|X|\\*`),
      E(
        'XRANGEPLAIN',
        `[v=\\s]*(${l[d.XRANGEIDENTIFIER]})(?:\\.(${l[d.XRANGEIDENTIFIER]})(?:\\.(${l[d.XRANGEIDENTIFIER]})(?:${l[d.PRERELEASE]})?${l[d.BUILD]}?)?)?`
      ),
      E(
        'XRANGEPLAINLOOSE',
        `[v=\\s]*(${l[d.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[d.XRANGEIDENTIFIERLOOSE]})(?:\\.(${l[d.XRANGEIDENTIFIERLOOSE]})(?:${l[d.PRERELEASELOOSE]})?${l[d.BUILD]}?)?)?`
      ),
      E('XRANGE', `^${l[d.GTLT]}\\s*${l[d.XRANGEPLAIN]}$`),
      E('XRANGELOOSE', `^${l[d.GTLT]}\\s*${l[d.XRANGEPLAINLOOSE]}$`),
      E('COERCEPLAIN', `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?`),
      E('COERCE', `${l[d.COERCEPLAIN]}(?:$|[^\\d])`),
      E(
        'COERCEFULL',
        l[d.COERCEPLAIN] + `(?:${l[d.PRERELEASE]})?` + `(?:${l[d.BUILD]})?` + '(?:$|[^\\d])'
      ),
      E('COERCERTL', l[d.COERCE], !0),
      E('COERCERTLFULL', l[d.COERCEFULL], !0),
      E('LONETILDE', '(?:~>?)'),
      E('TILDETRIM', `(\\s*)${l[d.LONETILDE]}\\s+`, !0),
      (n.tildeTrimReplace = '$1~'),
      E('TILDE', `^${l[d.LONETILDE]}${l[d.XRANGEPLAIN]}$`),
      E('TILDELOOSE', `^${l[d.LONETILDE]}${l[d.XRANGEPLAINLOOSE]}$`),
      E('LONECARET', '(?:\\^)'),
      E('CARETTRIM', `(\\s*)${l[d.LONECARET]}\\s+`, !0),
      (n.caretTrimReplace = '$1^'),
      E('CARET', `^${l[d.LONECARET]}${l[d.XRANGEPLAIN]}$`),
      E('CARETLOOSE', `^${l[d.LONECARET]}${l[d.XRANGEPLAINLOOSE]}$`),
      E('COMPARATORLOOSE', `^${l[d.GTLT]}\\s*(${l[d.LOOSEPLAIN]})$|^$`),
      E('COMPARATOR', `^${l[d.GTLT]}\\s*(${l[d.FULLPLAIN]})$|^$`),
      E('COMPARATORTRIM', `(\\s*)${l[d.GTLT]}\\s*(${l[d.LOOSEPLAIN]}|${l[d.XRANGEPLAIN]})`, !0),
      (n.comparatorTrimReplace = '$1$2$3'),
      E('HYPHENRANGE', `^\\s*(${l[d.XRANGEPLAIN]})\\s+-\\s+(${l[d.XRANGEPLAIN]})\\s*$`),
      E(
        'HYPHENRANGELOOSE',
        `^\\s*(${l[d.XRANGEPLAINLOOSE]})\\s+-\\s+(${l[d.XRANGEPLAINLOOSE]})\\s*$`
      ),
      E('STAR', '(<|>)?=?\\s*\\*'),
      E('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$'),
      E('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'));
  },
  25786,
  (e, t, n) => {
    'use strict';
    let r = Object.freeze({ loose: !0 }),
      i = Object.freeze({});
    t.exports = (e) => (e ? ('object' != typeof e ? r : e) : i);
  },
  89084,
  (e, t, n) => {
    'use strict';
    let r = /^[0-9]+$/,
      i = (e, t) => {
        let n = r.test(e),
          i = r.test(t);
        return (
          n && i && ((e *= 1), (t *= 1)),
          e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1
        );
      };
    t.exports = { compareIdentifiers: i, rcompareIdentifiers: (e, t) => i(t, e) };
  },
  62520,
  (e, t, n) => {
    'use strict';
    let r = e.r(41873),
      { MAX_LENGTH: i, MAX_SAFE_INTEGER: o } = e.r(86229),
      { safeRe: a, t: s } = e.r(13920),
      u = e.r(25786),
      { compareIdentifiers: l } = e.r(89084);
    class c {
      constructor(e, t) {
        if (((t = u(t)), e instanceof c))
          if (!!t.loose === e.loose && !!t.includePrerelease === e.includePrerelease) return e;
          else e = e.version;
        else if ('string' != typeof e)
          throw TypeError(`Invalid version. Must be a string. Got type "${typeof e}".`);
        if (e.length > i) throw TypeError(`version is longer than ${i} characters`);
        (r('SemVer', e, t),
          (this.options = t),
          (this.loose = !!t.loose),
          (this.includePrerelease = !!t.includePrerelease));
        let n = e.trim().match(t.loose ? a[s.LOOSE] : a[s.FULL]);
        if (!n) throw TypeError(`Invalid Version: ${e}`);
        if (
          ((this.raw = e),
          (this.major = +n[1]),
          (this.minor = +n[2]),
          (this.patch = +n[3]),
          this.major > o || this.major < 0)
        )
          throw TypeError('Invalid major version');
        if (this.minor > o || this.minor < 0) throw TypeError('Invalid minor version');
        if (this.patch > o || this.patch < 0) throw TypeError('Invalid patch version');
        (n[4]
          ? (this.prerelease = n[4].split('.').map((e) => {
              if (/^[0-9]+$/.test(e)) {
                let t = +e;
                if (t >= 0 && t < o) return t;
              }
              return e;
            }))
          : (this.prerelease = []),
          (this.build = n[5] ? n[5].split('.') : []),
          this.format());
      }
      format() {
        return (
          (this.version = `${this.major}.${this.minor}.${this.patch}`),
          this.prerelease.length && (this.version += `-${this.prerelease.join('.')}`),
          this.version
        );
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if ((r('SemVer.compare', this.version, this.options, e), !(e instanceof c))) {
          if ('string' == typeof e && e === this.version) return 0;
          e = new c(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return (
          e instanceof c || (e = new c(e, this.options)),
          l(this.major, e.major) || l(this.minor, e.minor) || l(this.patch, e.patch)
        );
      }
      comparePre(e) {
        if (
          (e instanceof c || (e = new c(e, this.options)),
          this.prerelease.length && !e.prerelease.length)
        )
          return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t = 0;
        do {
          let n = this.prerelease[t],
            i = e.prerelease[t];
          if ((r('prerelease compare', t, n, i), void 0 === n && void 0 === i)) return 0;
          if (void 0 === i) return 1;
          if (void 0 === n) return -1;
          else if (n === i) continue;
          else return l(n, i);
        } while (++t);
      }
      compareBuild(e) {
        e instanceof c || (e = new c(e, this.options));
        let t = 0;
        do {
          let n = this.build[t],
            i = e.build[t];
          if ((r('build compare', t, n, i), void 0 === n && void 0 === i)) return 0;
          if (void 0 === i) return 1;
          if (void 0 === n) return -1;
          else if (n === i) continue;
          else return l(n, i);
        } while (++t);
      }
      inc(e, t, n) {
        if (e.startsWith('pre')) {
          if (!t && !1 === n) throw Error('invalid increment argument: identifier is empty');
          if (t) {
            let e = `-${t}`.match(this.options.loose ? a[s.PRERELEASELOOSE] : a[s.PRERELEASE]);
            if (!e || e[1] !== t) throw Error(`invalid identifier: ${t}`);
          }
        }
        switch (e) {
          case 'premajor':
            ((this.prerelease.length = 0),
              (this.patch = 0),
              (this.minor = 0),
              this.major++,
              this.inc('pre', t, n));
            break;
          case 'preminor':
            ((this.prerelease.length = 0), (this.patch = 0), this.minor++, this.inc('pre', t, n));
            break;
          case 'prepatch':
            ((this.prerelease.length = 0), this.inc('patch', t, n), this.inc('pre', t, n));
            break;
          case 'prerelease':
            (0 === this.prerelease.length && this.inc('patch', t, n), this.inc('pre', t, n));
            break;
          case 'release':
            if (0 === this.prerelease.length)
              throw Error(`version ${this.raw} is not a prerelease`);
            this.prerelease.length = 0;
            break;
          case 'major':
            ((0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++,
              (this.minor = 0),
              (this.patch = 0),
              (this.prerelease = []));
            break;
          case 'minor':
            ((0 !== this.patch || 0 === this.prerelease.length) && this.minor++,
              (this.patch = 0),
              (this.prerelease = []));
            break;
          case 'patch':
            (0 === this.prerelease.length && this.patch++, (this.prerelease = []));
            break;
          case 'pre': {
            let e = +!!Number(n);
            if (0 === this.prerelease.length) this.prerelease = [e];
            else {
              let r = this.prerelease.length;
              for (; --r >= 0; )
                'number' == typeof this.prerelease[r] && (this.prerelease[r]++, (r = -2));
              if (-1 === r) {
                if (t === this.prerelease.join('.') && !1 === n)
                  throw Error('invalid increment argument: identifier already exists');
                this.prerelease.push(e);
              }
            }
            if (t) {
              let r = [t, e];
              (!1 === n && (r = [t]),
                0 === l(this.prerelease[0], t)
                  ? isNaN(this.prerelease[1]) && (this.prerelease = r)
                  : (this.prerelease = r));
            }
            break;
          }
          default:
            throw Error(`invalid increment argument: ${e}`);
        }
        return (
          (this.raw = this.format()),
          this.build.length && (this.raw += `+${this.build.join('.')}`),
          this
        );
      }
    }
    t.exports = c;
  },
  44514,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t, n = !1) => {
      if (e instanceof r) return e;
      try {
        return new r(e, t);
      } catch (e) {
        if (!n) return null;
        throw e;
      }
    };
  },
  58679,
  (e, t, n) => {
    'use strict';
    let r = e.r(44514);
    t.exports = (e, t) => {
      let n = r(e, t);
      return n ? n.version : null;
    };
  },
  20796,
  (e, t, n) => {
    'use strict';
    let r = e.r(44514);
    t.exports = (e, t) => {
      let n = r(e.trim().replace(/^[=v]+/, ''), t);
      return n ? n.version : null;
    };
  },
  42905,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t, n, i, o) => {
      'string' == typeof n && ((o = i), (i = n), (n = void 0));
      try {
        return new r(e instanceof r ? e.version : e, n).inc(t, i, o).version;
      } catch (e) {
        return null;
      }
    };
  },
  66420,
  (e, t, n) => {
    'use strict';
    let r = e.r(44514);
    t.exports = (e, t) => {
      let n = r(e, null, !0),
        i = r(t, null, !0),
        o = n.compare(i);
      if (0 === o) return null;
      let a = o > 0,
        s = a ? n : i,
        u = a ? i : n,
        l = !!s.prerelease.length;
      if (u.prerelease.length && !l) {
        if (!u.patch && !u.minor) return 'major';
        if (0 === u.compareMain(s)) return u.minor && !u.patch ? 'minor' : 'patch';
      }
      let c = l ? 'pre' : '';
      return n.major !== i.major
        ? c + 'major'
        : n.minor !== i.minor
          ? c + 'minor'
          : n.patch !== i.patch
            ? c + 'patch'
            : 'prerelease';
    };
  },
  82082,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t) => new r(e, t).major;
  },
  14620,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t) => new r(e, t).minor;
  },
  72846,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t) => new r(e, t).patch;
  },
  35703,
  (e, t, n) => {
    'use strict';
    let r = e.r(44514);
    t.exports = (e, t) => {
      let n = r(e, t);
      return n && n.prerelease.length ? n.prerelease : null;
    };
  },
  53079,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t, n) => new r(e, n).compare(new r(t, n));
  },
  60179,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => r(t, e, n);
  },
  11878,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t) => r(e, t, !0);
  },
  56900,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520);
    t.exports = (e, t, n) => {
      let i = new r(e, n),
        o = new r(t, n);
      return i.compare(o) || i.compareBuild(o);
    };
  },
  58581,
  (e, t, n) => {
    'use strict';
    let r = e.r(56900);
    t.exports = (e, t) => e.sort((e, n) => r(e, n, t));
  },
  92144,
  (e, t, n) => {
    'use strict';
    let r = e.r(56900);
    t.exports = (e, t) => e.sort((e, n) => r(n, e, t));
  },
  77149,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => r(e, t, n) > 0;
  },
  74059,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => 0 > r(e, t, n);
  },
  23630,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => 0 === r(e, t, n);
  },
  40716,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => 0 !== r(e, t, n);
  },
  93902,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => r(e, t, n) >= 0;
  },
  21871,
  (e, t, n) => {
    'use strict';
    let r = e.r(53079);
    t.exports = (e, t, n) => 0 >= r(e, t, n);
  },
  36141,
  (e, t, n) => {
    'use strict';
    let r = e.r(23630),
      i = e.r(40716),
      o = e.r(77149),
      a = e.r(93902),
      s = e.r(74059),
      u = e.r(21871);
    t.exports = (e, t, n, l) => {
      switch (t) {
        case '===':
          return (
            'object' == typeof e && (e = e.version),
            'object' == typeof n && (n = n.version),
            e === n
          );
        case '!==':
          return (
            'object' == typeof e && (e = e.version),
            'object' == typeof n && (n = n.version),
            e !== n
          );
        case '':
        case '=':
        case '==':
          return r(e, n, l);
        case '!=':
          return i(e, n, l);
        case '>':
          return o(e, n, l);
        case '>=':
          return a(e, n, l);
        case '<':
          return s(e, n, l);
        case '<=':
          return u(e, n, l);
        default:
          throw TypeError(`Invalid operator: ${t}`);
      }
    };
  },
  98074,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520),
      i = e.r(44514),
      { safeRe: o, t: a } = e.r(13920);
    t.exports = (e, t) => {
      if (e instanceof r) return e;
      if (('number' == typeof e && (e = String(e)), 'string' != typeof e)) return null;
      let n = null;
      if ((t = t || {}).rtl) {
        let r,
          i = t.includePrerelease ? o[a.COERCERTLFULL] : o[a.COERCERTL];
        for (; (r = i.exec(e)) && (!n || n.index + n[0].length !== e.length); )
          ((n && r.index + r[0].length === n.index + n[0].length) || (n = r),
            (i.lastIndex = r.index + r[1].length + r[2].length));
        i.lastIndex = -1;
      } else n = e.match(t.includePrerelease ? o[a.COERCEFULL] : o[a.COERCE]);
      if (null === n) return null;
      let s = n[2],
        u = n[3] || '0',
        l = n[4] || '0',
        c = t.includePrerelease && n[5] ? `-${n[5]}` : '',
        d = t.includePrerelease && n[6] ? `+${n[6]}` : '';
      return i(`${s}.${u}.${l}${c}${d}`, t);
    };
  },
  97115,
  (e, t, n) => {
    'use strict';
    t.exports = class {
      constructor() {
        ((this.max = 1e3), (this.map = new Map()));
      }
      get(e) {
        let t = this.map.get(e);
        if (void 0 !== t) return (this.map.delete(e), this.map.set(e, t), t);
      }
      delete(e) {
        return this.map.delete(e);
      }
      set(e, t) {
        if (!this.delete(e) && void 0 !== t) {
          if (this.map.size >= this.max) {
            let e = this.map.keys().next().value;
            this.delete(e);
          }
          this.map.set(e, t);
        }
        return this;
      }
    };
  },
  37136,
  (e, t, n) => {
    'use strict';
    let r = /\s+/g;
    class i {
      constructor(e, t) {
        if (((t = a(t)), e instanceof i))
          if (!!t.loose === e.loose && !!t.includePrerelease === e.includePrerelease) return e;
          else return new i(e.raw, t);
        if (e instanceof s)
          return ((this.raw = e.value), (this.set = [[e]]), (this.formatted = void 0), this);
        if (
          ((this.options = t),
          (this.loose = !!t.loose),
          (this.includePrerelease = !!t.includePrerelease),
          (this.raw = e.trim().replace(r, ' ')),
          (this.set = this.raw
            .split('||')
            .map((e) => this.parseRange(e.trim()))
            .filter((e) => e.length)),
          !this.set.length)
        )
          throw TypeError(`Invalid SemVer Range: ${this.raw}`);
        if (this.set.length > 1) {
          let e = this.set[0];
          if (((this.set = this.set.filter((e) => !m(e[0]))), 0 === this.set.length))
            this.set = [e];
          else if (this.set.length > 1) {
            for (let e of this.set)
              if (1 === e.length && g(e[0])) {
                this.set = [e];
                break;
              }
          }
        }
        this.formatted = void 0;
      }
      get range() {
        if (void 0 === this.formatted) {
          this.formatted = '';
          for (let e = 0; e < this.set.length; e++) {
            e > 0 && (this.formatted += '||');
            let t = this.set[e];
            for (let e = 0; e < t.length; e++)
              (e > 0 && (this.formatted += ' '), (this.formatted += t[e].toString().trim()));
          }
        }
        return this.formatted;
      }
      format() {
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e) {
        let t = ((this.options.includePrerelease && E) | (this.options.loose && T)) + ':' + e,
          n = o.get(t);
        if (n) return n;
        let r = this.options.loose,
          i = r ? c[d.HYPHENRANGELOOSE] : c[d.HYPHENRANGE];
        (u('hyphen replace', (e = e.replace(i, P(this.options.includePrerelease)))),
          u('comparator trim', (e = e.replace(c[d.COMPARATORTRIM], p))),
          u('tilde trim', (e = e.replace(c[d.TILDETRIM], _))),
          u('caret trim', (e = e.replace(c[d.CARETTRIM], S))));
        let a = e
          .split(' ')
          .map((e) => h(e, this.options))
          .join(' ')
          .split(/\s+/)
          .map((e) => C(e, this.options));
        (r &&
          (a = a.filter(
            (e) => (u('loose invalid filter', e, this.options), !!e.match(c[d.COMPARATORLOOSE]))
          )),
          u('range list', a));
        let l = new Map();
        for (let e of a.map((e) => new s(e, this.options))) {
          if (m(e)) return [e];
          l.set(e.value, e);
        }
        l.size > 1 && l.has('') && l.delete('');
        let g = [...l.values()];
        return (o.set(t, g), g);
      }
      intersects(e, t) {
        if (!(e instanceof i)) throw TypeError('a Range is required');
        return this.set.some(
          (n) =>
            f(n, t) &&
            e.set.some((e) => f(e, t) && n.every((n) => e.every((e) => n.intersects(e, t))))
        );
      }
      test(e) {
        if (!e) return !1;
        if ('string' == typeof e)
          try {
            e = new l(e, this.options);
          } catch (e) {
            return !1;
          }
        for (let t = 0; t < this.set.length; t++) if (M(this.set[t], e, this.options)) return !0;
        return !1;
      }
    }
    t.exports = i;
    let o = new (e.r(97115))(),
      a = e.r(25786),
      s = e.r(30519),
      u = e.r(41873),
      l = e.r(62520),
      {
        safeRe: c,
        t: d,
        comparatorTrimReplace: p,
        tildeTrimReplace: _,
        caretTrimReplace: S,
      } = e.r(13920),
      { FLAG_INCLUDE_PRERELEASE: E, FLAG_LOOSE: T } = e.r(86229),
      m = (e) => '<0.0.0-0' === e.value,
      g = (e) => '' === e.value,
      f = (e, t) => {
        let n = !0,
          r = e.slice(),
          i = r.pop();
        for (; n && r.length; ) ((n = r.every((e) => i.intersects(e, t))), (i = r.pop()));
        return n;
      },
      h = (e, t) => (
        u('comp', e, t),
        u('caret', (e = I(e, t))),
        u('tildes', (e = R(e, t))),
        u('xrange', (e = N(e, t))),
        u('stars', (e = v(e, t))),
        e
      ),
      A = (e) => !e || 'x' === e.toLowerCase() || '*' === e,
      R = (e, t) =>
        e
          .trim()
          .split(/\s+/)
          .map((e) => y(e, t))
          .join(' '),
      y = (e, t) => {
        let n = t.loose ? c[d.TILDELOOSE] : c[d.TILDE];
        return e.replace(n, (t, n, r, i, o) => {
          let a;
          return (
            u('tilde', e, t, n, r, i, o),
            A(n)
              ? (a = '')
              : A(r)
                ? (a = `>=${n}.0.0 <${+n + 1}.0.0-0`)
                : A(i)
                  ? (a = `>=${n}.${r}.0 <${n}.${+r + 1}.0-0`)
                  : o
                    ? (u('replaceTilde pr', o), (a = `>=${n}.${r}.${i}-${o} <${n}.${+r + 1}.0-0`))
                    : (a = `>=${n}.${r}.${i} <${n}.${+r + 1}.0-0`),
            u('tilde return', a),
            a
          );
        });
      },
      I = (e, t) =>
        e
          .trim()
          .split(/\s+/)
          .map((e) => b(e, t))
          .join(' '),
      b = (e, t) => {
        u('caret', e, t);
        let n = t.loose ? c[d.CARETLOOSE] : c[d.CARET],
          r = t.includePrerelease ? '-0' : '';
        return e.replace(n, (t, n, i, o, a) => {
          let s;
          return (
            u('caret', e, t, n, i, o, a),
            A(n)
              ? (s = '')
              : A(i)
                ? (s = `>=${n}.0.0${r} <${+n + 1}.0.0-0`)
                : A(o)
                  ? (s =
                      '0' === n
                        ? `>=${n}.${i}.0${r} <${n}.${+i + 1}.0-0`
                        : `>=${n}.${i}.0${r} <${+n + 1}.0.0-0`)
                  : a
                    ? (u('replaceCaret pr', a),
                      (s =
                        '0' === n
                          ? '0' === i
                            ? `>=${n}.${i}.${o}-${a} <${n}.${i}.${+o + 1}-0`
                            : `>=${n}.${i}.${o}-${a} <${n}.${+i + 1}.0-0`
                          : `>=${n}.${i}.${o}-${a} <${+n + 1}.0.0-0`))
                    : (u('no pr'),
                      (s =
                        '0' === n
                          ? '0' === i
                            ? `>=${n}.${i}.${o}${r} <${n}.${i}.${+o + 1}-0`
                            : `>=${n}.${i}.${o}${r} <${n}.${+i + 1}.0-0`
                          : `>=${n}.${i}.${o} <${+n + 1}.0.0-0`)),
            u('caret return', s),
            s
          );
        });
      },
      N = (e, t) => (
        u('replaceXRanges', e, t),
        e
          .split(/\s+/)
          .map((e) => O(e, t))
          .join(' ')
      ),
      O = (e, t) => {
        e = e.trim();
        let n = t.loose ? c[d.XRANGELOOSE] : c[d.XRANGE];
        return e.replace(n, (n, r, i, o, a, s) => {
          u('xRange', e, n, r, i, o, a, s);
          let l = A(i),
            c = l || A(o),
            d = c || A(a);
          return (
            '=' === r && d && (r = ''),
            (s = t.includePrerelease ? '-0' : ''),
            l
              ? (n = '>' === r || '<' === r ? '<0.0.0-0' : '*')
              : r && d
                ? (c && (o = 0),
                  (a = 0),
                  '>' === r
                    ? ((r = '>='), c ? ((i = +i + 1), (o = 0)) : (o = +o + 1), (a = 0))
                    : '<=' === r && ((r = '<'), c ? (i = +i + 1) : (o = +o + 1)),
                  '<' === r && (s = '-0'),
                  (n = `${r + i}.${o}.${a}${s}`))
                : c
                  ? (n = `>=${i}.0.0${s} <${+i + 1}.0.0-0`)
                  : d && (n = `>=${i}.${o}.0${s} <${i}.${+o + 1}.0-0`),
            u('xRange return', n),
            n
          );
        });
      },
      v = (e, t) => (u('replaceStars', e, t), e.trim().replace(c[d.STAR], '')),
      C = (e, t) => (
        u('replaceGTE0', e, t),
        e.trim().replace(c[t.includePrerelease ? d.GTE0PRE : d.GTE0], '')
      ),
      P = (e) => (t, n, r, i, o, a, s, u, l, c, d, p) => (
        (n = A(r)
          ? ''
          : A(i)
            ? `>=${r}.0.0${e ? '-0' : ''}`
            : A(o)
              ? `>=${r}.${i}.0${e ? '-0' : ''}`
              : a
                ? `>=${n}`
                : `>=${n}${e ? '-0' : ''}`),
        (u = A(l)
          ? ''
          : A(c)
            ? `<${+l + 1}.0.0-0`
            : A(d)
              ? `<${l}.${+c + 1}.0-0`
              : p
                ? `<=${l}.${c}.${d}-${p}`
                : e
                  ? `<${l}.${c}.${+d + 1}-0`
                  : `<=${u}`),
        `${n} ${u}`.trim()
      ),
      M = (e, t, n) => {
        for (let n = 0; n < e.length; n++) if (!e[n].test(t)) return !1;
        if (t.prerelease.length && !n.includePrerelease) {
          for (let n = 0; n < e.length; n++)
            if ((u(e[n].semver), e[n].semver !== s.ANY && e[n].semver.prerelease.length > 0)) {
              let r = e[n].semver;
              if (r.major === t.major && r.minor === t.minor && r.patch === t.patch) return !0;
            }
          return !1;
        }
        return !0;
      };
  },
  30519,
  (e, t, n) => {
    'use strict';
    let r = Symbol('SemVer ANY');
    class i {
      static get ANY() {
        return r;
      }
      constructor(e, t) {
        if (((t = o(t)), e instanceof i))
          if (!!t.loose === e.loose) return e;
          else e = e.value;
        (l('comparator', (e = e.trim().split(/\s+/).join(' ')), t),
          (this.options = t),
          (this.loose = !!t.loose),
          this.parse(e),
          this.semver === r
            ? (this.value = '')
            : (this.value = this.operator + this.semver.version),
          l('comp', this));
      }
      parse(e) {
        let t = this.options.loose ? a[s.COMPARATORLOOSE] : a[s.COMPARATOR],
          n = e.match(t);
        if (!n) throw TypeError(`Invalid comparator: ${e}`);
        ((this.operator = void 0 !== n[1] ? n[1] : ''),
          '=' === this.operator && (this.operator = ''),
          n[2] ? (this.semver = new c(n[2], this.options.loose)) : (this.semver = r));
      }
      toString() {
        return this.value;
      }
      test(e) {
        if ((l('Comparator.test', e, this.options.loose), this.semver === r || e === r)) return !0;
        if ('string' == typeof e)
          try {
            e = new c(e, this.options);
          } catch (e) {
            return !1;
          }
        return u(e, this.operator, this.semver, this.options);
      }
      intersects(e, t) {
        if (!(e instanceof i)) throw TypeError('a Comparator is required');
        return '' === this.operator
          ? '' === this.value || new d(e.value, t).test(this.value)
          : '' === e.operator
            ? '' === e.value || new d(this.value, t).test(e.semver)
            : !(
                ((t = o(t)).includePrerelease &&
                  ('<0.0.0-0' === this.value || '<0.0.0-0' === e.value)) ||
                (!t.includePrerelease &&
                  (this.value.startsWith('<0.0.0') || e.value.startsWith('<0.0.0')))
              ) &&
              !!(
                (this.operator.startsWith('>') && e.operator.startsWith('>')) ||
                (this.operator.startsWith('<') && e.operator.startsWith('<')) ||
                (this.semver.version === e.semver.version &&
                  this.operator.includes('=') &&
                  e.operator.includes('=')) ||
                (u(this.semver, '<', e.semver, t) &&
                  this.operator.startsWith('>') &&
                  e.operator.startsWith('<')) ||
                (u(this.semver, '>', e.semver, t) &&
                  this.operator.startsWith('<') &&
                  e.operator.startsWith('>'))
              );
      }
    }
    t.exports = i;
    let o = e.r(25786),
      { safeRe: a, t: s } = e.r(13920),
      u = e.r(36141),
      l = e.r(41873),
      c = e.r(62520),
      d = e.r(37136);
  },
  59020,
  (e, t, n) => {
    'use strict';
    let r = e.r(37136);
    t.exports = (e, t, n) => {
      try {
        t = new r(t, n);
      } catch (e) {
        return !1;
      }
      return t.test(e);
    };
  },
  44136,
  (e, t, n) => {
    'use strict';
    let r = e.r(37136);
    t.exports = (e, t) =>
      new r(e, t).set.map((e) =>
        e
          .map((e) => e.value)
          .join(' ')
          .trim()
          .split(' ')
      );
  },
  92177,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520),
      i = e.r(37136);
    t.exports = (e, t, n) => {
      let o = null,
        a = null,
        s = null;
      try {
        s = new i(t, n);
      } catch (e) {
        return null;
      }
      return (
        e.forEach((e) => {
          s.test(e) && (!o || -1 === a.compare(e)) && (a = new r((o = e), n));
        }),
        o
      );
    };
  },
  28419,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520),
      i = e.r(37136);
    t.exports = (e, t, n) => {
      let o = null,
        a = null,
        s = null;
      try {
        s = new i(t, n);
      } catch (e) {
        return null;
      }
      return (
        e.forEach((e) => {
          s.test(e) && (!o || 1 === a.compare(e)) && (a = new r((o = e), n));
        }),
        o
      );
    };
  },
  10962,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520),
      i = e.r(37136),
      o = e.r(77149);
    t.exports = (e, t) => {
      e = new i(e, t);
      let n = new r('0.0.0');
      if (e.test(n) || ((n = new r('0.0.0-0')), e.test(n))) return n;
      n = null;
      for (let t = 0; t < e.set.length; ++t) {
        let i = e.set[t],
          a = null;
        (i.forEach((e) => {
          let t = new r(e.semver.version);
          switch (e.operator) {
            case '>':
              (0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0), (t.raw = t.format()));
            case '':
            case '>=':
              (!a || o(t, a)) && (a = t);
              break;
            case '<':
            case '<=':
              break;
            default:
              throw Error(`Unexpected operation: ${e.operator}`);
          }
        }),
          a && (!n || o(n, a)) && (n = a));
      }
      return n && e.test(n) ? n : null;
    };
  },
  26841,
  (e, t, n) => {
    'use strict';
    let r = e.r(37136);
    t.exports = (e, t) => {
      try {
        return new r(e, t).range || '*';
      } catch (e) {
        return null;
      }
    };
  },
  5869,
  (e, t, n) => {
    'use strict';
    let r = e.r(62520),
      i = e.r(30519),
      { ANY: o } = i,
      a = e.r(37136),
      s = e.r(59020),
      u = e.r(77149),
      l = e.r(74059),
      c = e.r(21871),
      d = e.r(93902);
    t.exports = (e, t, n, p) => {
      let _, S, E, T, m;
      switch (((e = new r(e, p)), (t = new a(t, p)), n)) {
        case '>':
          ((_ = u), (S = c), (E = l), (T = '>'), (m = '>='));
          break;
        case '<':
          ((_ = l), (S = d), (E = u), (T = '<'), (m = '<='));
          break;
        default:
          throw TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (s(e, t, p)) return !1;
      for (let n = 0; n < t.set.length; ++n) {
        let r = t.set[n],
          a = null,
          s = null;
        if (
          (r.forEach((e) => {
            (e.semver === o && (e = new i('>=0.0.0')),
              (a = a || e),
              (s = s || e),
              _(e.semver, a.semver, p) ? (a = e) : E(e.semver, s.semver, p) && (s = e));
          }),
          a.operator === T ||
            a.operator === m ||
            ((!s.operator || s.operator === T) && S(e, s.semver)) ||
            (s.operator === m && E(e, s.semver)))
        )
          return !1;
      }
      return !0;
    };
  },
  57373,
  (e, t, n) => {
    'use strict';
    let r = e.r(5869);
    t.exports = (e, t, n) => r(e, t, '>', n);
  },
  124,
  (e, t, n) => {
    'use strict';
    let r = e.r(5869);
    t.exports = (e, t, n) => r(e, t, '<', n);
  },
  39533,
  (e, t, n) => {
    'use strict';
    let r = e.r(37136);
    t.exports = (e, t, n) => ((e = new r(e, n)), (t = new r(t, n)), e.intersects(t, n));
  },
  28171,
  (e, t, n) => {
    'use strict';
    let r = e.r(59020),
      i = e.r(53079);
    t.exports = (e, t, n) => {
      let o = [],
        a = null,
        s = null,
        u = e.sort((e, t) => i(e, t, n));
      for (let e of u)
        r(e, t, n) ? ((s = e), a || (a = e)) : (s && o.push([a, s]), (s = null), (a = null));
      a && o.push([a, null]);
      let l = [];
      for (let [e, t] of o)
        e === t
          ? l.push(e)
          : t || e !== u[0]
            ? t
              ? e === u[0]
                ? l.push(`<=${t}`)
                : l.push(`${e} - ${t}`)
              : l.push(`>=${e}`)
            : l.push('*');
      let c = l.join(' || '),
        d = 'string' == typeof t.raw ? t.raw : String(t);
      return c.length < d.length ? c : t;
    };
  },
  53498,
  (e, t, n) => {
    'use strict';
    let r = e.r(37136),
      i = e.r(30519),
      { ANY: o } = i,
      a = e.r(59020),
      s = e.r(53079),
      u = [new i('>=0.0.0-0')],
      l = [new i('>=0.0.0')],
      c = (e, t, n) => {
        let r, i, c, _, S, E, T;
        if (e === t) return !0;
        if (1 === e.length && e[0].semver === o)
          if (1 === t.length && t[0].semver === o) return !0;
          else e = n.includePrerelease ? u : l;
        if (1 === t.length && t[0].semver === o)
          if (n.includePrerelease) return !0;
          else t = l;
        let m = new Set();
        for (let t of e)
          '>' === t.operator || '>=' === t.operator
            ? (r = d(r, t, n))
            : '<' === t.operator || '<=' === t.operator
              ? (i = p(i, t, n))
              : m.add(t.semver);
        if (m.size > 1) return null;
        if (
          r &&
          i &&
          ((c = s(r.semver, i.semver, n)) > 0 ||
            (0 === c && ('>=' !== r.operator || '<=' !== i.operator)))
        )
          return null;
        for (let e of m) {
          if ((r && !a(e, String(r), n)) || (i && !a(e, String(i), n))) return null;
          for (let r of t) if (!a(e, String(r), n)) return !1;
          return !0;
        }
        let g = !!i && !n.includePrerelease && !!i.semver.prerelease.length && i.semver,
          f = !!r && !n.includePrerelease && !!r.semver.prerelease.length && r.semver;
        for (let e of (g &&
          1 === g.prerelease.length &&
          '<' === i.operator &&
          0 === g.prerelease[0] &&
          (g = !1),
        t)) {
          if (
            ((T = T || '>' === e.operator || '>=' === e.operator),
            (E = E || '<' === e.operator || '<=' === e.operator),
            r)
          ) {
            if (
              (f &&
                e.semver.prerelease &&
                e.semver.prerelease.length &&
                e.semver.major === f.major &&
                e.semver.minor === f.minor &&
                e.semver.patch === f.patch &&
                (f = !1),
              '>' === e.operator || '>=' === e.operator)
            ) {
              if ((_ = d(r, e, n)) === e && _ !== r) return !1;
            } else if ('>=' === r.operator && !a(r.semver, String(e), n)) return !1;
          }
          if (i) {
            if (
              (g &&
                e.semver.prerelease &&
                e.semver.prerelease.length &&
                e.semver.major === g.major &&
                e.semver.minor === g.minor &&
                e.semver.patch === g.patch &&
                (g = !1),
              '<' === e.operator || '<=' === e.operator)
            ) {
              if ((S = p(i, e, n)) === e && S !== i) return !1;
            } else if ('<=' === i.operator && !a(i.semver, String(e), n)) return !1;
          }
          if (!e.operator && (i || r) && 0 !== c) return !1;
        }
        return (!r || !E || !!i || 0 === c) && (!i || !T || !!r || 0 === c) && !f && !g && !0;
      },
      d = (e, t, n) => {
        if (!e) return t;
        let r = s(e.semver, t.semver, n);
        return r > 0 ? e : r < 0 || ('>' === t.operator && '>=' === e.operator) ? t : e;
      },
      p = (e, t, n) => {
        if (!e) return t;
        let r = s(e.semver, t.semver, n);
        return r < 0 ? e : r > 0 || ('<' === t.operator && '<=' === e.operator) ? t : e;
      };
    t.exports = (e, t, n = {}) => {
      if (e === t) return !0;
      ((e = new r(e, n)), (t = new r(t, n)));
      let i = !1;
      t: for (let r of e.set) {
        for (let e of t.set) {
          let t = c(r, e, n);
          if (((i = i || null !== t), t)) continue t;
        }
        if (i) return !1;
      }
      return !0;
    };
  },
  98649,
  (e, t, n) => {
    'use strict';
    let r = e.r(13920),
      i = e.r(86229),
      o = e.r(62520),
      a = e.r(89084),
      s = e.r(44514),
      u = e.r(58679),
      l = e.r(20796),
      c = e.r(42905),
      d = e.r(66420),
      p = e.r(82082),
      _ = e.r(14620),
      S = e.r(72846),
      E = e.r(35703),
      T = e.r(53079),
      m = e.r(60179),
      g = e.r(11878),
      f = e.r(56900),
      h = e.r(58581),
      A = e.r(92144),
      R = e.r(77149),
      y = e.r(74059),
      I = e.r(23630),
      b = e.r(40716),
      N = e.r(93902),
      O = e.r(21871),
      v = e.r(36141),
      C = e.r(98074),
      P = e.r(30519),
      M = e.r(37136),
      L = e.r(59020),
      U = e.r(44136),
      D = e.r(92177),
      x = e.r(28419),
      w = e.r(10962),
      k = e.r(26841),
      G = e.r(5869),
      V = e.r(57373),
      $ = e.r(124),
      B = e.r(39533);
    t.exports = {
      parse: s,
      valid: u,
      clean: l,
      inc: c,
      diff: d,
      major: p,
      minor: _,
      patch: S,
      prerelease: E,
      compare: T,
      rcompare: m,
      compareLoose: g,
      compareBuild: f,
      sort: h,
      rsort: A,
      gt: R,
      lt: y,
      eq: I,
      neq: b,
      gte: N,
      lte: O,
      cmp: v,
      coerce: C,
      Comparator: P,
      Range: M,
      satisfies: L,
      toComparators: U,
      maxSatisfying: D,
      minSatisfying: x,
      minVersion: w,
      validRange: k,
      outside: G,
      gtr: V,
      ltr: $,
      intersects: B,
      simplifyRange: e.r(28171),
      subset: e.r(53498),
      SemVer: o,
      re: r.re,
      src: r.src,
      tokens: r.t,
      SEMVER_SPEC_VERSION: i.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: i.RELEASE_TYPES,
      compareIdentifiers: a.compareIdentifiers,
      rcompareIdentifiers: a.rcompareIdentifiers,
    };
  },
  88792,
  (e, t, n) => {
    'use strict';
    function r(e) {
      return 'function' == typeof e;
    }
    var i = console.error.bind(console);
    function o(e, t, n) {
      var r = !!e[t] && e.propertyIsEnumerable(t);
      Object.defineProperty(e, t, { configurable: !0, enumerable: r, writable: !0, value: n });
    }
    function a(e) {
      e &&
        e.logger &&
        (r(e.logger) ? (i = e.logger) : i("new logger isn't a function, not replacing"));
    }
    function s(e, t, n) {
      if (!e || !e[t]) return void i('no original function ' + t + ' to wrap');
      if (!n) {
        (i('no wrapper function'), i(Error().stack));
        return;
      }
      if (!r(e[t]) || !r(n)) return void i('original object and wrapper must be functions');
      var a = e[t],
        s = n(a, t);
      return (
        o(s, '__original', a),
        o(s, '__unwrap', function () {
          e[t] === s && o(e, t, a);
        }),
        o(s, '__wrapped', !0),
        o(e, t, s),
        s
      );
    }
    function u(e, t) {
      if (!e || !e[t]) {
        (i('no function to unwrap.'), i(Error().stack));
        return;
      }
      if (e[t].__unwrap) return e[t].__unwrap();
      i('no original to unwrap to -- has ' + t + ' already been unwrapped?');
    }
    ((a.wrap = s),
      (a.massWrap = function (e, t, n) {
        if (e) Array.isArray(e) || (e = [e]);
        else {
          (i('must provide one or more modules to patch'), i(Error().stack));
          return;
        }
        if (!(t && Array.isArray(t)))
          return void i('must provide one or more functions to wrap on modules');
        e.forEach(function (e) {
          t.forEach(function (t) {
            s(e, t, n);
          });
        });
      }),
      (a.unwrap = u),
      (a.massUnwrap = function (e, t) {
        if (e) Array.isArray(e) || (e = [e]);
        else {
          (i('must provide one or more modules to patch'), i(Error().stack));
          return;
        }
        if (!(t && Array.isArray(t)))
          return void i('must provide one or more functions to unwrap on modules');
        e.forEach(function (e) {
          t.forEach(function (t) {
            u(e, t);
          });
        });
      }),
      (t.exports = a));
  },
  50225,
  (e) => {
    'use strict';
    (e.s(
      [
        'InstrumentationBase',
        () => w,
        'InstrumentationNodeModuleDefinition',
        () => G,
        'InstrumentationNodeModuleFile',
        () => V,
        'isWrapped',
        () => U,
        'registerInstrumentations',
        () => d,
        'safeExecuteInTheMiddle',
        () => M,
        'safeExecuteInTheMiddleAsync',
        () => L,
      ],
      50225
    ),
      e.s([], 72193),
      e.i(72193));
    var t = e.i(78224),
      n = e.i(25148),
      r = 'object' == typeof globalThis ? globalThis : e.g,
      i = Symbol.for('io.opentelemetry.js.api.logs'),
      o = (function () {
        function e() {}
        return ((e.prototype.emit = function (e) {}), e);
      })(),
      a = new o(),
      s = new ((function () {
        function e() {}
        return (
          (e.prototype.getLogger = function (e, t, n) {
            return new o();
          }),
          e
        );
      })())(),
      u = (function () {
        function e(e, t, n, r) {
          ((this._provider = e), (this.name = t), (this.version = n), (this.options = r));
        }
        return (
          (e.prototype.emit = function (e) {
            this._getLogger().emit(e);
          }),
          (e.prototype._getLogger = function () {
            if (this._delegate) return this._delegate;
            var e = this._provider.getDelegateLogger(this.name, this.version, this.options);
            return e ? ((this._delegate = e), this._delegate) : a;
          }),
          e
        );
      })(),
      l = (function () {
        function e() {}
        return (
          (e.prototype.getLogger = function (e, t, n) {
            var r;
            return null != (r = this.getDelegateLogger(e, t, n)) ? r : new u(this, e, t, n);
          }),
          (e.prototype.getDelegate = function () {
            var e;
            return null != (e = this._delegate) ? e : s;
          }),
          (e.prototype.setDelegate = function (e) {
            this._delegate = e;
          }),
          (e.prototype.getDelegateLogger = function (e, t, n) {
            var r;
            return null == (r = this._delegate) ? void 0 : r.getLogger(e, t, n);
          }),
          e
        );
      })(),
      c = (function () {
        function e() {
          this._proxyLoggerProvider = new l();
        }
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalLoggerProvider = function (e) {
            return r[i]
              ? this.getLoggerProvider()
              : ((r[i] = function (t) {
                  return 1 === t ? e : s;
                }),
                this._proxyLoggerProvider.setDelegate(e),
                e);
          }),
          (e.prototype.getLoggerProvider = function () {
            var e, t;
            return null != (t = null == (e = r[i]) ? void 0 : e.call(r, 1))
              ? t
              : this._proxyLoggerProvider;
          }),
          (e.prototype.getLogger = function (e, t, n) {
            return this.getLoggerProvider().getLogger(e, t, n);
          }),
          (e.prototype.disable = function () {
            (delete r[i], (this._proxyLoggerProvider = new l()));
          }),
          e
        );
      })().getInstance();
    function d(e) {
      for (
        var r,
          i,
          o = e.tracerProvider || t.trace.getTracerProvider(),
          a = e.meterProvider || n.metrics.getMeterProvider(),
          s = e.loggerProvider || c.getLoggerProvider(),
          u = null != (i = null == (r = e.instrumentations) ? void 0 : r.flat()) ? i : [],
          l = 0,
          d = u.length;
        l < d;
        l++
      ) {
        var p = u[l];
        (o && p.setTracerProvider(o),
          a && p.setMeterProvider(a),
          s && p.setLoggerProvider && p.setLoggerProvider(s),
          p.getConfig().enabled || p.enable());
      }
      return function () {
        u.forEach(function (e) {
          return e.disable();
        });
      };
    }
    var p = e.i(14747),
      _ = e.i(24361),
      S = e.i(98649),
      E = e.i(88792),
      T = e.i(43170);
    globalThis._sentryNextJsVersion = '15.5.2';
    var m = function () {
        return (m =
          Object.assign ||
          function (e) {
            for (var t, n = 1, r = arguments.length; n < r; n++)
              for (var i in (t = arguments[n]))
                Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
            return e;
          }).apply(this, arguments);
      },
      g = (function () {
        function e(e, r, i) {
          ((this.instrumentationName = e),
            (this.instrumentationVersion = r),
            (this._config = {}),
            (this._wrap = E.wrap),
            (this._unwrap = E.unwrap),
            (this._massWrap = E.massWrap),
            (this._massUnwrap = E.massUnwrap),
            this.setConfig(i),
            (this._diag = T.diag.createComponentLogger({ namespace: e })),
            (this._tracer = t.trace.getTracer(e, r)),
            (this._meter = n.metrics.getMeter(e, r)),
            (this._logger = c.getLogger(e, r)),
            this._updateMetricInstruments());
        }
        return (
          Object.defineProperty(e.prototype, 'meter', {
            get: function () {
              return this._meter;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.setMeterProvider = function (e) {
            ((this._meter = e.getMeter(this.instrumentationName, this.instrumentationVersion)),
              this._updateMetricInstruments());
          }),
          Object.defineProperty(e.prototype, 'logger', {
            get: function () {
              return this._logger;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype.setLoggerProvider = function (e) {
            this._logger = e.getLogger(this.instrumentationName, this.instrumentationVersion);
          }),
          (e.prototype.getModuleDefinitions = function () {
            var e,
              t = null != (e = this.init()) ? e : [];
            return Array.isArray(t) ? t : [t];
          }),
          (e.prototype._updateMetricInstruments = function () {}),
          (e.prototype.getConfig = function () {
            return this._config;
          }),
          (e.prototype.setConfig = function (e) {
            this._config = m({ enabled: !0 }, e);
          }),
          (e.prototype.setTracerProvider = function (e) {
            this._tracer = e.getTracer(this.instrumentationName, this.instrumentationVersion);
          }),
          Object.defineProperty(e.prototype, 'tracer', {
            get: function () {
              return this._tracer;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (e.prototype._runSpanCustomizationHook = function (e, t, n, r) {
            if (e)
              try {
                e(n, r);
              } catch (e) {
                this._diag.error(
                  'Error running span customization hook due to exception in handler',
                  { triggerName: t },
                  e
                );
              }
          }),
          e
        );
      })(),
      f = e.i(79314),
      h = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          n = t && e[t],
          r = 0;
        if (n) return n.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e });
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      },
      A = function (e, t) {
        var n = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!n) return e;
        var r,
          i,
          o = n.call(e),
          a = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(r = o.next()).done; ) a.push(r.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            r && !r.done && (n = o.return) && n.call(o);
          } finally {
            if (i) throw i.error;
          }
        }
        return a;
      },
      R = function (e, t, n) {
        if (n || 2 == arguments.length)
          for (var r, i = 0, o = t.length; i < o; i++)
            (!r && i in t) || (r || (r = Array.prototype.slice.call(t, 0, i)), (r[i] = t[i]));
        return e.concat(r || Array.prototype.slice.call(t));
      },
      y = function () {
        ((this.hooks = []), (this.children = new Map()));
      },
      I = (function () {
        function e() {
          ((this._trie = new y()), (this._counter = 0));
        }
        return (
          (e.prototype.insert = function (e) {
            var t,
              n,
              r = this._trie;
            try {
              for (var i = h(e.moduleName.split('/')), o = i.next(); !o.done; o = i.next()) {
                var a = o.value,
                  s = r.children.get(a);
                (s || ((s = new y()), r.children.set(a, s)), (r = s));
              }
            } catch (e) {
              t = { error: e };
            } finally {
              try {
                o && !o.done && (n = i.return) && n.call(i);
              } finally {
                if (t) throw t.error;
              }
            }
            r.hooks.push({ hook: e, insertedId: this._counter++ });
          }),
          (e.prototype.search = function (e, t) {
            var n,
              r,
              i = void 0 === t ? {} : t,
              o = i.maintainInsertionOrder,
              a = i.fullOnly,
              s = this._trie,
              u = [],
              l = !0;
            try {
              for (var c = h(e.split('/')), d = c.next(); !d.done; d = c.next()) {
                var p = d.value,
                  _ = s.children.get(p);
                if (!_) {
                  l = !1;
                  break;
                }
                (a || u.push.apply(u, R([], A(_.hooks), !1)), (s = _));
              }
            } catch (e) {
              n = { error: e };
            } finally {
              try {
                d && !d.done && (r = c.return) && r.call(c);
              } finally {
                if (n) throw n.error;
              }
            }
            return (a && l && u.push.apply(u, R([], A(s.hooks), !1)), 0 === u.length)
              ? []
              : 1 === u.length
                ? [u[0].hook]
                : (o &&
                    u.sort(function (e, t) {
                      return e.insertedId - t.insertedId;
                    }),
                  u.map(function (e) {
                    return e.hook;
                  }));
          }),
          e
        );
      })(),
      b = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          n = t && e[t],
          r = 0;
        if (n) return n.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e });
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      },
      N = ['afterEach', 'after', 'beforeEach', 'before', 'describe', 'it'].every(function (t) {
        return 'function' == typeof e.g[t];
      }),
      O = (function () {
        function e() {
          ((this._moduleNameTrie = new I()), this._initialize());
        }
        return (
          (e.prototype._initialize = function () {
            var e = this;
            new f.Hook(null, { internals: !0 }, function (t, n, r) {
              var i,
                o,
                a,
                s = ((i = n), '/' !== p.sep ? i.split(p.sep).join('/') : i),
                u = e._moduleNameTrie.search(s, {
                  maintainInsertionOrder: !0,
                  fullOnly: void 0 === r,
                });
              try {
                for (var l = b(u), c = l.next(); !c.done; c = l.next())
                  t = (0, c.value.onRequire)(t, n, r);
              } catch (e) {
                o = { error: e };
              } finally {
                try {
                  c && !c.done && (a = l.return) && a.call(l);
                } finally {
                  if (o) throw o.error;
                }
              }
              return t;
            });
          }),
          (e.prototype.register = function (e, t) {
            var n = { moduleName: e, onRequire: t };
            return (this._moduleNameTrie.insert(n), n);
          }),
          (e.getInstance = function () {
            var t;
            return N ? new e() : (this._instance = null != (t = this._instance) ? t : new e());
          }),
          e
        );
      })(),
      v = e.i(85397),
      C = e.i(22734),
      P = function (e, t) {
        var n,
          r,
          i,
          o,
          a = {
            label: 0,
            sent: function () {
              if (1 & i[0]) throw i[1];
              return i[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (o = { next: s(0), throw: s(1), return: s(2) }),
          'function' == typeof Symbol &&
            (o[Symbol.iterator] = function () {
              return this;
            }),
          o
        );
        function s(o) {
          return function (s) {
            var u = [o, s];
            if (n) throw TypeError('Generator is already executing.');
            for (; a; )
              try {
                if (
                  ((n = 1),
                  r &&
                    (i =
                      2 & u[0]
                        ? r.return
                        : u[0]
                          ? r.throw || ((i = r.return) && i.call(r), 0)
                          : r.next) &&
                    !(i = i.call(r, u[1])).done)
                )
                  return i;
                switch (((r = 0), i && (u = [2 & u[0], i.value]), u[0])) {
                  case 0:
                  case 1:
                    i = u;
                    break;
                  case 4:
                    return (a.label++, { value: u[1], done: !1 });
                  case 5:
                    (a.label++, (r = u[1]), (u = [0]));
                    continue;
                  case 7:
                    ((u = a.ops.pop()), a.trys.pop());
                    continue;
                  default:
                    if (
                      !(i = (i = a.trys).length > 0 && i[i.length - 1]) &&
                      (6 === u[0] || 2 === u[0])
                    ) {
                      a = 0;
                      continue;
                    }
                    if (3 === u[0] && (!i || (u[1] > i[0] && u[1] < i[3]))) {
                      a.label = u[1];
                      break;
                    }
                    if (6 === u[0] && a.label < i[1]) {
                      ((a.label = i[1]), (i = u));
                      break;
                    }
                    if (i && a.label < i[2]) {
                      ((a.label = i[2]), a.ops.push(u));
                      break;
                    }
                    (i[2] && a.ops.pop(), a.trys.pop());
                    continue;
                }
                u = t.call(e, a);
              } catch (e) {
                ((u = [6, e]), (r = 0));
              } finally {
                n = i = 0;
              }
            if (5 & u[0]) throw u[1];
            return { value: u[0] ? u[1] : void 0, done: !0 };
          };
        }
      };
    function M(e, t, n) {
      var r, i;
      try {
        i = e();
      } catch (e) {
        r = e;
      } finally {
        if ((t(r, i), r && !n)) throw r;
        return i;
      }
    }
    function L(e, t, n) {
      var r, i, o, a;
      return (
        (r = this),
        (i = void 0),
        (o = void 0),
        (a = function () {
          var r, i;
          return P(this, function (o) {
            switch (o.label) {
              case 0:
                return (o.trys.push([0, 2, 3, 4]), [4, e()]);
              case 1:
                return ((i = o.sent()), [3, 4]);
              case 2:
                return ((r = o.sent()), [3, 4]);
              case 3:
                if ((t(r, i), r && !n)) throw r;
                return [2, i];
              case 4:
                return [2];
            }
          });
        }),
        new (o || (o = Promise))(function (e, t) {
          function n(e) {
            try {
              u(a.next(e));
            } catch (e) {
              t(e);
            }
          }
          function s(e) {
            try {
              u(a.throw(e));
            } catch (e) {
              t(e);
            }
          }
          function u(t) {
            var r;
            t.done
              ? e(t.value)
              : ((r = t.value) instanceof o
                  ? r
                  : new o(function (e) {
                      e(r);
                    })
                ).then(n, s);
          }
          u((a = a.apply(r, i || [])).next());
        })
      );
    }
    function U(e) {
      return (
        'function' == typeof e &&
        'function' == typeof e.__original &&
        'function' == typeof e.__unwrap &&
        !0 === e.__wrapped
      );
    }
    globalThis._sentryNextJsVersion = '15.5.2';
    var D = (function () {
        var e = function (t, n) {
          return (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            })(t, n);
        };
        return function (t, n) {
          if ('function' != typeof n && null !== n)
            throw TypeError('Class extends value ' + String(n) + ' is not a constructor or null');
          function r() {
            this.constructor = t;
          }
          (e(t, n),
            (t.prototype = null === n ? Object.create(n) : ((r.prototype = n.prototype), new r())));
        };
      })(),
      x = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          n = t && e[t],
          r = 0;
        if (n) return n.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e });
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      },
      w = (function (t) {
        function n(e, n, r) {
          var i = t.call(this, e, n, r) || this;
          ((i._hooks = []),
            (i._requireInTheMiddleSingleton = O.getInstance()),
            (i._enabled = !1),
            (i._wrap = function (e, t, n) {
              if ((U(e[t]) && i._unwrap(e, t), !_.types.isProxy(e))) return (0, E.wrap)(e, t, n);
              var r = (0, E.wrap)(Object.assign({}, e), t, n);
              return (Object.defineProperty(e, t, { value: r }), r);
            }),
            (i._unwrap = function (e, t) {
              return _.types.isProxy(e)
                ? Object.defineProperty(e, t, { value: e[t] })
                : (0, E.unwrap)(e, t);
            }),
            (i._massWrap = function (e, t, n) {
              return e
                ? (Array.isArray(e) || (e = [e]), t && Array.isArray(t))
                  ? void e.forEach(function (e) {
                      t.forEach(function (t) {
                        i._wrap(e, t, n);
                      });
                    })
                  : void T.diag.error('must provide one or more functions to wrap on modules')
                : void T.diag.error('must provide one or more modules to patch');
            }),
            (i._massUnwrap = function (e, t) {
              return e
                ? (Array.isArray(e) || (e = [e]), t && Array.isArray(t))
                  ? void e.forEach(function (e) {
                      t.forEach(function (t) {
                        i._unwrap(e, t);
                      });
                    })
                  : void T.diag.error('must provide one or more functions to wrap on modules')
                : void T.diag.error('must provide one or more modules to patch');
            }));
          var o = i.init();
          return (
            o && !Array.isArray(o) && (o = [o]),
            (i._modules = o || []),
            i._config.enabled && i.enable(),
            i
          );
        }
        return (
          D(n, t),
          (n.prototype._warnOnPreloadedModules = function () {
            var t = this;
            this._modules.forEach(function (n) {
              var r = n.name;
              try {
                var i = (() => {
                  let e = Error('Cannot find module as expression is too dynamic');
                  throw ((e.code = 'MODULE_NOT_FOUND'), e);
                })();
                e.c[i] &&
                  t._diag.warn(
                    'Module ' +
                      r +
                      ' has been loaded before ' +
                      t.instrumentationName +
                      ' so it might not work, please initialize it before requiring ' +
                      r
                  );
              } catch (e) {}
            });
          }),
          (n.prototype._extractPackageVersion = function (e) {
            try {
              var t = (0, C.readFileSync)(p.join(e, 'package.json'), { encoding: 'utf8' }),
                n = JSON.parse(t).version;
              return 'string' == typeof n ? n : void 0;
            } catch (t) {
              T.diag.warn('Failed extracting version', e);
            }
          }),
          (n.prototype._onRequire = function (e, t, n, r) {
            var i,
              o = this;
            if (!r)
              return 'function' == typeof e.patch && ((e.moduleExports = t), this._enabled)
                ? (this._diag.debug(
                    'Applying instrumentation patch for nodejs core module on require hook',
                    { module: e.name }
                  ),
                  e.patch(t))
                : t;
            var a = this._extractPackageVersion(r);
            if (((e.moduleVersion = a), e.name === n))
              return k(e.supportedVersions, a, e.includePrerelease) &&
                'function' == typeof e.patch &&
                ((e.moduleExports = t), this._enabled)
                ? (this._diag.debug('Applying instrumentation patch for module on require hook', {
                    module: e.name,
                    version: e.moduleVersion,
                    baseDir: r,
                  }),
                  e.patch(t, e.moduleVersion))
                : t;
            var s = null != (i = e.files) ? i : [],
              u = p.normalize(n);
            return s
              .filter(function (e) {
                return e.name === u;
              })
              .filter(function (t) {
                return k(t.supportedVersions, a, e.includePrerelease);
              })
              .reduce(function (t, n) {
                return ((n.moduleExports = t), o._enabled)
                  ? (o._diag.debug(
                      'Applying instrumentation patch for nodejs module file on require hook',
                      { module: e.name, version: e.moduleVersion, fileName: n.name, baseDir: r }
                    ),
                    n.patch(t, e.moduleVersion))
                  : t;
              }, t);
          }),
          (n.prototype.enable = function () {
            var e,
              t,
              n,
              r,
              i,
              o,
              a = this;
            if (!this._enabled) {
              if (((this._enabled = !0), this._hooks.length > 0)) {
                try {
                  for (var s = x(this._modules), u = s.next(); !u.done; u = s.next()) {
                    var l = u.value;
                    'function' == typeof l.patch &&
                      l.moduleExports &&
                      (this._diag.debug(
                        'Applying instrumentation patch for nodejs module on instrumentation enabled',
                        { module: l.name, version: l.moduleVersion }
                      ),
                      l.patch(l.moduleExports, l.moduleVersion));
                    try {
                      for (
                        var c = ((n = void 0), x(l.files)), d = c.next();
                        !d.done;
                        d = c.next()
                      ) {
                        var _ = d.value;
                        _.moduleExports &&
                          (this._diag.debug(
                            'Applying instrumentation patch for nodejs module file on instrumentation enabled',
                            { module: l.name, version: l.moduleVersion, fileName: _.name }
                          ),
                          _.patch(_.moduleExports, l.moduleVersion));
                      }
                    } catch (e) {
                      n = { error: e };
                    } finally {
                      try {
                        d && !d.done && (r = c.return) && r.call(c);
                      } finally {
                        if (n) throw n.error;
                      }
                    }
                  }
                } catch (t) {
                  e = { error: t };
                } finally {
                  try {
                    u && !u.done && (t = s.return) && t.call(s);
                  } finally {
                    if (e) throw e.error;
                  }
                }
                return;
              }
              this._warnOnPreloadedModules();
              var S = function (e) {
                  var t = function (t, n, r) {
                      return a._onRequire(e, t, n, r);
                    },
                    n = p.isAbsolute(e.name)
                      ? new f.Hook([e.name], { internals: !0 }, t)
                      : E._requireInTheMiddleSingleton.register(e.name, t);
                  E._hooks.push(n);
                  var r = new v.Hook([e.name], { internals: !1 }, function (t, n, r) {
                    if (!r && p.isAbsolute(n)) {
                      var i = p.parse(n);
                      ((n = i.name), (r = i.dir));
                    }
                    return a._onRequire(e, t, n, r);
                  });
                  E._hooks.push(r);
                },
                E = this;
              try {
                for (var T = x(this._modules), m = T.next(); !m.done; m = T.next()) {
                  var g = m.value;
                  S(g);
                }
              } catch (e) {
                i = { error: e };
              } finally {
                try {
                  m && !m.done && (o = T.return) && o.call(T);
                } finally {
                  if (i) throw i.error;
                }
              }
            }
          }),
          (n.prototype.disable = function () {
            var e, t, n, r;
            if (this._enabled) {
              this._enabled = !1;
              try {
                for (var i = x(this._modules), o = i.next(); !o.done; o = i.next()) {
                  var a = o.value;
                  'function' == typeof a.unpatch &&
                    a.moduleExports &&
                    (this._diag.debug(
                      'Removing instrumentation patch for nodejs module on instrumentation disabled',
                      { module: a.name, version: a.moduleVersion }
                    ),
                    a.unpatch(a.moduleExports, a.moduleVersion));
                  try {
                    for (var s = ((n = void 0), x(a.files)), u = s.next(); !u.done; u = s.next()) {
                      var l = u.value;
                      l.moduleExports &&
                        (this._diag.debug(
                          'Removing instrumentation patch for nodejs module file on instrumentation disabled',
                          { module: a.name, version: a.moduleVersion, fileName: l.name }
                        ),
                        l.unpatch(l.moduleExports, a.moduleVersion));
                    }
                  } catch (e) {
                    n = { error: e };
                  } finally {
                    try {
                      u && !u.done && (r = s.return) && r.call(s);
                    } finally {
                      if (n) throw n.error;
                    }
                  }
                }
              } catch (t) {
                e = { error: t };
              } finally {
                try {
                  o && !o.done && (t = i.return) && t.call(i);
                } finally {
                  if (e) throw e.error;
                }
              }
            }
          }),
          (n.prototype.isEnabled = function () {
            return this._enabled;
          }),
          n
        );
      })(g);
    function k(e, t, n) {
      return void 0 === t
        ? e.includes('*')
        : e.some(function (e) {
            return (0, S.satisfies)(t, e, { includePrerelease: n });
          });
    }
    var G = function (e, t, n, r, i) {
        ((this.name = e),
          (this.supportedVersions = t),
          (this.patch = n),
          (this.unpatch = r),
          (this.files = i || []));
      },
      V = function (e, t, n, r) {
        ((this.supportedVersions = t),
          (this.patch = n),
          (this.unpatch = r),
          (this.name = (0, p.normalize)(e)));
      };
  },
  7640,
  (e, t, n) => {
    'use strict';
    var r = Object.defineProperty,
      i = Object.getOwnPropertyDescriptor,
      o = Object.getOwnPropertyNames,
      a = Object.prototype.hasOwnProperty,
      s = {};
    (((e, t) => {
      for (var n in t) r(e, n, { get: t[n], enumerable: !0 });
    })(s, {
      PrismaInstrumentation: () => A,
      registerInstrumentations: () => R.registerInstrumentations,
    }),
      (t.exports = ((e, t, n, s) => {
        if ((t && 'object' == typeof t) || 'function' == typeof t)
          for (let u of o(t))
            a.call(e, u) ||
              u === n ||
              r(e, u, { get: () => t[u], enumerable: !(s = i(t, u)) || s.enumerable });
        return e;
      })(r({}, '__esModule', { value: !0 }), s)));
    var u = e.r(52305),
      l = e.r(50225),
      c = e.r(52305),
      d = 'true' === process.env.PRISMA_SHOW_ALL_TRACES,
      p = class {
        tracerProvider;
        ignoreSpanTypes;
        constructor({ tracerProvider: e, ignoreSpanTypes: t }) {
          ((this.tracerProvider = e), (this.ignoreSpanTypes = t));
        }
        isEnabled() {
          return !0;
        }
        getTraceParent(e) {
          let t = c.trace.getSpanContext(e ?? c.context.active());
          return t ? `00-${t.traceId}-${t.spanId}-0${t.traceFlags}` : '00-10-10-00';
        }
        dispatchEngineSpans(e) {
          let t = this.tracerProvider.getTracer('prisma'),
            n = new Map();
          for (let r of e.filter((e) => null === e.parentId))
            !(function e(t, n, r, i, o) {
              if (S(n.name, o)) return;
              let a = {
                attributes: n.attributes,
                kind: 'client' === n.kind ? c.SpanKind.CLIENT : c.SpanKind.INTERNAL,
                startTime: n.startTime,
              };
              t.startActiveSpan(n.name, a, (a) => {
                for (let s of (i.set(n.id, a.spanContext().spanId),
                n.links &&
                  a.addLinks(
                    n.links.flatMap((e) => {
                      let t = i.get(e);
                      return t
                        ? {
                            context: {
                              spanId: t,
                              traceId: a.spanContext().traceId,
                              traceFlags: a.spanContext().traceFlags,
                            },
                          }
                        : [];
                    })
                  ),
                r.filter((e) => e.parentId === n.id)))
                  e(t, s, r, i, o);
                a.end(n.endTime);
              });
            })(t, r, e, n, this.ignoreSpanTypes);
        }
        getActiveContext() {
          return c.context.active();
        }
        runInChildSpan(e, t) {
          if (('string' == typeof e && (e = { name: e }), e.internal && !d)) return t();
          let n = this.tracerProvider.getTracer('prisma'),
            r = e.context ?? this.getActiveContext(),
            i = `prisma:client:${e.name}`;
          if (S(i, this.ignoreSpanTypes)) return t();
          if (!1 === e.active) {
            let o = n.startSpan(i, e, r);
            return _(o, t(o, r));
          }
          return n.startActiveSpan(i, e, (e) => _(e, t(e, r)));
        }
      };
    function _(e, t) {
      var n;
      return null != (n = t) && 'function' == typeof n.then
        ? t.then(
            (t) => (e.end(), t),
            (t) => {
              throw (e.end(), t);
            }
          )
        : (e.end(), t);
    }
    function S(e, t) {
      return t.some((t) => ('string' == typeof t ? t === e : t.test(e)));
    }
    var E = { name: '@prisma/instrumentation', version: '6.14.0' },
      T = E.version,
      m = T.split('.')[0],
      g = 'PRISMA_INSTRUMENTATION',
      f = `V${m}_PRISMA_INSTRUMENTATION`,
      h = E.name,
      A = class extends l.InstrumentationBase {
        tracerProvider;
        constructor(e = {}) {
          super(h, T, e);
        }
        setTracerProvider(e) {
          this.tracerProvider = e;
        }
        init() {
          return [new l.InstrumentationNodeModuleDefinition('@prisma/client', [T])];
        }
        enable() {
          let t = this._config,
            n = {
              helper: new p({
                tracerProvider: this.tracerProvider ?? u.trace.getTracerProvider(),
                ignoreSpanTypes: t.ignoreSpanTypes ?? [],
              }),
            };
          ((e.g[g] = n), (e.g[f] = n));
        }
        disable() {
          (delete e.g[g], delete e.g[f]);
        }
        isEnabled() {
          return !!e.g[f];
        }
      },
      R = e.r(50225);
  },
  72874,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(7640),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Prisma';
    function s() {
      let e = globalThis.PRISMA_INSTRUMENTATION;
      return e && 'object' == typeof e && 'helper' in e ? e.helper : void 0;
    }
    class u extends r.PrismaInstrumentation {
      constructor() {
        super();
      }
      enable() {
        super.enable();
        let e = s(),
          t = !1;
        e &&
          'object' == typeof e &&
          'dispatchEngineSpans' in e &&
          (e.createEngineSpan = () => {
            i.consoleSandbox(() => {
              t ||
                ((t = !0),
                console.warn(
                  '[Sentry] The Sentry SDK supports tracing with Prisma version 5 only with limited capabilities. For full tracing capabilities pass `prismaInstrumentation` for version 5 to the Sentry `prismaIntegration`. Read more: https://docs.sentry.io/platforms/javascript/guides/node/configuration/integrations/prisma/'
                ));
            });
          });
      }
    }
    let l = o.generateInstrumentOnce(a, (e) =>
        e?.prismaInstrumentation ? e.prismaInstrumentation : new u()
      ),
      c = i.defineIntegration(({ prismaInstrumentation: e } = {}) => ({
        name: a,
        setupOnce() {
          l({ prismaInstrumentation: e });
        },
        setup(e) {
          s() &&
            e.on('spanStart', (e) => {
              let t = i.spanToJSON(e);
              (t.description?.startsWith('prisma:') &&
                e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.prisma'),
                'prisma:engine:db_query' === t.description &&
                  t.data['db.query.text'] &&
                  e.updateName(t.data['db.query.text']),
                'prisma:engine:db_query' !== t.description ||
                  t.data['db.system'] ||
                  e.setAttribute('db.system', 'prisma'));
            });
        },
      }));
    ((n.instrumentPrisma = l), (n.prismaIntegration = c));
  },
  97941,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.50.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-hapi'));
  },
  15466,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.HapiLifecycleMethodNames =
        n.HapiLayerType =
        n.handlerPatched =
        n.HapiComponentName =
          void 0),
      (n.HapiComponentName = '@hapi/hapi'),
      (n.handlerPatched = Symbol('hapi-handler-patched')),
      (n.HapiLayerType = { ROUTER: 'router', PLUGIN: 'plugin', EXT: 'server.ext' }),
      (n.HapiLifecycleMethodNames = new Set([
        'onPreAuth',
        'onCredentials',
        'onPostAuth',
        'onPreHandler',
        'onPostHandler',
        'onPreResponse',
        'onRequest',
      ])));
  },
  81985,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ATTR_HTTP_METHOD = void 0),
      (n.ATTR_HTTP_METHOD = 'http.method'));
  },
  73222,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.HAPI_TYPE = 'hapi.type'),
          (e.PLUGIN_NAME = 'hapi.plugin.name'),
          (e.EXT_TYPE = 'server.ext.type'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  13895,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.getPluginFromInput =
        n.getExtMetadata =
        n.getRouteMetadata =
        n.isPatchableExtMethod =
        n.isDirectExtInput =
        n.isLifecycleExtEventObj =
        n.isLifecycleExtType =
        n.getPluginName =
          void 0));
    let r = e.r(81964),
      i = e.r(81985),
      o = e.r(15466),
      a = e.r(73222),
      s = e.r(75235);
    ((n.getPluginName = function (e) {
      return e.name ? e.name : e.pkg.name;
    }),
      (n.isLifecycleExtType = (e) => 'string' == typeof e && o.HapiLifecycleMethodNames.has(e)),
      (n.isLifecycleExtEventObj = (e) => {
        let t = e?.type;
        return void 0 !== t && (0, n.isLifecycleExtType)(t);
      }),
      (n.isDirectExtInput = (e) =>
        Array.isArray(e) &&
        e.length <= 3 &&
        (0, n.isLifecycleExtType)(e[0]) &&
        'function' == typeof e[1]),
      (n.isPatchableExtMethod = (e) => !Array.isArray(e)),
      (n.getRouteMetadata = (e, t, n) => {
        let u,
          l = { [r.ATTR_HTTP_ROUTE]: e.path };
        return (
          t & s.SemconvStability.OLD && (l[i.ATTR_HTTP_METHOD] = e.method),
          t & s.SemconvStability.STABLE && (l[r.ATTR_HTTP_REQUEST_METHOD] = e.method),
          n
            ? ((l[a.AttributeNames.HAPI_TYPE] = o.HapiLayerType.PLUGIN),
              (l[a.AttributeNames.PLUGIN_NAME] = n),
              (u = `${n}: route - ${e.path}`))
            : ((l[a.AttributeNames.HAPI_TYPE] = o.HapiLayerType.ROUTER), (u = `route - ${e.path}`)),
          { attributes: l, name: u }
        );
      }),
      (n.getExtMetadata = (e, t) =>
        t
          ? {
              attributes: {
                [a.AttributeNames.EXT_TYPE]: e,
                [a.AttributeNames.HAPI_TYPE]: o.HapiLayerType.EXT,
                [a.AttributeNames.PLUGIN_NAME]: t,
              },
              name: `${t}: ext - ${e}`,
            }
          : {
              attributes: {
                [a.AttributeNames.EXT_TYPE]: e,
                [a.AttributeNames.HAPI_TYPE]: o.HapiLayerType.EXT,
              },
              name: `ext - ${e}`,
            }),
      (n.getPluginFromInput = (e) =>
        'plugin' in e ? ('plugin' in e.plugin ? e.plugin.plugin : e.plugin) : e));
  },
  81665,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.HapiInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(75235),
      a = e.r(97941),
      s = e.r(15466),
      u = e.r(13895);
    class l extends o.InstrumentationBase {
      _semconvStability;
      constructor(e = {}) {
        (super(a.PACKAGE_NAME, a.PACKAGE_VERSION, e),
          (this._semconvStability = (0, o.semconvStabilityFromStr)(
            'http',
            process.env.OTEL_SEMCONV_STABILITY_OPT_IN
          )));
      }
      init() {
        return new o.InstrumentationNodeModuleDefinition(
          s.HapiComponentName,
          ['>=17.0.0 <22'],
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag] ? e.default : e;
            return (
              (0, o.isWrapped)(t.server) ||
                this._wrap(t, 'server', this._getServerPatch.bind(this)),
              (0, o.isWrapped)(t.Server) ||
                this._wrap(t, 'Server', this._getServerPatch.bind(this)),
              t
            );
          },
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag] ? e.default : e;
            this._massUnwrap([t], ['server', 'Server']);
          }
        );
      }
      _getServerPatch(e) {
        let t = this,
          n = this;
        return function (r) {
          let i = e.apply(this, [r]);
          return (
            n._wrap(i, 'route', (e) => t._getServerRoutePatch.bind(t)(e)),
            n._wrap(i, 'ext', (e) => t._getServerExtPatch.bind(t)(e)),
            n._wrap(i, 'register', t._getServerRegisterPatch.bind(t)),
            i
          );
        };
      }
      _getServerRegisterPatch(e) {
        let t = this;
        return function (n, r) {
          if (Array.isArray(n))
            for (let e of n) {
              let n = (0, u.getPluginFromInput)(e);
              t._wrapRegisterHandler(n);
            }
          else {
            let e = (0, u.getPluginFromInput)(n);
            t._wrapRegisterHandler(e);
          }
          return e.apply(this, [n, r]);
        };
      }
      _getServerExtPatch(e, t) {
        let n = this;
        return function (...r) {
          if (Array.isArray(r[0])) {
            let e = r[0];
            for (let r = 0; r < e.length; r++) {
              let i = e[r];
              if ((0, u.isLifecycleExtType)(i.type)) {
                let o = n._wrapExtMethods(i.method, i.type, t);
                ((i.method = o), (e[r] = i));
              }
            }
          } else if ((0, u.isDirectExtInput)(r)) {
            let i = r[1],
              o = n._wrapExtMethods(i, r[0], t);
            return e.apply(this, [r[0], o, r[2]]);
          } else if ((0, u.isLifecycleExtEventObj)(r[0])) {
            let i = r[0],
              o = n._wrapExtMethods(i.method, i.type, t);
            return ((i.method = o), e.call(this, i));
          }
          return e.apply(this, r);
        };
      }
      _getServerRoutePatch(e, t) {
        let n = this;
        return function (r) {
          if (Array.isArray(r))
            for (let e = 0; e < r.length; e++) {
              let i = n._wrapRouteHandler.call(n, r[e], t);
              r[e] = i;
            }
          else r = n._wrapRouteHandler.call(n, r, t);
          return e.apply(this, [r]);
        };
      }
      _wrapRegisterHandler(e) {
        let t = this,
          n = (0, u.getPluginName)(e),
          r = e.register,
          i = this;
        e.register = function (e, o) {
          return (
            i._wrap(e, 'route', (e) => t._getServerRoutePatch.bind(t)(e, n)),
            i._wrap(e, 'ext', (e) => t._getServerExtPatch.bind(t)(e, n)),
            r.call(this, e, o)
          );
        };
      }
      _wrapExtMethods(e, t, n) {
        let i = this;
        if (e instanceof Array)
          for (let n = 0; n < e.length; n++) e[n] = i._wrapExtMethods(e[n], t);
        else if ((0, u.isPatchableExtMethod)(e))
          return !0 === e[s.handlerPatched]
            ? e
            : ((e[s.handlerPatched] = !0),
              async function (...o) {
                if (void 0 === r.trace.getSpan(r.context.active())) return await e.apply(this, o);
                let a = (0, u.getExtMetadata)(t, n),
                  s = i.tracer.startSpan(a.name, { attributes: a.attributes });
                try {
                  return await r.context.with(
                    r.trace.setSpan(r.context.active(), s),
                    e,
                    void 0,
                    ...o
                  );
                } catch (e) {
                  throw (
                    s.recordException(e),
                    s.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                    e
                  );
                } finally {
                  s.end();
                }
              });
        return e;
      }
      _wrapRouteHandler(e, t) {
        let n = this;
        if (!0 === e[s.handlerPatched]) return e;
        e[s.handlerPatched] = !0;
        let o = (o) =>
          async function (...a) {
            if (void 0 === r.trace.getSpan(r.context.active())) return await o.call(this, ...a);
            let s = (0, i.getRPCMetadata)(r.context.active());
            s?.type === i.RPCType.HTTP && (s.route = e.path);
            let l = (0, u.getRouteMetadata)(e, n._semconvStability, t),
              c = n.tracer.startSpan(l.name, { attributes: l.attributes });
            try {
              return await r.context.with(r.trace.setSpan(r.context.active(), c), () =>
                o.call(this, ...a)
              );
            } catch (e) {
              throw (
                c.recordException(e),
                c.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                e
              );
            } finally {
              c.end();
            }
          };
        if ('function' == typeof e.handler) e.handler = o(e.handler);
        else if ('function' == typeof e.options) {
          let t = e.options;
          e.options = function (e) {
            let n = t(e);
            return ('function' == typeof n.handler && (n.handler = o(n.handler)), n);
          };
        } else
          'function' == typeof e.options?.handler && (e.options.handler = o(e.options.handler));
        return e;
      }
    }
    n.HapiInstrumentation = l;
  },
  77435,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = n.HapiInstrumentation = void 0));
    var r = e.r(81665);
    Object.defineProperty(n, 'HapiInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.HapiInstrumentation;
      },
    });
    var i = e.r(73222);
    Object.defineProperty(n, 'AttributeNames', {
      enumerable: !0,
      get: function () {
        return i.AttributeNames;
      },
    });
  },
  88441,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(77435),
      i = e.r(48009),
      o = e.r(15527),
      a = e.r(59589),
      s = 'Hapi',
      u = o.generateInstrumentOnce(s, () => new r.HapiInstrumentation()),
      l = i.defineIntegration(() => ({
        name: s,
        setupOnce() {
          u();
        },
      })),
      c = {
        name: 'SentryHapiErrorPlugin',
        version: i.SDK_VERSION,
        register: async function (e) {
          e.events.on({ name: 'request', channels: ['error'] }, (e, t) => {
            var n;
            if (i.getIsolationScope() !== i.getDefaultIsolationScope()) {
              let t = e.route;
              t.path &&
                i.getIsolationScope().setTransactionName(`${t.method.toUpperCase()} ${t.path}`);
            } else
              a.DEBUG_BUILD &&
                i.debug.warn(
                  'Isolation scope is still the default isolation scope - skipping setting transactionName'
                );
            t &&
              'object' == typeof t &&
              'error' in t &&
              t.error &&
              ((n = t.error),
              i.captureException(n, {
                mechanism: { type: 'hapi', handled: !1, data: { function: 'hapiErrorPlugin' } },
              }));
          });
        },
      };
    async function d(e) {
      await e.register(c);
      let t = i.getClient();
      (t &&
        t.on('spanStart', (e) => {
          var t = e;
          let n = i.spanToJSON(t).data,
            r = n['hapi.type'];
          !n[i.SEMANTIC_ATTRIBUTE_SENTRY_OP] &&
            r &&
            t.setAttributes({
              [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.hapi',
              [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${r}.hapi`,
            });
        }),
        o.ensureIsWrapped(e.register, 'hapi'));
    }
    ((n.hapiErrorPlugin = c),
      (n.hapiIntegration = l),
      (n.instrumentHapi = u),
      (n.setupHapiErrorHandler = d));
  },
  33235,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.KoaLayerType = void 0),
      (function (e) {
        ((e.ROUTER = 'router'), (e.MIDDLEWARE = 'middleware'));
      })(n.KoaLayerType || (n.KoaLayerType = {})));
  },
  45852,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.51.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-koa'));
  },
  27804,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.AttributeNames = void 0),
      (function (e) {
        ((e.KOA_TYPE = 'koa.type'), (e.KOA_NAME = 'koa.name'));
      })(n.AttributeNames || (n.AttributeNames = {})));
  },
  35144,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.isLayerIgnored = n.getMiddlewareMetadata = void 0));
    let r = e.r(33235),
      i = e.r(27804),
      o = e.r(81964);
    ((n.getMiddlewareMetadata = (e, t, n, a) =>
      n
        ? {
            attributes: {
              [i.AttributeNames.KOA_NAME]: a?.toString(),
              [i.AttributeNames.KOA_TYPE]: r.KoaLayerType.ROUTER,
              [o.SEMATTRS_HTTP_ROUTE]: a?.toString(),
            },
            name: e._matchedRouteName || `router - ${a}`,
          }
        : {
            attributes: {
              [i.AttributeNames.KOA_NAME]: t.name ?? 'middleware',
              [i.AttributeNames.KOA_TYPE]: r.KoaLayerType.MIDDLEWARE,
            },
            name: `middleware - ${t.name}`,
          }),
      (n.isLayerIgnored = (e, t) =>
        !!(Array.isArray(t?.ignoreLayersType) && t?.ignoreLayersType?.includes(e))));
  },
  29050,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.kLayerPatched = void 0),
      (n.kLayerPatched = Symbol('koa-layer-patched')));
  },
  72024,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.KoaInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(33235),
      a = e.r(45852),
      s = e.r(35144),
      u = e.r(88540),
      l = e.r(29050);
    class c extends i.InstrumentationBase {
      constructor(e = {}) {
        super(a.PACKAGE_NAME, a.PACKAGE_VERSION, e);
      }
      init() {
        return new i.InstrumentationNodeModuleDefinition(
          'koa',
          ['>=2.0.0 <3'],
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag] ? e.default : e;
            return null == t
              ? t
              : ((0, i.isWrapped)(t.prototype.use) && this._unwrap(t.prototype, 'use'),
                this._wrap(t.prototype, 'use', this._getKoaUsePatch.bind(this)),
                e);
          },
          (e) => {
            let t = 'Module' === e[Symbol.toStringTag] ? e.default : e;
            (0, i.isWrapped)(t.prototype.use) && this._unwrap(t.prototype, 'use');
          }
        );
      }
      _getKoaUsePatch(e) {
        let t = this;
        return function (n) {
          let r;
          return (
            (r = n.router ? t._patchRouterDispatch(n) : t._patchLayer(n, !1)),
            e.apply(this, [r])
          );
        };
      }
      _patchRouterDispatch(e) {
        r.diag.debug('Patching @koa/router dispatch');
        let t = e.router;
        for (let e of t?.stack ?? []) {
          let t = e.path,
            n = e.stack;
          for (let e = 0; e < n.length; e++) {
            let r = n[e];
            n[e] = this._patchLayer(r, !0, t);
          }
        }
        return e;
      }
      _patchLayer(e, t, n) {
        let a = t ? o.KoaLayerType.ROUTER : o.KoaLayerType.MIDDLEWARE;
        return !0 === e[l.kLayerPatched] || (0, s.isLayerIgnored)(a, this.getConfig())
          ? e
          : 'GeneratorFunction' === e.constructor.name ||
              'AsyncGeneratorFunction' === e.constructor.name
            ? (r.diag.debug('ignoring generator-based Koa middleware layer'), e)
            : ((e[l.kLayerPatched] = !0),
              r.diag.debug('patching Koa middleware layer'),
              async (o, l) => {
                if (void 0 === r.trace.getSpan(r.context.active())) return e(o, l);
                let c = (0, s.getMiddlewareMetadata)(o, e, t, n),
                  d = this.tracer.startSpan(c.name, { attributes: c.attributes }),
                  p = (0, u.getRPCMetadata)(r.context.active());
                p?.type === u.RPCType.HTTP &&
                  o._matchedRoute &&
                  (p.route = o._matchedRoute.toString());
                let { requestHook: _ } = this.getConfig();
                _ &&
                  (0, i.safeExecuteInTheMiddle)(
                    () => _(d, { context: o, middlewareLayer: e, layerType: a }),
                    (e) => {
                      e && r.diag.error('koa instrumentation: request hook failed', e);
                    },
                    !0
                  );
                let S = r.trace.setSpan(r.context.active(), d);
                return r.context.with(S, async () => {
                  try {
                    return await e(o, l);
                  } catch (e) {
                    throw (d.recordException(e), e);
                  } finally {
                    d.end();
                  }
                });
              });
      }
    }
    n.KoaInstrumentation = c;
  },
  84813,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.KoaLayerType = n.AttributeNames = n.KoaInstrumentation = void 0));
    var r = e.r(72024);
    Object.defineProperty(n, 'KoaInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.KoaInstrumentation;
      },
    });
    var i = e.r(27804);
    Object.defineProperty(n, 'AttributeNames', {
      enumerable: !0,
      get: function () {
        return i.AttributeNames;
      },
    });
    var o = e.r(33235);
    Object.defineProperty(n, 'KoaLayerType', {
      enumerable: !0,
      get: function () {
        return o.KoaLayerType;
      },
    });
  },
  82306,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(84813),
      i = e.r(81964),
      o = e.r(48009),
      a = e.r(15527),
      s = e.r(59589),
      u = a.generateInstrumentOnce('Koa', r.KoaInstrumentation, (e = {}) => ({
        ignoreLayersType: e.ignoreLayersType,
        requestHook(e, t) {
          a.addOriginToSpan(e, 'auto.http.otel.koa');
          let n = o.spanToJSON(e).data,
            r = n['koa.type'];
          r && e.setAttribute(o.SEMANTIC_ATTRIBUTE_SENTRY_OP, `${r}.koa`);
          let u = n['koa.name'];
          if (
            ('string' == typeof u && e.updateName(u || '< unknown >'),
            o.getIsolationScope() === o.getDefaultIsolationScope())
          ) {
            s.DEBUG_BUILD &&
              o.debug.warn(
                'Isolation scope is default isolation scope - skipping setting transactionName'
              );
            return;
          }
          let l = n[i.ATTR_HTTP_ROUTE],
            c = t.context?.request?.method?.toUpperCase() || 'GET';
          l && o.getIsolationScope().setTransactionName(`${c} ${l}`);
        },
      })),
      l = o.defineIntegration((e = {}) => ({
        name: 'Koa',
        setupOnce() {
          u(e);
        },
      }));
    ((n.instrumentKoa = u),
      (n.koaIntegration = l),
      (n.setupKoaErrorHandler = (e) => {
        (e.use(async (e, t) => {
          try {
            await t();
          } catch (e) {
            throw (o.captureException(e), e);
          }
        }),
          a.ensureIsWrapped(e.use, 'koa'));
      }));
  },
  28710,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ConnectNames = n.ConnectTypes = n.AttributeNames = void 0),
      (function (e) {
        ((e.CONNECT_TYPE = 'connect.type'), (e.CONNECT_NAME = 'connect.name'));
      })(n.AttributeNames || (n.AttributeNames = {})),
      (function (e) {
        ((e.MIDDLEWARE = 'middleware'), (e.REQUEST_HANDLER = 'request_handler'));
      })(n.ConnectTypes || (n.ConnectTypes = {})),
      (function (e) {
        ((e.MIDDLEWARE = 'middleware'), (e.REQUEST_HANDLER = 'request handler'));
      })(n.ConnectNames || (n.ConnectNames = {})));
  },
  22759,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.47.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-connect'));
  },
  13520,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n._LAYERS_STORE_PROPERTY = void 0),
      (n._LAYERS_STORE_PROPERTY = Symbol(
        'opentelemetry.instrumentation-connect.request-route-stack'
      )));
  },
  98628,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.generateRoute = n.replaceCurrentStackRoute = n.addNewStackLayer = void 0));
    let r = e.r(52305),
      i = e.r(13520);
    ((n.addNewStackLayer = (e) => {
      (!1 === Array.isArray(e[i._LAYERS_STORE_PROPERTY]) &&
        Object.defineProperty(e, i._LAYERS_STORE_PROPERTY, { enumerable: !1, value: [] }),
        e[i._LAYERS_STORE_PROPERTY].push('/'));
      let t = e[i._LAYERS_STORE_PROPERTY].length;
      return () => {
        t === e[i._LAYERS_STORE_PROPERTY].length
          ? e[i._LAYERS_STORE_PROPERTY].pop()
          : r.diag.warn('Connect: Trying to pop the stack multiple time');
      };
    }),
      (n.replaceCurrentStackRoute = (e, t) => {
        t && e[i._LAYERS_STORE_PROPERTY].splice(-1, 1, t);
      }),
      (n.generateRoute = (e) =>
        e[i._LAYERS_STORE_PROPERTY].reduce((e, t) => e.replace(/\/+$/, '') + t)));
  },
  96991,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ConnectInstrumentation = n.ANONYMOUS_NAME = void 0));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(28710),
      a = e.r(22759),
      s = e.r(75235),
      u = e.r(81964),
      l = e.r(98628);
    n.ANONYMOUS_NAME = 'anonymous';
    class c extends s.InstrumentationBase {
      constructor(e = {}) {
        super(a.PACKAGE_NAME, a.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new s.InstrumentationNodeModuleDefinition('connect', ['>=3.0.0 <4'], (e) =>
            this._patchConstructor(e)
          ),
        ];
      }
      _patchApp(e) {
        ((0, s.isWrapped)(e.use) || this._wrap(e, 'use', this._patchUse.bind(this)),
          (0, s.isWrapped)(e.handle) || this._wrap(e, 'handle', this._patchHandle.bind(this)));
      }
      _patchConstructor(e) {
        let t = this;
        return function (...n) {
          let r = e.apply(this, n);
          return (t._patchApp(r), r);
        };
      }
      _patchNext(e, t) {
        return function (n) {
          let r = e.apply(this, [n]);
          return (t(), r);
        };
      }
      _startSpan(e, t) {
        let r, i, a;
        e
          ? ((r = o.ConnectTypes.REQUEST_HANDLER), (a = o.ConnectNames.REQUEST_HANDLER), (i = e))
          : ((r = o.ConnectTypes.MIDDLEWARE),
            (a = o.ConnectNames.MIDDLEWARE),
            (i = t.name || n.ANONYMOUS_NAME));
        let s = `${a} - ${i}`,
          l = {
            attributes: {
              [u.ATTR_HTTP_ROUTE]: e.length > 0 ? e : '/',
              [o.AttributeNames.CONNECT_TYPE]: r,
              [o.AttributeNames.CONNECT_NAME]: i,
            },
          };
        return this.tracer.startSpan(s, l);
      }
      _patchMiddleware(e, t) {
        let o = this,
          a = 4 === t.length;
        function s() {
          if (!o.isEnabled()) return t.apply(this, arguments);
          let [s, u, c] = a ? [1, 2, 3] : [0, 1, 2],
            d = arguments[s],
            p = arguments[u],
            _ = arguments[c];
          (0, l.replaceCurrentStackRoute)(d, e);
          let S = (0, i.getRPCMetadata)(r.context.active());
          e && S?.type === i.RPCType.HTTP && (S.route = (0, l.generateRoute)(d));
          let E = '';
          E = e ? `request handler - ${e}` : `middleware - ${t.name || n.ANONYMOUS_NAME}`;
          let T = o._startSpan(e, t);
          o._diag.debug('start span', E);
          let m = !1;
          function g() {
            (m
              ? o._diag.debug(`span ${T.name} - already finished`)
              : ((m = !0), o._diag.debug(`finishing span ${T.name}`), T.end()),
              p.removeListener('close', g));
          }
          return (
            p.addListener('close', g),
            (arguments[c] = o._patchNext(_, g)),
            t.apply(this, arguments)
          );
        }
        return (
          Object.defineProperty(s, 'length', { value: t.length, writable: !1, configurable: !0 }),
          s
        );
      }
      _patchUse(e) {
        let t = this;
        return function (...n) {
          let r = n[n.length - 1],
            i = n[n.length - 2] || '';
          return ((n[n.length - 1] = t._patchMiddleware(i, r)), e.apply(this, n));
        };
      }
      _patchHandle(e) {
        let t = this;
        return function () {
          let [n, r] = [0, 2],
            i = arguments[n],
            o = arguments[r],
            a = (0, l.addNewStackLayer)(i);
          return (
            'function' == typeof o && (arguments[r] = t._patchOut(o, a)),
            e.apply(this, arguments)
          );
        };
      }
      _patchOut(e, t) {
        return function (...n) {
          return (t(), Reflect.apply(e, this, n));
        };
      }
    }
    n.ConnectInstrumentation = c;
  },
  14797,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.ConnectTypes =
        n.ConnectNames =
        n.AttributeNames =
        n.ANONYMOUS_NAME =
        n.ConnectInstrumentation =
          void 0));
    var r = e.r(96991);
    (Object.defineProperty(n, 'ConnectInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.ConnectInstrumentation;
      },
    }),
      Object.defineProperty(n, 'ANONYMOUS_NAME', {
        enumerable: !0,
        get: function () {
          return r.ANONYMOUS_NAME;
        },
      }));
    var i = e.r(28710);
    (Object.defineProperty(n, 'AttributeNames', {
      enumerable: !0,
      get: function () {
        return i.AttributeNames;
      },
    }),
      Object.defineProperty(n, 'ConnectNames', {
        enumerable: !0,
        get: function () {
          return i.ConnectNames;
        },
      }),
      Object.defineProperty(n, 'ConnectTypes', {
        enumerable: !0,
        get: function () {
          return i.ConnectTypes;
        },
      }));
  },
  60467,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(14797),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Connect',
      s = o.generateInstrumentOnce(a, () => new r.ConnectInstrumentation());
    function u(e, t, n, r) {
      (i.captureException(e), r(e));
    }
    ((n.connectIntegration = i.defineIntegration(() => ({
      name: a,
      setupOnce() {
        s();
      },
    }))),
      (n.instrumentConnect = s),
      (n.setupConnectErrorHandler = (e) => {
        e.use(u);
        let t = i.getClient();
        (t &&
          t.on('spanStart', (e) => {
            !(function (e) {
              let t = i.spanToJSON(e).data,
                n = t['connect.type'];
              if (t[i.SEMANTIC_ATTRIBUTE_SENTRY_OP] || !n) return;
              e.setAttributes({
                [i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.connect',
                [i.SEMANTIC_ATTRIBUTE_SENTRY_OP]: `${n}.connect`,
              });
              let r = t['connect.name'];
              'string' == typeof r && e.updateName(r);
            })(e);
          }),
          o.ensureIsWrapped(e.use, 'connect'));
      }));
  },
  83324,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.48.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-knex'));
  },
  31381,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.SUPPORTED_VERSIONS = n.MODULE_NAME = void 0),
      (n.MODULE_NAME = 'knex'),
      (n.SUPPORTED_VERSIONS = [
        '>=0.22.0 <4',
        '>=0.10.0 <0.18.0',
        '>=0.19.0 <0.22.0',
        '>=0.18.0 <0.19.0',
      ]));
  },
  82806,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.DB_SYSTEM_NAME_VALUE_SQLITE = void 0),
      (n.DB_SYSTEM_NAME_VALUE_SQLITE = 'sqlite'));
  },
  70642,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.extractTableName =
        n.limitLength =
        n.getName =
        n.mapSystem =
        n.otelExceptionFromKnexError =
        n.getFormatter =
          void 0));
    let r = e.r(81964),
      i = e.r(82806);
    ((n.getFormatter = (e) => {
      if (e) {
        if (e.client) {
          if (e.client._formatQuery) return e.client._formatQuery.bind(e.client);
          else if (e.client.SqlString) return e.client.SqlString.format.bind(e.client.SqlString);
        }
        if (e.builder) return e.builder.toString.bind(e.builder);
      }
      return () => '<noop formatter>';
    }),
      (n.otelExceptionFromKnexError = function (e, t) {
        return e && e instanceof Error
          ? { message: t, code: e.code, stack: e.stack, name: e.name }
          : e;
      }));
    let o = new Map([
      ['sqlite3', i.DB_SYSTEM_NAME_VALUE_SQLITE],
      ['pg', r.DB_SYSTEM_NAME_VALUE_POSTGRESQL],
    ]);
    ((n.mapSystem = (e) => o.get(e) || e),
      (n.getName = (e, t, n) => (t ? (n ? `${t} ${e}.${n}` : `${t} ${e}`) : e)),
      (n.limitLength = (e, t) =>
        'string' == typeof e && 'number' == typeof t && 0 < t && t < e.length
          ? e.substring(0, t) + '..'
          : e),
      (n.extractTableName = (e) => {
        let t = e?._single?.table;
        return 'object' == typeof t ? (0, n.extractTableName)(t) : t;
      }));
  },
  48377,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.KnexInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(83324),
      o = e.r(31381),
      a = e.r(75235),
      s = e.r(70642),
      u = e.r(81964),
      l = Symbol('opentelemetry.instrumentation-knex.context'),
      c = { maxQueryLength: 1022, requireParentSpan: !1 };
    class d extends a.InstrumentationBase {
      _semconvStability;
      constructor(e = {}) {
        (super(i.PACKAGE_NAME, i.PACKAGE_VERSION, { ...c, ...e }),
          (this._semconvStability = (0, a.semconvStabilityFromStr)(
            'database',
            process.env.OTEL_SEMCONV_STABILITY_OPT_IN
          )));
      }
      setConfig(e = {}) {
        super.setConfig({ ...c, ...e });
      }
      init() {
        let e = new a.InstrumentationNodeModuleDefinition(o.MODULE_NAME, o.SUPPORTED_VERSIONS);
        return (
          e.files.push(
            this.getClientNodeModuleFileInstrumentation('src'),
            this.getClientNodeModuleFileInstrumentation('lib'),
            this.getRunnerNodeModuleFileInstrumentation('src'),
            this.getRunnerNodeModuleFileInstrumentation('lib'),
            this.getRunnerNodeModuleFileInstrumentation('lib/execution')
          ),
          e
        );
      }
      getRunnerNodeModuleFileInstrumentation(e) {
        return new a.InstrumentationNodeModuleFile(
          `knex/${e}/runner.js`,
          o.SUPPORTED_VERSIONS,
          (e, t) => (this.ensureWrapped(e.prototype, 'query', this.createQueryWrapper(t)), e),
          (e, t) => (this._unwrap(e.prototype, 'query'), e)
        );
      }
      getClientNodeModuleFileInstrumentation(e) {
        return new a.InstrumentationNodeModuleFile(
          `knex/${e}/client.js`,
          o.SUPPORTED_VERSIONS,
          (e) => (
            this.ensureWrapped(e.prototype, 'queryBuilder', this.storeContext.bind(this)),
            this.ensureWrapped(e.prototype, 'schemaBuilder', this.storeContext.bind(this)),
            this.ensureWrapped(e.prototype, 'raw', this.storeContext.bind(this)),
            e
          ),
          (e) => (
            this._unwrap(e.prototype, 'queryBuilder'),
            this._unwrap(e.prototype, 'schemaBuilder'),
            this._unwrap(e.prototype, 'raw'),
            e
          )
        );
      }
      createQueryWrapper(e) {
        let t = this;
        return function (n) {
          return function (i) {
            let o = this.client.config,
              c = s.extractTableName(this.builder),
              d = i?.method,
              p = o?.connection?.filename || o?.connection?.database,
              { maxQueryLength: _ } = t.getConfig(),
              S = { 'knex.version': e },
              E = o?.connection?.filename === ':memory:' ? 'inproc' : void 0;
            if (
              (t._semconvStability & a.SemconvStability.OLD &&
                Object.assign(S, {
                  [u.SEMATTRS_DB_SYSTEM]: s.mapSystem(o.client),
                  [u.SEMATTRS_DB_SQL_TABLE]: c,
                  [u.SEMATTRS_DB_OPERATION]: d,
                  [u.SEMATTRS_DB_USER]: o?.connection?.user,
                  [u.SEMATTRS_DB_NAME]: p,
                  [u.SEMATTRS_NET_PEER_NAME]: o?.connection?.host,
                  [u.SEMATTRS_NET_PEER_PORT]: o?.connection?.port,
                  [u.SEMATTRS_NET_TRANSPORT]: E,
                }),
              t._semconvStability & a.SemconvStability.STABLE &&
                Object.assign(S, {
                  [u.ATTR_DB_SYSTEM_NAME]: s.mapSystem(o.client),
                  [u.ATTR_DB_COLLECTION_NAME]: c,
                  [u.ATTR_DB_OPERATION_NAME]: d,
                  [u.ATTR_DB_NAMESPACE]: p,
                  [u.ATTR_SERVER_ADDRESS]: o?.connection?.host,
                  [u.ATTR_SERVER_PORT]: o?.connection?.port,
                }),
              _)
            ) {
              let e = s.limitLength(i?.sql, _);
              (t._semconvStability & a.SemconvStability.STABLE && (S[u.ATTR_DB_QUERY_TEXT] = e),
                t._semconvStability & a.SemconvStability.OLD && (S[u.SEMATTRS_DB_STATEMENT] = e));
            }
            let T = this.builder[l] || r.context.active(),
              m = r.trace.getSpan(T),
              g = m && r.trace.isSpanContextValid(m.spanContext());
            if (t._config.requireParentSpan && !g) return n.bind(this)(...arguments);
            let f = t.tracer.startSpan(
                s.getName(p, d, c),
                { kind: r.SpanKind.CLIENT, attributes: S },
                T
              ),
              h = r.trace.setSpan(r.context.active(), f);
            return r.context
              .with(h, n, this, ...arguments)
              .then((e) => (f.end(), e))
              .catch((e) => {
                let t = s.getFormatter(this)(i.sql, i.bindings || []),
                  n = e.message.replace(t + ' - ', ''),
                  o = s.otelExceptionFromKnexError(e, n);
                throw (
                  f.recordException(o),
                  f.setStatus({ code: r.SpanStatusCode.ERROR, message: n }),
                  f.end(),
                  e
                );
              });
          };
        };
      }
      storeContext(e) {
        return function () {
          let t = e.apply(this, arguments);
          return (Object.defineProperty(t, l, { value: r.context.active() }), t);
        };
      }
      ensureWrapped(e, t, n) {
        ((0, a.isWrapped)(e[t]) && this._unwrap(e, t), this._wrap(e, t, n));
      }
    }
    n.KnexInstrumentation = d;
  },
  54176,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.KnexInstrumentation = void 0));
    var r = e.r(48377);
    Object.defineProperty(n, 'KnexInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.KnexInstrumentation;
      },
    });
  },
  71761,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(54176),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Knex',
      s = o.generateInstrumentOnce(a, () => new r.KnexInstrumentation({ requireParentSpan: !0 })),
      u = i.defineIntegration(() => {
        let e;
        return {
          name: a,
          setupOnce() {
            let t = s();
            e = o.instrumentWhenWrapped(t);
          },
          setup(t) {
            e?.(() =>
              t.on('spanStart', (e) => {
                let { data: t } = i.spanToJSON(e);
                'knex.version' in t &&
                  e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.knex');
              })
            );
          },
        };
      });
    ((n.instrumentKnex = s), (n.knexIntegration = u));
  },
  72545,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.once = n.getSpanName = void 0),
      (n.getSpanName = function (e, t, n, r) {
        return 'execBulkLoad' === e && r && t
          ? `${e} ${r} ${t}`
          : 'callProcedure' === e
            ? t
              ? `${e} ${n} ${t}`
              : `${e} ${n}`
            : t
              ? `${e} ${t}`
              : `${e}`;
      }),
      (n.once = (e) => {
        let t = !1;
        return (...n) => {
          if (!t) return ((t = !0), e(...n));
        };
      }));
  },
  88137,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.22.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-tedious'));
  },
  11496,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.TediousInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(27699),
      o = e.r(75235),
      a = e.r(81964),
      s = e.r(72545),
      u = e.r(88137),
      l = Symbol('opentelemetry.instrumentation-tedious.current-database'),
      c = ['callProcedure', 'execSql', 'execSqlBatch', 'execBulkLoad', 'prepare', 'execute'];
    function d(e) {
      Object.defineProperty(this, l, { value: e, writable: !0 });
    }
    class p extends o.InstrumentationBase {
      static COMPONENT = 'tedious';
      constructor(e = {}) {
        super(u.PACKAGE_NAME, u.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new o.InstrumentationNodeModuleDefinition(
            p.COMPONENT,
            ['>=1.11.0 <20'],
            (e) => {
              let t = e.Connection.prototype;
              for (let e of c)
                ((0, o.isWrapped)(t[e]) && this._unwrap(t, e),
                  this._wrap(t, e, this._patchQuery(e)));
              return (
                (0, o.isWrapped)(t.connect) && this._unwrap(t, 'connect'),
                this._wrap(t, 'connect', this._patchConnect),
                e
              );
            },
            (e) => {
              if (void 0 === e) return;
              let t = e.Connection.prototype;
              for (let e of c) this._unwrap(t, e);
              this._unwrap(t, 'connect');
            }
          ),
        ];
      }
      _patchConnect(e) {
        return function () {
          return (
            d.call(this, this.config?.options?.database),
            this.removeListener('databaseChange', d),
            this.on('databaseChange', d),
            this.once('end', () => {
              this.removeListener('databaseChange', d);
            }),
            e.apply(this, arguments)
          );
        };
      }
      _patchQuery(e) {
        return (t) => {
          let n = this;
          function o(o) {
            if (!(o instanceof i.EventEmitter))
              return (
                n._diag.warn(`Unexpected invocation of patched ${e} method. Span not recorded`),
                t.apply(this, arguments)
              );
            let u = 0,
              c = 0,
              d = () => c++,
              p = () => u++,
              _ = this[l],
              S =
                'sp_prepare' === o.sqlTextOrProcedure && o.parametersByName?.stmt?.value
                  ? o.parametersByName.stmt.value
                  : o.sqlTextOrProcedure,
              E = n.tracer.startSpan((0, s.getSpanName)(e, _, S, o.table), {
                kind: r.SpanKind.CLIENT,
                attributes: {
                  [a.SEMATTRS_DB_SYSTEM]: a.DBSYSTEMVALUES_MSSQL,
                  [a.SEMATTRS_DB_NAME]: _,
                  [a.SEMATTRS_NET_PEER_PORT]: this.config?.options?.port,
                  [a.SEMATTRS_NET_PEER_NAME]: this.config?.server,
                  [a.SEMATTRS_DB_USER]:
                    this.config?.userName ?? this.config?.authentication?.options?.userName,
                  [a.SEMATTRS_DB_STATEMENT]: S,
                  [a.SEMATTRS_DB_SQL_TABLE]: o.table,
                },
              }),
              T = (0, s.once)((e) => {
                (o.removeListener('done', d),
                  o.removeListener('doneInProc', d),
                  o.removeListener('doneProc', p),
                  o.removeListener('error', T),
                  this.removeListener('end', T),
                  E.setAttribute('tedious.procedure_count', u),
                  E.setAttribute('tedious.statement_count', c),
                  e && E.setStatus({ code: r.SpanStatusCode.ERROR, message: e.message }),
                  E.end());
              });
            return (
              o.on('done', d),
              o.on('doneInProc', d),
              o.on('doneProc', p),
              o.once('error', T),
              this.on('end', T),
              'function' == typeof o.callback
                ? n._wrap(o, 'callback', n._patchCallbackQuery(T))
                : n._diag.error('Expected request.callback to be a function'),
              r.context.with(r.trace.setSpan(r.context.active(), E), t, this, ...arguments)
            );
          }
          return (Object.defineProperty(o, 'length', { value: t.length, writable: !1 }), o);
        };
      }
      _patchCallbackQuery(e) {
        return (t) =>
          function (n, r, i) {
            return (e(n), t.apply(this, arguments));
          };
      }
    }
    n.TediousInstrumentation = p;
  },
  61450,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.TediousInstrumentation = void 0));
    var r = e.r(11496);
    Object.defineProperty(n, 'TediousInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.TediousInstrumentation;
      },
    });
  },
  10878,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(61450),
      i = e.r(48009),
      o = e.r(15527),
      a = new Set([
        'callProcedure',
        'execSql',
        'execSqlBatch',
        'execBulkLoad',
        'prepare',
        'execute',
      ]),
      s = 'Tedious',
      u = o.generateInstrumentOnce(s, () => new r.TediousInstrumentation({})),
      l = i.defineIntegration(() => {
        let e;
        return {
          name: s,
          setupOnce() {
            let t = u();
            e = o.instrumentWhenWrapped(t);
          },
          setup(t) {
            e?.(() =>
              t.on('spanStart', (e) => {
                let { description: t, data: n } = i.spanToJSON(e);
                if (!t || 'mssql' !== n['db.system']) return;
                let r = t.split(' ')[0] || '';
                a.has(r) &&
                  e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.tedious');
              })
            );
          },
        };
      });
    ((n.instrumentTedious = u), (n.tediousIntegration = l));
  },
  57129,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.47.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-generic-pool'));
  },
  89579,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.GenericPoolInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(75235),
      o = e.r(57129),
      a = 'generic-pool';
    class s extends i.InstrumentationBase {
      _isDisabled = !1;
      constructor(e = {}) {
        super(o.PACKAGE_NAME, o.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new i.InstrumentationNodeModuleDefinition(
            a,
            ['>=3.0.0 <4'],
            (e) => {
              let t = e.Pool;
              return (
                (0, i.isWrapped)(t.prototype.acquire) && this._unwrap(t.prototype, 'acquire'),
                this._wrap(t.prototype, 'acquire', this._acquirePatcher.bind(this)),
                e
              );
            },
            (e) => {
              let t = e.Pool;
              return (this._unwrap(t.prototype, 'acquire'), e);
            }
          ),
          new i.InstrumentationNodeModuleDefinition(
            a,
            ['>=2.4.0 <3'],
            (e) => {
              let t = e.Pool;
              return (
                (0, i.isWrapped)(t.prototype.acquire) && this._unwrap(t.prototype, 'acquire'),
                this._wrap(t.prototype, 'acquire', this._acquireWithCallbacksPatcher.bind(this)),
                e
              );
            },
            (e) => {
              let t = e.Pool;
              return (this._unwrap(t.prototype, 'acquire'), e);
            }
          ),
          new i.InstrumentationNodeModuleDefinition(
            a,
            ['>=2.0.0 <2.4'],
            (e) => (
              (this._isDisabled = !1),
              (0, i.isWrapped)(e.Pool) && this._unwrap(e, 'Pool'),
              this._wrap(e, 'Pool', this._poolWrapper.bind(this)),
              e
            ),
            (e) => ((this._isDisabled = !0), e)
          ),
        ];
      }
      _acquirePatcher(e) {
        let t = this;
        return function (...n) {
          let i = r.context.active(),
            o = t.tracer.startSpan('generic-pool.acquire', {}, i);
          return r.context.with(r.trace.setSpan(i, o), () =>
            e.call(this, ...n).then(
              (e) => (o.end(), e),
              (e) => {
                throw (o.recordException(e), o.end(), e);
              }
            )
          );
        };
      }
      _poolWrapper(e) {
        let t = this;
        return function () {
          let n = e.apply(this, arguments);
          return (t._wrap(n, 'acquire', t._acquireWithCallbacksPatcher.bind(t)), n);
        };
      }
      _acquireWithCallbacksPatcher(e) {
        let t = this;
        return function (n, i) {
          if (t._isDisabled) return e.call(this, n, i);
          let o = r.context.active(),
            a = t.tracer.startSpan('generic-pool.acquire', {}, o);
          return r.context.with(r.trace.setSpan(o, a), () => {
            e.call(
              this,
              (e, t) => {
                if ((a.end(), n)) return n(e, t);
              },
              i
            );
          });
        };
      }
    }
    n.GenericPoolInstrumentation = s;
  },
  24556,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.GenericPoolInstrumentation = void 0));
    var r = e.r(89579);
    Object.defineProperty(n, 'GenericPoolInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.GenericPoolInstrumentation;
      },
    });
  },
  80190,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(24556),
      i = e.r(48009),
      o = e.r(15527),
      a = 'GenericPool',
      s = o.generateInstrumentOnce(a, () => new r.GenericPoolInstrumentation({}));
    ((n.genericPoolIntegration = i.defineIntegration(() => {
      let e;
      return {
        name: a,
        setupOnce() {
          let t = s();
          e = o.instrumentWhenWrapped(t);
        },
        setup(t) {
          e?.(() =>
            t.on('spanStart', (e) => {
              let t = i.spanToJSON(e).description;
              ('generic-pool.aquire' === t || 'generic-pool.acquire' === t) &&
                e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.generic_pool');
            })
          );
        },
      };
    })),
      (n.instrumentGenericPool = s));
  },
  93934,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.21.1'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-dataloader'));
  },
  28761,
  (e, t, n) => {
    'use strict';
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.DataloaderInstrumentation = void 0));
    let r = e.r(75235),
      i = e.r(52305),
      o = e.r(93934),
      a = 'dataloader';
    function s(e) {
      return 'Module' === e[Symbol.toStringTag] ? e.default : e;
    }
    class u extends r.InstrumentationBase {
      constructor(e = {}) {
        super(o.PACKAGE_NAME, o.PACKAGE_VERSION, e);
      }
      init() {
        return [
          new r.InstrumentationNodeModuleDefinition(
            a,
            ['>=2.0.0 <3'],
            (e) => {
              let t = s(e);
              return (
                this._patchLoad(t.prototype),
                this._patchLoadMany(t.prototype),
                this._patchPrime(t.prototype),
                this._patchClear(t.prototype),
                this._patchClearAll(t.prototype),
                this._getPatchedConstructor(t)
              );
            },
            (e) => {
              let t = s(e);
              ['load', 'loadMany', 'prime', 'clear', 'clearAll'].forEach((e) => {
                (0, r.isWrapped)(t.prototype[e]) && this._unwrap(t.prototype, e);
              });
            }
          ),
        ];
      }
      shouldCreateSpans() {
        let e = this.getConfig();
        return void 0 !== i.trace.getSpan(i.context.active()) || !e.requireParentSpan;
      }
      getSpanName(e, t) {
        let n = e.name;
        return null == n ? `${a}.${t}` : `${a}.${t} ${n}`;
      }
      _wrapBatchLoadFn(e) {
        let t = this;
        return function (...n) {
          if (!t.isEnabled() || !t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(
              t.getSpanName(this, 'batch'),
              { links: this._batch?.spanLinks },
              r
            );
          return i.context.with(i.trace.setSpan(r, o), () =>
            e
              .apply(this, n)
              .then((e) => (o.end(), e))
              .catch((e) => {
                throw (
                  o.recordException(e),
                  o.setStatus({ code: i.SpanStatusCode.ERROR, message: e.message }),
                  o.end(),
                  e
                );
              })
          );
        };
      }
      _getPatchedConstructor(e) {
        let t = this,
          n = e.prototype;
        if (!t.isEnabled()) return e;
        function i(...n) {
          return (
            'function' == typeof n[0] &&
              ((0, r.isWrapped)(n[0]) && t._unwrap(n, 0), (n[0] = t._wrapBatchLoadFn(n[0]))),
            e.apply(this, n)
          );
        }
        return ((i.prototype = n), i);
      }
      _patchLoad(e) {
        ((0, r.isWrapped)(e.load) && this._unwrap(e, 'load'),
          this._wrap(e, 'load', this._getPatchedLoad.bind(this)));
      }
      _getPatchedLoad(e) {
        let t = this;
        return function (...n) {
          if (!t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(t.getSpanName(this, 'load'), { kind: i.SpanKind.CLIENT }, r);
          return i.context.with(i.trace.setSpan(r, o), () => {
            let t = e
              .call(this, ...n)
              .then((e) => (o.end(), e))
              .catch((e) => {
                throw (
                  o.recordException(e),
                  o.setStatus({ code: i.SpanStatusCode.ERROR, message: e.message }),
                  o.end(),
                  e
                );
              });
            return (
              this._batch &&
                (this._batch.spanLinks || (this._batch.spanLinks = []),
                this._batch.spanLinks.push({ context: o.spanContext() })),
              t
            );
          });
        };
      }
      _patchLoadMany(e) {
        ((0, r.isWrapped)(e.loadMany) && this._unwrap(e, 'loadMany'),
          this._wrap(e, 'loadMany', this._getPatchedLoadMany.bind(this)));
      }
      _getPatchedLoadMany(e) {
        let t = this;
        return function (...n) {
          if (!t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(t.getSpanName(this, 'loadMany'), { kind: i.SpanKind.CLIENT }, r);
          return i.context.with(i.trace.setSpan(r, o), () =>
            e.call(this, ...n).then((e) => (o.end(), e))
          );
        };
      }
      _patchPrime(e) {
        ((0, r.isWrapped)(e.prime) && this._unwrap(e, 'prime'),
          this._wrap(e, 'prime', this._getPatchedPrime.bind(this)));
      }
      _getPatchedPrime(e) {
        let t = this;
        return function (...n) {
          if (!t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(t.getSpanName(this, 'prime'), { kind: i.SpanKind.CLIENT }, r),
            a = i.context.with(i.trace.setSpan(r, o), () => e.call(this, ...n));
          return (o.end(), a);
        };
      }
      _patchClear(e) {
        ((0, r.isWrapped)(e.clear) && this._unwrap(e, 'clear'),
          this._wrap(e, 'clear', this._getPatchedClear.bind(this)));
      }
      _getPatchedClear(e) {
        let t = this;
        return function (...n) {
          if (!t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(t.getSpanName(this, 'clear'), { kind: i.SpanKind.CLIENT }, r),
            a = i.context.with(i.trace.setSpan(r, o), () => e.call(this, ...n));
          return (o.end(), a);
        };
      }
      _patchClearAll(e) {
        ((0, r.isWrapped)(e.clearAll) && this._unwrap(e, 'clearAll'),
          this._wrap(e, 'clearAll', this._getPatchedClearAll.bind(this)));
      }
      _getPatchedClearAll(e) {
        let t = this;
        return function (...n) {
          if (!t.shouldCreateSpans()) return e.call(this, ...n);
          let r = i.context.active(),
            o = t.tracer.startSpan(t.getSpanName(this, 'clearAll'), { kind: i.SpanKind.CLIENT }, r),
            a = i.context.with(i.trace.setSpan(r, o), () => e.call(this, ...n));
          return (o.end(), a);
        };
      }
    }
    n.DataloaderInstrumentation = u;
  },
  89824,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.DataloaderInstrumentation = void 0));
    var r = e.r(28761);
    Object.defineProperty(n, 'DataloaderInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.DataloaderInstrumentation;
      },
    });
  },
  41100,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(89824),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Dataloader',
      s = o.generateInstrumentOnce(
        a,
        () => new r.DataloaderInstrumentation({ requireParentSpan: !0 })
      );
    ((n.dataloaderIntegration = i.defineIntegration(() => {
      let e;
      return {
        name: a,
        setupOnce() {
          let t = s();
          e = o.instrumentWhenWrapped(t);
        },
        setup(t) {
          e?.(() => {
            t.on('spanStart', (e) => {
              let t = i.spanToJSON(e);
              (t.description?.startsWith('dataloader') &&
                e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.dataloader'),
                ('dataloader.load' === t.description ||
                  'dataloader.loadMany' === t.description ||
                  'dataloader.batch' === t.description) &&
                  e.setAttribute(i.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'cache.get'));
            });
          });
        },
      };
    })),
      (n.instrumentDataloader = s));
  },
  9277,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.DEFAULT_CONFIG = n.EndOperation = void 0),
      (function (e) {
        ((e.AutoAck = 'auto ack'),
          (e.Ack = 'ack'),
          (e.AckAll = 'ackAll'),
          (e.Reject = 'reject'),
          (e.Nack = 'nack'),
          (e.NackAll = 'nackAll'),
          (e.ChannelClosed = 'channel closed'),
          (e.ChannelError = 'channel error'),
          (e.InstrumentationTimeout = 'instrumentation timeout'));
      })(n.EndOperation || (n.EndOperation = {})),
      (n.DEFAULT_CONFIG = { consumeTimeoutMs: 6e4, useLinksForConsume: !1 }));
  },
  77572,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.isConfirmChannelTracing =
        n.unmarkConfirmChannelTracing =
        n.markConfirmChannelTracing =
        n.getConnectionAttributesFromUrl =
        n.getConnectionAttributesFromServer =
        n.normalizeExchange =
        n.CONNECTION_ATTRIBUTES =
        n.CHANNEL_CONSUME_TIMEOUT_TIMER =
        n.CHANNEL_SPANS_NOT_ENDED =
        n.MESSAGE_STORED_SPAN =
          void 0));
    let r = e.r(52305),
      i = e.r(81964);
    ((n.MESSAGE_STORED_SPAN = Symbol('opentelemetry.amqplib.message.stored-span')),
      (n.CHANNEL_SPANS_NOT_ENDED = Symbol('opentelemetry.amqplib.channel.spans-not-ended')),
      (n.CHANNEL_CONSUME_TIMEOUT_TIMER = Symbol(
        'opentelemetry.amqplib.channel.consumer-timeout-timer'
      )),
      (n.CONNECTION_ATTRIBUTES = Symbol('opentelemetry.amqplib.connection.attributes')));
    let o = (0, r.createContextKey)('opentelemetry.amqplib.channel.is-confirm-channel');
    n.normalizeExchange = (e) => ('' !== e ? e : '<default>');
    let a = (e, t) => e || ('AMQP' === t ? 5672 : 5671),
      s = (e) => {
        let t = e || 'amqp';
        return (t.endsWith(':') ? t.substring(0, t.length - 1) : t).toUpperCase();
      },
      u = (e, t, n, i) =>
        n
          ? { [t]: n }
          : (r.diag.error(
              `amqplib instrumentation: could not extract connection attribute ${i} from user supplied url`,
              { url: e }
            ),
            {});
    ((n.getConnectionAttributesFromServer = (e) => {
      let t = e.serverProperties.product?.toLowerCase?.();
      return t ? { [i.SEMATTRS_MESSAGING_SYSTEM]: t } : {};
    }),
      (n.getConnectionAttributesFromUrl = (e) => {
        let t = { [i.SEMATTRS_MESSAGING_PROTOCOL_VERSION]: '0.9.1' };
        if ('object' == typeof (e = e || 'amqp://localhost')) {
          let n = e,
            r = s(n?.protocol);
          Object.assign(t, { ...u(e, i.SEMATTRS_MESSAGING_PROTOCOL, r, 'protocol') });
          let o = n?.hostname || 'localhost';
          Object.assign(t, { ...u(e, i.SEMATTRS_NET_PEER_NAME, o, 'hostname') });
          let l = a(n.port, r);
          Object.assign(t, { ...u(e, i.SEMATTRS_NET_PEER_PORT, l, 'port') });
        } else {
          let n = e.replace(/:[^:@/]*@/, ':***@');
          t[i.SEMATTRS_MESSAGING_URL] = n;
          try {
            let e = new URL(n),
              r = s(e.protocol);
            Object.assign(t, { ...u(n, i.SEMATTRS_MESSAGING_PROTOCOL, r, 'protocol') });
            let o = e.hostname || 'localhost';
            Object.assign(t, { ...u(n, i.SEMATTRS_NET_PEER_NAME, o, 'hostname') });
            let l = a(e.port ? parseInt(e.port) : void 0, r);
            Object.assign(t, { ...u(n, i.SEMATTRS_NET_PEER_PORT, l, 'port') });
          } catch (e) {
            r.diag.error(
              'amqplib instrumentation: error while extracting connection details from connection url',
              { censoredUrl: n, err: e }
            );
          }
        }
        return t;
      }),
      (n.markConfirmChannelTracing = (e) => e.setValue(o, !0)),
      (n.unmarkConfirmChannelTracing = (e) => e.deleteValue(o)),
      (n.isConfirmChannelTracing = (e) => !0 === e.getValue(o)));
  },
  56087,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.PACKAGE_NAME = n.PACKAGE_VERSION = void 0),
      (n.PACKAGE_VERSION = '0.50.0'),
      (n.PACKAGE_NAME = '@opentelemetry/instrumentation-amqplib'));
  },
  31985,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }), (n.AmqplibInstrumentation = void 0));
    let r = e.r(52305),
      i = e.r(88540),
      o = e.r(75235),
      a = e.r(81964),
      s = e.r(9277),
      u = e.r(77572),
      l = e.r(56087),
      c = ['>=0.5.5 <1'];
    class d extends o.InstrumentationBase {
      constructor(e = {}) {
        super(l.PACKAGE_NAME, l.PACKAGE_VERSION, { ...s.DEFAULT_CONFIG, ...e });
      }
      setConfig(e = {}) {
        super.setConfig({ ...s.DEFAULT_CONFIG, ...e });
      }
      init() {
        let e = new o.InstrumentationNodeModuleFile(
            'amqplib/lib/channel_model.js',
            c,
            this.patchChannelModel.bind(this),
            this.unpatchChannelModel.bind(this)
          ),
          t = new o.InstrumentationNodeModuleFile(
            'amqplib/lib/callback_model.js',
            c,
            this.patchChannelModel.bind(this),
            this.unpatchChannelModel.bind(this)
          ),
          n = new o.InstrumentationNodeModuleFile(
            'amqplib/lib/connect.js',
            c,
            this.patchConnect.bind(this),
            this.unpatchConnect.bind(this)
          );
        return new o.InstrumentationNodeModuleDefinition('amqplib', c, void 0, void 0, [e, n, t]);
      }
      patchConnect(e) {
        return (
          (e = this.unpatchConnect(e)),
          (0, o.isWrapped)(e.connect) || this._wrap(e, 'connect', this.getConnectPatch.bind(this)),
          e
        );
      }
      unpatchConnect(e) {
        return ((0, o.isWrapped)(e.connect) && this._unwrap(e, 'connect'), e);
      }
      patchChannelModel(e, t) {
        return (
          (0, o.isWrapped)(e.Channel.prototype.publish) ||
            this._wrap(e.Channel.prototype, 'publish', this.getPublishPatch.bind(this, t)),
          (0, o.isWrapped)(e.Channel.prototype.consume) ||
            this._wrap(e.Channel.prototype, 'consume', this.getConsumePatch.bind(this, t)),
          (0, o.isWrapped)(e.Channel.prototype.ack) ||
            this._wrap(
              e.Channel.prototype,
              'ack',
              this.getAckPatch.bind(this, !1, s.EndOperation.Ack)
            ),
          (0, o.isWrapped)(e.Channel.prototype.nack) ||
            this._wrap(
              e.Channel.prototype,
              'nack',
              this.getAckPatch.bind(this, !0, s.EndOperation.Nack)
            ),
          (0, o.isWrapped)(e.Channel.prototype.reject) ||
            this._wrap(
              e.Channel.prototype,
              'reject',
              this.getAckPatch.bind(this, !0, s.EndOperation.Reject)
            ),
          (0, o.isWrapped)(e.Channel.prototype.ackAll) ||
            this._wrap(
              e.Channel.prototype,
              'ackAll',
              this.getAckAllPatch.bind(this, !1, s.EndOperation.AckAll)
            ),
          (0, o.isWrapped)(e.Channel.prototype.nackAll) ||
            this._wrap(
              e.Channel.prototype,
              'nackAll',
              this.getAckAllPatch.bind(this, !0, s.EndOperation.NackAll)
            ),
          (0, o.isWrapped)(e.Channel.prototype.emit) ||
            this._wrap(e.Channel.prototype, 'emit', this.getChannelEmitPatch.bind(this)),
          (0, o.isWrapped)(e.ConfirmChannel.prototype.publish) ||
            this._wrap(
              e.ConfirmChannel.prototype,
              'publish',
              this.getConfirmedPublishPatch.bind(this, t)
            ),
          e
        );
      }
      unpatchChannelModel(e) {
        return (
          (0, o.isWrapped)(e.Channel.prototype.publish) &&
            this._unwrap(e.Channel.prototype, 'publish'),
          (0, o.isWrapped)(e.Channel.prototype.consume) &&
            this._unwrap(e.Channel.prototype, 'consume'),
          (0, o.isWrapped)(e.Channel.prototype.ack) && this._unwrap(e.Channel.prototype, 'ack'),
          (0, o.isWrapped)(e.Channel.prototype.nack) && this._unwrap(e.Channel.prototype, 'nack'),
          (0, o.isWrapped)(e.Channel.prototype.reject) &&
            this._unwrap(e.Channel.prototype, 'reject'),
          (0, o.isWrapped)(e.Channel.prototype.ackAll) &&
            this._unwrap(e.Channel.prototype, 'ackAll'),
          (0, o.isWrapped)(e.Channel.prototype.nackAll) &&
            this._unwrap(e.Channel.prototype, 'nackAll'),
          (0, o.isWrapped)(e.Channel.prototype.emit) && this._unwrap(e.Channel.prototype, 'emit'),
          (0, o.isWrapped)(e.ConfirmChannel.prototype.publish) &&
            this._unwrap(e.ConfirmChannel.prototype, 'publish'),
          e
        );
      }
      getConnectPatch(e) {
        return function (t, n, r) {
          return e.call(this, t, n, function (e, n) {
            if (null == e) {
              let e = (0, u.getConnectionAttributesFromUrl)(t),
                r = (0, u.getConnectionAttributesFromServer)(n);
              n[u.CONNECTION_ATTRIBUTES] = { ...e, ...r };
            }
            r.apply(this, arguments);
          });
        };
      }
      getChannelEmitPatch(e) {
        let t = this;
        return function (n) {
          if ('close' === n) {
            t.endAllSpansOnChannel(this, !0, s.EndOperation.ChannelClosed, void 0);
            let e = this[u.CHANNEL_CONSUME_TIMEOUT_TIMER];
            (e && clearInterval(e), (this[u.CHANNEL_CONSUME_TIMEOUT_TIMER] = void 0));
          } else
            'error' === n && t.endAllSpansOnChannel(this, !0, s.EndOperation.ChannelError, void 0);
          return e.apply(this, arguments);
        };
      }
      getAckAllPatch(e, t, n) {
        let r = this;
        return function (i) {
          return (r.endAllSpansOnChannel(this, e, t, i), n.apply(this, arguments));
        };
      }
      getAckPatch(e, t, n) {
        let r = this;
        return function (i, o, a) {
          let l = t === s.EndOperation.Reject ? o : a,
            c = this[u.CHANNEL_SPANS_NOT_ENDED] ?? [],
            d = c.findIndex((e) => e.msg === i);
          if (d < 0) r.endConsumerSpan(i, e, t, l);
          else if (t !== s.EndOperation.Reject && o) {
            for (let n = 0; n <= d; n++) r.endConsumerSpan(c[n].msg, e, t, l);
            c.splice(0, d + 1);
          } else (r.endConsumerSpan(i, e, t, l), c.splice(d, 1));
          return n.apply(this, arguments);
        };
      }
      getConsumePatch(e, t) {
        let n = this;
        return function (l, c, d) {
          let p = this;
          if (!Object.prototype.hasOwnProperty.call(p, u.CHANNEL_SPANS_NOT_ENDED)) {
            let { consumeTimeoutMs: e } = n.getConfig();
            if (e) {
              let t = setInterval(() => {
                n.checkConsumeTimeoutOnChannel(p);
              }, e);
              (t.unref(), (p[u.CHANNEL_CONSUME_TIMEOUT_TIMER] = t));
            }
            p[u.CHANNEL_SPANS_NOT_ENDED] = [];
          }
          return (
            (arguments[1] = function (t) {
              let _;
              if (!t) return c.call(this, t);
              let S = t.properties.headers ?? {},
                E = r.propagation.extract(r.ROOT_CONTEXT, S),
                T = t.fields?.exchange;
              if (n._config.useLinksForConsume) {
                let e = E ? r.trace.getSpan(E)?.spanContext() : void 0;
                ((E = void 0), e && (_ = [{ context: e }]));
              }
              let m = n.tracer.startSpan(
                  `${l} process`,
                  {
                    kind: r.SpanKind.CONSUMER,
                    attributes: {
                      ...p?.connection?.[u.CONNECTION_ATTRIBUTES],
                      [a.SEMATTRS_MESSAGING_DESTINATION]: T,
                      [a.SEMATTRS_MESSAGING_DESTINATION_KIND]:
                        a.MESSAGINGDESTINATIONKINDVALUES_TOPIC,
                      [a.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: t.fields?.routingKey,
                      [a.SEMATTRS_MESSAGING_OPERATION]: a.MESSAGINGOPERATIONVALUES_PROCESS,
                      [a.SEMATTRS_MESSAGING_MESSAGE_ID]: t?.properties.messageId,
                      [a.SEMATTRS_MESSAGING_CONVERSATION_ID]: t?.properties.correlationId,
                    },
                    links: _,
                  },
                  E
                ),
                { consumeHook: g } = n.getConfig();
              (g &&
                (0, o.safeExecuteInTheMiddle)(
                  () => g(m, { moduleVersion: e, msg: t }),
                  (e) => {
                    e && r.diag.error('amqplib instrumentation: consumerHook error', e);
                  },
                  !0
                ),
                d?.noAck ||
                  (p[u.CHANNEL_SPANS_NOT_ENDED].push({ msg: t, timeOfConsume: (0, i.hrTime)() }),
                  (t[u.MESSAGE_STORED_SPAN] = m)));
              let f = E || r.ROOT_CONTEXT;
              (r.context.with(r.trace.setSpan(f, m), () => {
                c.call(this, t);
              }),
                d?.noAck && (n.callConsumeEndHook(m, t, !1, s.EndOperation.AutoAck), m.end()));
            }),
            t.apply(this, arguments)
          );
        };
      }
      getConfirmedPublishPatch(e, t) {
        let n = this;
        return function (i, a, s, l, c) {
          let { span: d, modifiedOptions: p } = n.createPublishSpan(n, i, a, this, l),
            { publishHook: _ } = n.getConfig();
          _ &&
            (0, o.safeExecuteInTheMiddle)(
              () =>
                _(d, {
                  moduleVersion: e,
                  exchange: i,
                  routingKey: a,
                  content: s,
                  options: p,
                  isConfirmChannel: !0,
                }),
              (e) => {
                e && r.diag.error('amqplib instrumentation: publishHook error', e);
              },
              !0
            );
          let S = (0, u.markConfirmChannelTracing)(r.context.active()),
            E = [...arguments];
          return (
            (E[3] = p),
            (E[4] = r.context.bind(
              (0, u.unmarkConfirmChannelTracing)(r.trace.setSpan(S, d)),
              function (t, u) {
                try {
                  c?.call(this, t, u);
                } finally {
                  let { publishConfirmHook: u } = n.getConfig();
                  (u &&
                    (0, o.safeExecuteInTheMiddle)(
                      () =>
                        u(d, {
                          moduleVersion: e,
                          exchange: i,
                          routingKey: a,
                          content: s,
                          options: l,
                          isConfirmChannel: !0,
                          confirmError: t,
                        }),
                      (e) => {
                        e && r.diag.error('amqplib instrumentation: publishConfirmHook error', e);
                      },
                      !0
                    ),
                    t &&
                      d.setStatus({
                        code: r.SpanStatusCode.ERROR,
                        message: "message confirmation has been nack'ed",
                      }),
                    d.end());
                }
              }
            )),
            r.context.with(S, t.bind(this, ...E))
          );
        };
      }
      getPublishPatch(e, t) {
        let n = this;
        return function (i, a, s, l) {
          if ((0, u.isConfirmChannelTracing)(r.context.active())) return t.apply(this, arguments);
          {
            let { span: u, modifiedOptions: c } = n.createPublishSpan(n, i, a, this, l),
              { publishHook: d } = n.getConfig();
            d &&
              (0, o.safeExecuteInTheMiddle)(
                () =>
                  d(u, {
                    moduleVersion: e,
                    exchange: i,
                    routingKey: a,
                    content: s,
                    options: c,
                    isConfirmChannel: !1,
                  }),
                (e) => {
                  e && r.diag.error('amqplib instrumentation: publishHook error', e);
                },
                !0
              );
            let p = [...arguments];
            p[3] = c;
            let _ = t.apply(this, p);
            return (u.end(), _);
          }
        };
      }
      createPublishSpan(e, t, n, i, o) {
        let s = (0, u.normalizeExchange)(t),
          l = e.tracer.startSpan(`publish ${s}`, {
            kind: r.SpanKind.PRODUCER,
            attributes: {
              ...i.connection[u.CONNECTION_ATTRIBUTES],
              [a.SEMATTRS_MESSAGING_DESTINATION]: t,
              [a.SEMATTRS_MESSAGING_DESTINATION_KIND]: a.MESSAGINGDESTINATIONKINDVALUES_TOPIC,
              [a.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY]: n,
              [a.SEMATTRS_MESSAGING_MESSAGE_ID]: o?.messageId,
              [a.SEMATTRS_MESSAGING_CONVERSATION_ID]: o?.correlationId,
            },
          }),
          c = o ?? {};
        return (
          (c.headers = c.headers ?? {}),
          r.propagation.inject(r.trace.setSpan(r.context.active(), l), c.headers),
          { span: l, modifiedOptions: c }
        );
      }
      endConsumerSpan(e, t, n, i) {
        let o = e[u.MESSAGE_STORED_SPAN];
        o &&
          (!1 !== t &&
            o.setStatus({
              code: r.SpanStatusCode.ERROR,
              message:
                n !== s.EndOperation.ChannelClosed && n !== s.EndOperation.ChannelError
                  ? `${n} called on message${!0 === i ? ' with requeue' : !1 === i ? ' without requeue' : ''}`
                  : n,
            }),
          this.callConsumeEndHook(o, e, t, n),
          o.end(),
          (e[u.MESSAGE_STORED_SPAN] = void 0));
      }
      endAllSpansOnChannel(e, t, n, r) {
        ((e[u.CHANNEL_SPANS_NOT_ENDED] ?? []).forEach((e) => {
          this.endConsumerSpan(e.msg, t, n, r);
        }),
          (e[u.CHANNEL_SPANS_NOT_ENDED] = []));
      }
      callConsumeEndHook(e, t, n, i) {
        let { consumeEndHook: a } = this.getConfig();
        a &&
          (0, o.safeExecuteInTheMiddle)(
            () => a(e, { msg: t, rejected: n, endOperation: i }),
            (e) => {
              e && r.diag.error('amqplib instrumentation: consumerEndHook error', e);
            },
            !0
          );
      }
      checkConsumeTimeoutOnChannel(e) {
        let t,
          n = (0, i.hrTime)(),
          r = e[u.CHANNEL_SPANS_NOT_ENDED] ?? [],
          { consumeTimeoutMs: o } = this.getConfig();
        for (t = 0; t < r.length; t++) {
          let e = r[t],
            a = (0, i.hrTimeDuration)(e.timeOfConsume, n);
          if ((0, i.hrTimeToMilliseconds)(a) < o) break;
          this.endConsumerSpan(e.msg, null, s.EndOperation.InstrumentationTimeout, !0);
        }
        r.splice(0, t);
      }
    }
    n.AmqplibInstrumentation = d;
  },
  84420,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      (n.EndOperation = n.DEFAULT_CONFIG = n.AmqplibInstrumentation = void 0));
    var r = e.r(31985);
    Object.defineProperty(n, 'AmqplibInstrumentation', {
      enumerable: !0,
      get: function () {
        return r.AmqplibInstrumentation;
      },
    });
    var i = e.r(9277);
    (Object.defineProperty(n, 'DEFAULT_CONFIG', {
      enumerable: !0,
      get: function () {
        return i.DEFAULT_CONFIG;
      },
    }),
      Object.defineProperty(n, 'EndOperation', {
        enumerable: !0,
        get: function () {
          return i.EndOperation;
        },
      }));
  },
  63074,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(84420),
      i = e.r(48009),
      o = e.r(15527),
      a = 'Amqplib',
      s = {
        consumeEndHook: (e) => {
          o.addOriginToSpan(e, 'auto.amqplib.otel.consumer');
        },
        publishHook: (e) => {
          o.addOriginToSpan(e, 'auto.amqplib.otel.publisher');
        },
      },
      u = o.generateInstrumentOnce(a, () => new r.AmqplibInstrumentation(s));
    ((n.amqplibIntegration = i.defineIntegration(() => ({
      name: a,
      setupOnce() {
        u();
      },
    }))),
      (n.instrumentAmqplib = u));
  },
  52818,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.INTEGRATION_NAME = 'VercelAI'));
  },
  44601,
  (e, t, n) => {
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
    let r = e.r(75235),
      i = e.r(48009),
      o = e.r(52818),
      a = ['generateText', 'streamText', 'generateObject', 'streamObject', 'embed', 'embedMany'];
    function s(e, t, n, r) {
      return {
        recordInputs:
          e?.recordInputs !== void 0
            ? e.recordInputs
            : void 0 !== t.recordInputs
              ? t.recordInputs
              : !0 === n || r,
        recordOutputs:
          e?.recordOutputs !== void 0
            ? e.recordOutputs
            : void 0 !== t.recordOutputs
              ? t.recordOutputs
              : !0 === n || r,
      };
    }
    class u extends r.InstrumentationBase {
      __init() {
        this._isPatched = !1;
      }
      __init2() {
        this._callbacks = [];
      }
      constructor(e = {}) {
        (super('@sentry/instrumentation-vercel-ai', i.SDK_VERSION, e),
          u.prototype.__init.call(this),
          u.prototype.__init2.call(this));
      }
      init() {
        return new r.InstrumentationNodeModuleDefinition(
          'ai',
          ['>=3.0.0 <6'],
          this._patch.bind(this)
        );
      }
      callWhenPatched(e) {
        this._isPatched ? e() : this._callbacks.push(e);
      }
      _patch(e) {
        function t(e) {
          return (...t) => {
            let n = t[0].experimental_telemetry || {},
              r = n.isEnabled,
              a = i.getCurrentScope().getClient(),
              u = a?.getIntegrationByName(o.INTEGRATION_NAME),
              { recordInputs: l, recordOutputs: c } = s(
                u?.options,
                n,
                r,
                !!u && !!a?.getOptions().sendDefaultPii
              );
            return (
              (t[0].experimental_telemetry = {
                ...n,
                isEnabled: void 0 === r || r,
                recordInputs: l,
                recordOutputs: c,
              }),
              i.handleCallbackErrors(
                async () => {
                  let n = await e.apply(this, t);
                  return (
                    !(function (e) {
                      if (
                        'object' == typeof e &&
                        null !== e &&
                        'content' in e &&
                        Array.isArray(e.content)
                      ) {
                        for (let t of e.content)
                          if (
                            'object' == typeof t &&
                            null !== t &&
                            'type' in t &&
                            'error' in t &&
                            'toolName' in t &&
                            'toolCallId' in t &&
                            'tool-error' === t.type &&
                            t.error instanceof Error
                          ) {
                            let e = i._INTERNAL_getSpanForToolCallId(t.toolCallId);
                            if (e) {
                              let n = e.spanContext();
                              (i.withScope((e) => {
                                (e.setContext('trace', { trace_id: n.traceId, span_id: n.spanId }),
                                  e.setTag('vercel.ai.tool.name', t.toolName),
                                  e.setTag('vercel.ai.tool.callId', t.toolCallId),
                                  e.setLevel('error'),
                                  i.captureException(t.error, {
                                    mechanism: { type: 'auto.vercelai.otel', handled: !1 },
                                  }));
                              }),
                                i._INTERNAL_cleanupToolCallSpan(t.toolCallId));
                            } else
                              i.withScope((e) => {
                                (e.setTag('vercel.ai.tool.name', t.toolName),
                                  e.setTag('vercel.ai.tool.callId', t.toolCallId),
                                  e.setLevel('error'),
                                  i.captureException(t.error, {
                                    mechanism: { type: 'auto.vercelai.otel', handled: !1 },
                                  }));
                              });
                          }
                      }
                    })(n),
                    n
                  );
                },
                (e) => {
                  e &&
                    'object' == typeof e &&
                    i.addNonEnumerableProperty(e, '_sentry_active_span', i.getActiveSpan());
                }
              )
            );
          };
        }
        if (
          ((this._isPatched = !0),
          this._callbacks.forEach((e) => e()),
          (this._callbacks = []),
          '[object Module]' === Object.prototype.toString.call(e))
        ) {
          for (let n of a) e[n] = t(e[n]);
          return e;
        }
        {
          let n = a.reduce((n, r) => ((n[r] = t(e[r])), n), {});
          return { ...e, ...n };
        }
      }
    }
    ((n.SentryVercelAiInstrumentation = u), (n.determineRecordingSettings = s));
  },
  77055,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(15527),
      o = e.r(52818),
      a = e.r(44601),
      s = i.generateInstrumentOnce(
        o.INTEGRATION_NAME,
        () => new a.SentryVercelAiInstrumentation({})
      ),
      u = r.defineIntegration((e = {}) => {
        let t;
        return {
          name: o.INTEGRATION_NAME,
          options: e,
          setupOnce() {
            t = s();
          },
          afterAllSetup(n) {
            (e.force ??
            (function (e) {
              let t = e.getIntegrationByName('Modules');
              return !!t?.getModules?.()?.ai;
            })(n))
              ? r.addVercelAiProcessors(n)
              : t?.callWhenPatched(() => r.addVercelAiProcessors(n));
          },
        };
      });
    ((n.instrumentVercelAi = s), (n.vercelAIIntegration = u));
  },
  17748,
  (e, t, n) => {
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
    let r = e.r(75235),
      i = e.r(48009),
      o = ['>=4.0.0 <6'];
    class a extends r.InstrumentationBase {
      constructor(e = {}) {
        super('@sentry/instrumentation-openai', i.SDK_VERSION, e);
      }
      init() {
        return new r.InstrumentationNodeModuleDefinition('openai', o, this._patch.bind(this));
      }
      _patch(e) {
        let t = e.OpenAI,
          n = function (...e) {
            var n, r;
            let o = Reflect.construct(t, e),
              a = i.getCurrentScope().getClient(),
              s = a?.getIntegrationByName(i.OPENAI_INTEGRATION_NAME),
              { recordInputs: u, recordOutputs: l } =
                ((n = s?.options),
                (r = !!a?.getOptions().sendDefaultPii),
                { recordInputs: n?.recordInputs ?? r, recordOutputs: n?.recordOutputs ?? r });
            return i.instrumentOpenAiClient(o, { recordInputs: u, recordOutputs: l });
          };
        for (let e of (Object.setPrototypeOf(n, t),
        Object.setPrototypeOf(n.prototype, t.prototype),
        Object.getOwnPropertyNames(t)))
          if (!['length', 'name', 'prototype'].includes(e)) {
            let r = Object.getOwnPropertyDescriptor(t, e);
            r && Object.defineProperty(n, e, r);
          }
        try {
          e.OpenAI = n;
        } catch (t) {
          Object.defineProperty(e, 'OpenAI', {
            value: n,
            writable: !0,
            configurable: !0,
            enumerable: !0,
          });
        }
        if (e.default === t)
          try {
            e.default = n;
          } catch (t) {
            Object.defineProperty(e, 'default', {
              value: n,
              writable: !0,
              configurable: !0,
              enumerable: !0,
            });
          }
        return e;
      }
    }
    n.SentryOpenAiInstrumentation = a;
  },
  6684,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(15527),
      o = e.r(17748),
      a = i.generateInstrumentOnce(
        r.OPENAI_INTEGRATION_NAME,
        () => new o.SentryOpenAiInstrumentation({})
      ),
      s = r.defineIntegration((e = {}) => ({
        name: r.OPENAI_INTEGRATION_NAME,
        options: e,
        setupOnce() {
          a();
        },
      }));
    ((n.instrumentOpenAi = a), (n.openAIIntegration = s));
  },
  89677,
  (e, t, n) => {
    ((globalThis._sentryNextJsVersion = '15.5.2'),
      Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
    let r = e.r(75235),
      i = e.r(48009),
      o = ['>=0.19.2 <1.0.0'];
    class a extends r.InstrumentationBase {
      constructor(e = {}) {
        super('@sentry/instrumentation-anthropic-ai', i.SDK_VERSION, e);
      }
      init() {
        return new r.InstrumentationNodeModuleDefinition(
          '@anthropic-ai/sdk',
          o,
          this._patch.bind(this)
        );
      }
      _patch(e) {
        let t = e.Anthropic,
          n = function (...e) {
            var n, r;
            let o = Reflect.construct(t, e),
              a = i.getCurrentScope().getClient(),
              s = a?.getIntegrationByName(i.ANTHROPIC_AI_INTEGRATION_NAME),
              { recordInputs: u, recordOutputs: l } =
                ((n = s?.options),
                (r = !!a?.getOptions().sendDefaultPii),
                { recordInputs: n?.recordInputs ?? r, recordOutputs: n?.recordOutputs ?? r });
            return i.instrumentAnthropicAiClient(o, { recordInputs: u, recordOutputs: l });
          };
        for (let e of (Object.setPrototypeOf(n, t),
        Object.setPrototypeOf(n.prototype, t.prototype),
        Object.getOwnPropertyNames(t)))
          if (!['length', 'name', 'prototype'].includes(e)) {
            let r = Object.getOwnPropertyDescriptor(t, e);
            r && Object.defineProperty(n, e, r);
          }
        try {
          e.Anthropic = n;
        } catch (t) {
          Object.defineProperty(e, 'Anthropic', {
            value: n,
            writable: !0,
            configurable: !0,
            enumerable: !0,
          });
        }
        if (e.default === t)
          try {
            e.default = n;
          } catch (t) {
            Object.defineProperty(e, 'default', {
              value: n,
              writable: !0,
              configurable: !0,
              enumerable: !0,
            });
          }
        return e;
      }
    }
    n.SentryAnthropicAiInstrumentation = a;
  },
  37484,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(15527),
      o = e.r(89677),
      a = i.generateInstrumentOnce(
        r.ANTHROPIC_AI_INTEGRATION_NAME,
        () => new o.SentryAnthropicAiInstrumentation({})
      );
    ((n.anthropicAIIntegration = r.defineIntegration((e = {}) => ({
      name: r.ANTHROPIC_AI_INTEGRATION_NAME,
      options: e,
      setupOnce() {
        a();
      },
    }))),
      (n.instrumentAnthropicAi = a));
  },
  88743,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = r.defineIntegration(
        (e) => (
          r.isBrowser() ||
            r.consoleSandbox(() => {
              console.warn('The launchDarklyIntegration() can only be used in the browser.');
            }),
          { name: 'LaunchDarkly' }
        )
      );
    ((n.buildLaunchDarklyFlagUsedHandlerShim = function () {
      return (
        r.isBrowser() ||
          r.consoleSandbox(() => {
            console.warn('The buildLaunchDarklyFlagUsedHandler() can only be used in the browser.');
          }),
        { name: 'sentry-flag-auditor', type: 'flag-used', synchronous: !0, method: () => null }
      );
    }),
      (n.launchDarklyIntegrationShim = i));
  },
  62494,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = r.defineIntegration(
        (e) => (
          r.isBrowser() ||
            r.consoleSandbox(() => {
              console.warn('The openFeatureIntegration() can only be used in the browser.');
            }),
          { name: 'OpenFeature' }
        )
      );
    ((n.OpenFeatureIntegrationHookShim = class {
      constructor() {
        r.isBrowser() ||
          r.consoleSandbox(() => {
            console.warn('The OpenFeatureIntegrationHook can only be used in the browser.');
          });
      }
      after() {}
      error() {}
    }),
      (n.openFeatureIntegrationShim = i));
  },
  99230,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.statsigIntegrationShim = r.defineIntegration(
      (e) => (
        r.isBrowser() ||
          r.consoleSandbox(() => {
            console.warn('The statsigIntegration() can only be used in the browser.');
          }),
        { name: 'Statsig' }
      )
    );
  },
  34834,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.unleashIntegrationShim = r.defineIntegration(
      (e) => (
        r.isBrowser() ||
          r.consoleSandbox(() => {
            console.warn('The unleashIntegration() can only be used in the browser.');
          }),
        { name: 'Unleash' }
      )
    );
  },
  6519,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(61095),
      i = e.r(52305),
      o = e.r(75235),
      a = e.r(81964);
    function s(e, t, n, r, i) {
      var o, a, s, d, p, _, S, E;
      return (
        u(e, n),
        t(
          e,
          'addDoc',
          ((o = r),
          (a = i),
          function (e) {
            return function (t, n) {
              let r = c(o, 'addDoc', t);
              return (a(r), l(r, () => e(t, n)));
            };
          })
        ),
        t(
          e,
          'getDocs',
          ((s = r),
          (d = i),
          function (e) {
            return function (t) {
              let n = c(s, 'getDocs', t);
              return (d(n), l(n, () => e(t)));
            };
          })
        ),
        t(
          e,
          'setDoc',
          ((p = r),
          (_ = i),
          function (e) {
            return function (t, n, r) {
              let i = c(p, 'setDoc', t.parent || t);
              return (_(i), l(i, () => (void 0 !== r ? e(t, n, r) : e(t, n))));
            };
          })
        ),
        t(
          e,
          'deleteDoc',
          ((S = r),
          (E = i),
          function (e) {
            return function (t) {
              let n = c(S, 'deleteDoc', t.parent || t);
              return (E(n), l(n, () => e(t)));
            };
          })
        ),
        e
      );
    }
    function u(e, t) {
      for (let n of ['addDoc', 'getDocs', 'setDoc', 'deleteDoc']) o.isWrapped(e[n]) && t(e, n);
      return e;
    }
    function l(e, t) {
      return i.context.with(i.trace.setSpan(i.context.active(), e), () =>
        o.safeExecuteInTheMiddle(
          () => t(),
          (t) => {
            (t && e.recordException(t), e.end());
          },
          !0
        )
      );
    }
    function c(e, t, n) {
      let r = e.startSpan(`${t} ${n.path}`, { kind: i.SpanKind.CLIENT });
      return (
        (function (e, t) {
          let n = t.firestore.app,
            r = n.options,
            i = (t.firestore.toJSON() || {}).settings || {},
            o = {
              [a.ATTR_DB_COLLECTION_NAME]: t.path,
              [a.ATTR_DB_NAMESPACE]: n.name,
              [a.ATTR_DB_SYSTEM_NAME]: 'firebase.firestore',
              'firebase.firestore.type': t.type,
              'firebase.firestore.options.projectId': r.projectId,
              'firebase.firestore.options.appId': r.appId,
              'firebase.firestore.options.messagingSenderId': r.messagingSenderId,
              'firebase.firestore.options.storageBucket': r.storageBucket,
            },
            { address: s, port: u } = d(i);
          (s && (o[a.ATTR_SERVER_ADDRESS] = s),
            u && (o[a.ATTR_SERVER_PORT] = u),
            e.setAttributes(o));
        })(r, n),
        r.setAttribute(a.ATTR_DB_OPERATION_NAME, t),
        r
      );
    }
    function d(e) {
      let t, n;
      if ('string' == typeof e.host)
        if (e.host.startsWith('[')) {
          if (e.host.endsWith(']')) t = e.host.replace(/^\[|\]$/g, '');
          else if (e.host.includes(']:')) {
            let r = e.host.lastIndexOf(':');
            -1 !== r &&
              ((t = e.host.slice(1, r).replace(/^\[|\]$/g, '')), (n = e.host.slice(r + 1)));
          }
        } else if (r.isIPv6(e.host)) t = e.host;
        else {
          let r = e.host.lastIndexOf(':');
          -1 !== r ? ((t = e.host.slice(0, r)), (n = e.host.slice(r + 1))) : (t = e.host);
        }
      return { address: t, port: n ? parseInt(n, 10) : void 0 };
    }
    ((n.getPortAndAddress = d),
      (n.patchFirestore = function (e, t, n, r, a) {
        let l = () => {},
          c = a.firestoreSpanCreationHook;
        'function' == typeof c &&
          (l = (e) => {
            o.safeExecuteInTheMiddle(
              () => c(e),
              (e) => {
                e && i.diag.error(e?.message);
              },
              !0
            );
          });
        let d = new o.InstrumentationNodeModuleDefinition('@firebase/firestore', t, (t) =>
          s(t, n, r, e, l)
        );
        for (let i of [
          '@firebase/firestore/dist/lite/index.node.cjs.js',
          '@firebase/firestore/dist/lite/index.node.mjs.js',
          '@firebase/firestore/dist/lite/index.rn.esm2017.js',
          '@firebase/firestore/dist/lite/index.cjs.js',
        ])
          d.files.push(
            new o.InstrumentationNodeModuleFile(
              i,
              t,
              (t) => s(t, n, r, e, l),
              (e) => u(e, r)
            )
          );
        return d;
      }));
  },
  11741,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(75235),
      i = e.r(48009),
      o = e.r(6519),
      a = {},
      s = ['>=3.0.0 <5'];
    class u extends r.InstrumentationBase {
      constructor(e = a) {
        super('@sentry/instrumentation-firebase', i.SDK_VERSION, e);
      }
      setConfig(e = {}) {
        super.setConfig({ ...a, ...e });
      }
      init() {
        let e = [];
        return (
          e.push(o.patchFirestore(this.tracer, s, this._wrap, this._unwrap, this.getConfig())),
          e
        );
      }
    }
    n.FirebaseInstrumentation = u;
  },
  92020,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(15527),
      o = e.r(11741),
      a = 'Firebase',
      s = {
        firestoreSpanCreationHook: (e) => {
          (i.addOriginToSpan(e, 'auto.firebase.otel.firestore'),
            e.setAttribute(r.SEMANTIC_ATTRIBUTE_SENTRY_OP, 'db.query'));
        },
      },
      u = i.generateInstrumentOnce(a, () => new o.FirebaseInstrumentation(s));
    ((n.firebaseIntegration = r.defineIntegration(() => ({
      name: a,
      setupOnce() {
        u();
      },
    }))),
      (n.instrumentFirebase = u));
  },
  77825,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23569),
      i = e.r(63074),
      o = e.r(37484),
      a = e.r(60467),
      s = e.r(50219),
      u = e.r(29482),
      l = e.r(92020),
      c = e.r(80190),
      d = e.r(9832),
      p = e.r(88441),
      _ = e.r(43523),
      S = e.r(82306),
      E = e.r(54688),
      T = e.r(65441),
      m = e.r(25332),
      g = e.r(46988),
      f = e.r(63268),
      h = e.r(6684),
      A = e.r(75094),
      R = e.r(91480),
      y = e.r(72874),
      I = e.r(20176),
      b = e.r(10878),
      N = e.r(77055);
    ((n.getAutoPerformanceIntegrations = function () {
      return [
        s.expressIntegration(),
        u.fastifyIntegration(),
        d.graphqlIntegration(),
        T.mongoIntegration(),
        m.mongooseIntegration(),
        g.mysqlIntegration(),
        f.mysql2Integration(),
        I.redisIntegration(),
        A.postgresIntegration(),
        y.prismaIntegration(),
        p.hapiIntegration(),
        S.koaIntegration(),
        a.connectIntegration(),
        b.tediousIntegration(),
        c.genericPoolIntegration(),
        _.kafkaIntegration(),
        i.amqplibIntegration(),
        E.lruMemoizerIntegration(),
        N.vercelAIIntegration(),
        h.openAIIntegration(),
        R.postgresJsIntegration(),
        l.firebaseIntegration(),
        o.anthropicAIIntegration(),
      ];
    }),
      (n.getOpenTelemetryInstrumentationToPreload = function () {
        return [
          r.instrumentSentryHttp,
          r.instrumentOtelHttp,
          s.instrumentExpress,
          a.instrumentConnect,
          u.instrumentFastify,
          u.instrumentFastifyV3,
          p.instrumentHapi,
          _.instrumentKafka,
          S.instrumentKoa,
          E.instrumentLruMemoizer,
          T.instrumentMongo,
          m.instrumentMongoose,
          g.instrumentMysql,
          f.instrumentMysql2,
          A.instrumentPostgres,
          p.instrumentHapi,
          d.instrumentGraphql,
          I.instrumentRedis,
          b.instrumentTedious,
          c.instrumentGenericPool,
          i.instrumentAmqplib,
          N.instrumentVercelAi,
          h.instrumentOpenAi,
          R.instrumentPostgresJs,
          l.instrumentFirebase,
          o.instrumentAnthropicAi,
        ];
      }));
  },
  81289,
  (e) => {
    'use strict';
    let t;
    (e.s(
      [
        'defaultResource',
        () => m.defaultResource,
        'defaultServiceName',
        () => g.defaultServiceName,
        'detectResources',
        () => i,
        'emptyResource',
        () => m.emptyResource,
        'envDetector',
        () => u,
        'hostDetector',
        () => p,
        'osDetector',
        () => _,
        'processDetector',
        () => S,
        'resourceFromAttributes',
        () => m.resourceFromAttributes,
        'serviceInstanceIdDetector',
        () => T,
      ],
      81289
    ),
      e.s([], 81353),
      e.i(81353));
    var n = e.i(43170),
      r = e.i(31588);
    let i = (e = {}) =>
      (e.detectors || [])
        .map((t) => {
          try {
            let i = (0, r.resourceFromDetectedResource)(t.detect(e));
            return (n.diag.debug(`${t.constructor.name} found resource.`, i), i);
          } catch (e) {
            return (
              n.diag.debug(`${t.constructor.name} failed: ${e.message}`),
              (0, r.emptyResource)()
            );
          }
        })
        .reduce((e, t) => e.merge(t), (0, r.emptyResource)());
    var o = e.i(1709),
      a = e.i(60531);
    class s {
      _MAX_LENGTH = 255;
      _COMMA_SEPARATOR = ',';
      _LABEL_KEY_VALUE_SPLITTER = '=';
      _ERROR_MESSAGE_INVALID_CHARS =
        'should be a ASCII string with a length greater than 0 and not exceed ' +
        this._MAX_LENGTH +
        ' characters.';
      _ERROR_MESSAGE_INVALID_VALUE =
        'should be a ASCII string with a length not exceed ' + this._MAX_LENGTH + ' characters.';
      detect(e) {
        let t = {},
          r = (0, a.getStringFromEnv)('OTEL_RESOURCE_ATTRIBUTES'),
          i = (0, a.getStringFromEnv)('OTEL_SERVICE_NAME');
        if (r)
          try {
            let e = this._parseResourceAttributes(r);
            Object.assign(t, e);
          } catch (e) {
            n.diag.debug(`EnvDetector failed: ${e.message}`);
          }
        return (i && (t[o.ATTR_SERVICE_NAME] = i), { attributes: t });
      }
      _parseResourceAttributes(e) {
        if (!e) return {};
        let t = {};
        for (let n of e.split(this._COMMA_SEPARATOR, -1)) {
          let e = n.split(this._LABEL_KEY_VALUE_SPLITTER, -1);
          if (2 !== e.length) continue;
          let [r, i] = e;
          if (
            ((r = r.trim()), (i = i.trim().split(/^"|"$/).join('')), !this._isValidAndNotEmpty(r))
          )
            throw Error(`Attribute key ${this._ERROR_MESSAGE_INVALID_CHARS}`);
          if (!this._isValid(i))
            throw Error(`Attribute value ${this._ERROR_MESSAGE_INVALID_VALUE}`);
          t[r] = decodeURIComponent(i);
        }
        return t;
      }
      _isValid(e) {
        return e.length <= this._MAX_LENGTH && this._isBaggageOctetString(e);
      }
      _isBaggageOctetString(e) {
        for (let t = 0; t < e.length; t++) {
          let n = e.charCodeAt(t);
          if (n < 33 || 44 === n || 59 === n || 92 === n || n > 126) return !1;
        }
        return !0;
      }
      _isValidAndNotEmpty(e) {
        return e.length > 0 && this._isValid(e);
      }
    }
    let u = new s();
    var l = e.i(46786),
      c = e.i(5365);
    async function d() {
      if (!t)
        switch (c.platform) {
          case 'darwin':
            t = (await e.A(48135)).getMachineId;
            break;
          case 'linux':
            t = (await e.A(14337)).getMachineId;
            break;
          case 'freebsd':
            t = (await e.A(15385)).getMachineId;
            break;
          case 'win32':
            t = (await e.A(23242)).getMachineId;
            break;
          default:
            t = (await e.A(38996)).getMachineId;
        }
      return t();
    }
    let p = new (class {
        detect(e) {
          return {
            attributes: {
              'host.name': (0, l.hostname)(),
              'host.arch': ((e) => {
                switch (e) {
                  case 'arm':
                    return 'arm32';
                  case 'ppc':
                    return 'ppc32';
                  case 'x64':
                    return 'amd64';
                  default:
                    return e;
                }
              })((0, l.arch)()),
              'host.id': d(),
            },
          };
        }
      })(),
      _ = new (class {
        detect(e) {
          return {
            attributes: {
              'os.type': ((e) => {
                switch (e) {
                  case 'sunos':
                    return 'solaris';
                  case 'win32':
                    return 'windows';
                  default:
                    return e;
                }
              })((0, l.platform)()),
              'os.version': (0, l.release)(),
            },
          };
        }
      })(),
      S = new (class {
        detect(e) {
          let t = {
            'process.pid': process.pid,
            'process.executable.name': process.title,
            'process.executable.path': process.execPath,
            'process.command_args': [
              process.argv[0],
              ...process.execArgv,
              ...process.argv.slice(1),
            ],
            'process.runtime.version': process.versions.node,
            'process.runtime.name': 'nodejs',
            'process.runtime.description': 'Node.js',
          };
          process.argv.length > 1 && (t['process.command'] = process.argv[1]);
          try {
            let e = l.userInfo();
            t['process.owner'] = e.username;
          } catch (e) {
            n.diag.debug(`error obtaining process owner: ${e}`);
          }
          return { attributes: t };
        }
      })();
    var E = e.i(54799);
    let T = new (class {
      detect(e) {
        return { attributes: { 'service.instance.id': (0, E.randomUUID)() } };
      }
    })();
    var m = r,
      g = e.i(73078);
  },
  30501,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(81289),
      o = e.r(18271),
      a = e.r(81964),
      s = e.r(48009),
      u = e.r(15527),
      l = e.r(52780),
      c = e.r(85397),
      d = e.r(62562),
      p = e.r(59589),
      _ = e.r(77825);
    var S = 'undefined' != typeof document ? document.currentScript : null;
    function E() {
      let [t = 0, n = 0] = process.versions.node.split('.').map(Number);
      if (t >= 21 || (20 === t && n >= 6) || (18 === t && n >= 19)) {
        if (!s.GLOBAL_OBJ._sentryEsmLoaderHookRegistered)
          try {
            let { addHookMessagePort: t } = c.createAddHookMessageChannel();
            d.default.register(
              'import-in-the-middle/hook.mjs',
              'undefined' == typeof document
                ? e
                    .r(92509)
                    .pathToFileURL(
                      '/ROOT/node_modules/.pnpm/@sentry+node@10.10.0/node_modules/@sentry/node/build/cjs/sdk/initOtel.js'
                    ).href
                : (S && 'SCRIPT' === S.tagName.toUpperCase() && S.src) ||
                    new URL('sdk/initOtel.js', document.baseURI).href,
              { data: { addHookMessagePort: t, include: [] }, transferList: [t] }
            );
          } catch (e) {
            s.debug.warn('Failed to register ESM hook', e);
          }
      } else
        s.consoleSandbox(() => {
          console.warn(
            `[Sentry] You are using Node.js v${process.versions.node} in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or upgrade your Node.js version.`
          );
        });
    }
    function T(e, t = {}) {
      let n = new o.BasicTracerProvider({
        sampler: new l.SentrySampler(e),
        resource: i
          .defaultResource()
          .merge(
            i.resourceFromAttributes({
              [a.ATTR_SERVICE_NAME]: 'node',
              [a.SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
              [a.ATTR_SERVICE_VERSION]: s.SDK_VERSION,
            })
          ),
        forceFlushTimeoutMillis: 500,
        spanProcessors: [
          new l.SentrySpanProcessor({ timeout: m(e.getOptions().maxSpanWaitDuration) }),
          ...(t.spanProcessors || []),
        ],
      });
      return (
        r.trace.setGlobalTracerProvider(n),
        r.propagation.setGlobalPropagator(new l.SentryPropagator()),
        r.context.setGlobalContextManager(new u.SentryContextManager()),
        n
      );
    }
    function m(e) {
      if (null != e) {
        if (e > 1e6)
          return (
            p.DEBUG_BUILD &&
              s.debug.warn('`maxSpanWaitDuration` is too high, using the maximum value of 1000000'),
            1e6
          );
        if (e <= 0 || Number.isNaN(e)) {
          p.DEBUG_BUILD &&
            s.debug.warn(
              '`maxSpanWaitDuration` must be a positive number, using default value instead.'
            );
          return;
        }
        return e;
      }
    }
    ((n._clampSpanProcessorTimeout = m),
      (n.initOpenTelemetry = function (e, t = {}) {
        e.getOptions().debug && u.setupOpenTelemetryLogger();
        let n = T(e, t);
        e.traceProvider = n;
      }),
      (n.maybeInitializeEsmLoader = E),
      (n.preloadOpenTelemetry = function (e = {}) {
        let { debug: t } = e;
        (t && s.debug.enable(),
          u.isCjs() || E(),
          (function (e) {
            let t = _.getOpenTelemetryInstrumentationToPreload();
            return e
              ? t.filter((t) => {
                  let n = t.id;
                  return e.some((e) => n === e || n.startsWith(`${e}.`));
                })
              : t;
          })(e.integrations).forEach((e) => {
            (e(), t && s.debug.log(`[Sentry] Preloaded ${e.id} instrumentation`));
          }));
      }),
      (n.setupOtel = T));
  },
  78269,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(15527),
      o = e.r(23569),
      a = e.r(45750),
      s = e.r(77825),
      u = e.r(30501);
    function l() {
      return i
        .getDefaultIntegrations()
        .filter((e) => 'Http' !== e.name && 'NodeFetch' !== e.name)
        .concat(o.httpIntegration(), a.nativeNodeFetchIntegration());
    }
    function c(e) {
      return [...l(), ...(r.hasSpansEnabled(e) ? s.getAutoPerformanceIntegrations() : [])];
    }
    function d(e = {}, t) {
      r.applySdkMetadata(e, 'node');
      let n = i.init({ ...e, defaultIntegrations: e.defaultIntegrations ?? t(e) });
      return (
        n &&
          !e.skipOpenTelemetrySetup &&
          (u.initOpenTelemetry(n, { spanProcessors: e.openTelemetrySpanProcessors }),
          i.validateOpenTelemetrySetup()),
        n
      );
    }
    ((n.getDefaultIntegrations = c),
      (n.getDefaultIntegrationsWithoutPerformance = l),
      (n.init = function (e = {}) {
        return d(e, c);
      }),
      (n.initWithoutDefaultIntegrations = function (e = {}) {
        return d(e, () => []);
      }));
  },
  9152,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(23569),
      i = e.r(45750),
      o = e.r(64631),
      a = e.r(50219),
      s = e.r(29482),
      u = e.r(9832),
      l = e.r(43523),
      c = e.r(54688),
      d = e.r(65441),
      p = e.r(25332),
      _ = e.r(46988),
      S = e.r(63268),
      E = e.r(20176),
      T = e.r(75094),
      m = e.r(91480),
      g = e.r(72874),
      f = e.r(88441),
      h = e.r(82306),
      A = e.r(60467),
      R = e.r(71761),
      y = e.r(10878),
      I = e.r(80190),
      b = e.r(41100),
      N = e.r(63074),
      O = e.r(77055),
      v = e.r(6684),
      C = e.r(37484),
      P = e.r(88743),
      M = e.r(62494),
      L = e.r(99230),
      U = e.r(34834),
      D = e.r(92020),
      x = e.r(78269),
      w = e.r(30501),
      k = e.r(77825),
      G = e.r(52780),
      V = e.r(48009),
      $ = e.r(15527);
    ((n.httpIntegration = r.httpIntegration),
      (n.nativeNodeFetchIntegration = i.nativeNodeFetchIntegration),
      (n.fsIntegration = o.fsIntegration),
      (n.expressErrorHandler = a.expressErrorHandler),
      (n.expressIntegration = a.expressIntegration),
      (n.setupExpressErrorHandler = a.setupExpressErrorHandler),
      (n.fastifyIntegration = s.fastifyIntegration),
      (n.setupFastifyErrorHandler = s.setupFastifyErrorHandler),
      (n.graphqlIntegration = u.graphqlIntegration),
      (n.kafkaIntegration = l.kafkaIntegration),
      (n.lruMemoizerIntegration = c.lruMemoizerIntegration),
      (n.mongoIntegration = d.mongoIntegration),
      (n.mongooseIntegration = p.mongooseIntegration),
      (n.mysqlIntegration = _.mysqlIntegration),
      (n.mysql2Integration = S.mysql2Integration),
      (n.redisIntegration = E.redisIntegration),
      (n.postgresIntegration = T.postgresIntegration),
      (n.postgresJsIntegration = m.postgresJsIntegration),
      (n.prismaIntegration = g.prismaIntegration),
      (n.hapiIntegration = f.hapiIntegration),
      (n.setupHapiErrorHandler = f.setupHapiErrorHandler),
      (n.koaIntegration = h.koaIntegration),
      (n.setupKoaErrorHandler = h.setupKoaErrorHandler),
      (n.connectIntegration = A.connectIntegration),
      (n.setupConnectErrorHandler = A.setupConnectErrorHandler),
      (n.knexIntegration = R.knexIntegration),
      (n.tediousIntegration = y.tediousIntegration),
      (n.genericPoolIntegration = I.genericPoolIntegration),
      (n.dataloaderIntegration = b.dataloaderIntegration),
      (n.amqplibIntegration = N.amqplibIntegration),
      (n.vercelAIIntegration = O.vercelAIIntegration),
      (n.openAIIntegration = v.openAIIntegration),
      (n.anthropicAIIntegration = C.anthropicAIIntegration),
      (n.buildLaunchDarklyFlagUsedHandler = P.buildLaunchDarklyFlagUsedHandlerShim),
      (n.launchDarklyIntegration = P.launchDarklyIntegrationShim),
      (n.OpenFeatureIntegrationHook = M.OpenFeatureIntegrationHookShim),
      (n.openFeatureIntegration = M.openFeatureIntegrationShim),
      (n.statsigIntegration = L.statsigIntegrationShim),
      (n.unleashIntegration = U.unleashIntegrationShim),
      (n.firebaseIntegration = D.firebaseIntegration),
      (n.getDefaultIntegrations = x.getDefaultIntegrations),
      (n.getDefaultIntegrationsWithoutPerformance = x.getDefaultIntegrationsWithoutPerformance),
      (n.init = x.init),
      (n.initWithoutDefaultIntegrations = x.initWithoutDefaultIntegrations),
      (n.initOpenTelemetry = w.initOpenTelemetry),
      (n.preloadOpenTelemetry = w.preloadOpenTelemetry),
      (n.getAutoPerformanceIntegrations = k.getAutoPerformanceIntegrations),
      (n.setNodeAsyncContextStrategy = G.setOpenTelemetryContextAsyncContextStrategy),
      (n.SDK_VERSION = V.SDK_VERSION),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_OP = V.SEMANTIC_ATTRIBUTE_SENTRY_OP),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = V.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = V.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE),
      (n.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = V.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE),
      (n.Scope = V.Scope),
      (n.addBreadcrumb = V.addBreadcrumb),
      (n.addEventProcessor = V.addEventProcessor),
      (n.addIntegration = V.addIntegration),
      (n.captureCheckIn = V.captureCheckIn),
      (n.captureConsoleIntegration = V.captureConsoleIntegration),
      (n.captureEvent = V.captureEvent),
      (n.captureException = V.captureException),
      (n.captureFeedback = V.captureFeedback),
      (n.captureMessage = V.captureMessage),
      (n.captureSession = V.captureSession),
      (n.close = V.close),
      (n.consoleIntegration = V.consoleIntegration),
      (n.consoleLoggingIntegration = V.consoleLoggingIntegration),
      (n.continueTrace = V.continueTrace),
      (n.createTransport = V.createTransport),
      (n.dedupeIntegration = V.dedupeIntegration),
      (n.endSession = V.endSession),
      (n.eventFiltersIntegration = V.eventFiltersIntegration),
      (n.extraErrorDataIntegration = V.extraErrorDataIntegration),
      (n.featureFlagsIntegration = V.featureFlagsIntegration),
      (n.flush = V.flush),
      (n.functionToStringIntegration = V.functionToStringIntegration),
      (n.getActiveSpan = V.getActiveSpan),
      (n.getClient = V.getClient),
      (n.getCurrentScope = V.getCurrentScope),
      (n.getGlobalScope = V.getGlobalScope),
      (n.getIsolationScope = V.getIsolationScope),
      (n.getRootSpan = V.getRootSpan),
      (n.getSpanDescendants = V.getSpanDescendants),
      (n.getSpanStatusFromHttpCode = V.getSpanStatusFromHttpCode),
      (n.getTraceData = V.getTraceData),
      (n.getTraceMetaTags = V.getTraceMetaTags),
      (n.inboundFiltersIntegration = V.inboundFiltersIntegration),
      (n.instrumentSupabaseClient = V.instrumentSupabaseClient),
      (n.isEnabled = V.isEnabled),
      (n.isInitialized = V.isInitialized),
      (n.lastEventId = V.lastEventId),
      (n.linkedErrorsIntegration = V.linkedErrorsIntegration),
      (n.parameterize = V.parameterize),
      (n.profiler = V.profiler),
      (n.requestDataIntegration = V.requestDataIntegration),
      (n.rewriteFramesIntegration = V.rewriteFramesIntegration),
      (n.setContext = V.setContext),
      (n.setCurrentClient = V.setCurrentClient),
      (n.setExtra = V.setExtra),
      (n.setExtras = V.setExtras),
      (n.setHttpStatus = V.setHttpStatus),
      (n.setMeasurement = V.setMeasurement),
      (n.setTag = V.setTag),
      (n.setTags = V.setTags),
      (n.setUser = V.setUser),
      (n.spanToBaggageHeader = V.spanToBaggageHeader),
      (n.spanToJSON = V.spanToJSON),
      (n.spanToTraceHeader = V.spanToTraceHeader),
      (n.startInactiveSpan = V.startInactiveSpan),
      (n.startNewTrace = V.startNewTrace),
      (n.startSession = V.startSession),
      (n.startSpan = V.startSpan),
      (n.startSpanManual = V.startSpanManual),
      (n.supabaseIntegration = V.supabaseIntegration),
      (n.suppressTracing = V.suppressTracing),
      (n.trpcMiddleware = V.trpcMiddleware),
      (n.updateSpanName = V.updateSpanName),
      (n.withActiveSpan = V.withActiveSpan),
      (n.withIsolationScope = V.withIsolationScope),
      (n.withMonitor = V.withMonitor),
      (n.withScope = V.withScope),
      (n.wrapMcpServerWithSentry = V.wrapMcpServerWithSentry),
      (n.zodErrorsIntegration = V.zodErrorsIntegration),
      (n.NODE_VERSION = $.NODE_VERSION),
      (n.NodeClient = $.NodeClient),
      (n.SentryContextManager = $.SentryContextManager),
      (n.anrIntegration = $.anrIntegration),
      (n.childProcessIntegration = $.childProcessIntegration),
      (n.contextLinesIntegration = $.contextLinesIntegration),
      (n.createGetModuleFromFilename = $.createGetModuleFromFilename),
      (n.createSentryWinstonTransport = $.createSentryWinstonTransport),
      (n.cron = $.cron),
      (n.defaultStackParser = $.defaultStackParser),
      (n.disableAnrDetectionForCallback = $.disableAnrDetectionForCallback),
      (n.generateInstrumentOnce = $.generateInstrumentOnce),
      (n.getSentryRelease = $.getSentryRelease),
      (n.localVariablesIntegration = $.localVariablesIntegration),
      (n.logger = $.logger),
      (n.makeNodeTransport = $.makeNodeTransport),
      (n.modulesIntegration = $.modulesIntegration),
      (n.nodeContextIntegration = $.nodeContextIntegration),
      (n.onUncaughtExceptionIntegration = $.onUncaughtExceptionIntegration),
      (n.onUnhandledRejectionIntegration = $.onUnhandledRejectionIntegration),
      (n.spotlightIntegration = $.spotlightIntegration),
      (n.systemErrorIntegration = $.systemErrorIntegration),
      (n.validateOpenTelemetrySetup = $.validateOpenTelemetrySetup));
  },
  58551,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(14747);
    n.getBuildPluginOptions = function ({
      sentryBuildOptions: e,
      releaseName: t,
      distDirAbsPath: n,
    }) {
      let i = [],
        o = [],
        a = n.replace(/\\/g, '/');
      return (
        i.push(r.posix.join(a, '**')),
        e.sourcemaps?.deleteSourcemapsAfterUpload &&
          o.push(
            r.posix.join(a, '**', '*.js.map'),
            r.posix.join(a, '**', '*.mjs.map'),
            r.posix.join(a, '**', '*.cjs.map')
          ),
        {
          authToken: e.authToken,
          headers: e.headers,
          org: e.org,
          project: e.project,
          telemetry: e.telemetry,
          debug: e.debug,
          errorHandler: e.errorHandler,
          reactComponentAnnotation: {
            ...e.reactComponentAnnotation,
            ...e.unstable_sentryWebpackPluginOptions?.reactComponentAnnotation,
          },
          silent: e.silent,
          url: e.sentryUrl,
          sourcemaps: {
            disable: e.sourcemaps?.disable,
            rewriteSources: (e) =>
              e.startsWith('webpack://_N_E/')
                ? e.replace('webpack://_N_E/', '')
                : e.startsWith('webpack://')
                  ? e.replace('webpack://', '')
                  : e,
            assets: e.sourcemaps?.assets ?? i,
            ignore: e.sourcemaps?.ignore ?? [],
            filesToDeleteAfterUpload: o,
            ...e.unstable_sentryWebpackPluginOptions?.sourcemaps,
          },
          release:
            void 0 !== t
              ? {
                  inject: !1,
                  name: t,
                  create: e.release?.create,
                  finalize: e.release?.finalize,
                  dist: e.release?.dist,
                  vcsRemote: e.release?.vcsRemote,
                  setCommits: e.release?.setCommits,
                  deploy: e.release?.deploy,
                  ...e.unstable_sentryWebpackPluginOptions?.release,
                }
              : { inject: !1, create: !1, finalize: !1 },
          bundleSizeOptimizations: { ...e.bundleSizeOptimizations },
          _metaOptions: {
            loggerPrefixOverride: '[@sentry/nextjs]',
            telemetry: { metaFramework: 'nextjs' },
          },
          ...e.unstable_sentryWebpackPluginOptions,
        }
      );
    };
  },
  65260,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(58551);
    n.handleRunAfterProductionCompile = async function (
      { releaseName: e, distDir: n, buildTool: o },
      a
    ) {
      if ('webpack' === o) return;
      a.debug && console.debug('[@sentry/nextjs] Running runAfterProductionCompile logic.');
      let { createSentryBuildPluginManager: s } =
        r.loadModule('@sentry/bundler-plugin-core', t) ?? {};
      if (!s)
        return void console.warn(
          '[@sentry/nextjs] Could not load build manager package. Will not run runAfterProductionCompile logic.'
        );
      let u = s(
        i.getBuildPluginOptions({ sentryBuildOptions: a, releaseName: e, distDirAbsPath: n }),
        { buildTool: o, loggerPrefix: '[@sentry/nextjs]' }
      );
      (await u.telemetry.emitBundlerPluginExecutionSignal(),
        await u.createRelease(),
        await u.injectDebugIds([n]),
        await u.uploadSourcemaps([n], { prepareArtifacts: !1 }),
        await u.deleteArtifacts());
    };
  },
  10222,
  (e, t, n) => {
    let r;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let i = e.r(22734),
      o = e.r(14747),
      a = null,
      s = null;
    n.createRouteManifest = function (e) {
      let t;
      {
        let e = process.cwd(),
          n = o.join(e, 'app'),
          r = o.join(e, 'src', 'app');
        i.existsSync(n) && i.lstatSync(n).isDirectory()
          ? (t = n)
          : i.existsSync(r) && i.lstatSync(r).isDirectory() && (t = r);
      }
      if (!t) return { dynamicRoutes: [], staticRoutes: [] };
      if (a && s === t && r === e?.includeRouteGroups) return a;
      let { dynamicRoutes: n, staticRoutes: u } = (function e(t, n = '', r = !1) {
          let a = [],
            s = [];
          try {
            let l = i.readdirSync(t, { withFileTypes: !0 });
            if (
              l.some((e) => {
                var t;
                return (
                  (t = e.name),
                  'page.tsx' === t || 'page.jsx' === t || 'page.ts' === t || 'page.js' === t
                );
              })
            ) {
              let e = r ? n || '/' : (n || '/').replace(/\/\([^)]+\)/g, '');
              if (e.includes(':')) {
                let { regex: t, paramNames: n } = (function (e) {
                  let t,
                    n = e.split('/').filter(Boolean),
                    r = [],
                    i = [],
                    o = !1;
                  for (let e of n)
                    if (e.startsWith(':')) {
                      let t = e.substring(1);
                      if (t.endsWith('*?')) {
                        let e = t.slice(0, -2);
                        (i.push(e), (o = !0));
                      } else if (t.endsWith('*')) {
                        let e = t.slice(0, -1);
                        (i.push(e), r.push('(.+)'));
                      } else (i.push(t), r.push('([^/]+)'));
                    } else r.push(e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
                  if (o)
                    if (0 === r.length) t = '^/(.*)$';
                    else {
                      let e = r.join('/');
                      t = `^/${e}(?:/(.*))?$`;
                    }
                  else t = `^/${r.join('/')}$`;
                  return { regex: t, paramNames: i };
                })(e);
                a.push({ path: e, regex: t, paramNames: n });
              } else s.push({ path: e });
            }
            for (let i of l)
              if (i.isDirectory()) {
                var u;
                let l,
                  c = o.join(t, i.name),
                  d = i.name.startsWith('[') && i.name.endsWith(']'),
                  p = (l =
                    (u = i.name).startsWith('(') && u.endsWith(')')
                      ? r
                        ? i.name
                        : ''
                      : d
                        ? (function (e) {
                            if (e.startsWith('[[...') && e.endsWith(']]')) {
                              let t = e.slice(5, -2);
                              return `:${t}*?`;
                            }
                            if (e.startsWith('[...') && e.endsWith(']')) {
                              let t = e.slice(4, -1);
                              return `:${t}*`;
                            }
                            return `:${e.slice(1, -1)}`;
                          })(i.name)
                        : i.name)
                    ? `${n}/${l}`
                    : n,
                  _ = e(c, p, r);
                (a.push(..._.dynamicRoutes), s.push(..._.staticRoutes));
              }
          } catch (e) {
            console.warn('Error building route manifest:', e);
          }
          return { dynamicRoutes: a, staticRoutes: s };
        })(t, '', e?.includeRouteGroups),
        l = { dynamicRoutes: n, staticRoutes: u };
      return ((a = l), (s = t), (r = e?.includeRouteGroups), l);
    };
  },
  39160,
  (e, t, n) => {
    'use strict';
    let r =
        /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
      i = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,
      o = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,
      a = /\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi,
      s = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '	'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', '\x1b'],
        ['a', '\x07'],
      ]);
    function u(e) {
      let t = 'u' === e[0],
        n = '{' === e[1];
      return (t && !n && 5 === e.length) || ('x' === e[0] && 3 === e.length)
        ? String.fromCharCode(parseInt(e.slice(1), 16))
        : t && n
          ? String.fromCodePoint(parseInt(e.slice(2, -1), 16))
          : s.get(e) || e;
    }
    function l(e, t) {
      let n = {};
      for (let e of t) for (let t of e.styles) n[t[0]] = e.inverse ? null : t.slice(1);
      let r = e;
      for (let [e, t] of Object.entries(n))
        if (Array.isArray(t)) {
          if (!(e in r)) throw Error(`Unknown Chalk style: ${e}`);
          r = t.length > 0 ? r[e](...t) : r[e];
        }
      return r;
    }
    t.exports = (e, t) => {
      let n = [],
        s = [],
        c = [];
      if (
        (t.replace(r, (t, r, d, p, _, S) => {
          if (r) c.push(u(r));
          else if (p) {
            let t = c.join('');
            ((c = []),
              s.push(0 === n.length ? t : l(e, n)(t)),
              n.push({
                inverse: d,
                styles: (function (e) {
                  let t;
                  i.lastIndex = 0;
                  let n = [];
                  for (; null !== (t = i.exec(e)); ) {
                    let e = t[1];
                    if (t[2]) {
                      let r = (function (e, t) {
                        let n,
                          r = [];
                        for (let i of t.trim().split(/\s*,\s*/g)) {
                          let t = Number(i);
                          if (Number.isNaN(t))
                            if ((n = i.match(o)))
                              r.push(n[2].replace(a, (e, t, n) => (t ? u(t) : n)));
                            else
                              throw Error(
                                `Invalid Chalk template style argument: ${i} (in style '${e}')`
                              );
                          else r.push(t);
                        }
                        return r;
                      })(e, t[2]);
                      n.push([e].concat(r));
                    } else n.push([e]);
                  }
                  return n;
                })(p),
              }));
          } else if (_) {
            if (0 === n.length) throw Error('Found extraneous } in Chalk template literal');
            (s.push(l(e, n)(c.join(''))), (c = []), n.pop());
          } else c.push(S);
        }),
        s.push(c.join('')),
        n.length > 0)
      )
        throw Error(
          `Chalk template literal is missing ${n.length} closing bracket${1 === n.length ? '' : 's'} (\`}\`)`
        );
      return s.join('');
    };
  },
  26847,
  (e, t, n) => {
    'use strict';
    t.exports = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50],
    };
  },
  24054,
  (e, t, n) => {
    let r = e.r(26847),
      i = {};
    for (let e of Object.keys(r)) i[r[e]] = e;
    let o = {
      rgb: { channels: 3, labels: 'rgb' },
      hsl: { channels: 3, labels: 'hsl' },
      hsv: { channels: 3, labels: 'hsv' },
      hwb: { channels: 3, labels: 'hwb' },
      cmyk: { channels: 4, labels: 'cmyk' },
      xyz: { channels: 3, labels: 'xyz' },
      lab: { channels: 3, labels: 'lab' },
      lch: { channels: 3, labels: 'lch' },
      hex: { channels: 1, labels: ['hex'] },
      keyword: { channels: 1, labels: ['keyword'] },
      ansi16: { channels: 1, labels: ['ansi16'] },
      ansi256: { channels: 1, labels: ['ansi256'] },
      hcg: { channels: 3, labels: ['h', 'c', 'g'] },
      apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
      gray: { channels: 1, labels: ['gray'] },
    };
    for (let e of ((t.exports = o), Object.keys(o))) {
      if (!('channels' in o[e])) throw Error('missing channels property: ' + e);
      if (!('labels' in o[e])) throw Error('missing channel labels property: ' + e);
      if (o[e].labels.length !== o[e].channels)
        throw Error('channel and label counts mismatch: ' + e);
      let { channels: t, labels: n } = o[e];
      (delete o[e].channels,
        delete o[e].labels,
        Object.defineProperty(o[e], 'channels', { value: t }),
        Object.defineProperty(o[e], 'labels', { value: n }));
    }
    ((o.rgb.hsl = function (e) {
      let t,
        n = e[0] / 255,
        r = e[1] / 255,
        i = e[2] / 255,
        o = Math.min(n, r, i),
        a = Math.max(n, r, i),
        s = a - o;
      (a === o
        ? (t = 0)
        : n === a
          ? (t = (r - i) / s)
          : r === a
            ? (t = 2 + (i - n) / s)
            : i === a && (t = 4 + (n - r) / s),
        (t = Math.min(60 * t, 360)) < 0 && (t += 360));
      let u = (o + a) / 2;
      return [t, 100 * (a === o ? 0 : u <= 0.5 ? s / (a + o) : s / (2 - a - o)), 100 * u];
    }),
      (o.rgb.hsv = function (e) {
        let t,
          n,
          r,
          i,
          o,
          a = e[0] / 255,
          s = e[1] / 255,
          u = e[2] / 255,
          l = Math.max(a, s, u),
          c = l - Math.min(a, s, u),
          d = function (e) {
            return (l - e) / 6 / c + 0.5;
          };
        return (
          0 === c
            ? ((i = 0), (o = 0))
            : ((o = c / l),
              (t = d(a)),
              (n = d(s)),
              (r = d(u)),
              a === l
                ? (i = r - n)
                : s === l
                  ? (i = 1 / 3 + t - r)
                  : u === l && (i = 2 / 3 + n - t),
              i < 0 ? (i += 1) : i > 1 && (i -= 1)),
          [360 * i, 100 * o, 100 * l]
        );
      }),
      (o.rgb.hwb = function (e) {
        let t = e[0],
          n = e[1],
          r = e[2];
        return [
          o.rgb.hsl(e)[0],
          (1 / 255) * Math.min(t, Math.min(n, r)) * 100,
          100 * (r = 1 - (1 / 255) * Math.max(t, Math.max(n, r))),
        ];
      }),
      (o.rgb.cmyk = function (e) {
        let t = e[0] / 255,
          n = e[1] / 255,
          r = e[2] / 255,
          i = Math.min(1 - t, 1 - n, 1 - r);
        return [
          100 * ((1 - t - i) / (1 - i) || 0),
          100 * ((1 - n - i) / (1 - i) || 0),
          100 * ((1 - r - i) / (1 - i) || 0),
          100 * i,
        ];
      }),
      (o.rgb.keyword = function (e) {
        let t,
          n = i[e];
        if (n) return n;
        let o = 1 / 0;
        for (let n of Object.keys(r)) {
          let i = r[n],
            a = (e[0] - i[0]) ** 2 + (e[1] - i[1]) ** 2 + (e[2] - i[2]) ** 2;
          a < o && ((o = a), (t = n));
        }
        return t;
      }),
      (o.keyword.rgb = function (e) {
        return r[e];
      }),
      (o.rgb.xyz = function (e) {
        let t = e[0] / 255,
          n = e[1] / 255,
          r = e[2] / 255;
        return [
          100 *
            (0.4124 * (t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92) +
              0.3576 * (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92) +
              0.1805 * (r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92)),
          100 * (0.2126 * t + 0.7152 * n + 0.0722 * r),
          100 * (0.0193 * t + 0.1192 * n + 0.9505 * r),
        ];
      }),
      (o.rgb.lab = function (e) {
        let t = o.rgb.xyz(e),
          n = t[0],
          r = t[1],
          i = t[2];
        return (
          (n /= 95.047),
          (r /= 100),
          (i /= 108.883),
          [
            116 * (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116) - 16,
            500 * ((n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116) - r),
            200 * (r - (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116)),
          ]
        );
      }),
      (o.hsl.rgb = function (e) {
        let t,
          n,
          r,
          i = e[0] / 360,
          o = e[1] / 100,
          a = e[2] / 100;
        if (0 === o) return [(r = 255 * a), r, r];
        t = a < 0.5 ? a * (1 + o) : a + o - a * o;
        let s = 2 * a - t,
          u = [0, 0, 0];
        for (let e = 0; e < 3; e++)
          ((n = i + -((1 / 3) * (e - 1))) < 0 && n++,
            n > 1 && n--,
            (r =
              6 * n < 1
                ? s + (t - s) * 6 * n
                : 2 * n < 1
                  ? t
                  : 3 * n < 2
                    ? s + (t - s) * (2 / 3 - n) * 6
                    : s),
            (u[e] = 255 * r));
        return u;
      }),
      (o.hsl.hsv = function (e) {
        let t = e[0],
          n = e[1] / 100,
          r = e[2] / 100,
          i = n,
          o = Math.max(r, 0.01);
        ((r *= 2), (n *= r <= 1 ? r : 2 - r), (i *= o <= 1 ? o : 2 - o));
        let a = (r + n) / 2;
        return [t, 100 * (0 === r ? (2 * i) / (o + i) : (2 * n) / (r + n)), 100 * a];
      }),
      (o.hsv.rgb = function (e) {
        let t = e[0] / 60,
          n = e[1] / 100,
          r = e[2] / 100,
          i = Math.floor(t) % 6,
          o = t - Math.floor(t),
          a = 255 * r * (1 - n),
          s = 255 * r * (1 - n * o),
          u = 255 * r * (1 - n * (1 - o));
        switch (((r *= 255), i)) {
          case 0:
            return [r, u, a];
          case 1:
            return [s, r, a];
          case 2:
            return [a, r, u];
          case 3:
            return [a, s, r];
          case 4:
            return [u, a, r];
          case 5:
            return [r, a, s];
        }
      }),
      (o.hsv.hsl = function (e) {
        let t,
          n,
          r = e[0],
          i = e[1] / 100,
          o = e[2] / 100,
          a = Math.max(o, 0.01);
        n = (2 - i) * o;
        let s = (2 - i) * a;
        return [r, 100 * (t = (t = (i * a) / (s <= 1 ? s : 2 - s)) || 0), 100 * (n /= 2)];
      }),
      (o.hwb.rgb = function (e) {
        let t,
          n,
          r,
          i,
          o = e[0] / 360,
          a = e[1] / 100,
          s = e[2] / 100,
          u = a + s;
        u > 1 && ((a /= u), (s /= u));
        let l = Math.floor(6 * o),
          c = 1 - s;
        ((t = 6 * o - l), (1 & l) != 0 && (t = 1 - t));
        let d = a + t * (c - a);
        switch (l) {
          default:
          case 6:
          case 0:
            ((n = c), (r = d), (i = a));
            break;
          case 1:
            ((n = d), (r = c), (i = a));
            break;
          case 2:
            ((n = a), (r = c), (i = d));
            break;
          case 3:
            ((n = a), (r = d), (i = c));
            break;
          case 4:
            ((n = d), (r = a), (i = c));
            break;
          case 5:
            ((n = c), (r = a), (i = d));
        }
        return [255 * n, 255 * r, 255 * i];
      }),
      (o.cmyk.rgb = function (e) {
        let t = e[0] / 100,
          n = e[1] / 100,
          r = e[2] / 100,
          i = e[3] / 100;
        return [
          255 * (1 - Math.min(1, t * (1 - i) + i)),
          255 * (1 - Math.min(1, n * (1 - i) + i)),
          255 * (1 - Math.min(1, r * (1 - i) + i)),
        ];
      }),
      (o.xyz.rgb = function (e) {
        let t,
          n,
          r,
          i = e[0] / 100,
          o = e[1] / 100,
          a = e[2] / 100;
        return (
          (t =
            (t = 3.2406 * i + -1.5372 * o + -0.4986 * a) > 0.0031308
              ? 1.055 * t ** (1 / 2.4) - 0.055
              : 12.92 * t),
          (n =
            (n = -0.9689 * i + 1.8758 * o + 0.0415 * a) > 0.0031308
              ? 1.055 * n ** (1 / 2.4) - 0.055
              : 12.92 * n),
          (r =
            (r = 0.0557 * i + -0.204 * o + 1.057 * a) > 0.0031308
              ? 1.055 * r ** (1 / 2.4) - 0.055
              : 12.92 * r),
          [
            255 * (t = Math.min(Math.max(0, t), 1)),
            255 * (n = Math.min(Math.max(0, n), 1)),
            255 * (r = Math.min(Math.max(0, r), 1)),
          ]
        );
      }),
      (o.xyz.lab = function (e) {
        let t = e[0],
          n = e[1],
          r = e[2];
        return (
          (t /= 95.047),
          (n /= 100),
          (r /= 108.883),
          [
            116 * (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116) - 16,
            500 * ((t = t > 0.008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116) - n),
            200 * (n - (r = r > 0.008856 ? r ** (1 / 3) : 7.787 * r + 16 / 116)),
          ]
        );
      }),
      (o.lab.xyz = function (e) {
        let t,
          n,
          r,
          i = e[0],
          o = e[1],
          a = e[2];
        ((t = o / 500 + (n = (i + 16) / 116)), (r = n - a / 200));
        let s = n ** 3,
          u = t ** 3,
          l = r ** 3;
        return (
          (n = (s > 0.008856 ? s : (n - 16 / 116) / 7.787) * 100),
          [
            (t = (u > 0.008856 ? u : (t - 16 / 116) / 7.787) * 95.047),
            n,
            (r = (l > 0.008856 ? l : (r - 16 / 116) / 7.787) * 108.883),
          ]
        );
      }),
      (o.lab.lch = function (e) {
        let t,
          n = e[0],
          r = e[1],
          i = e[2];
        return (
          (t = (360 * Math.atan2(i, r)) / 2 / Math.PI) < 0 && (t += 360),
          [n, Math.sqrt(r * r + i * i), t]
        );
      }),
      (o.lch.lab = function (e) {
        let t = e[0],
          n = e[1],
          r = (e[2] / 360) * 2 * Math.PI;
        return [t, n * Math.cos(r), n * Math.sin(r)];
      }),
      (o.rgb.ansi16 = function (e, t = null) {
        let [n, r, i] = e,
          a = null === t ? o.rgb.hsv(e)[2] : t;
        if (0 === (a = Math.round(a / 50))) return 30;
        let s =
          30 + ((Math.round(i / 255) << 2) | (Math.round(r / 255) << 1) | Math.round(n / 255));
        return (2 === a && (s += 60), s);
      }),
      (o.hsv.ansi16 = function (e) {
        return o.rgb.ansi16(o.hsv.rgb(e), e[2]);
      }),
      (o.rgb.ansi256 = function (e) {
        let t = e[0],
          n = e[1],
          r = e[2];
        return t === n && n === r
          ? t < 8
            ? 16
            : t > 248
              ? 231
              : Math.round(((t - 8) / 247) * 24) + 232
          : 16 +
              36 * Math.round((t / 255) * 5) +
              6 * Math.round((n / 255) * 5) +
              Math.round((r / 255) * 5);
      }),
      (o.ansi16.rgb = function (e) {
        let t = e % 10;
        if (0 === t || 7 === t) return (e > 50 && (t += 3.5), [(t = (t / 10.5) * 255), t, t]);
        let n = (~~(e > 50) + 1) * 0.5;
        return [(1 & t) * n * 255, ((t >> 1) & 1) * n * 255, ((t >> 2) & 1) * n * 255];
      }),
      (o.ansi256.rgb = function (e) {
        let t;
        if (e >= 232) {
          let t = (e - 232) * 10 + 8;
          return [t, t, t];
        }
        return [
          (Math.floor((e -= 16) / 36) / 5) * 255,
          (Math.floor((t = e % 36) / 6) / 5) * 255,
          ((t % 6) / 5) * 255,
        ];
      }),
      (o.rgb.hex = function (e) {
        let t = (
          ((255 & Math.round(e[0])) << 16) +
          ((255 & Math.round(e[1])) << 8) +
          (255 & Math.round(e[2]))
        )
          .toString(16)
          .toUpperCase();
        return '000000'.substring(t.length) + t;
      }),
      (o.hex.rgb = function (e) {
        let t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t) return [0, 0, 0];
        let n = t[0];
        3 === t[0].length &&
          (n = n
            .split('')
            .map((e) => e + e)
            .join(''));
        let r = parseInt(n, 16);
        return [(r >> 16) & 255, (r >> 8) & 255, 255 & r];
      }),
      (o.rgb.hcg = function (e) {
        let t,
          n = e[0] / 255,
          r = e[1] / 255,
          i = e[2] / 255,
          o = Math.max(Math.max(n, r), i),
          a = Math.min(Math.min(n, r), i),
          s = o - a;
        return (
          (t = s < 1 ? a / (1 - s) : 0),
          [
            360 *
              (((s <= 0
                ? 0
                : o === n
                  ? ((r - i) / s) % 6
                  : o === r
                    ? 2 + (i - n) / s
                    : 4 + (n - r) / s) /
                6) %
                1),
            100 * s,
            100 * t,
          ]
        );
      }),
      (o.hsl.hcg = function (e) {
        let t = e[1] / 100,
          n = e[2] / 100,
          r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n),
          i = 0;
        return (r < 1 && (i = (n - 0.5 * r) / (1 - r)), [e[0], 100 * r, 100 * i]);
      }),
      (o.hsv.hcg = function (e) {
        let t = e[1] / 100,
          n = e[2] / 100,
          r = t * n,
          i = 0;
        return (r < 1 && (i = (n - r) / (1 - r)), [e[0], 100 * r, 100 * i]);
      }),
      (o.hcg.rgb = function (e) {
        let t = e[0] / 360,
          n = e[1] / 100,
          r = e[2] / 100;
        if (0 === n) return [255 * r, 255 * r, 255 * r];
        let i = [0, 0, 0],
          o = (t % 1) * 6,
          a = o % 1,
          s = 1 - a,
          u = 0;
        switch (Math.floor(o)) {
          case 0:
            ((i[0] = 1), (i[1] = a), (i[2] = 0));
            break;
          case 1:
            ((i[0] = s), (i[1] = 1), (i[2] = 0));
            break;
          case 2:
            ((i[0] = 0), (i[1] = 1), (i[2] = a));
            break;
          case 3:
            ((i[0] = 0), (i[1] = s), (i[2] = 1));
            break;
          case 4:
            ((i[0] = a), (i[1] = 0), (i[2] = 1));
            break;
          default:
            ((i[0] = 1), (i[1] = 0), (i[2] = s));
        }
        return (
          (u = (1 - n) * r),
          [(n * i[0] + u) * 255, (n * i[1] + u) * 255, (n * i[2] + u) * 255]
        );
      }),
      (o.hcg.hsv = function (e) {
        let t = e[1] / 100,
          n = t + (e[2] / 100) * (1 - t),
          r = 0;
        return (n > 0 && (r = t / n), [e[0], 100 * r, 100 * n]);
      }),
      (o.hcg.hsl = function (e) {
        let t = e[1] / 100,
          n = (e[2] / 100) * (1 - t) + 0.5 * t,
          r = 0;
        return (
          n > 0 && n < 0.5 ? (r = t / (2 * n)) : n >= 0.5 && n < 1 && (r = t / (2 * (1 - n))),
          [e[0], 100 * r, 100 * n]
        );
      }),
      (o.hcg.hwb = function (e) {
        let t = e[1] / 100,
          n = t + (e[2] / 100) * (1 - t);
        return [e[0], (n - t) * 100, (1 - n) * 100];
      }),
      (o.hwb.hcg = function (e) {
        let t = e[1] / 100,
          n = 1 - e[2] / 100,
          r = n - t,
          i = 0;
        return (r < 1 && (i = (n - r) / (1 - r)), [e[0], 100 * r, 100 * i]);
      }),
      (o.apple.rgb = function (e) {
        return [(e[0] / 65535) * 255, (e[1] / 65535) * 255, (e[2] / 65535) * 255];
      }),
      (o.rgb.apple = function (e) {
        return [(e[0] / 255) * 65535, (e[1] / 255) * 65535, (e[2] / 255) * 65535];
      }),
      (o.gray.rgb = function (e) {
        return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255];
      }),
      (o.gray.hsl = function (e) {
        return [0, 0, e[0]];
      }),
      (o.gray.hsv = o.gray.hsl),
      (o.gray.hwb = function (e) {
        return [0, 100, e[0]];
      }),
      (o.gray.cmyk = function (e) {
        return [0, 0, 0, e[0]];
      }),
      (o.gray.lab = function (e) {
        return [e[0], 0, 0];
      }),
      (o.gray.hex = function (e) {
        let t = 255 & Math.round((e[0] / 100) * 255),
          n = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
        return '000000'.substring(n.length) + n;
      }),
      (o.rgb.gray = function (e) {
        return [((e[0] + e[1] + e[2]) / 3 / 255) * 100];
      }));
  },
  70931,
  (e, t, n) => {
    let r = e.r(24054);
    t.exports = function (e) {
      let t = (function (e) {
          let t = (function () {
              let e = {},
                t = Object.keys(r);
              for (let n = t.length, r = 0; r < n; r++) e[t[r]] = { distance: -1, parent: null };
              return e;
            })(),
            n = [e];
          for (t[e].distance = 0; n.length; ) {
            let e = n.pop(),
              i = Object.keys(r[e]);
            for (let r = i.length, o = 0; o < r; o++) {
              let r = i[o],
                a = t[r];
              -1 === a.distance && ((a.distance = t[e].distance + 1), (a.parent = e), n.unshift(r));
            }
          }
          return t;
        })(e),
        n = {},
        i = Object.keys(t);
      for (let e = i.length, o = 0; o < e; o++) {
        let e = i[o];
        null !== t[e].parent &&
          (n[e] = (function (e, t) {
            let n = [t[e].parent, e],
              i = r[t[e].parent][e],
              o = t[e].parent;
            for (; t[o].parent; )
              (n.unshift(t[o].parent),
                (i = (function (e, t) {
                  return function (n) {
                    return t(e(n));
                  };
                })(r[t[o].parent][o], i)),
                (o = t[o].parent));
            return ((i.conversion = n), i);
          })(e, t));
      }
      return n;
    };
  },
  66803,
  (e, t, n) => {
    let r = e.r(24054),
      i = e.r(70931),
      o = {};
    (Object.keys(r).forEach((e) => {
      ((o[e] = {}),
        Object.defineProperty(o[e], 'channels', { value: r[e].channels }),
        Object.defineProperty(o[e], 'labels', { value: r[e].labels }));
      let t = i(e);
      Object.keys(t).forEach((n) => {
        let r = t[n];
        ((o[e][n] = (function (e) {
          let t = function (...t) {
            let n = t[0];
            if (null == n) return n;
            n.length > 1 && (t = n);
            let r = e(t);
            if ('object' == typeof r)
              for (let e = r.length, t = 0; t < e; t++) r[t] = Math.round(r[t]);
            return r;
          };
          return ('conversion' in e && (t.conversion = e.conversion), t);
        })(r)),
          (o[e][n].raw = (function (e) {
            let t = function (...t) {
              let n = t[0];
              return null == n ? n : (n.length > 1 && (t = n), e(t));
            };
            return ('conversion' in e && (t.conversion = e.conversion), t);
          })(r)));
      });
    }),
      (t.exports = o));
  },
  6951,
  (e, t, n) => {
    'use strict';
    let r,
      i =
        (e, t) =>
        (...n) => {
          let r = e(...n);
          return `\u001B[${r + t}m`;
        },
      o =
        (e, t) =>
        (...n) => {
          let r = e(...n);
          return `\u001B[${38 + t};5;${r}m`;
        },
      a =
        (e, t) =>
        (...n) => {
          let r = e(...n);
          return `\u001B[${38 + t};2;${r[0]};${r[1]};${r[2]}m`;
        },
      s = (e) => e,
      u = (e, t, n) => [e, t, n],
      l = (e, t, n) => {
        Object.defineProperty(e, t, {
          get: () => {
            let r = n();
            return (Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0 }), r);
          },
          enumerable: !0,
          configurable: !0,
        });
      },
      c = (t, n, i, o) => {
        void 0 === r && (r = e.r(66803));
        let a = 10 * !!o,
          s = {};
        for (let [e, o] of Object.entries(r)) {
          let r = 'ansi16' === e ? 'ansi' : e;
          e === n ? (s[r] = t(i, a)) : 'object' == typeof o && (s[r] = t(o[n], a));
        }
        return s;
      };
    Object.defineProperty(t, 'exports', {
      enumerable: !0,
      get: function () {
        let e = new Map(),
          t = {
            modifier: {
              reset: [0, 0],
              bold: [1, 22],
              dim: [2, 22],
              italic: [3, 23],
              underline: [4, 24],
              inverse: [7, 27],
              hidden: [8, 28],
              strikethrough: [9, 29],
            },
            color: {
              black: [30, 39],
              red: [31, 39],
              green: [32, 39],
              yellow: [33, 39],
              blue: [34, 39],
              magenta: [35, 39],
              cyan: [36, 39],
              white: [37, 39],
              blackBright: [90, 39],
              redBright: [91, 39],
              greenBright: [92, 39],
              yellowBright: [93, 39],
              blueBright: [94, 39],
              magentaBright: [95, 39],
              cyanBright: [96, 39],
              whiteBright: [97, 39],
            },
            bgColor: {
              bgBlack: [40, 49],
              bgRed: [41, 49],
              bgGreen: [42, 49],
              bgYellow: [43, 49],
              bgBlue: [44, 49],
              bgMagenta: [45, 49],
              bgCyan: [46, 49],
              bgWhite: [47, 49],
              bgBlackBright: [100, 49],
              bgRedBright: [101, 49],
              bgGreenBright: [102, 49],
              bgYellowBright: [103, 49],
              bgBlueBright: [104, 49],
              bgMagentaBright: [105, 49],
              bgCyanBright: [106, 49],
              bgWhiteBright: [107, 49],
            },
          };
        for (let [n, r] of ((t.color.gray = t.color.blackBright),
        (t.bgColor.bgGray = t.bgColor.bgBlackBright),
        (t.color.grey = t.color.blackBright),
        (t.bgColor.bgGrey = t.bgColor.bgBlackBright),
        Object.entries(t))) {
          for (let [n, i] of Object.entries(r))
            ((t[n] = { open: `\u001B[${i[0]}m`, close: `\u001B[${i[1]}m` }),
              (r[n] = t[n]),
              e.set(i[0], i[1]));
          Object.defineProperty(t, n, { value: r, enumerable: !1 });
        }
        return (
          Object.defineProperty(t, 'codes', { value: e, enumerable: !1 }),
          (t.color.close = '\x1b[39m'),
          (t.bgColor.close = '\x1b[49m'),
          l(t.color, 'ansi', () => c(i, 'ansi16', s, !1)),
          l(t.color, 'ansi256', () => c(o, 'ansi256', s, !1)),
          l(t.color, 'ansi16m', () => c(a, 'rgb', u, !1)),
          l(t.bgColor, 'ansi', () => c(i, 'ansi16', s, !0)),
          l(t.bgColor, 'ansi256', () => c(o, 'ansi256', s, !0)),
          l(t.bgColor, 'ansi16m', () => c(a, 'rgb', u, !0)),
          t
        );
      },
    });
  },
  20955,
  (e, t, n) => {
    'use strict';
    t.exports = (e, t = process.argv) => {
      let n = e.startsWith('-') ? '' : 1 === e.length ? '-' : '--',
        r = t.indexOf(n + e),
        i = t.indexOf('--');
      return -1 !== r && (-1 === i || r < i);
    };
  },
  80700,
  (e, t, n) => {
    'use strict';
    let r;
    e.r(46786);
    let i = e.r(70722),
      o = e.r(20955),
      { env: a } = process;
    function s(e) {
      return 0 !== e && { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 };
    }
    function u(e, t) {
      if (0 === r) return 0;
      if (o('color=16m') || o('color=full') || o('color=truecolor')) return 3;
      if (o('color=256')) return 2;
      if (e && !t && void 0 === r) return 0;
      let n = r || 0;
      if ('dumb' === a.TERM) return n;
      if ('CI' in a)
        return ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(
          (e) => e in a
        ) || 'codeship' === a.CI_NAME
          ? 1
          : n;
      if ('TEAMCITY_VERSION' in a)
        return +!!/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(a.TEAMCITY_VERSION);
      if ('truecolor' === a.COLORTERM) return 3;
      if ('TERM_PROGRAM' in a) {
        let e = parseInt((a.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch (a.TERM_PROGRAM) {
          case 'iTerm.app':
            return e >= 3 ? 3 : 2;
          case 'Apple_Terminal':
            return 2;
        }
      }
      return /-256(color)?$/i.test(a.TERM)
        ? 2
        : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(a.TERM) ||
            'COLORTERM' in a
          ? 1
          : n;
    }
    (o('no-color') || o('no-colors') || o('color=false') || o('color=never')
      ? (r = 0)
      : (o('color') || o('colors') || o('color=true') || o('color=always')) && (r = 1),
      'FORCE_COLOR' in a &&
        (r =
          'true' === a.FORCE_COLOR
            ? 1
            : 'false' === a.FORCE_COLOR
              ? 0
              : 0 === a.FORCE_COLOR.length
                ? 1
                : Math.min(parseInt(a.FORCE_COLOR, 10), 3)),
      (t.exports = {
        supportsColor: function (e) {
          return s(u(e, e && e.isTTY));
        },
        stdout: s(u(!0, i.isatty(1))),
        stderr: s(u(!0, i.isatty(2))),
      }));
  },
  17216,
  (e, t, n) => {
    'use strict';
    t.exports = {
      stringReplaceAll: (e, t, n) => {
        let r = e.indexOf(t);
        if (-1 === r) return e;
        let i = t.length,
          o = 0,
          a = '';
        do ((a += e.substr(o, r - o) + t + n), (o = r + i), (r = e.indexOf(t, o)));
        while (-1 !== r);
        return a + e.substr(o);
      },
      stringEncaseCRLFWithFirstIndex: (e, t, n, r) => {
        let i = 0,
          o = '';
        do {
          let a = '\r' === e[r - 1];
          ((o += e.substr(i, (a ? r - 1 : r) - i) + t + (a ? '\r\n' : '\n') + n),
            (i = r + 1),
            (r = e.indexOf('\n', i)));
        } while (-1 !== r);
        return o + e.substr(i);
      },
    };
  },
  47626,
  (e, t, n) => {
    'use strict';
    let r,
      i = e.r(6951),
      { stdout: o, stderr: a } = e.r(80700),
      { stringReplaceAll: s, stringEncaseCRLFWithFirstIndex: u } = e.r(17216),
      l = ['ansi', 'ansi', 'ansi256', 'ansi16m'],
      c = Object.create(null);
    class d {
      constructor(e) {
        return p(e);
      }
    }
    let p = (e) => {
      let t = {};
      return (
        ((e, t = {}) => {
          if (t.level > 3 || t.level < 0)
            throw Error('The `level` option should be an integer from 0 to 3');
          let n = o ? o.level : 0;
          e.level = void 0 === t.level ? n : t.level;
        })(t, e),
        (t.template = (...e) => f(t.template, ...e)),
        Object.setPrototypeOf(t, _.prototype),
        Object.setPrototypeOf(t.template, t),
        (t.template.constructor = () => {
          throw Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');
        }),
        (t.template.Instance = d),
        t.template
      );
    };
    function _(e) {
      return p(e);
    }
    for (let [e, t] of Object.entries(i))
      c[e] = {
        get() {
          let n = m(this, T(t.open, t.close, this._styler), this._isEmpty);
          return (Object.defineProperty(this, e, { value: n }), n);
        },
      };
    c.visible = {
      get() {
        let e = m(this, this._styler, !0);
        return (Object.defineProperty(this, 'visible', { value: e }), e);
      },
    };
    let S = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];
    for (let e of S)
      c[e] = {
        get() {
          let { level: t } = this;
          return function (...n) {
            return m(this, T(i.color[l[t]][e](...n), i.color.close, this._styler), this._isEmpty);
          };
        },
      };
    for (let e of S)
      c['bg' + e[0].toUpperCase() + e.slice(1)] = {
        get() {
          let { level: t } = this;
          return function (...n) {
            return m(
              this,
              T(i.bgColor[l[t]][e](...n), i.bgColor.close, this._styler),
              this._isEmpty
            );
          };
        },
      };
    let E = Object.defineProperties(() => {}, {
        ...c,
        level: {
          enumerable: !0,
          get() {
            return this._generator.level;
          },
          set(e) {
            this._generator.level = e;
          },
        },
      }),
      T = (e, t, n) => {
        let r, i;
        return (
          void 0 === n ? ((r = e), (i = t)) : ((r = n.openAll + e), (i = t + n.closeAll)),
          { open: e, close: t, openAll: r, closeAll: i, parent: n }
        );
      },
      m = (e, t, n) => {
        let r = (...e) => g(r, 1 === e.length ? '' + e[0] : e.join(' '));
        return ((r.__proto__ = E), (r._generator = e), (r._styler = t), (r._isEmpty = n), r);
      },
      g = (e, t) => {
        if (e.level <= 0 || !t) return e._isEmpty ? '' : t;
        let n = e._styler;
        if (void 0 === n) return t;
        let { openAll: r, closeAll: i } = n;
        if (-1 !== t.indexOf('\x1b'))
          for (; void 0 !== n; ) ((t = s(t, n.close, n.open)), (n = n.parent));
        let o = t.indexOf('\n');
        return (-1 !== o && (t = u(t, i, r, o)), r + t + i);
      },
      f = (t, ...n) => {
        let [i] = n;
        if (!Array.isArray(i)) return n.join(' ');
        let o = n.slice(1),
          a = [i.raw[0]];
        for (let e = 1; e < i.length; e++)
          a.push(String(o[e - 1]).replace(/[{}\\]/g, '\\$&'), String(i.raw[e]));
        return (void 0 === r && (r = e.r(39160)), r(t, a.join('')));
      };
    Object.defineProperties(_.prototype, c);
    let h = p(void 0);
    ((h.supportsColor = o),
      (h.stderr = p({ level: a ? a.level : 0 })),
      (h.stderr.supportsColor = a),
      (h.Level = {
        None: 0,
        Basic: 1,
        Ansi256: 2,
        TrueColor: 3,
        0: 'None',
        1: 'Basic',
        2: 'Ansi256',
        3: 'TrueColor',
      }),
      (t.exports = h));
  },
  26207,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(14747);
    n.generateValueInjectionRules = function ({ routeManifest: e, nextJsVersion: t }) {
      let n = [],
        i = {},
        o = {},
        a = {};
      return (
        t && (i._sentryNextJsVersion = t),
        e && (o._sentryRouteManifest = JSON.stringify(e)),
        Object.keys(i).length > 0 && ((o = { ...o, ...i }), (a = { ...a, ...i })),
        Object.keys(o).length > 0 &&
          n.push({
            matcher: '**/instrumentation-client.*',
            rule: {
              loaders: [
                {
                  loader: r.resolve(
                    '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config/turbopack',
                    '..',
                    'loaders',
                    'valueInjectionLoader.js'
                  ),
                  options: { values: o },
                },
              ],
            },
          }),
        Object.keys(a).length > 0 &&
          n.push({
            matcher: '**/instrumentation.*',
            rule: {
              loaders: [
                {
                  loader: r.resolve(
                    '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config/turbopack',
                    '..',
                    'loaders',
                    'valueInjectionLoader.js'
                  ),
                  options: { values: a },
                },
              ],
            },
          }),
        n
      );
    };
  },
  36376,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(47626),
      o = e.r(26207);
    function a(e, { matcher: t, rule: n }) {
      return e
        ? e[t]
          ? (r.debug.log(
              `${i.cyan('info')} - Turbopack rule already exists for ${t}. Please remove it from your Next.js config in order for Sentry to work properly.`
            ),
            e)
          : { ...e, [t]: n }
        : { [t]: n };
    }
    ((n.constructTurbopackConfig = function ({
      userNextConfig: e,
      routeManifest: t,
      nextJsVersion: n,
    }) {
      let r = { ...e.turbopack };
      for (let { matcher: e, rule: i } of o.generateValueInjectionRules({
        routeManifest: t,
        nextJsVersion: n,
      }))
        r.rules = a(r.rules, { matcher: e, rule: i });
      return r;
    }),
      (n.safelyAddTurbopackRule = a));
  },
  46296,
  (e, t, n) => {
    'use strict';
    t.exports =
      e.r(46786).homedir ||
      function () {
        var e = process.env.HOME,
          t = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
        return e || (t ? '/Users/' + t : null);
      };
  },
  53355,
  (e, t, n) => {
    t.exports = function () {
      var e = Error.prepareStackTrace;
      Error.prepareStackTrace = function (e, t) {
        return t;
      };
      var t = Error().stack;
      return ((Error.prepareStackTrace = e), t[2].getFileName());
    };
  },
  66332,
  (e, t, n) => {
    'use strict';
    process.platform;
    var r =
        /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/,
      i = {};
    i.parse = function (e) {
      if ('string' != typeof e)
        throw TypeError("Parameter 'pathString' must be a string, not " + typeof e);
      var t = r.exec(e).slice(1);
      if (!t || 5 !== t.length) throw TypeError("Invalid path '" + e + "'");
      return {
        root: t[1],
        dir: t[0] === t[1] ? t[0] : t[0].slice(0, -1),
        base: t[2],
        ext: t[4],
        name: t[3],
      };
    };
    var o = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/,
      a = {};
    ((a.parse = function (e) {
      if ('string' != typeof e)
        throw TypeError("Parameter 'pathString' must be a string, not " + typeof e);
      var t = o.exec(e).slice(1);
      if (!t || 5 !== t.length) throw TypeError("Invalid path '" + e + "'");
      return { root: t[1], dir: t[0].slice(0, -1), base: t[2], ext: t[4], name: t[3] };
    }),
      (t.exports = a.parse),
      (t.exports.posix = a.parse),
      (t.exports.win32 = i.parse));
  },
  17108,
  (e, t, n) => {
    var r = e.r(14747),
      i = r.parse || e.r(66332),
      o = function (e, t) {
        var n = '/';
        /^([A-Za-z]:)/.test(e) ? (n = '') : /^\\\\/.test(e) && (n = '\\\\');
        for (var o = [e], a = i(e); a.dir !== o[o.length - 1]; ) (o.push(a.dir), (a = i(a.dir)));
        return o.reduce(function (e, i) {
          return e.concat(
            t.map(function (e) {
              return r.resolve(n, i, e);
            })
          );
        }, []);
      };
    t.exports = function (e, t, n) {
      var r = t && t.moduleDirectory ? [].concat(t.moduleDirectory) : ['node_modules'];
      if (t && 'function' == typeof t.paths)
        return t.paths(
          n,
          e,
          function () {
            return o(e, r);
          },
          t
        );
      var i = o(e, r);
      return t && t.paths ? i.concat(t.paths) : i;
    };
  },
  91096,
  (e, t, n) => {
    t.exports = function (e, t) {
      return t || {};
    };
  },
  46835,
  (e, t, n) => {
    'use strict';
    var r = Object.prototype.toString,
      i = Math.max,
      o = function (e, t) {
        for (var n = [], r = 0; r < e.length; r += 1) n[r] = e[r];
        for (var i = 0; i < t.length; i += 1) n[i + e.length] = t[i];
        return n;
      },
      a = function (e, t) {
        for (var n = [], r = t || 0, i = 0; r < e.length; r += 1, i += 1) n[i] = e[r];
        return n;
      },
      s = function (e, t) {
        for (var n = '', r = 0; r < e.length; r += 1) ((n += e[r]), r + 1 < e.length && (n += t));
        return n;
      };
    t.exports = function (e) {
      var t,
        n = this;
      if ('function' != typeof n || '[object Function]' !== r.apply(n))
        throw TypeError('Function.prototype.bind called on incompatible ' + n);
      for (var u = a(arguments, 1), l = i(0, n.length - u.length), c = [], d = 0; d < l; d++)
        c[d] = '$' + d;
      if (
        ((t = Function(
          'binder',
          'return function (' + s(c, ',') + '){ return binder.apply(this,arguments); }'
        )(function () {
          if (this instanceof t) {
            var r = n.apply(this, o(u, arguments));
            return Object(r) === r ? r : this;
          }
          return n.apply(e, o(u, arguments));
        })),
        n.prototype)
      ) {
        var p = function () {};
        ((p.prototype = n.prototype), (t.prototype = new p()), (p.prototype = null));
      }
      return t;
    };
  },
  71224,
  (e, t, n) => {
    'use strict';
    var r = e.r(46835);
    t.exports = Function.prototype.bind || r;
  },
  60388,
  (e, t, n) => {
    'use strict';
    var r = Function.prototype.call,
      i = Object.prototype.hasOwnProperty;
    t.exports = e.r(71224).call(r, i);
  },
  46548,
  (e, t, n) => {
    'use strict';
    var r = e.r(60388);
    function i(e, t) {
      var n = t.split(/ ?&& ?/);
      if (0 === n.length) return !1;
      for (var r = 0; r < n.length; ++r)
        if (
          !(function (e, t) {
            for (
              var n = e.split('.'),
                r = t.split(' '),
                i = r.length > 1 ? r[0] : '=',
                o = (r.length > 1 ? r[1] : r[0]).split('.'),
                a = 0;
              a < 3;
              ++a
            ) {
              var s = parseInt(n[a] || 0, 10),
                u = parseInt(o[a] || 0, 10);
              if (s !== u) {
                if ('<' === i) return s < u;
                if ('>=' === i) return s >= u;
                return !1;
              }
            }
            return '>=' === i;
          })(e, n[r])
        )
          return !1;
      return !0;
    }
    var o = e.r(18314);
    t.exports = function (e, t) {
      return (
        r(o, e) &&
        (function (e, t) {
          if ('boolean' == typeof t) return t;
          var n = void 0 === e ? process.versions && process.versions.node : e;
          if ('string' != typeof n)
            throw TypeError(
              void 0 === e
                ? 'Unable to determine current node version'
                : 'If provided, a valid node version is required'
            );
          if (t && 'object' == typeof t) {
            for (var r = 0; r < t.length; ++r) if (i(n, t[r])) return !0;
            return !1;
          }
          return i(n, t);
        })(t, o[e])
      );
    };
  },
  95820,
  (e, t, n) => {
    var r = e.r(22734),
      i = e.r(46296),
      o = e.r(14747),
      a = e.r(53355),
      s = e.r(17108),
      u = e.r(91096),
      l = e.r(46548),
      c =
        'win32' !== process.platform && r.realpath && 'function' == typeof r.realpath.native
          ? r.realpath.native
          : r.realpath,
      d = i(),
      p = function (e, t) {
        r.stat(e, function (e, n) {
          return e
            ? 'ENOENT' === e.code || 'ENOTDIR' === e.code
              ? t(null, !1)
              : t(e)
            : t(null, n.isFile() || n.isFIFO());
        });
      },
      _ = function (e, t) {
        r.stat(e, function (e, n) {
          return e
            ? 'ENOENT' === e.code || 'ENOTDIR' === e.code
              ? t(null, !1)
              : t(e)
            : t(null, n.isDirectory());
        });
      },
      S = function (e, t) {
        c(e, function (n, r) {
          n && 'ENOENT' !== n.code ? t(n) : t(null, n ? e : r);
        });
      },
      E = function (e, t, n, r) {
        n && !1 === n.preserveSymlinks ? e(t, r) : r(null, t);
      },
      T = function (e, t, n) {
        e(t, function (e, t) {
          if (e) n(e);
          else
            try {
              var r = JSON.parse(t);
              n(null, r);
            } catch (e) {
              n(null);
            }
        });
      },
      m = function (e, t, n) {
        for (var r = s(t, n, e), i = 0; i < r.length; i++) r[i] = o.join(r[i], e);
        return r;
      };
    t.exports = function (e, t, n) {
      var i,
        s = n,
        c = t;
      if (('function' == typeof t && ((s = c), (c = {})), 'string' != typeof e)) {
        var g = TypeError('Path must be a string.');
        return process.nextTick(function () {
          s(g);
        });
      }
      var f = (c = u(e, c)).isFile || p,
        h = c.isDirectory || _,
        A = c.readFile || r.readFile,
        R = c.realpath || S,
        y = c.readPackage || T;
      if (c.readFile && c.readPackage) {
        var I = TypeError('`readFile` and `readPackage` are mutually exclusive.');
        return process.nextTick(function () {
          s(I);
        });
      }
      var b = c.packageIterator,
        N = c.extensions || ['.js'],
        O = !1 !== c.includeCoreModules,
        v = c.basedir || o.dirname(a()),
        C = c.filename || v;
      function P(t, n, r) {
        t
          ? s(t)
          : n
            ? s(null, n, r)
            : L(i, function (t, n, r) {
                if (t) s(t);
                else if (n)
                  E(R, n, c, function (e, t) {
                    e ? s(e) : s(null, t, r);
                  });
                else {
                  var i = Error("Cannot find module '" + e + "' from '" + C + "'");
                  ((i.code = 'MODULE_NOT_FOUND'), s(i));
                }
              });
      }
      function M(e, t, n) {
        var r = t,
          i = n;
        ('function' == typeof r && ((i = r), (r = void 0)),
          (function e(t, n, r) {
            if (0 === t.length) return i(null, void 0, r);
            var a = n + t[0],
              s = r;
            function u(r, u, d) {
              if (((s = u), r)) return i(r);
              if (d && s && c.pathFilter) {
                var p = o.relative(d, a),
                  _ = p.slice(0, p.length - t[0].length),
                  S = c.pathFilter(s, n, _);
                if (S) return e([''].concat(N.slice()), o.resolve(d, S), s);
              }
              f(a, l);
            }
            function l(r, o) {
              return r ? i(r) : o ? i(null, a, s) : void e(t.slice(1), n, s);
            }
            s
              ? u(null, s)
              : (function e(t, n) {
                  return '' === t ||
                    '/' === t ||
                    ('win32' === process.platform && /^\w:[/\\]*$/.test(t),
                    /[/\\]node_modules[/\\]*$/.test(t))
                    ? n(null)
                    : void E(R, t, c, function (r, i) {
                        if (r) return e(o.dirname(t), n);
                        var a = o.join(i, 'package.json');
                        f(a, function (r, i) {
                          if (!i) return e(o.dirname(t), n);
                          y(A, a, function (e, r) {
                            e && n(e);
                            var i = r;
                            (i && c.packageFilter && (i = c.packageFilter(i, a)), n(null, i, t));
                          });
                        });
                      });
                })(o.dirname(a), u);
          })([''].concat(N), e, r));
      }
      function L(e, t, n) {
        var r = n,
          i = t;
        ('function' == typeof i && ((r = i), (i = c.package)),
          E(R, e, c, function (t, n) {
            if (t) return r(t);
            var a = o.join(n, 'package.json');
            f(a, function (t, n) {
              return t
                ? r(t)
                : n
                  ? void y(A, a, function (t, n) {
                      if (t) return r(t);
                      var i = n;
                      if ((i && c.packageFilter && (i = c.packageFilter(i, a)), i && i.main)) {
                        if ('string' != typeof i.main) {
                          var s = TypeError('package “' + i.name + '” `main` must be a string');
                          return ((s.code = 'INVALID_PACKAGE_MAIN'), r(s));
                        }
                        return (
                          ('.' === i.main || './' === i.main) && (i.main = 'index'),
                          void M(o.resolve(e, i.main), i, function (t, n, i) {
                            return t
                              ? r(t)
                              : n
                                ? r(null, n, i)
                                : i
                                  ? void L(o.resolve(e, i.main), i, function (t, n, i) {
                                      return t
                                        ? r(t)
                                        : n
                                          ? r(null, n, i)
                                          : void M(o.join(e, 'index'), i, r);
                                    })
                                  : M(o.join(e, 'index'), i, r);
                          })
                        );
                      }
                      M(o.join(e, '/index'), i, r);
                    })
                  : M(o.join(e, 'index'), i, r);
            });
          }));
      }
      ((c.paths = c.paths || [o.join(d, '.node_modules'), o.join(d, '.node_libraries')]),
        E(R, o.resolve(v), c, function (t, n) {
          t
            ? s(t)
            : (function (t) {
                if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(e))
                  ((i = o.resolve(t, e)),
                    ('.' === e || '..' === e || '/' === e.slice(-1)) && (i += '/'),
                    /\/$/.test(e) && i === t ? L(i, c.package, P) : M(i, c.package, P));
                else {
                  var n, r, a, u;
                  if (O && l(e)) return s(null, e);
                  ((n = e),
                    (r = t),
                    (a = function (t, n, r) {
                      if (t) s(t);
                      else {
                        if (n)
                          return E(R, n, c, function (e, t) {
                            e ? s(e) : s(null, t, r);
                          });
                        var i = Error("Cannot find module '" + e + "' from '" + C + "'");
                        ((i.code = 'MODULE_NOT_FOUND'), s(i));
                      }
                    }),
                    (u = function () {
                      return m(n, r, c);
                    }),
                    (function e(t, n) {
                      if (0 === n.length) return t(null, void 0);
                      var r = n[0];
                      function i(e, n, i) {
                        return e ? t(e) : n ? t(null, n, i) : void L(r, c.package, a);
                      }
                      function a(r, i, o) {
                        return r ? t(r) : i ? t(null, i, o) : void e(t, n.slice(1));
                      }
                      h(o.dirname(r), function (o, a) {
                        return o ? t(o) : a ? void M(r, c.package, i) : e(t, n.slice(1));
                      });
                    })(a, b ? b(n, r, u, c) : u()));
                }
              })(n);
        }));
    };
  },
  24936,
  (e, t, n) => {
    'use strict';
    var r = e.r(46548),
      i = e.r(28879),
      o = {};
    for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (o[a] = r(a));
    t.exports = o;
  },
  73314,
  (e, t, n) => {
    var r = e.r(46548);
    t.exports = function (e) {
      return r(e);
    };
  },
  59482,
  (e, t, n) => {
    var r = e.r(46548),
      i = e.r(22734),
      o = e.r(14747),
      a = e.r(46296),
      s = e.r(53355),
      u = e.r(17108),
      l = e.r(91096),
      c =
        'win32' !== process.platform && i.realpathSync && 'function' == typeof i.realpathSync.native
          ? i.realpathSync.native
          : i.realpathSync,
      d = a(),
      p = function (e) {
        try {
          var t = i.statSync(e, { throwIfNoEntry: !1 });
        } catch (e) {
          if (e && ('ENOENT' === e.code || 'ENOTDIR' === e.code)) return !1;
          throw e;
        }
        return !!t && (t.isFile() || t.isFIFO());
      },
      _ = function (e) {
        try {
          var t = i.statSync(e, { throwIfNoEntry: !1 });
        } catch (e) {
          if (e && ('ENOENT' === e.code || 'ENOTDIR' === e.code)) return !1;
          throw e;
        }
        return !!t && t.isDirectory();
      },
      S = function (e) {
        try {
          return c(e);
        } catch (e) {
          if ('ENOENT' !== e.code) throw e;
        }
        return e;
      },
      E = function (e, t, n) {
        return n && !1 === n.preserveSymlinks ? e(t) : t;
      },
      T = function (e, t) {
        var n = e(t);
        try {
          return JSON.parse(n);
        } catch (e) {}
      },
      m = function (e, t, n) {
        for (var r = u(t, n, e), i = 0; i < r.length; i++) r[i] = o.join(r[i], e);
        return r;
      };
    t.exports = function (e, t) {
      if ('string' != typeof e) throw TypeError('Path must be a string.');
      var n = l(e, t),
        a = n.isFile || p,
        u = n.readFileSync || i.readFileSync,
        c = n.isDirectory || _,
        g = n.realpathSync || S,
        f = n.readPackageSync || T;
      if (n.readFileSync && n.readPackageSync)
        throw TypeError('`readFileSync` and `readPackageSync` are mutually exclusive.');
      var h = n.packageIterator,
        A = n.extensions || ['.js'],
        R = !1 !== n.includeCoreModules,
        y = n.basedir || o.dirname(s()),
        I = n.filename || y;
      n.paths = n.paths || [o.join(d, '.node_modules'), o.join(d, '.node_libraries')];
      var b = E(g, o.resolve(y), n);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(e)) {
        var N = o.resolve(b, e);
        ('.' === e || '..' === e || '/' === e.slice(-1)) && (N += '/');
        var O = P(N) || M(N);
        if (O) return E(g, O, n);
      } else {
        if (R && r(e)) return e;
        var v = (function (e, t) {
          for (
            var r = function () {
                return m(e, t, n);
              },
              i = h ? h(e, t, r, n) : r(),
              a = 0;
            a < i.length;
            a++
          ) {
            var s = i[a];
            if (c(o.dirname(s))) {
              var u = P(s);
              if (u) return u;
              var l = M(s);
              if (l) return l;
            }
          }
        })(e, b);
        if (v) return E(g, v, n);
      }
      var C = Error("Cannot find module '" + e + "' from '" + I + "'");
      throw ((C.code = 'MODULE_NOT_FOUND'), C);
      function P(e) {
        var t = (function e(t) {
          if (
            '' !== t &&
            '/' !== t &&
            ('win32' === process.platform && /^\w:[/\\]*$/.test(t),
            !/[/\\]node_modules[/\\]*$/.test(t))
          ) {
            var r = o.join(E(g, t, n), 'package.json');
            if (!a(r)) return e(o.dirname(t));
            var i = f(u, r);
            return (i && n.packageFilter && (i = n.packageFilter(i, t)), { pkg: i, dir: t });
          }
        })(o.dirname(e));
        if (t && t.dir && t.pkg && n.pathFilter) {
          var r = o.relative(t.dir, e),
            i = n.pathFilter(t.pkg, e, r);
          i && (e = o.resolve(t.dir, i));
        }
        if (a(e)) return e;
        for (var s = 0; s < A.length; s++) {
          var l = e + A[s];
          if (a(l)) return l;
        }
      }
      function M(e) {
        var t = o.join(E(g, e, n), '/package.json');
        if (a(t)) {
          try {
            var r = f(u, t);
          } catch (e) {}
          if ((r && n.packageFilter && (r = n.packageFilter(r, e)), r && r.main)) {
            if ('string' != typeof r.main) {
              var i = TypeError('package “' + r.name + '” `main` must be a string');
              throw ((i.code = 'INVALID_PACKAGE_MAIN'), i);
            }
            ('.' === r.main || './' === r.main) && (r.main = 'index');
            try {
              var s = P(o.resolve(e, r.main));
              if (s) return s;
              var l = M(o.resolve(e, r.main));
              if (l) return l;
            } catch (e) {}
          }
        }
        return P(o.join(e, '/index'));
      }
    };
  },
  84139,
  (e, t, n) => {
    var r = e.r(95820);
    ((r.core = e.r(24936)), (r.isCore = e.r(73314)), (r.sync = e.r(59482)), (t.exports = r));
  },
  59179,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(22734),
      o = e.r(84139);
    function a() {
      let e = (function () {
        try {
          return o.sync('next/package.json', { basedir: process.cwd() });
        } catch {
          return;
        }
      })();
      if (e)
        try {
          return JSON.parse(i.readFileSync(e, { encoding: 'utf-8' })).version;
        } catch {}
    }
    ((n.getNextjsVersion = a),
      (n.supportsProductionCompileHook = function () {
        let e = a();
        if (!e) return !1;
        let { major: t, minor: n, patch: i } = r.parseSemver(e);
        return (
          void 0 !== t &&
          void 0 !== n &&
          void 0 !== i &&
          (!!(t > 15) || (15 === t && (!!(n > 4) || (4 === n && !!(i >= 1)))) || !1)
        );
      }));
  },
  14287,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(14747);
    n.getWebpackPluginOptions = function (e, t, n) {
      let { isServer: i, config: o, dir: a, nextRuntime: s } = e,
        u = a.replace(/\\/g, '/'),
        l = o.distDir?.replace(/\\/g, '/') ?? '.next',
        c = r.posix.join(u, l),
        d = [],
        p = [];
      return (
        i
          ? d.push(r.posix.join(c, 'server', '**'), r.posix.join(c, 'serverless', '**'))
          : (t.widenClientFileUpload
              ? d.push(r.posix.join(c, 'static', 'chunks', '**'))
              : d.push(
                  r.posix.join(c, 'static', 'chunks', 'pages', '**'),
                  r.posix.join(c, 'static', 'chunks', 'app', '**')
                ),
            t.widenClientFileUpload || p.push(r.posix.join(c, 'static', 'chunks', 'main-*')),
            p.push(
              r.posix.join(c, 'static', 'chunks', 'framework-*'),
              r.posix.join(c, 'static', 'chunks', 'framework.*'),
              r.posix.join(c, 'static', 'chunks', 'polyfills-*'),
              r.posix.join(c, 'static', 'chunks', 'webpack-*')
            )),
        {
          authToken: t.authToken,
          headers: t.headers,
          org: t.org,
          project: t.project,
          telemetry: t.telemetry,
          debug: t.debug,
          errorHandler: t.errorHandler,
          reactComponentAnnotation: {
            ...t.reactComponentAnnotation,
            ...t.unstable_sentryWebpackPluginOptions?.reactComponentAnnotation,
          },
          silent: t.silent,
          url: t.sentryUrl,
          sourcemaps: {
            disable: t.sourcemaps?.disable,
            rewriteSources: (e) =>
              e.startsWith('webpack://_N_E/')
                ? e.replace('webpack://_N_E/', '')
                : e.startsWith('webpack://')
                  ? e.replace('webpack://', '')
                  : e,
            assets: t.sourcemaps?.assets ?? d,
            ignore: t.sourcemaps?.ignore ?? p,
            filesToDeleteAfterUpload: t.sourcemaps?.deleteSourcemapsAfterUpload
              ? [
                  r.posix.join(c, 'static', '**', '*.js.map'),
                  r.posix.join(c, 'static', '**', '*.mjs.map'),
                  r.posix.join(c, 'static', '**', '*.cjs.map'),
                ]
              : void 0,
            ...t.unstable_sentryWebpackPluginOptions?.sourcemaps,
          },
          release:
            void 0 !== n
              ? {
                  inject: !1,
                  name: n,
                  create: t.release?.create,
                  finalize: t.release?.finalize,
                  dist: t.release?.dist,
                  vcsRemote: t.release?.vcsRemote,
                  setCommits: t.release?.setCommits,
                  deploy: t.release?.deploy,
                  ...t.unstable_sentryWebpackPluginOptions?.release,
                }
              : { inject: !1, create: !1, finalize: !1 },
          bundleSizeOptimizations: { ...t.bundleSizeOptimizations },
          _metaOptions: {
            loggerPrefixOverride: `[@sentry/nextjs - ${i ? ('edge' === s ? 'Edge' : 'Node.js') : 'Client'}]`,
            telemetry: { metaFramework: 'nextjs' },
          },
          ...t.unstable_sentryWebpackPluginOptions,
        }
      );
    };
  },
  30699,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(47626),
      o = e.r(22734),
      a = e.r(14747),
      s = e.r(84139),
      u = e.r(59179),
      l = e.r(14287),
      c = !1;
    async function d(e, t) {
      let { dir: n, dev: r } = t,
        i = 'function' == typeof e ? await e() : { ...e },
        s = p(n),
        u = (function (e) {
          for (let t of [
            ['src', 'instrumentation-client.js'],
            ['src', 'instrumentation-client.ts'],
            ['instrumentation-client.js'],
            ['instrumentation-client.ts'],
          ])
            if (o.existsSync(a.resolve(e, ...t))) return a.join(...t);
        })(n),
        l = [];
      for (let e in (s && l.push(`./${s}`), u && l.push(`./${u}`), i))
        ('pages/_app' === e || 'main-app' === e) &&
          (function (e, t, n, r) {
            let i = e[t],
              o = i;
            if ('string' == typeof i || Array.isArray(i)) {
              if ((o = Array.isArray(i) ? i : [i]).some((e) => n.includes(e))) return;
              r ? o.push(...n) : o.unshift(...n);
            } else if ('object' == typeof i && 'import' in i) {
              let e = i.import,
                t = Array.isArray(e) ? e : [e];
              if (t.some((e) => n.includes(e))) return;
              (r ? t.push(...n) : t.unshift(...n), (o = { ...i, import: t }));
            } else
              console.error(
                'Sentry Logger [Error]:',
                `Could not inject SDK initialization code into entry point ${t}, as its current value is not in a recognized format.
`,
                'Expected: string | Array<string> | { [key:string]: any, import: string | Array<string> }\n',
                `Got: ${i}`
              );
            o && (e[t] = o);
          })(i, e, l, r);
      return i;
    }
    function p(e) {
      for (let t of ['sentry.client.config.ts', 'sentry.client.config.js'])
        if (o.existsSync(a.resolve(e, t))) return t;
    }
    let _ = [
      'next/dist/client/components/request-async-storage.js',
      'next/dist/client/components/request-async-storage.external.js',
      'next/dist/server/app-render/work-unit-async-storage.external.js',
      'next/dist/client/components/work-unit-async-storage.external.js',
    ];
    n.constructWebpackConfigFunction = function (e = {}, n = {}, S, E, T) {
      return function (m, g) {
        var f;
        let h,
          A,
          { isServer: R, dev: y, dir: I } = g,
          b = R ? ('edge' === g.nextRuntime ? 'edge' : 'server') : 'client',
          N = e.pageExtensions || ['tsx', 'ts', 'jsx', 'js'],
          O = N.map((e) => `.${e}`),
          v = N.map(r.escapeStringForRegex).join('|'),
          C = (function (e, t) {
            for (let n of t.flatMap((e) => [
              ['src', `instrumentation${e}`],
              [`instrumentation${e}`],
            ]))
              try {
                return o.readFileSync(a.resolve(e, ...n), { encoding: 'utf-8' });
              } catch {}
            return null;
          })(I, O.concat(['.ts', '.js']));
        if (
          ('client' !== b &&
            (function (e, t, n) {
              if (
                !(
                  t &&
                  (t.includes('@sentry/') || t.match(/sentry\.(server|edge)\.config(\.(ts|js))?/))
                )
              )
                for (let t of [`sentry.${n}.config.ts`, `sentry.${n}.config.js`])
                  o.existsSync(a.resolve(e, t)) &&
                    console.warn(
                      `[@sentry/nextjs] It appears you've configured a \`${t}\` file. Please ensure to put this file's content into the \`register()\` function of a Next.js instrumentation file instead. To ensure correct functionality of the SDK, \`Sentry.init\` must be called inside of an instrumentation file. Learn more about setting up an instrumentation file in Next.js: https://nextjs.org/docs/app/building-your-application/optimizing/instrumentation. You can safely delete the \`${t}\` file afterward.`
                    );
            })(I, C, b),
          'server' === b)
        ) {
          let e = u.getNextjsVersion(),
            { major: t } = r.parseSemver(e || '');
          t &&
            t >= 15 &&
            (function (e) {
              if (!e) {
                process.env.SENTRY_SUPPRESS_INSTRUMENTATION_FILE_WARNING ||
                  console.warn(
                    i.yellow(
                      '[@sentry/nextjs] Could not find a Next.js instrumentation file. This indicates an incomplete configuration of the Sentry SDK. An instrumentation file is required for the Sentry SDK to be initialized on the server: https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/#create-initialization-config-files (you can suppress this warning by setting SENTRY_SUPPRESS_INSTRUMENTATION_FILE_WARNING=1 as environment variable)'
                    )
                  );
                return;
              }
              e.includes('onRequestError') ||
                console.warn(
                  i.yellow(
                    '[@sentry/nextjs] Could not find `onRequestError` hook in instrumentation file. This indicates outdated configuration of the Sentry SDK. Use `Sentry.captureRequestError` to instrument the `onRequestError` hook: https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/#errors-from-nested-react-server-components'
                  )
                );
            })(C);
        }
        let P = { ...m };
        'webpack' in e && 'function' == typeof e.webpack && (P = e.webpack(P, g));
        let M = (((f = P).module = { ...f.module, rules: [...(f.module?.rules || [])] }), f);
        ((function ({
          newConfig: e,
          userNextConfig: t,
          userSentryOptions: n,
          buildContext: r,
          releaseName: i,
          routeManifest: o,
          nextJsVersion: s,
        }) {
          let u = t.assetPrefix || t.basePath || '',
            l = n.release?.create !== !1,
            c = i && l ? i : void 0,
            d = {
              _sentryRewritesTunnelPath:
                void 0 !== n.tunnelRoute &&
                'export' !== t.output &&
                'string' == typeof n.tunnelRoute
                  ? `${t.basePath ?? ''}${n.tunnelRoute}`
                  : void 0,
              SENTRY_RELEASE: c && !r.dev ? { id: c } : void 0,
              _sentryBasePath: r.dev ? t.basePath : void 0,
              _sentryNextJsVersion: s,
            },
            p = { ...d, _sentryRewriteFramesDistDir: t.distDir?.replace(/\\/g, '\\\\') || '.next' },
            _ = {
              ...d,
              _sentryRewriteFramesAssetPrefixPath: u
                ? new URL(u, 'http://dogs.are.great').pathname.replace(/\/$/, '')
                : '',
              _sentryAssetPrefix: t.assetPrefix,
              _sentryExperimentalThirdPartyOriginStackFrames: n._experimental
                ?.thirdPartyOriginStackFrames
                ? 'true'
                : void 0,
              _sentryRouteManifest: JSON.stringify(o),
            };
          r.isServer
            ? e.module.rules.push({
                test: /(src[\\/])?instrumentation.(js|ts)/,
                use: [
                  {
                    loader: a.resolve(
                      '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                      'loaders/valueInjectionLoader.js'
                    ),
                    options: { values: p },
                  },
                ],
              })
            : e.module.rules.push({
                test: /(?:sentry\.client\.config\.(jsx?|tsx?)|(?:src[\\/])?instrumentation-client\.(js|ts))$/,
                use: [
                  {
                    loader: a.resolve(
                      '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                      'loaders/valueInjectionLoader.js'
                    ),
                    options: { values: _ },
                  },
                ],
              });
        })({
          newConfig: M,
          userNextConfig: e,
          userSentryOptions: n,
          buildContext: g,
          releaseName: S,
          routeManifest: E,
          nextJsVersion: T,
        }),
          (function (e) {
            let t = [
              (e, t) => {
                try {
                  if (!e.module) return !1;
                  let n =
                      /@opentelemetry\/instrumentation/.test(
                        e.module.readableIdentifier(t.requestShortener)
                      ) ||
                      /@prisma\/instrumentation/.test(
                        e.module.readableIdentifier(t.requestShortener)
                      ),
                    r = /Critical dependency/.test(e.message);
                  return n && r;
                } catch {
                  return !1;
                }
              },
              { module: /@opentelemetry\/instrumentation/, message: /Critical dependency/ },
              { module: /@prisma\/instrumentation/, message: /Critical dependency/ },
              { module: /require-in-the-middle/, message: /Critical dependency/ },
            ];
            void 0 === e.ignoreWarnings
              ? (e.ignoreWarnings = t)
              : Array.isArray(e.ignoreWarnings) && e.ignoreWarnings.push(...t);
          })(M));
        let L = a.join(I, 'pages'),
          U = a.join(I, 'src', 'pages');
        o.existsSync(L) && o.lstatSync(L).isDirectory()
          ? (h = L)
          : o.existsSync(U) && o.lstatSync(U).isDirectory() && (h = U);
        let D = a.join(I, 'app'),
          x = a.join(I, 'src', 'app');
        o.existsSync(D) && o.lstatSync(D).isDirectory()
          ? (A = D)
          : o.existsSync(x) && o.lstatSync(x).isDirectory() && (A = x);
        let w = h ? a.join(h, 'api') : void 0,
          k = h ? a.join(h, '..') : A ? a.join(A, '..') : I,
          G = {
            appDir: A,
            pagesDir: h,
            pageExtensionRegex: v,
            excludeServerRoutes: n.excludeServerRoutes,
            nextjsRequestAsyncStorageModulePath: (function (e, t) {
              if (void 0 !== t)
                for (let n of t.map((t) => a.resolve(e, t))) {
                  let e = (function (e) {
                    try {
                      return a.dirname(s.sync('next/package.json', { basedir: e }));
                    } catch {
                      return;
                    }
                  })(n);
                  if (e) {
                    let t = _.find((t) => o.existsSync(a.join(e, '..', t)));
                    if (t) return t;
                  }
                }
            })(I, P.resolve?.modules),
          },
          V = (e) => {
            let t;
            return ((t = a.isAbsolute(e) ? e : a.join(I, e)), a.normalize(t));
          },
          $ = N.map((e) => a.join(k, `middleware.${e}`));
        if (R && !1 !== n.autoInstrumentServerFunctions) {
          let e;
          M.module.rules.unshift({
            test: (e) => {
              let t = V(e);
              return (
                void 0 !== h &&
                t.startsWith(h + a.sep) &&
                !t.startsWith(w + a.sep) &&
                O.some((e) => t.endsWith(e))
              );
            },
            use: [
              {
                loader: a.resolve(
                  '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                  'loaders',
                  'wrappingLoader.js'
                ),
                options: { ...G, wrappingTargetKind: 'page' },
              },
            ],
          });
          try {
            process.env.VERCEL &&
              n.automaticVercelMonitors &&
              (e = JSON.parse(
                o.readFileSync(a.join(process.cwd(), 'vercel.json'), 'utf8')
              ).crons) &&
              r.debug.log(
                `${i.cyan('info')} - Creating Sentry cron monitors for your Vercel Cron Jobs. You can disable this feature by setting the ${i.bold.cyan('automaticVercelMonitors')} option to false in you Next.js config.`
              );
          } catch (e) {
            'ENOENT' === e.code ||
              r.debug.error(
                `${i.red('error')} - Sentry failed to read vercel.json for automatic cron job monitoring instrumentation`,
                e
              );
          }
          (M.module.rules.unshift({
            test: (e) => {
              let t = V(e);
              return t.startsWith(w + a.sep) && O.some((e) => t.endsWith(e));
            },
            use: [
              {
                loader: a.resolve(
                  '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                  'loaders',
                  'wrappingLoader.js'
                ),
                options: { ...G, vercelCronsConfig: e, wrappingTargetKind: 'api-route' },
              },
            ],
          }),
            (n.autoInstrumentMiddleware ?? !0) &&
              M.module.rules.unshift({
                test: (e) => {
                  let t = V(e);
                  return $.includes(t);
                },
                use: [
                  {
                    loader: a.resolve(
                      '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                      'loaders',
                      'wrappingLoader.js'
                    ),
                    options: { ...G, wrappingTargetKind: 'middleware' },
                  },
                ],
              }));
        }
        if (
          (R &&
            !1 !== n.autoInstrumentAppDirectory &&
            (M.module.rules.unshift({
              test: (e) => {
                let t = V(e);
                return (
                  void 0 !== A &&
                  t.startsWith(A + a.sep) &&
                  !!t.match(RegExp(`[\\\\/](page|layout|loading|head|not-found)\\.(${v})$`))
                );
              },
              use: [
                {
                  loader: a.resolve(
                    '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                    'loaders',
                    'wrappingLoader.js'
                  ),
                  options: { ...G, wrappingTargetKind: 'server-component' },
                },
              ],
            }),
            M.module.rules.unshift({
              test: (e) => {
                let t = V(e);
                return (
                  void 0 !== A &&
                  t.startsWith(A + a.sep) &&
                  !!t.match(RegExp(`[\\\\/]route\\.(${v})$`))
                );
              },
              use: [
                {
                  loader: a.resolve(
                    '/ROOT/node_modules/.pnpm/@sentry+nextjs@10.10.0_@opentelemetry+context-async-hooks@2.1.0_@opentelemetry+api@1.9._686bf83fd3b1c1678f4a9c7e1601b75c/node_modules/@sentry/nextjs/build/cjs/config',
                    'loaders',
                    'wrappingLoader.js'
                  ),
                  options: { ...G, wrappingTargetKind: 'route-handler' },
                },
              ],
            })),
          A &&
            (N.map((e) => `global-error.${e}`).some((e) => o.existsSync(a.join(A, e))) ||
              c ||
              process.env.SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING ||
              (console.log(
                `${i.yellow('warn')}  - It seems like you don't have a global error handler set up. It is recommended that you add a ${i.cyan('global-error.js')} file with Sentry instrumentation so that React rendering errors are reported to Sentry. Read more: https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/#react-render-errors-in-app-router (you can suppress this warning by setting SENTRY_SUPPRESS_GLOBAL_ERROR_HANDLER_FILE_WARNING=1 as environment variable)`
              ),
              (c = !0))),
          !R)
        ) {
          let e = M.entry;
          M.entry = async () => d(e, g);
          let t = p(I);
          t &&
            console.warn(
              `[@sentry/nextjs] DEPRECATION WARNING: It is recommended renaming your \`${t}\` file, or moving its content to \`instrumentation-client.ts\`. When using Turbopack \`${t}\` will no longer work. Read more about the \`instrumentation-client.ts\` file: https://nextjs.org/docs/app/api-reference/file-conventions/instrumentation-client`
            );
        }
        let B = e?.output === 'export';
        if (!(y || (B && R))) {
          let { sentryWebpackPlugin: e } = r.loadModule('@sentry/webpack-plugin', t) ?? {};
          if (e) {
            (!n.sourcemaps?.disable &&
              (M.devtool ||
                (r.debug.log(
                  `[@sentry/nextjs] Automatically enabling source map generation for ${b} build.`
                ),
                R ? (M.devtool = 'source-map') : (M.devtool = 'hidden-source-map')),
              R ||
                n.sourcemaps?.deleteSourcemapsAfterUpload !== void 0 ||
                (r.debug.warn(
                  '[@sentry/nextjs] Source maps will be automatically deleted after being uploaded to Sentry. If you want to keep the source maps, set the `sourcemaps.deleteSourcemapsAfterUpload` option to false in `withSentryConfig()`. If you do not want to generate and upload sourcemaps at all, set the `sourcemaps.disable` option to true.'
                ),
                (n.sourcemaps = { ...n.sourcemaps, deleteSourcemapsAfterUpload: !0 }))),
              (M.plugins = M.plugins || []));
            let t = e(l.getWebpackPluginOptions(g, n, S));
            ((t._name = 'sentry-webpack-plugin'), M.plugins.push(t));
          }
        }
        return (
          n.disableLogger &&
            ((M.plugins = M.plugins || []),
            M.plugins.push(new g.webpack.DefinePlugin({ __SENTRY_DEBUG__: !1 }))),
          (M.plugins = M.plugins || []),
          M.plugins.push(
            new g.webpack.DefinePlugin({
              __SENTRY_SERVER_MODULES__: JSON.stringify(
                (function (e) {
                  try {
                    let t = a.join(e, 'package.json'),
                      n = o.readFileSync(t, 'utf8'),
                      r = JSON.parse(n);
                    return { ...r.dependencies, ...r.devDependencies };
                  } catch {
                    return {};
                  }
                })(I)
              ),
            })
          ),
          M
        );
      };
    };
  },
  87885,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(9152),
      o = e.r(33405),
      a = e.r(22734),
      s = e.r(14747),
      u = e.r(65260),
      l = e.r(10222),
      c = e.r(36376),
      d = e.r(59179);
    e.r(30699);
    let p = !1,
      _ = !1,
      S = [
        'amqplib',
        'connect',
        'dataloader',
        'express',
        'generic-pool',
        'graphql',
        '@hapi/hapi',
        'ioredis',
        'kafkajs',
        'koa',
        'lru-memoizer',
        'mongodb',
        'mongoose',
        'mysql',
        'mysql2',
        'knex',
        'pg',
        'pg-pool',
        '@node-redis/client',
        '@redis/client',
        'redis',
        'tedious',
      ];
    function E(e, t) {
      let n,
        E,
        T =
          t.release?.create !== !1
            ? (t.release?.name ??
              i.getSentryRelease() ??
              (function () {
                let e;
                try {
                  e = o
                    .execSync('git rev-parse HEAD', { stdio: ['ignore', 'pipe', 'ignore'] })
                    .toString()
                    .trim();
                } catch {}
                return e;
              })())
            : t.release?.name;
      if (t?.tunnelRoute)
        if ('export' === e.output)
          p ||
            ((p = !0),
            console.warn(
              '[@sentry/nextjs] The Sentry Next.js SDK `tunnelRoute` option will not work in combination with Next.js static exports. The `tunnelRoute` option uses server-side features that cannot be accessed in export mode. If you still want to tunnel Sentry events, set up your own tunnel: https://docs.sentry.io/platforms/javascript/troubleshooting/#using-the-tunnel-option'
            ));
        else {
          let n =
            !0 === t.tunnelRoute
              ? (function () {
                  let e = Math.random().toString(36).substring(2, 10);
                  return `/${e}`;
                })()
              : t.tunnelRoute;
          ((t.tunnelRoute = n || void 0),
            (function (e, t) {
              let n = e.rewrites;
              e.rewrites = async (...e) => {
                let r = {
                    source: `${t}(/?)`,
                    has: [
                      { type: 'query', key: 'o', value: '(?<orgid>\\d*)' },
                      { type: 'query', key: 'p', value: '(?<projectid>\\d*)' },
                    ],
                    destination: 'https://o:orgid.ingest.sentry.io/api/:projectid/envelope/?hsts=0',
                  },
                  i = [
                    {
                      source: `${t}(/?)`,
                      has: [
                        { type: 'query', key: 'o', value: '(?<orgid>\\d*)' },
                        { type: 'query', key: 'p', value: '(?<projectid>\\d*)' },
                        { type: 'query', key: 'r', value: '(?<region>[a-z]{2})' },
                      ],
                      destination:
                        'https://o:orgid.ingest.:region.sentry.io/api/:projectid/envelope/?hsts=0',
                    },
                    r,
                  ];
                if ('function' != typeof n) return i;
                let o = await n(...e);
                return Array.isArray(o)
                  ? [...i, ...o]
                  : { ...o, beforeFiles: [...i, ...(o.beforeFiles || [])] };
              };
            })(e, n));
        }
      if (
        process.argv.includes('--experimental-build-mode') &&
        (_ ||
          ((_ = !0),
          console.warn(
            '[@sentry/nextjs] The Sentry Next.js SDK does not currently fully support next build --experimental-build-mode'
          )),
        process.argv.includes('generate'))
      )
        return e;
      (t.disableManifestInjection || (n = l.createRouteManifest()),
        (function (e, t, n) {
          let r = e.assetPrefix || e.basePath || '',
            i = e.basePath ?? '',
            o =
              void 0 !== t.tunnelRoute && 'export' !== e.output && 'string' == typeof t.tunnelRoute
                ? `${i}${t.tunnelRoute}`
                : void 0,
            a = {
              _sentryRewriteFramesDistDir: e.distDir?.replace(/\\/g, '\\\\') || '.next',
              _sentryRewriteFramesAssetPrefixPath: r
                ? new URL(r, 'http://dogs.are.great').pathname.replace(/\/$/, '')
                : '',
            };
          (e.assetPrefix && (a._assetsPrefix = e.assetPrefix),
            t._experimental?.thirdPartyOriginStackFrames &&
              (a._experimentalThirdPartyOriginStackFrames = 'true'),
            o && (a._sentryRewritesTunnelPath = o),
            i && (a._sentryBasePath = i),
            e.assetPrefix && (a._sentryAssetPrefix = e.assetPrefix),
            t._experimental?.thirdPartyOriginStackFrames &&
              (a._experimentalThirdPartyOriginStackFrames = 'true'),
            n && (a._sentryRelease = n),
            'object' == typeof e.env
              ? (e.env = { ...a, ...e.env })
              : void 0 === e.env && (e.env = a));
        })(e, t, T));
      let m = d.getNextjsVersion();
      if (m) {
        let { major: t, minor: n } = r.parseSemver(m);
        void 0 !== t &&
          void 0 !== n &&
          (t >= 15 || (14 === t && n >= 3)) &&
          ((e.experimental = e.experimental || {}),
          (e.experimental.clientTraceMetadata = [
            'baggage',
            'sentry-trace',
            ...(e.experimental?.clientTraceMetadata || []),
          ]));
      } else
        console.log(
          "[@sentry/nextjs] The Sentry SDK was not able to determine your Next.js version. If you are using Next.js version 15 or greater, please add `experimental.clientTraceMetadata: ['sentry-trace', 'baggage']` to your Next.js config to enable pageload tracing for App Router."
        );
      if (m) {
        let { major: t, minor: n, patch: i, prerelease: o } = r.parseSemver(m),
          a =
            void 0 !== t &&
            void 0 !== n &&
            void 0 !== i &&
            t >= 15 &&
            ((0 === n && 0 === i && void 0 === o) || n > 0 || i > 0),
          s =
            void 0 !== t &&
            void 0 !== n &&
            void 0 !== i &&
            void 0 !== o &&
            15 === t &&
            0 === n &&
            0 === i &&
            o.startsWith('rc.') &&
            parseInt(o.split('.')[1] || '', 10) > 0,
          u =
            void 0 !== n &&
            void 0 !== i &&
            void 0 !== o &&
            15 === t &&
            0 === n &&
            0 === i &&
            o.startsWith('canary.') &&
            parseInt(o.split('.')[1] || '', 10) >= 124;
        a ||
          s ||
          u ||
          (e.experimental?.instrumentationHook === !1 &&
            console.warn(
              '[@sentry/nextjs] You turned off the `experimental.instrumentationHook` option. Note that Sentry will not be initialized if you did not set it up inside `instrumentation.(js|ts)`.'
            ),
          (e.experimental = { instrumentationHook: !0, ...e.experimental }));
      } else
        e.experimental && 'instrumentationHook' in e.experimental
          ? !1 === e.experimental.instrumentationHook &&
            console.warn(
              '[@sentry/nextjs] You set `experimental.instrumentationHook` to `false`. If you are using Next.js version 15 or greater, you can remove that option. If you are using Next.js version 14 or lower, you need to set `experimental.instrumentationHook` in your `next.config.(js|mjs)` to `true` for the SDK to be properly initialized in combination with `instrumentation.(js|ts)`.'
            )
          : (console.log(
              "[@sentry/nextjs] The Sentry SDK was not able to determine your Next.js version. If you are using Next.js version 15 or greater, Next.js will probably show you a warning about the `experimental.instrumentationHook` being set. To silence Next.js' warning, explicitly set the `experimental.instrumentationHook` option in your `next.config.(js|mjs|ts)` to `undefined`. If you are on Next.js version 14 or lower, you can silence this particular warning by explicitly setting the `experimental.instrumentationHook` option in your `next.config.(js|mjs)` to `true`."
            ),
            (e.experimental = { instrumentationHook: !0, ...e.experimental }));
      let g = (function () {
        for (let e of [
          ['src', 'instrumentation-client.ts'],
          ['src', 'instrumentation-client.js'],
          ['instrumentation-client.ts'],
          ['instrumentation-client.js'],
        ])
          try {
            return a.readFileSync(s.join(process.cwd(), ...e), 'utf-8');
          } catch {}
      })();
      void 0 === g ||
        g.includes('onRouterTransitionStart') ||
        t.suppressOnRouterTransitionStartWarning ||
        console.warn(
          '[@sentry/nextjs] ACTION REQUIRED: To instrument navigations, the Sentry SDK requires you to export an `onRouterTransitionStart` hook from your `instrumentation-client.(js|ts)` file. You can do so by adding `export const onRouterTransitionStart = Sentry.captureRouterTransitionStart;` to the file.'
        );
      let f = !1;
      if (m) {
        let { major: e, minor: t, patch: n, prerelease: i } = r.parseSemver(m);
        E = e;
        let o =
          void 0 !== e &&
          void 0 !== t &&
          void 0 !== n &&
          (e > 15 ||
            (15 === e && t > 3) ||
            (15 === e && 3 === t && 0 === n && void 0 === i) ||
            (15 === e && 3 === t && n > 0));
        ((f = o),
          (void 0 !== e &&
            void 0 !== t &&
            void 0 !== n &&
            void 0 !== i &&
            15 === e &&
            3 === t &&
            0 === n &&
            i.startsWith('canary.') &&
            parseInt(i.split('.')[1] || '', 10) >= 28) ||
            o ||
            console.warn(
              `[@sentry/nextjs] WARNING: You are using the Sentry SDK with Turbopack (\`next build --turbo\`). The Sentry SDK is compatible with Turbopack on Next.js version 15.3.0 or later. You are currently on ${m}. Please upgrade to a newer Next.js version to use the Sentry SDK with Turbopack. Note that as Turbopack is still experimental for production builds, some of the Sentry SDK features like source maps will not work. Follow this issue for progress on Sentry + Turbopack: https://github.com/getsentry/sentry-javascript/issues/8105.`
            ));
      }
      return (
        t?._experimental?.useRunAfterProductionCompileHook === !0 &&
          d.supportsProductionCompileHook() &&
          (e?.compiler?.runAfterProductionCompile === void 0
            ? ((e.compiler ??= {}),
              (e.compiler.runAfterProductionCompile = async ({ distDir: e }) => {
                await u.handleRunAfterProductionCompile(
                  { releaseName: T, distDir: e, buildTool: 'turbopack' },
                  t
                );
              }))
            : 'function' == typeof e.compiler.runAfterProductionCompile
              ? (e.compiler.runAfterProductionCompile = new Proxy(
                  e.compiler.runAfterProductionCompile,
                  {
                    async apply(e, n, r) {
                      let { distDir: i } = r[0] ?? { distDir: '.next' };
                      (await e.apply(n, r),
                        await u.handleRunAfterProductionCompile(
                          { releaseName: T, distDir: i, buildTool: 'turbopack' },
                          t
                        ));
                    },
                  }
                ))
              : console.warn(
                  '[@sentry/nextjs] The configured `compiler.runAfterProductionCompile` option is not a function. Will not run source map and release management logic.'
                )),
        f &&
          !t.sourcemaps?.disable &&
          void 0 === e.productionBrowserSourceMaps &&
          (console.log(
            '[@sentry/nextjs] Automatically enabling browser source map generation for turbopack build.'
          ),
          (e.productionBrowserSourceMaps = !0),
          t.sourcemaps?.deleteSourcemapsAfterUpload === void 0 &&
            (console.warn(
              '[@sentry/nextjs] Source maps will be automatically deleted after being uploaded to Sentry. If you want to keep the source maps, set the `sourcemaps.deleteSourcemapsAfterUpload` option to false in `withSentryConfig()`. If you do not want to generate and upload sourcemaps at all, set the `sourcemaps.disable` option to true.'
            ),
            (t.sourcemaps = { ...t.sourcemaps, deleteSourcemapsAfterUpload: !0 }))),
        {
          ...e,
          ...(E && E >= 15
            ? { serverExternalPackages: [...(e.serverExternalPackages || []), ...S] }
            : {
                experimental: {
                  ...e.experimental,
                  serverComponentsExternalPackages: [
                    ...(e.experimental?.serverComponentsExternalPackages || []),
                    ...S,
                  ],
                },
              }),
          webpack: e.webpack,
          ...(f && 1
            ? {
                turbopack: c.constructTurbopackConfig({
                  userNextConfig: e,
                  routeManifest: n,
                  nextJsVersion: m,
                }),
              }
            : {}),
        }
      );
    }
    ((n.DEFAULT_SERVER_EXTERNAL_PACKAGES = S),
      (n.withSentryConfig = function (e, t = {}) {
        let n = e || {};
        return 'function' == typeof n
          ? function (...e) {
              let i = n.apply(this, e);
              return r.isThenable(i) ? i.then((e) => E(e, t)) : E(i, t);
            }
          : E(n, t);
      }));
  },
  69277,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.DEBUG_BUILD = 'undefined' == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__));
  },
  17157,
  (e) => {
    'use strict';
    e.s(['parse', () => n]);
    var t = '<unknown>';
    function n(e) {
      return e.split('\n').reduce(function (e, n) {
        var c,
          d,
          p,
          _ =
            (function (e) {
              var n = r.exec(e);
              if (!n) return null;
              var o = n[2] && 0 === n[2].indexOf('native'),
                a = n[2] && 0 === n[2].indexOf('eval'),
                s = i.exec(n[2]);
              return (
                a && null != s && ((n[2] = s[1]), (n[3] = s[2]), (n[4] = s[3])),
                {
                  file: o ? null : n[2],
                  methodName: n[1] || t,
                  arguments: o ? [n[2]] : [],
                  lineNumber: n[3] ? +n[3] : null,
                  column: n[4] ? +n[4] : null,
                }
              );
            })(n) ||
            ((c = o.exec(n))
              ? {
                  file: c[2],
                  methodName: c[1] || t,
                  arguments: [],
                  lineNumber: +c[3],
                  column: c[4] ? +c[4] : null,
                }
              : null) ||
            (function (e) {
              var n = a.exec(e);
              if (!n) return null;
              var r = n[3] && n[3].indexOf(' > eval') > -1,
                i = s.exec(n[3]);
              return (
                r && null != i && ((n[3] = i[1]), (n[4] = i[2]), (n[5] = null)),
                {
                  file: n[3],
                  methodName: n[1] || t,
                  arguments: n[2] ? n[2].split(',') : [],
                  lineNumber: n[4] ? +n[4] : null,
                  column: n[5] ? +n[5] : null,
                }
              );
            })(n) ||
            ((d = l.exec(n))
              ? {
                  file: d[2],
                  methodName: d[1] || t,
                  arguments: [],
                  lineNumber: +d[3],
                  column: d[4] ? +d[4] : null,
                }
              : null) ||
            ((p = u.exec(n))
              ? {
                  file: p[3],
                  methodName: p[1] || t,
                  arguments: [],
                  lineNumber: +p[4],
                  column: p[5] ? +p[5] : null,
                }
              : null);
        return (_ && e.push(_), e);
      }, []);
    }
    var r =
        /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
      i = /\((\S*)(?::(\d+))(?::(\d+))\)/,
      o =
        /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
      a =
        /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,
      s = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
      u = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i,
      l =
        /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  },
  80638,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(17157),
      o = e.r(69277),
      a = r.GLOBAL_OBJ;
    async function s(e, t) {
      try {
        if (!(e.file?.startsWith('webpack-internal:') || e.file?.startsWith('file:'))) return null;
        let n = new URLSearchParams();
        (n.append('isServer', String(!1)),
          n.append('isEdgeServer', String(!1)),
          n.append('isAppDirectory', String(!0)),
          n.append('errorMessage', t.toString()),
          Object.keys(e).forEach((t) => {
            n.append(t, (e[t] ?? '').toString());
          }));
        let i = process.env._sentryBasePath ?? a._sentryBasePath ?? '';
        '' === i || i.match(/^\//) || (i = `/${i}`);
        let o = new AbortController(),
          s = setTimeout(() => o.abort(), 3e3),
          u = await r.suppressTracing(() =>
            fetch(`http://localhost:3000${i}/__nextjs_original-stack-frame?${n.toString()}`, {
              signal: o.signal,
            }).finally(() => {
              clearTimeout(s);
            })
          );
        if (!u.ok || 204 === u.status) return null;
        let l = await u.json();
        return { originalCodeFrame: l.originalCodeFrame, originalStackFrame: l.originalStackFrame };
      } catch (e) {
        return (
          o.DEBUG_BUILD && r.debug.error('Failed to symbolicate event with Next.js dev server', e),
          null
        );
      }
    }
    async function u(e) {
      try {
        let t = {
            frames: e
              .filter((e) => !!e.file)
              .map(
                (e) => (
                  (e.file = e.file.replace(/^rsc:\/\/React\/[^/]+\//, '').replace(/\?\d+$/, '')),
                  {
                    file: e.file,
                    methodName: e.methodName ?? '<unknown>',
                    arguments: [],
                    lineNumber: e.lineNumber ?? 0,
                    column: e.column ?? 0,
                    line1: e.lineNumber ?? 0,
                    column1: e.column ?? 0,
                  }
                )
              ),
            isServer: !1,
            isEdgeServer: !1,
            isAppDirectory: !0,
          },
          n = process.env._sentryBasePath ?? a._sentryBasePath ?? '';
        '' === n || n.match(/^\//) || (n = `/${n}`);
        let i = new AbortController(),
          o = setTimeout(() => i.abort(), 3e3),
          s = await r.suppressTracing(() =>
            fetch(`http://localhost:3000${n}/__nextjs_original-stack-frames`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              signal: i.signal,
              body: JSON.stringify(t),
            }).finally(() => {
              clearTimeout(o);
            })
          );
        if (!s.ok || 204 === s.status) return null;
        return (await s.json()).map((e) => ({
          originalCodeFrame: e.value.originalCodeFrame,
          originalStackFrame: e.value.originalStackFrame,
        }));
      } catch (e) {
        return (
          o.DEBUG_BUILD && r.debug.error('Failed to symbolicate event with Next.js dev server', e),
          null
        );
      }
    }
    n.devErrorSymbolicationEventProcessor = async function e(e, t) {
      'transaction' === e.type &&
        (e.spans = e.spans?.filter((e) => {
          let t = e.data?.['http.url'];
          return 'string' != typeof t || !t.includes('__nextjs_original-stack-frame');
        }));
      try {
        if (
          t.originalException &&
          t.originalException instanceof Error &&
          t.originalException.stack
        ) {
          let n,
            o = i.parse(t.originalException.stack),
            l = a._sentryNextJsVersion;
          if (!l) return e;
          let c = r.parseSemver(l);
          if (c.major > 15 || (15 === c.major && c.minor >= 2)) {
            let t = await u(o);
            if (null === t) return e;
            n = t;
          } else n = await Promise.all(o.map((e) => s(e, t.originalException)));
          e.exception?.values?.[0]?.stacktrace?.frames &&
            (e.exception.values[0].stacktrace.frames = e.exception.values[0].stacktrace.frames.map(
              (e, t, r) => {
                let i = n[r.length - 1 - t];
                if (!i?.originalStackFrame || !i.originalCodeFrame)
                  return {
                    ...e,
                    platform: e.filename?.startsWith('node:internal') ? 'nodejs' : void 0,
                    in_app: !1,
                  };
                let {
                  contextLine: o,
                  preContextLines: a,
                  postContextLines: s,
                } = (function (e) {
                  let t,
                    n = e
                      .replace(
                        /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g,
                        ''
                      )
                      .split('\n')
                      .filter((e) => !e.match(/^\s*\|/))
                      .map((e) => ({ line: e, isErrorLine: !!e.match(/^>/) }))
                      .map((e) => ({ ...e, line: e.line.replace(/^.*\|/, '') })),
                    r = [],
                    i = [],
                    o = !1;
                  for (let e of n)
                    e.isErrorLine ? ((t = e.line), (o = !0)) : o ? i.push(e.line) : r.push(e.line);
                  return { contextLine: t, preContextLines: r, postContextLines: i };
                })(i.originalCodeFrame);
                return {
                  ...e,
                  pre_context: a,
                  context_line: o,
                  post_context: s,
                  function: i.originalStackFrame.methodName,
                  filename: i.originalStackFrame.file
                    ? (function (e) {
                        if (!e) return e;
                        let t = e.match(/^webpack-internal:(?:\/+)?(?:\([^)]*\)\/)?(.+)$/);
                        return t ? t[1] : e;
                      })(i.originalStackFrame.file)
                    : void 0,
                  lineno: i.originalStackFrame.lineNumber || i.originalStackFrame.line1 || void 0,
                  colno: i.originalStackFrame.column || i.originalStackFrame.column1 || void 0,
                };
              }
            ));
        }
      } catch {}
      return e;
    };
  },
  60459,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.getVercelEnv = function (e) {
        let t = e ? process.env.NEXT_PUBLIC_VERCEL_ENV : process.env.VERCEL_ENV;
        return t ? `vercel-${t}` : void 0;
      }));
  },
  79730,
  (e, t, n) => {
    (Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }),
      (n.TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL = 'sentry.route_backfill'),
      (n.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL = 'sentry.sentry_trace_backfill'),
      (n.TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION = 'sentry.drop_transaction'));
  },
  86669,
  (e, t, n) => {
    'use strict';
    n._ = function (e) {
      return e && e.__esModule ? e : { default: e };
    };
  },
  1973,
  (e, t, n) => {
    'use strict';
    t.exports = ['chrome 64', 'edge 79', 'firefox 67', 'opera 51', 'safari 12'];
  },
  96772,
  (e, t, n) => {
    'use strict';
    (Object.defineProperty(n, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var n in t) Object.defineProperty(e, n, { enumerable: !0, get: t[n] });
      })(n, {
        APP_BUILD_MANIFEST: function () {
          return h;
        },
        APP_CLIENT_INTERNALS: function () {
          return q;
        },
        APP_PATHS_MANIFEST: function () {
          return m;
        },
        APP_PATH_ROUTES_MANIFEST: function () {
          return g;
        },
        AdapterOutputType: function () {
          return o;
        },
        BARREL_OPTIMIZATION_PREFIX: function () {
          return F;
        },
        BLOCKED_PAGES: function () {
          return V;
        },
        BUILD_ID_FILE: function () {
          return G;
        },
        BUILD_MANIFEST: function () {
          return f;
        },
        CLIENT_PUBLIC_FILES_PATH: function () {
          return $;
        },
        CLIENT_REFERENCE_MANIFEST: function () {
          return Z;
        },
        CLIENT_STATIC_FILES_PATH: function () {
          return B;
        },
        CLIENT_STATIC_FILES_RUNTIME_AMP: function () {
          return et;
        },
        CLIENT_STATIC_FILES_RUNTIME_MAIN: function () {
          return J;
        },
        CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: function () {
          return Q;
        },
        CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: function () {
          return er;
        },
        CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: function () {
          return ei;
        },
        CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: function () {
          return ee;
        },
        CLIENT_STATIC_FILES_RUNTIME_WEBPACK: function () {
          return en;
        },
        COMPILER_INDEXES: function () {
          return a;
        },
        COMPILER_NAMES: function () {
          return i;
        },
        CONFIG_FILES: function () {
          return k;
        },
        DEFAULT_RUNTIME_WEBPACK: function () {
          return eo;
        },
        DEFAULT_SANS_SERIF_FONT: function () {
          return ec;
        },
        DEFAULT_SERIF_FONT: function () {
          return el;
        },
        DEV_CLIENT_MIDDLEWARE_MANIFEST: function () {
          return D;
        },
        DEV_CLIENT_PAGES_MANIFEST: function () {
          return P;
        },
        DYNAMIC_CSS_MANIFEST: function () {
          return X;
        },
        EDGE_RUNTIME_WEBPACK: function () {
          return ea;
        },
        EDGE_UNSUPPORTED_NODE_APIS: function () {
          return eE;
        },
        EXPORT_DETAIL: function () {
          return b;
        },
        EXPORT_MARKER: function () {
          return I;
        },
        FUNCTIONS_CONFIG_MANIFEST: function () {
          return A;
        },
        IMAGES_MANIFEST: function () {
          return v;
        },
        INTERCEPTION_ROUTE_REWRITE_MANIFEST: function () {
          return z;
        },
        MIDDLEWARE_BUILD_MANIFEST: function () {
          return W;
        },
        MIDDLEWARE_MANIFEST: function () {
          return M;
        },
        MIDDLEWARE_REACT_LOADABLE_MANIFEST: function () {
          return K;
        },
        MODERN_BROWSERSLIST_TARGET: function () {
          return r.default;
        },
        NEXT_BUILTIN_DOCUMENT: function () {
          return j;
        },
        NEXT_FONT_MANIFEST: function () {
          return y;
        },
        PAGES_MANIFEST: function () {
          return E;
        },
        PHASE_DEVELOPMENT_SERVER: function () {
          return p;
        },
        PHASE_EXPORT: function () {
          return l;
        },
        PHASE_INFO: function () {
          return S;
        },
        PHASE_PRODUCTION_BUILD: function () {
          return c;
        },
        PHASE_PRODUCTION_SERVER: function () {
          return d;
        },
        PHASE_TEST: function () {
          return _;
        },
        PRERENDER_MANIFEST: function () {
          return N;
        },
        REACT_LOADABLE_MANIFEST: function () {
          return x;
        },
        ROUTES_MANIFEST: function () {
          return O;
        },
        RSC_MODULE_TYPES: function () {
          return eS;
        },
        SERVER_DIRECTORY: function () {
          return w;
        },
        SERVER_FILES_MANIFEST: function () {
          return C;
        },
        SERVER_PROPS_ID: function () {
          return eu;
        },
        SERVER_REFERENCE_MANIFEST: function () {
          return Y;
        },
        STATIC_PROPS_ID: function () {
          return es;
        },
        STATIC_STATUS_PAGES: function () {
          return ed;
        },
        STRING_LITERAL_DROP_BUNDLE: function () {
          return H;
        },
        SUBRESOURCE_INTEGRITY_MANIFEST: function () {
          return R;
        },
        SYSTEM_ENTRYPOINTS: function () {
          return eT;
        },
        TRACE_OUTPUT_VERSION: function () {
          return ep;
        },
        TURBOPACK_CLIENT_BUILD_MANIFEST: function () {
          return U;
        },
        TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST: function () {
          return L;
        },
        TURBO_TRACE_DEFAULT_MEMORY_LIMIT: function () {
          return e_;
        },
        UNDERSCORE_NOT_FOUND_ROUTE: function () {
          return s;
        },
        UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function () {
          return u;
        },
        WEBPACK_STATS: function () {
          return T;
        },
      }));
    let r = e.r(86669)._(e.r(1973)),
      i = { client: 'client', server: 'server', edgeServer: 'edge-server' };
    var o = (function (e) {
      return (
        (e.PAGES = 'PAGES'),
        (e.PAGES_API = 'PAGES_API'),
        (e.APP_PAGE = 'APP_PAGE'),
        (e.APP_ROUTE = 'APP_ROUTE'),
        (e.PRERENDER = 'PRERENDER'),
        (e.STATIC_FILE = 'STATIC_FILE'),
        (e.MIDDLEWARE = 'MIDDLEWARE'),
        e
      );
    })({});
    let a = { [i.client]: 0, [i.server]: 1, [i.edgeServer]: 2 },
      s = '/_not-found',
      u = '' + s + '/page',
      l = 'phase-export',
      c = 'phase-production-build',
      d = 'phase-production-server',
      p = 'phase-development-server',
      _ = 'phase-test',
      S = 'phase-info',
      E = 'pages-manifest.json',
      T = 'webpack-stats.json',
      m = 'app-paths-manifest.json',
      g = 'app-path-routes-manifest.json',
      f = 'build-manifest.json',
      h = 'app-build-manifest.json',
      A = 'functions-config-manifest.json',
      R = 'subresource-integrity-manifest',
      y = 'next-font-manifest',
      I = 'export-marker.json',
      b = 'export-detail.json',
      N = 'prerender-manifest.json',
      O = 'routes-manifest.json',
      v = 'images-manifest.json',
      C = 'required-server-files.json',
      P = '_devPagesManifest.json',
      M = 'middleware-manifest.json',
      L = '_clientMiddlewareManifest.json',
      U = 'client-build-manifest.json',
      D = '_devMiddlewareManifest.json',
      x = 'react-loadable-manifest.json',
      w = 'server',
      k = ['next.config.js', 'next.config.mjs', 'next.config.ts'],
      G = 'BUILD_ID',
      V = ['/_document', '/_app', '/_error'],
      $ = 'public',
      B = 'static',
      H = '__NEXT_DROP_CLIENT_FILE__',
      j = '__NEXT_BUILTIN_DOCUMENT__',
      F = '__barrel_optimize__',
      Z = 'client-reference-manifest',
      Y = 'server-reference-manifest',
      W = 'middleware-build-manifest',
      K = 'middleware-react-loadable-manifest',
      z = 'interception-route-rewrite-manifest',
      X = 'dynamic-css-manifest',
      J = 'main',
      Q = '' + J + '-app',
      q = 'app-pages-internals',
      ee = 'react-refresh',
      et = 'amp',
      en = 'webpack',
      er = 'polyfills',
      ei = Symbol(er),
      eo = 'webpack-runtime',
      ea = 'edge-runtime-webpack',
      es = '__N_SSG',
      eu = '__N_SSP',
      el = {
        name: 'Times New Roman',
        xAvgCharWidth: 821,
        azAvgWidth: 854.3953488372093,
        unitsPerEm: 2048,
      },
      ec = { name: 'Arial', xAvgCharWidth: 904, azAvgWidth: 934.5116279069767, unitsPerEm: 2048 },
      ed = ['/500'],
      ep = 1,
      e_ = 6e3,
      eS = { client: 'client', server: 'server' },
      eE = [
        'clearImmediate',
        'setImmediate',
        'BroadcastChannel',
        'ByteLengthQueuingStrategy',
        'CompressionStream',
        'CountQueuingStrategy',
        'DecompressionStream',
        'DomException',
        'MessageChannel',
        'MessageEvent',
        'MessagePort',
        'ReadableByteStreamController',
        'ReadableStreamBYOBRequest',
        'ReadableStreamDefaultController',
        'TransformStreamDefaultController',
        'WritableStreamDefaultController',
      ],
      eT = new Set([J, ee, et, Q]);
    ('function' == typeof n.default || ('object' == typeof n.default && null !== n.default)) &&
      void 0 === n.default.__esModule &&
      (Object.defineProperty(n.default, '__esModule', { value: !0 }),
      Object.assign(n.default, n),
      (t.exports = n.default));
  },
  21439,
  (e, t, n) => {
    t.exports = e.r(96772);
  },
  95617,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(21439);
    n.isBuild = function () {
      return process.env.NEXT_PHASE === r.PHASE_PRODUCTION_BUILD;
    };
  },
  24508,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(14747);
    n.distDirRewriteFramesIntegration = r.defineIntegration(({ distDirName: e }) => {
      let t = i.resolve(e).replace(/(\/|\\)$/, ''),
        n = new RegExp(r.escapeStringForRegex(t));
      return {
        ...r.rewriteFramesIntegration({
          iteratee: (e) => ((e.filename = e.filename?.replace(n, 'app:///_next')), e),
        }),
        name: 'DistDirRewriteFrames',
      };
    });
  },
  29640,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(69277);
    n.flushSafelyWithTimeout = async function () {
      try {
        (i.DEBUG_BUILD && r.debug.log('Flushing events...'),
          await r.flush(2e3),
          i.DEBUG_BUILD && r.debug.log('Done flushing events'));
      } catch (e) {
        i.DEBUG_BUILD && r.debug.log('Error while flushing events:\n', e);
      }
    };
  },
  61017,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(29640);
    n.captureUnderscoreErrorException = async function (e) {
      let { req: t, res: n, err: o } = e,
        a = n?.statusCode || e.statusCode;
      if ((a && a < 500) || !e.pathname) return Promise.resolve();
      (r.withScope((e) => {
        if (t) {
          let n = r.httpRequestToRequestData(t);
          e.setSDKProcessingMetadata({ normalizedRequest: n });
        }
        r.captureException(o || `_error.js called with falsy error (${o})`, {
          mechanism: {
            type: 'instrument',
            handled: !1,
            data: { function: '_error.getInitialProps' },
          },
        });
      }),
        r.vercelWaitUntil(i.flushSafelyWithTimeout()));
    };
  },
  23841,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(79730);
    ((n.callDataFetcherTraced = async function e(e, t) {
      try {
        return await e(...t);
      } catch (e) {
        throw (r.captureException(e, { mechanism: { handled: !1 } }), e);
      }
    }),
      (n.maybeExtractSynchronousParamsAndSearchParams = function (e) {
        let t = e && 'object' == typeof e && 'params' in e ? e.params : void 0;
        r.isThenable(t) && (t = void 0);
        let n = e && 'object' == typeof e && 'searchParams' in e ? e.searchParams : void 0;
        return (r.isThenable(n) && (n = void 0), { params: t, searchParams: n });
      }),
      (n.withErrorInstrumentation = function (e) {
        return async function (...t) {
          try {
            return await e.apply(this, t);
          } catch (e) {
            throw (r.captureException(e, { mechanism: { handled: !1 } }), e);
          }
        };
      }),
      (n.withTracedServerSideDataFetcher = function (e, t, n, o) {
        return async function (...n) {
          let a = r.httpRequestToRequestData(t);
          (r
            .getCurrentScope()
            .setTransactionName(`${o.dataFetchingMethodName} (${o.dataFetcherRouteName})`),
            r.getIsolationScope().setSDKProcessingMetadata({ normalizedRequest: a }));
          let s = r.getActiveSpan();
          s &&
            '/_error' !== o.requestedRouteName &&
            r
              .getRootSpan(s)
              .setAttribute(i.TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL, o.requestedRouteName);
          let { 'sentry-trace': u, baggage: l } = r.getTraceData();
          return { sentryTrace: u, baggage: l, data: await e.apply(this, n) };
        };
      }));
  },
  79179,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapGetStaticPropsWithSentry = function (e, t) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          if (r.isBuild()) return e.apply(t, n);
          let o = i.withErrorInstrumentation(e);
          return i.callDataFetcherTraced(o, n);
        },
      });
    };
  },
  39971,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapGetInitialPropsWithSentry = function (e) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          if (r.isBuild()) return e.apply(t, n);
          let [o] = n,
            { req: a, res: s } = o,
            u = i.withErrorInstrumentation(e);
          if (!a || !s) return u.apply(t, n);
          {
            let e = i.withTracedServerSideDataFetcher(u, a, s, {
                dataFetcherRouteName: o.pathname,
                requestedRouteName: o.pathname,
                dataFetchingMethodName: 'getInitialProps',
              }),
              { data: r, baggage: l, sentryTrace: c } = (await e.apply(t, n)) ?? {};
            return (
              'object' == typeof r &&
                null !== r &&
                (c && (r._sentryTraceData = c), l && (r._sentryBaggage = l)),
              r
            );
          }
        },
      });
    };
  },
  11029,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapAppGetInitialPropsWithSentry = function (e) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          if (r.isBuild()) return e.apply(t, n);
          let [o] = n,
            { req: a, res: s } = o.ctx,
            u = i.withErrorInstrumentation(e);
          if (!a || !s) return u.apply(t, n);
          {
            let e = i.withTracedServerSideDataFetcher(u, a, s, {
                dataFetcherRouteName: '/_app',
                requestedRouteName: o.ctx.pathname,
                dataFetchingMethodName: 'getInitialProps',
              }),
              { data: r, sentryTrace: l, baggage: c } = await e.apply(t, n);
            return (
              'object' == typeof r &&
                null !== r &&
                (r.pageProps || (r.pageProps = {}),
                l && (r.pageProps._sentryTraceData = l),
                c && (r.pageProps._sentryBaggage = c)),
              r
            );
          }
        },
      });
    };
  },
  94360,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapDocumentGetInitialPropsWithSentry = function (e) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          if (r.isBuild()) return e.apply(t, n);
          let [o] = n,
            { req: a, res: s } = o,
            u = i.withErrorInstrumentation(e);
          if (!a || !s) return u.apply(t, n);
          {
            let e = i.withTracedServerSideDataFetcher(u, a, s, {
                dataFetcherRouteName: '/_document',
                requestedRouteName: o.pathname,
                dataFetchingMethodName: 'getInitialProps',
              }),
              { data: r } = await e.apply(t, n);
            return r;
          }
        },
      });
    };
  },
  43982,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapErrorGetInitialPropsWithSentry = function (e) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          if (r.isBuild()) return e.apply(t, n);
          let [o] = n,
            { req: a, res: s } = o,
            u = i.withErrorInstrumentation(e);
          if (!a || !s) return u.apply(t, n);
          {
            let e = i.withTracedServerSideDataFetcher(u, a, s, {
                dataFetcherRouteName: '/_error',
                requestedRouteName: o.pathname,
                dataFetchingMethodName: 'getInitialProps',
              }),
              { data: r, baggage: l, sentryTrace: c } = await e.apply(t, n);
            return (
              'object' == typeof r &&
                null !== r &&
                (c && (r._sentryTraceData = c), l && (r._sentryBaggage = l)),
              r
            );
          }
        },
      });
    };
  },
  23135,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(95617),
      i = e.r(23841);
    n.wrapGetServerSidePropsWithSentry = function (e, t) {
      return new Proxy(e, {
        apply: async (e, n, o) => {
          if (r.isBuild()) return e.apply(n, o);
          let [a] = o,
            { req: s, res: u } = a,
            l = i.withErrorInstrumentation(e),
            c = i.withTracedServerSideDataFetcher(l, s, u, {
              dataFetcherRouteName: t,
              requestedRouteName: t,
              dataFetchingMethodName: 'getServerSideProps',
            }),
            { data: d, baggage: p, sentryTrace: _ } = await c.apply(n, o);
          return (
            'object' == typeof d &&
              null !== d &&
              'props' in d &&
              (_ && (d.props._sentryTraceData = _), p && (d.props._sentryBaggage = p)),
            d
          );
        },
      });
    };
  },
  45715,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    ((n.isNotFoundNavigationError = function (e) {
      return r.isError(e) && ['NEXT_NOT_FOUND', 'NEXT_HTTP_ERROR_FALLBACK;404'].includes(e.digest);
    }),
      (n.isRedirectNavigationError = function (e) {
        return r.isError(e) && 'string' == typeof e.digest && e.digest.startsWith('NEXT_REDIRECT;');
      }));
  },
  43619,
  (e, t, n) => {
    let r;
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let i = e.r(48009),
      o = e.r(69277),
      a = e.r(79730),
      s = new WeakMap(),
      u = new WeakMap();
    ((n.commonObjectToIsolationScope = function (e) {
      if ('object' != typeof e || !e) return new i.Scope();
      {
        let t = u.get(e);
        if (t) return t;
        {
          let t = new i.Scope();
          return (u.set(e, t), t);
        }
      }
    }),
      (n.commonObjectToPropagationContext = function (e, t) {
        if ('object' != typeof e || !e) return t;
        {
          let n = s.get(e);
          return n || (s.set(e, t), t);
        }
      }),
      (n.dropNextjsRootContext = function () {
        let e = i.getActiveSpan();
        if (e) {
          let t = i.getRootSpan(e),
            n = i.spanToJSON(t).data;
          n?.['next.span_type'] &&
            i.getRootSpan(e)?.setAttribute(a.TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION, !0);
        }
      }),
      (n.escapeNextjsTracing = function (e) {
        let t = i.GLOBAL_OBJ.AsyncLocalStorage;
        return t
          ? (r || (r = new t()), r.getStore())
            ? e()
            : i.startNewTrace(() => r.run(!0, () => e()))
          : (o.DEBUG_BUILD &&
              i.debug.warn(
                "Tried to register AsyncLocalStorage async context strategy in a runtime that doesn't support AsyncLocalStorage."
              ),
            e());
      }));
  },
  13916,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = {
        FORWARDED_PROTO: 'x-forwarded-proto',
        FORWARDED_HOST: 'x-forwarded-host',
        HOST: 'host',
        REFERER: 'referer',
      };
    function o(e, t) {
      if (!t || 'object' != typeof t) return e;
      let n = e;
      for (let [e, r] of Object.entries(t)) n = n.split(`[${e}]`).join(encodeURIComponent(r));
      return n;
    }
    function a(e) {
      let t = e.split('/').filter((e) => e && !(e.startsWith('(') && e.endsWith(')')));
      return t.length > 0 ? `/${t.join('/')}` : '/';
    }
    function s(e, t, n, s) {
      let u = o(e, t),
        l = s ?? a(u),
        c = n?.[i.FORWARDED_PROTO],
        d = n?.[i.FORWARDED_HOST] || n?.[i.HOST];
      if (!c || !d) return l;
      let p = `${c}://${d}${l}`,
        _ = r.parseStringToURLObject(p);
      return _ ? r.getSanitizedUrlStringFromUrlObject(_) : l;
    }
    function u(e) {
      let t = e?.[i.REFERER];
      if (t)
        try {
          let e = new URL(t);
          return r.getSanitizedUrlStringFromUrlObject(e);
        } catch {
          return;
        }
    }
    ((n.buildUrlFromComponentRoute = s),
      (n.extractSanitizedUrlFromRefererHeader = u),
      (n.getSanitizedRequestUrl = function (e, t, n, r) {
        let i = u(n);
        return i || s(e, t, n, r);
      }),
      (n.sanitizeRoutePath = a),
      (n.substituteRouteParams = o));
  },
  75002,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(45715),
      o = e.r(29640),
      a = e.r(79730),
      s = e.r(43619),
      u = e.r(13916),
      l = e.r(23841);
    n.wrapServerComponentWithSentry = function (e, t) {
      let { componentRoute: n, componentType: c } = t;
      return new Proxy(e, {
        apply: (e, d, p) => {
          let _, S;
          r.getActiveSpan()?.spanContext().traceId;
          let E = s.commonObjectToIsolationScope(t.headers),
            T = r.getActiveSpan();
          if (T) {
            let e = r.getRootSpan(T),
              { scope: t } = r.getCapturedScopesOnSpan(e);
            r.setCapturedScopesOnSpan(e, t ?? new r.Scope(), E);
            let n = r.spanToJSON(e);
            n.data && 'http.target' in n.data && (_ = n.data['http.target']?.toString());
          }
          let m = t.headers ? r.winterCGHeadersToDict(t.headers) : void 0;
          if (r.getClient()?.getOptions().sendDefaultPii) {
            let e = p[0],
              { params: t } = l.maybeExtractSynchronousParamsAndSearchParams(e);
            S = t;
          }
          return (
            E.setSDKProcessingMetadata({
              normalizedRequest: { headers: m, url: u.getSanitizedRequestUrl(n, S, m, _) },
            }),
            r.withIsolationScope(E, () =>
              r.withScope((t) => {
                t.setTransactionName(`${c} Server Component (${n})`);
                let s = r.getActiveSpan();
                if (s) {
                  let e = r.getRootSpan(s),
                    t = m?.['sentry-trace'];
                  t && e.setAttribute(a.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL, t);
                }
                return r.startSpanManual(
                  {
                    op: 'function.nextjs',
                    name: `${c} Server Component (${n})`,
                    attributes: {
                      [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'component',
                      [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
                      'sentry.nextjs.ssr.function.type': c,
                      'sentry.nextjs.ssr.function.route': n,
                    },
                  },
                  (t) =>
                    r.handleCallbackErrors(
                      () => e.apply(d, p),
                      (e) => {
                        i.isNotFoundNavigationError(e)
                          ? t.setStatus({ code: r.SPAN_STATUS_ERROR, message: 'not_found' })
                          : i.isRedirectNavigationError(e)
                            ? t.setStatus({ code: r.SPAN_STATUS_OK })
                            : (t.setStatus({
                                code: r.SPAN_STATUS_ERROR,
                                message: 'internal_error',
                              }),
                              r.captureException(e, { mechanism: { handled: !1 } }));
                      },
                      () => {
                        (t.end(), r.vercelWaitUntil(o.flushSafelyWithTimeout()));
                      }
                    )
                );
              })
            )
          );
        },
      });
    };
  },
  31205,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(45715),
      o = e.r(29640);
    (e.r(43619),
      (n.wrapRouteHandlerWithSentry = function (e, t) {
        let { method: n, parameterizedRoute: a, headers: s } = t;
        return new Proxy(e, {
          apply: async (e, t, s) => {
            let u = r.getActiveSpan(),
              l = u ? r.getRootSpan(u) : void 0;
            return r.withIsolationScope(r.getIsolationScope(), () =>
              r.withScope(async (c) => {
                c.setTransactionName(`${n} ${a}`);
                let d = await r.handleCallbackErrors(
                  () => e.apply(t, s),
                  (e) => {
                    i.isRedirectNavigationError(e) ||
                      (i.isNotFoundNavigationError(e)
                        ? (u && r.setHttpStatus(u, 404), l && r.setHttpStatus(l, 404))
                        : r.captureException(e, { mechanism: { handled: !1 } }));
                  },
                  () => {
                    r.vercelWaitUntil(o.flushSafelyWithTimeout());
                  }
                );
                try {
                  d.status &&
                    (u && r.setHttpStatus(u, d.status), l && r.setHttpStatus(l, d.status));
                } catch {}
                return d;
              })
            );
          },
        });
      }));
  },
  5101,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.wrapApiHandlerWithSentryVercelCrons = function (e, t) {
      return new Proxy(e, {
        apply: (e, n, i) => {
          let o;
          if (!i?.[0]) return e.apply(n, i);
          let [a] = i,
            s = 'nextUrl' in a ? a.nextUrl.pathname : a.url,
            u = 'nextUrl' in a ? a.headers.get('user-agent') : a.headers['user-agent'];
          if (!t || !u?.includes('vercel-cron')) return e.apply(n, i);
          let l = t.find((e) => e.path === s);
          if (!l?.path || !l.schedule) return e.apply(n, i);
          let c = l.path,
            d = r.captureCheckIn(
              { monitorSlug: c, status: 'in_progress' },
              { maxRuntime: 720, schedule: { type: 'crontab', value: l.schedule } }
            ),
            p = Date.now() / 1e3,
            _ = () => {
              r.captureCheckIn({
                checkInId: d,
                monitorSlug: c,
                status: 'error',
                duration: Date.now() / 1e3 - p,
              });
            };
          try {
            o = e.apply(n, i);
          } catch (e) {
            throw (_(), e);
          }
          return (
            'object' == typeof o && null !== o && 'then' in o
              ? Promise.resolve(o).then(
                  () => {
                    r.captureCheckIn({
                      checkInId: d,
                      monitorSlug: c,
                      status: 'ok',
                      duration: Date.now() / 1e3 - p,
                    });
                  },
                  () => {
                    _();
                  }
                )
              : r.captureCheckIn({
                  checkInId: d,
                  monitorSlug: c,
                  status: 'ok',
                  duration: Date.now() / 1e3 - p,
                }),
            o
          );
        },
      });
    };
  },
  23861,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(29640);
    n.wrapMiddlewareWithSentry = function (e) {
      return new Proxy(e, {
        apply: async (e, t, n) => {
          let o =
            '_sentryRewritesTunnelPath' in globalThis
              ? globalThis._sentryRewritesTunnelPath
              : void 0;
          if (o && 'string' == typeof o) {
            let e = n[0];
            if (e instanceof Request && new URL(e.url).pathname.startsWith(o))
              return new Response(null, { status: 200, headers: { 'x-middleware-next': '1' } });
          }
          return r.withIsolationScope((o) => {
            let a,
              s,
              u = n[0],
              l = r.getCurrentScope();
            (u instanceof Request
              ? (o.setSDKProcessingMetadata({
                  normalizedRequest: r.winterCGRequestToRequestData(u),
                }),
                (a = `middleware ${u.method} ${new URL(u.url).pathname}`),
                (s = 'url'))
              : ((a = 'middleware'), (s = 'component')),
              l.setTransactionName(a));
            let c = r.getActiveSpan();
            if (c) {
              ((a = 'middleware'), (s = 'component'));
              let e = r.getRootSpan(c);
              e && r.setCapturedScopesOnSpan(e, l, o);
            }
            return r.startSpan(
              {
                name: a,
                op: 'http.server.middleware',
                attributes: {
                  [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: s,
                  [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]:
                    'auto.function.nextjs.wrapMiddlewareWithSentry',
                },
              },
              () =>
                r.handleCallbackErrors(
                  () => e.apply(t, n),
                  (e) => {
                    r.captureException(e, { mechanism: { type: 'instrument', handled: !1 } });
                  },
                  () => {
                    r.vercelWaitUntil(i.flushSafelyWithTimeout());
                  }
                )
            );
          });
        },
      });
    };
  },
  13364,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009);
    n.wrapPageComponentWithSentry = function (e) {
      return 'function' == typeof e && e?.prototype?.isReactComponent
        ? class extends e {
            render(...e) {
              return r.withIsolationScope(() => {
                let t = r.getCurrentScope(),
                  n =
                    'object' == typeof this.props &&
                    null !== this.props &&
                    '_sentryTraceData' in this.props &&
                    'string' == typeof this.props._sentryTraceData
                      ? this.props._sentryTraceData
                      : void 0;
                if (n) {
                  let e = r.extractTraceparentData(n);
                  t.setContext('trace', { span_id: e?.parentSpanId, trace_id: e?.traceId });
                }
                try {
                  return super.render(...e);
                } catch (e) {
                  throw (r.captureException(e, { mechanism: { handled: !1 } }), e);
                }
              });
            }
          }
        : 'function' == typeof e
          ? new Proxy(e, {
              apply: (e, t, n) =>
                r.withIsolationScope(() => {
                  let i = r.getCurrentScope(),
                    o = n?.[0]?._sentryTraceData;
                  if (o) {
                    let e = r.extractTraceparentData(o);
                    i.setContext('trace', { span_id: e?.parentSpanId, trace_id: e?.traceId });
                  }
                  try {
                    return e.apply(t, n);
                  } catch (e) {
                    throw (r.captureException(e, { mechanism: { handled: !1 } }), e);
                  }
                }),
            })
          : e;
    };
  },
  75509,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(45715),
      o = e.r(79730),
      a = e.r(43619),
      s = e.r(13916),
      u = e.r(23841);
    n.wrapGenerationFunctionWithSentry = function (e, t) {
      let {
        requestAsyncStorage: n,
        componentRoute: l,
        componentType: c,
        generationFunctionIdentifier: d,
      } = t;
      return new Proxy(e, {
        apply: (e, t, p) => {
          let _,
            S,
            E,
            T = r.getActiveSpan()?.spanContext().traceId;
          try {
            _ = n?.getStore()?.headers;
          } catch {}
          let m = a.commonObjectToIsolationScope(_),
            g = r.getActiveSpan();
          if (g) {
            let e = r.getRootSpan(g),
              { scope: t } = r.getCapturedScopesOnSpan(e);
            r.setCapturedScopesOnSpan(e, t ?? new r.Scope(), m);
            let n = r.spanToJSON(e);
            n.data && 'http.target' in n.data && (S = n.data['http.target']);
          }
          let f = _ ? r.winterCGHeadersToDict(_) : void 0;
          if (r.getClient()?.getOptions().sendDefaultPii) {
            let e = p[0],
              { params: t, searchParams: n } = u.maybeExtractSynchronousParamsAndSearchParams(e);
            E = { params: t, searchParams: n };
          }
          return r.withIsolationScope(m, () =>
            r.withScope((n) => {
              (n.setTransactionName(`${c}.${d} (${l})`),
                m.setSDKProcessingMetadata({
                  normalizedRequest: {
                    headers: f,
                    url: s.getSanitizedRequestUrl(l, E?.params, f, S),
                  },
                }));
              let u = r.getActiveSpan();
              if (u) {
                let e = r.getRootSpan(u),
                  t = f?.['sentry-trace'];
                t && e.setAttribute(o.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL, t);
              }
              let g = a.commonObjectToPropagationContext(
                _,
                r.propagationContextFromHeaders(f?.['sentry-trace'], f?.baggage)
              );
              return (
                T && (g.traceId = T),
                n.setPropagationContext(g),
                n.setExtra('route_data', E),
                r.startSpanManual(
                  {
                    op: 'function.nextjs',
                    name: `${c}.${d} (${l})`,
                    attributes: {
                      [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                      [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
                      'sentry.nextjs.ssr.function.type': d,
                      'sentry.nextjs.ssr.function.route': l,
                    },
                  },
                  (n) =>
                    r.handleCallbackErrors(
                      () => e.apply(t, p),
                      (e) => {
                        i.isNotFoundNavigationError(e)
                          ? (n.setStatus({ code: r.SPAN_STATUS_ERROR, message: 'not_found' }),
                            r
                              .getRootSpan(n)
                              .setStatus({ code: r.SPAN_STATUS_ERROR, message: 'not_found' }))
                          : i.isRedirectNavigationError(e)
                            ? n.setStatus({ code: r.SPAN_STATUS_OK })
                            : (n.setStatus({
                                code: r.SPAN_STATUS_ERROR,
                                message: 'internal_error',
                              }),
                              r
                                .getRootSpan(n)
                                .setStatus({
                                  code: r.SPAN_STATUS_ERROR,
                                  message: 'internal_error',
                                }),
                              r.captureException(e, { mechanism: { handled: !1 } }));
                      },
                      () => {
                        n.end();
                      }
                    )
                )
              );
            })
          );
        },
      });
    };
  },
  81929,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(29640),
      o = e.r(69277),
      a = e.r(45715);
    async function s(e, t, n) {
      return r.withIsolationScope(async (s) => {
        let u,
          l,
          c = r.getClient()?.getOptions().sendDefaultPii,
          d = {};
        try {
          let e = await t.headers;
          ((u = e?.get('sentry-trace') ?? void 0),
            (l = e?.get('baggage')),
            e?.forEach((e, t) => {
              d[t] = e;
            }));
        } catch {
          o.DEBUG_BUILD &&
            r.debug.warn(
              "Sentry wasn't able to extract the tracing headers for a server action. Will not trace this request."
            );
        }
        return (
          s.setTransactionName(`serverAction/${e}`),
          s.setSDKProcessingMetadata({ normalizedRequest: { headers: d } }),
          (r.getActiveSpan() ? (e, t) => t() : r.continueTrace)(
            { sentryTrace: u, baggage: l },
            async () => {
              try {
                return await r.startSpan(
                  {
                    op: 'function.server_action',
                    name: `serverAction/${e}`,
                    forceTransaction: !0,
                    attributes: { [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route' },
                  },
                  async (e) => {
                    let i = await r.handleCallbackErrors(n, (t) => {
                      a.isNotFoundNavigationError(t)
                        ? e.setStatus({ code: r.SPAN_STATUS_ERROR, message: 'not_found' })
                        : a.isRedirectNavigationError(t) ||
                          (e.setStatus({ code: r.SPAN_STATUS_ERROR, message: 'internal_error' }),
                          r.captureException(t, { mechanism: { handled: !1 } }));
                    });
                    return (
                      (void 0 !== t.recordResponse ? t.recordResponse : c) &&
                        r.getIsolationScope().setExtra('server_action_result', i),
                      t.formData &&
                        t.formData.forEach((e, t) => {
                          r.getIsolationScope().setExtra(
                            `server_action_form_data.${t}`,
                            'string' == typeof e ? e : '[non-string value]'
                          );
                        }),
                      i
                    );
                  }
                );
              } finally {
                r.vercelWaitUntil(i.flushSafelyWithTimeout());
              }
            }
          )
        );
      });
    }
    n.withServerActionInstrumentation = function (...e) {
      if ('function' == typeof e[1]) {
        let [t, n] = e;
        return s(t, {}, n);
      }
      {
        let [t, n, r] = e;
        return s(t, n, r);
      }
    };
  },
  64042,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(29640);
    n.captureRequestError = function (e, t, n) {
      r.withScope((o) => {
        (o.setSDKProcessingMetadata({
          normalizedRequest: { headers: r.headersToDict(t.headers), method: t.method },
        }),
          o.setContext('nextjs', {
            request_path: t.path,
            router_kind: n.routerKind,
            router_path: n.routePath,
            route_type: n.routeType,
          }),
          o.setTransactionName(n.routePath),
          r.captureException(e, { mechanism: { handled: !1 } }),
          r.vercelWaitUntil(i.flushSafelyWithTimeout()));
      });
    };
  },
  26585,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(48009),
      i = e.r(29640),
      o = e.r(43619);
    n.wrapApiHandlerWithSentry = function (e, t) {
      return new Proxy(e, {
        apply: (e, n, a) => (
          o.dropNextjsRootContext(),
          o.escapeNextjsTracing(() => {
            let [o, s] = a;
            return o
              ? s
                ? o.__withSentry_applied__
                  ? e.apply(n, a)
                  : ((o.__withSentry_applied__ = !0),
                    r.withIsolationScope((u) =>
                      (r.getActiveSpan() ? (e, t) => t() : r.continueTrace)(
                        {
                          sentryTrace:
                            o.headers && r.isString(o.headers['sentry-trace'])
                              ? o.headers['sentry-trace']
                              : void 0,
                          baggage: o.headers?.baggage,
                        },
                        () => {
                          let l = `${(o.method || 'GET').toUpperCase()} `,
                            c = r.httpRequestToRequestData(o);
                          return (
                            u.setSDKProcessingMetadata({ normalizedRequest: c }),
                            u.setTransactionName(`${l}${t}`),
                            r.startSpanManual(
                              {
                                name: `${l}${t}`,
                                op: 'http.server',
                                forceTransaction: !0,
                                attributes: {
                                  [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                                  [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.nextjs',
                                },
                              },
                              async (t) => {
                                s.end = new Proxy(s.end, {
                                  apply: (e, n, o) => (
                                    r.setHttpStatus(t, s.statusCode),
                                    t.end(),
                                    r.vercelWaitUntil(i.flushSafelyWithTimeout()),
                                    e.apply(n, o)
                                  ),
                                });
                                try {
                                  return await e.apply(n, a);
                                } catch (o) {
                                  let n = r.objectify(o);
                                  throw (
                                    r.captureException(n, {
                                      mechanism: {
                                        type: 'instrument',
                                        handled: !1,
                                        data: { wrapped_handler: e.name, function: 'withSentry' },
                                      },
                                    }),
                                    r.setHttpStatus(t, 500),
                                    t.end(),
                                    await i.flushSafelyWithTimeout(),
                                    n
                                  );
                                }
                              }
                            )
                          );
                        }
                      )
                    ))
                : (r.debug.log(
                    `Wrapped API handler on route "${t}" was not passed a response object. Will not instrument.`
                  ),
                  e.apply(n, a))
              : (r.debug.log(
                  `Wrapped API handler on route "${t}" was not passed a request object. Will not instrument.`
                ),
                e.apply(n, a));
          })
        ),
      });
    };
  },
  77467,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(52305),
      i = e.r(81964),
      o = e.r(48009),
      a = e.r(9152),
      s = e.r(52780),
      u = e.r(69277);
    e.r(80638);
    let l = e.r(60459),
      c = e.r(79730),
      d = e.r(95617),
      p = e.r(24508),
      _ = e.r(61017),
      S = e.r(79179),
      E = e.r(39971),
      T = e.r(11029),
      m = e.r(94360),
      g = e.r(43982),
      f = e.r(23135),
      h = e.r(75002),
      A = e.r(31205),
      R = e.r(5101),
      y = e.r(23861),
      I = e.r(13364),
      b = e.r(75509),
      N = e.r(81929),
      O = e.r(64042),
      v = e.r(26585),
      C = o.GLOBAL_OBJ;
    ((n.captureUnderscoreErrorException = _.captureUnderscoreErrorException),
      (n.wrapGetStaticPropsWithSentry = S.wrapGetStaticPropsWithSentry),
      (n.wrapGetInitialPropsWithSentry = E.wrapGetInitialPropsWithSentry),
      (n.wrapAppGetInitialPropsWithSentry = T.wrapAppGetInitialPropsWithSentry),
      (n.wrapDocumentGetInitialPropsWithSentry = m.wrapDocumentGetInitialPropsWithSentry),
      (n.wrapErrorGetInitialPropsWithSentry = g.wrapErrorGetInitialPropsWithSentry),
      (n.wrapGetServerSidePropsWithSentry = f.wrapGetServerSidePropsWithSentry),
      (n.wrapServerComponentWithSentry = h.wrapServerComponentWithSentry),
      (n.wrapRouteHandlerWithSentry = A.wrapRouteHandlerWithSentry),
      (n.wrapApiHandlerWithSentryVercelCrons = R.wrapApiHandlerWithSentryVercelCrons),
      (n.wrapMiddlewareWithSentry = y.wrapMiddlewareWithSentry),
      (n.wrapPageComponentWithSentry = I.wrapPageComponentWithSentry),
      (n.wrapGenerationFunctionWithSentry = b.wrapGenerationFunctionWithSentry),
      (n.withServerActionInstrumentation = N.withServerActionInstrumentation),
      (n.captureRequestError = O.captureRequestError),
      (n.wrapApiHandlerWithSentry = v.wrapApiHandlerWithSentry),
      (n.ErrorBoundary = (e) =>
        e.children ? ('function' == typeof e.children ? e.children() : e.children) : null),
      (n.createReduxEnhancer = function () {
        return (e) => e;
      }),
      (n.init = function (e) {
        if (d.isBuild()) return;
        let t = a
          .getDefaultIntegrations(e)
          .filter((e) => 'Http' !== e.name)
          .concat(a.httpIntegration({ disableIncomingRequestSpans: !0 }));
        ((process.env.NEXT_OTEL_FETCH_DISABLED = '1'),
          t.push(p.distDirRewriteFramesIntegration({ distDirName: '.next' })));
        let n = {
          environment: process.env.SENTRY_ENVIRONMENT || l.getVercelEnv(!1) || 'production',
          release: '00ee10857f6757b115ef0e493e592c555dbd4df8',
          defaultIntegrations: t,
          ...e,
        };
        if (
          (u.DEBUG_BUILD && n.debug && o.debug.enable(),
          u.DEBUG_BUILD && o.debug.log('Initializing SDK...'),
          o.getClient())
        ) {
          u.DEBUG_BUILD && o.debug.log('SDK already initialized');
          return;
        }
        o.applySdkMetadata(n, 'nextjs', ['nextjs', 'node']);
        let _ = a.init(n);
        (_?.on('beforeSampling', ({ spanAttributes: e }, t) => {
          (('string' == typeof e[i.SEMATTRS_HTTP_TARGET] &&
            e[i.SEMATTRS_HTTP_TARGET].includes('sentry_key') &&
            e[i.SEMATTRS_HTTP_TARGET].includes('sentry_client')) ||
            ('string' == typeof e[i.ATTR_URL_QUERY] &&
              e[i.ATTR_URL_QUERY].includes('sentry_key') &&
              e[i.ATTR_URL_QUERY].includes('sentry_client'))) &&
            (t.decision = !1);
        }),
          _?.on('spanStart', (e) => {
            let t = o.spanToJSON(e).data;
            if ('string' == typeof t?.['next.route']) {
              let n = o.getRootSpan(e),
                r = o.spanToJSON(n).data;
              if (
                (r?.[i.ATTR_HTTP_REQUEST_METHOD] || r?.[i.SEMATTRS_HTTP_METHOD]) &&
                !r?.[i.ATTR_HTTP_ROUTE]
              ) {
                let e = t['next.route'].replace(/\/route$/, '');
                (n.updateName(e),
                  n.setAttribute(i.ATTR_HTTP_ROUTE, e),
                  n.setAttribute('next.route', e));
              }
            }
            if (
              (t?.['next.span_type'] !== void 0 &&
                e.setAttribute(o.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto'),
              t?.['next.span_type'] === 'BaseServer.handleRequest' && e === o.getRootSpan(e))
            ) {
              let t = o.getCapturedScopesOnSpan(e),
                n = (t.isolationScope || o.getIsolationScope()).clone(),
                i = t.scope || o.getCurrentScope(),
                a = s.getScopesFromContext(r.context.active());
              (a && (a.isolationScope = n), o.setCapturedScopesOnSpan(e, i, n));
            }
          }),
          o.getGlobalScope().addEventProcessor(
            Object.assign(
              (e) => {
                if ('transaction' !== e.type) return e;
                if (
                  e.transaction?.match(/^GET (\/.*)?\/_next\/static\//) ||
                  (C._sentryRewritesTunnelPath &&
                    e.transaction === `POST ${C._sentryRewritesTunnelPath}`) ||
                  (process.env._sentryRewritesTunnelPath &&
                    e.transaction === `POST ${process.env._sentryRewritesTunnelPath}`) ||
                  e.transaction?.match(/\/__nextjs_original-stack-frame/) ||
                  '/404' === e.transaction ||
                  e.transaction?.match(
                    /^(GET|HEAD|POST|PUT|DELETE|CONNECT|OPTIONS|TRACE|PATCH) \/(404|_not-found)$/
                  ) ||
                  e.contexts?.trace?.data?.[c.TRANSACTION_ATTR_SHOULD_DROP_TRANSACTION] ||
                  'NextServer.getRequestHandler' === e.transaction
                )
                  return null;
                if (
                  'string' ==
                  typeof e.contexts?.trace?.data?.[c.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL]
                ) {
                  let t = o.extractTraceparentData(
                    e.contexts.trace.data[c.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL]
                  );
                  if (t?.parentSampled === !1) return null;
                }
                return e;
              },
              { id: 'NextLowQualityTransactionsFilter' }
            )
          ),
          o.getGlobalScope().addEventProcessor(
            Object.assign(
              (e, t) => {
                if (void 0 !== e.type) return e;
                let n = t.originalException;
                if (
                  'object' == typeof n &&
                  null !== n &&
                  '$$typeof' in n &&
                  n.$$typeof === Symbol.for('react.postpone')
                )
                  return null;
                let r = e.exception?.values?.[0]?.value;
                return r?.includes('Suspense Exception: This is not a real error!') ||
                  r?.includes('Suspense Exception: This is not a real error, and should not leak')
                  ? null
                  : e;
              },
              { id: 'DropReactControlFlowErrors' }
            )
          ),
          _?.on('preprocessEvent', (e) => {
            if (
              'transaction' === e.type &&
              e.contexts?.trace?.data?.['next.span_type'] === 'BaseServer.handleRequest'
            ) {
              ((e.contexts.trace.data[o.SEMANTIC_ATTRIBUTE_SENTRY_OP] = 'http.server'),
                (e.contexts.trace.op = 'http.server'),
                e.transaction && (e.transaction = o.stripUrlQueryAndFragment(e.transaction)));
              let t = e.contexts.trace.data[i.SEMATTRS_HTTP_METHOD],
                n = e.contexts?.trace?.data?.[i.SEMATTRS_HTTP_TARGET],
                r = e.contexts.trace.data[i.ATTR_HTTP_ROUTE] || e.contexts.trace.data['next.route'];
              if ('string' == typeof t && 'string' == typeof r) {
                let n = r.replace(/\/route$/, '');
                ((e.transaction = `${t} ${n}`),
                  (e.contexts.trace.data[o.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route'),
                  (e.contexts.trace.data['next.route'] = n));
              }
              (e.contexts.trace.data[c.TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL] &&
                'GET /_app' !== e.transaction &&
                (e.transaction = `${t} ${e.contexts.trace.data[c.TRANSACTION_ATTR_SENTRY_ROUTE_BACKFILL]}`),
                'GET /_error' === e.transaction &&
                  n &&
                  (e.transaction = `${t ? `${t} ` : ''}${n}`));
            }
            if (
              'transaction' === e.type &&
              'string' == typeof e.contexts?.trace?.data?.[c.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL]
            ) {
              let t = o.extractTraceparentData(
                e.contexts.trace.data[c.TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL]
              );
              (t?.traceId && (e.contexts.trace.trace_id = t.traceId),
                t?.parentSpanId && (e.contexts.trace.parent_span_id = t.parentSpanId));
            }
          }));
        try {
          o.getGlobalScope().setTag('turbopack', !0);
        } catch {}
        return (u.DEBUG_BUILD && o.debug.log('SDK successfully initialized'), _);
      }),
      (n.showReportDialog = function () {}),
      (n.withErrorBoundary = function (e) {
        return e;
      }),
      Object.prototype.hasOwnProperty.call(a, '__proto__') &&
        !Object.prototype.hasOwnProperty.call(n, '__proto__') &&
        Object.defineProperty(n, '__proto__', { enumerable: !0, value: a.__proto__ }),
      Object.keys(a).forEach((e) => {
        'default' === e || Object.prototype.hasOwnProperty.call(n, e) || (n[e] = a[e]);
      }));
  },
  51011,
  (e, t, n) => {
    Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' });
    let r = e.r(87885),
      i = e.r(77467),
      o = e.r(61017),
      a = e.r(26585),
      s = e.r(79179),
      u = e.r(39971),
      l = e.r(11029),
      c = e.r(94360),
      d = e.r(43982),
      p = e.r(23135),
      _ = e.r(75002),
      S = e.r(31205),
      E = e.r(5101),
      T = e.r(23861),
      m = e.r(13364),
      g = e.r(75509),
      f = e.r(81929),
      h = e.r(64042),
      A = e.r(9152);
    ((n.withSentryConfig = r.withSentryConfig),
      (n.ErrorBoundary = i.ErrorBoundary),
      (n.createReduxEnhancer = i.createReduxEnhancer),
      (n.init = i.init),
      (n.showReportDialog = i.showReportDialog),
      (n.withErrorBoundary = i.withErrorBoundary),
      (n.captureUnderscoreErrorException = o.captureUnderscoreErrorException),
      (n.wrapApiHandlerWithSentry = a.wrapApiHandlerWithSentry),
      (n.wrapGetStaticPropsWithSentry = s.wrapGetStaticPropsWithSentry),
      (n.wrapGetInitialPropsWithSentry = u.wrapGetInitialPropsWithSentry),
      (n.wrapAppGetInitialPropsWithSentry = l.wrapAppGetInitialPropsWithSentry),
      (n.wrapDocumentGetInitialPropsWithSentry = c.wrapDocumentGetInitialPropsWithSentry),
      (n.wrapErrorGetInitialPropsWithSentry = d.wrapErrorGetInitialPropsWithSentry),
      (n.wrapGetServerSidePropsWithSentry = p.wrapGetServerSidePropsWithSentry),
      (n.wrapServerComponentWithSentry = _.wrapServerComponentWithSentry),
      (n.wrapRouteHandlerWithSentry = S.wrapRouteHandlerWithSentry),
      (n.wrapApiHandlerWithSentryVercelCrons = E.wrapApiHandlerWithSentryVercelCrons),
      (n.wrapMiddlewareWithSentry = T.wrapMiddlewareWithSentry),
      (n.wrapPageComponentWithSentry = m.wrapPageComponentWithSentry),
      (n.wrapGenerationFunctionWithSentry = g.wrapGenerationFunctionWithSentry),
      (n.withServerActionInstrumentation = f.withServerActionInstrumentation),
      (n.captureRequestError = h.captureRequestError),
      Object.prototype.hasOwnProperty.call(A, '__proto__') &&
        !Object.prototype.hasOwnProperty.call(n, '__proto__') &&
        Object.defineProperty(n, '__proto__', { enumerable: !0, value: A.__proto__ }),
      Object.keys(A).forEach((e) => {
        'default' === e || Object.prototype.hasOwnProperty.call(n, e) || (n[e] = A[e]);
      }));
  },
  3872,
  (e) => {
    'use strict';
    e.s([], 3872);
    var t,
      n = e.i(51011);
    function r(e, t) {
      if (e instanceof Promise) throw Error(t);
    }
    (e.s(
      [
        '$brand',
        () => a,
        '$input',
        () => iA,
        '$output',
        () => ih,
        'NEVER',
        () => i,
        'TimePrecision',
        () => iz,
        'ZodAny',
        () => sZ,
        'ZodArray',
        () => s1,
        'ZodBase64',
        () => sd,
        'ZodBase64URL',
        () => s_,
        'ZodBigInt',
        () => sD,
        'ZodBigIntFormat',
        () => sw,
        'ZodBoolean',
        () => sL,
        'ZodCIDRv4',
        () => ss,
        'ZodCIDRv6',
        () => sl,
        'ZodCUID',
        () => a5,
        'ZodCUID2',
        () => a9,
        'ZodCatch',
        () => ux,
        'ZodCodec',
        () => uB,
        'ZodCustom',
        () => uq,
        'ZodCustomStringFormat',
        () => sf,
        'ZodDate',
        () => sq,
        'ZodDefault',
        () => uO,
        'ZodDiscriminatedUnion',
        () => ue,
        'ZodE164',
        () => sE,
        'ZodEmail',
        () => aB,
        'ZodEmoji',
        () => aq,
        'ZodEnum',
        () => u_,
        'ZodError',
        () => aR,
        'ZodFile',
        () => ug,
        'ZodFirstPartyTypeKind',
        () => t,
        'ZodFunction',
        () => uJ,
        'ZodGUID',
        () => aj,
        'ZodIPv4',
        () => sr,
        'ZodIPv6',
        () => so,
        'ZodISODate',
        () => aE,
        'ZodISODateTime',
        () => a_,
        'ZodISODuration',
        () => af,
        'ZodISOTime',
        () => am,
        'ZodIntersection',
        () => un,
        'ZodIssueCode',
        () => u7,
        'ZodJWT',
        () => sm,
        'ZodKSUID',
        () => st,
        'ZodLazy',
        () => uW,
        'ZodLiteral',
        () => uT,
        'ZodMap',
        () => ul,
        'ZodNaN',
        () => uk,
        'ZodNanoID',
        () => a1,
        'ZodNever',
        () => sz,
        'ZodNonOptional',
        () => uM,
        'ZodNull',
        () => sj,
        'ZodNullable',
        () => uI,
        'ZodNumber',
        () => sI,
        'ZodNumberFormat',
        () => sN,
        'ZodObject',
        () => s4,
        'ZodOptional',
        () => uR,
        'ZodPipe',
        () => uV,
        'ZodPrefault',
        () => uC,
        'ZodPromise',
        () => uz,
        'ZodReadonly',
        () => uj,
        'ZodRealError',
        () => ay,
        'ZodRecord',
        () => ua,
        'ZodSet',
        () => ud,
        'ZodString',
        () => aG,
        'ZodStringFormat',
        () => a$,
        'ZodSuccess',
        () => uU,
        'ZodSymbol',
        () => sV,
        'ZodTemplateLiteral',
        () => uZ,
        'ZodTransform',
        () => uh,
        'ZodTuple',
        () => ui,
        'ZodType',
        () => aw,
        'ZodULID',
        () => a6,
        'ZodURL',
        () => aX,
        'ZodUUID',
        () => aZ,
        'ZodUndefined',
        () => sB,
        'ZodUnion',
        () => s7,
        'ZodUnknown',
        () => sW,
        'ZodVoid',
        () => sJ,
        'ZodXID',
        () => a8,
        '_ZodString',
        () => ak,
        '_default',
        () => uv,
        '_function',
        () => uQ,
        'any',
        () => sY,
        'array',
        () => s2,
        'base64',
        () => sp,
        'base64url',
        () => sS,
        'bigint',
        () => sx,
        'boolean',
        () => sU,
        'catch',
        () => uw,
        'check',
        () => u0,
        'cidrv4',
        () => su,
        'cidrv6',
        () => sc,
        'clone',
        () => j,
        'codec',
        () => uH,
        'coerce',
        () => lu,
        'config',
        () => c,
        'core',
        () => ac,
        'cuid',
        () => a4,
        'cuid2',
        () => a3,
        'custom',
        () => u1,
        'date',
        () => s0,
        'decode',
        () => aC,
        'decodeAsync',
        () => aM,
        'discriminatedUnion',
        () => ut,
        'e164',
        () => sT,
        'email',
        () => aH,
        'emoji',
        () => a0,
        'encode',
        () => av,
        'encodeAsync',
        () => aP,
        'endsWith',
        () => oU,
        'enum',
        () => uS,
        'file',
        () => uf,
        'flattenError',
        () => eR,
        'float32',
        () => sv,
        'float64',
        () => sC,
        'formatError',
        () => ey,
        'function',
        () => uQ,
        'getErrorMap',
        () => le,
        'globalRegistry',
        () => iI,
        'gt',
        () => oE,
        'gte',
        () => oT,
        'guid',
        () => aF,
        'hash',
        () => sy,
        'hex',
        () => sR,
        'hostname',
        () => sA,
        'httpUrl',
        () => aQ,
        'includes',
        () => oM,
        'instanceof',
        () => u4,
        'int',
        () => sO,
        'int32',
        () => sP,
        'int64',
        () => sk,
        'intersection',
        () => ur,
        'ipv4',
        () => si,
        'ipv6',
        () => sa,
        'iso',
        () => ln,
        'json',
        () => u3,
        'jwt',
        () => sg,
        'keyof',
        () => s5,
        'ksuid',
        () => sn,
        'lazy',
        () => uK,
        'length',
        () => oO,
        'literal',
        () => um,
        'locales',
        () => lt,
        'looseObject',
        () => s6,
        'lowercase',
        () => oC,
        'lt',
        () => o_,
        'lte',
        () => oS,
        'map',
        () => uc,
        'maxLength',
        () => ob,
        'maxSize',
        () => oR,
        'mime',
        () => ox,
        'minLength',
        () => oN,
        'minSize',
        () => oy,
        'multipleOf',
        () => oA,
        'nan',
        () => uG,
        'nanoid',
        () => a2,
        'nativeEnum',
        () => uE,
        'negative',
        () => og,
        'never',
        () => sX,
        'nonnegative',
        () => oh,
        'nonoptional',
        () => uL,
        'nonpositive',
        () => of,
        'normalize',
        () => ok,
        'null',
        () => sF,
        'nullable',
        () => ub,
        'nullish',
        () => uN,
        'number',
        () => sb,
        'object',
        () => s9,
        'optional',
        () => uy,
        'overwrite',
        () => ow,
        'parse',
        () => aI,
        'parseAsync',
        () => ab,
        'partialRecord',
        () => uu,
        'pipe',
        () => u$,
        'positive',
        () => om,
        'prefault',
        () => uP,
        'preprocess',
        () => u6,
        'prettifyError',
        () => eN,
        'promise',
        () => uX,
        'property',
        () => oD,
        'readonly',
        () => uF,
        'record',
        () => us,
        'refine',
        () => u2,
        'regex',
        () => ov,
        'regexes',
        () => ad,
        'registry',
        () => iy,
        'safeDecode',
        () => aU,
        'safeDecodeAsync',
        () => ax,
        'safeEncode',
        () => aL,
        'safeEncodeAsync',
        () => aD,
        'safeParse',
        () => aN,
        'safeParseAsync',
        () => aO,
        'set',
        () => up,
        'setErrorMap',
        () => u8,
        'size',
        () => oI,
        'startsWith',
        () => oL,
        'strictObject',
        () => s3,
        'string',
        () => aV,
        'stringFormat',
        () => sh,
        'stringbool',
        () => u9,
        'success',
        () => uD,
        'superRefine',
        () => u5,
        'symbol',
        () => s$,
        'templateLiteral',
        () => uY,
        'toJSONSchema',
        () => au,
        'toLowerCase',
        () => oV,
        'toUpperCase',
        () => o$,
        'transform',
        () => uA,
        'treeifyError',
        () => eI,
        'trim',
        () => oG,
        'tuple',
        () => uo,
        'uint32',
        () => sM,
        'uint64',
        () => sG,
        'ulid',
        () => a7,
        'undefined',
        () => sH,
        'union',
        () => s8,
        'unknown',
        () => sK,
        'uppercase',
        () => oP,
        'url',
        () => aJ,
        'util',
        () => ap,
        'uuid',
        () => aY,
        'uuidv4',
        () => aW,
        'uuidv6',
        () => aK,
        'uuidv7',
        () => az,
        'void',
        () => sQ,
        'xid',
        () => se,
      ],
      4542
    ),
      e.s([], 52439),
      e.s(
        [
          '$ZodAsyncError',
          () => s,
          '$ZodEncodeError',
          () => u,
          '$brand',
          () => a,
          '$constructor',
          () => o,
          'NEVER',
          () => i,
          'config',
          () => c,
          'globalConfig',
          () => l,
        ],
        97423
      ));
    let i = Object.freeze({ status: 'aborted' });
    function o(e, t, n) {
      function r(n, r) {
        var i;
        for (let o in (Object.defineProperty(n, '_zod', { value: n._zod ?? {}, enumerable: !1 }),
        (i = n._zod).traits ?? (i.traits = new Set()),
        n._zod.traits.add(e),
        t(n, r),
        a.prototype))
          o in n || Object.defineProperty(n, o, { value: a.prototype[o].bind(n) });
        ((n._zod.constr = a), (n._zod.def = r));
      }
      let i = n?.Parent ?? Object;
      class o extends i {}
      function a(e) {
        var t;
        let i = n?.Parent ? new o() : this;
        for (let n of (r(i, e), (t = i._zod).deferred ?? (t.deferred = []), i._zod.deferred)) n();
        return i;
      }
      return (
        Object.defineProperty(o, 'name', { value: e }),
        Object.defineProperty(a, 'init', { value: r }),
        Object.defineProperty(a, Symbol.hasInstance, {
          value: (t) => (!!n?.Parent && t instanceof n.Parent) || t?._zod?.traits?.has(e),
        }),
        Object.defineProperty(a, 'name', { value: e }),
        a
      );
    }
    let a = Symbol('zod_brand');
    class s extends Error {
      constructor() {
        super('Encountered Promise during synchronous parse. Use .parseAsync() instead.');
      }
    }
    class u extends Error {
      constructor(e) {
        (super(`Encountered unidirectional transform during encode: ${e}`),
          (this.name = 'ZodEncodeError'));
      }
    }
    let l = {};
    function c(e) {
      return (e && Object.assign(l, e), l);
    }
    function d(e) {
      return e;
    }
    function p(e) {
      return e;
    }
    function _(e) {}
    function S(e) {
      throw Error();
    }
    function E(e) {}
    function T(e) {
      let t = Object.values(e).filter((e) => 'number' == typeof e);
      return Object.entries(e)
        .filter(([e, n]) => -1 === t.indexOf(+e))
        .map(([e, t]) => t);
    }
    function m(e, t = '|') {
      return e.map((e) => Y(e)).join(t);
    }
    function g(e, t) {
      return 'bigint' == typeof t ? t.toString() : t;
    }
    function f(e) {
      return {
        get value() {
          {
            let t = e();
            return (Object.defineProperty(this, 'value', { value: t }), t);
          }
        },
      };
    }
    function h(e) {
      return null == e;
    }
    function A(e) {
      let t = +!!e.startsWith('^'),
        n = e.endsWith('$') ? e.length - 1 : e.length;
      return e.slice(t, n);
    }
    function R(e, t) {
      let n = (e.toString().split('.')[1] || '').length,
        r = t.toString(),
        i = (r.split('.')[1] || '').length;
      if (0 === i && /\d?e-\d?/.test(r)) {
        let e = r.match(/\d?e-(\d?)/);
        e?.[1] && (i = Number.parseInt(e[1]));
      }
      let o = n > i ? n : i;
      return (
        (Number.parseInt(e.toFixed(o).replace('.', '')) %
          Number.parseInt(t.toFixed(o).replace('.', ''))) /
        10 ** o
      );
    }
    e.s(
      [
        'BIGINT_FORMAT_RANGES',
        () => z,
        'Class',
        () => em,
        'NUMBER_FORMAT_RANGES',
        () => K,
        'aborted',
        () => er,
        'allowsEval',
        () => x,
        'assert',
        () => E,
        'assertEqual',
        () => d,
        'assertIs',
        () => _,
        'assertNever',
        () => S,
        'assertNotEqual',
        () => p,
        'assignProp',
        () => N,
        'base64ToUint8Array',
        () => ed,
        'base64urlToUint8Array',
        () => e_,
        'cached',
        () => f,
        'captureStackTrace',
        () => U,
        'cleanEnum',
        () => ec,
        'cleanRegex',
        () => A,
        'clone',
        () => j,
        'cloneDef',
        () => v,
        'createTransparentProxy',
        () => Z,
        'defineLazy',
        () => I,
        'esc',
        () => L,
        'escapeRegex',
        () => H,
        'extend',
        () => Q,
        'finalizeIssue',
        () => ea,
        'floatSafeRemainder',
        () => R,
        'getElementAtPath',
        () => C,
        'getEnumValues',
        () => T,
        'getLengthableOrigin',
        () => eu,
        'getParsedType',
        () => V,
        'getSizableOrigin',
        () => es,
        'hexToUint8Array',
        () => eE,
        'isObject',
        () => D,
        'isPlainObject',
        () => w,
        'issue',
        () => el,
        'joinValues',
        () => m,
        'jsonStringifyReplacer',
        () => g,
        'merge',
        () => ee,
        'mergeDefs',
        () => O,
        'normalizeParams',
        () => F,
        'nullish',
        () => h,
        'numKeys',
        () => G,
        'objectClone',
        () => b,
        'omit',
        () => J,
        'optionalKeys',
        () => W,
        'partial',
        () => et,
        'pick',
        () => X,
        'prefixIssues',
        () => ei,
        'primitiveTypes',
        () => B,
        'promiseAllObject',
        () => P,
        'propertyKeyTypes',
        () => $,
        'randomString',
        () => M,
        'required',
        () => en,
        'safeExtend',
        () => q,
        'shallowClone',
        () => k,
        'stringifyPrimitive',
        () => Y,
        'uint8ArrayToBase64',
        () => ep,
        'uint8ArrayToBase64url',
        () => eS,
        'uint8ArrayToHex',
        () => eT,
        'unwrapMessage',
        () => eo,
      ],
      42540
    );
    let y = Symbol('evaluating');
    function I(e, t, n) {
      let r;
      Object.defineProperty(e, t, {
        get() {
          if (r !== y) return (void 0 === r && ((r = y), (r = n())), r);
        },
        set(n) {
          Object.defineProperty(e, t, { value: n });
        },
        configurable: !0,
      });
    }
    function b(e) {
      return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
    }
    function N(e, t, n) {
      Object.defineProperty(e, t, { value: n, writable: !0, enumerable: !0, configurable: !0 });
    }
    function O(...e) {
      let t = {};
      for (let n of e) Object.assign(t, Object.getOwnPropertyDescriptors(n));
      return Object.defineProperties({}, t);
    }
    function v(e) {
      return O(e._zod.def);
    }
    function C(e, t) {
      return t ? t.reduce((e, t) => e?.[t], e) : e;
    }
    function P(e) {
      let t = Object.keys(e);
      return Promise.all(t.map((t) => e[t])).then((e) => {
        let n = {};
        for (let r = 0; r < t.length; r++) n[t[r]] = e[r];
        return n;
      });
    }
    function M(e = 10) {
      let t = 'abcdefghijklmnopqrstuvwxyz',
        n = '';
      for (let r = 0; r < e; r++) n += t[Math.floor(Math.random() * t.length)];
      return n;
    }
    function L(e) {
      return JSON.stringify(e);
    }
    let U = 'captureStackTrace' in Error ? Error.captureStackTrace : (...e) => {};
    function D(e) {
      return 'object' == typeof e && null !== e && !Array.isArray(e);
    }
    let x = f(() => {
      if ('undefined' != typeof navigator && navigator?.userAgent?.includes('Cloudflare'))
        return !1;
      try {
        return (Function(''), !0);
      } catch (e) {
        return !1;
      }
    });
    function w(e) {
      if (!1 === D(e)) return !1;
      let t = e.constructor;
      if (void 0 === t) return !0;
      let n = t.prototype;
      return !1 !== D(n) && !1 !== Object.prototype.hasOwnProperty.call(n, 'isPrototypeOf');
    }
    function k(e) {
      return w(e) ? { ...e } : e;
    }
    function G(e) {
      let t = 0;
      for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && t++;
      return t;
    }
    let V = (e) => {
        let t = typeof e;
        switch (t) {
          case 'undefined':
            return 'undefined';
          case 'string':
            return 'string';
          case 'number':
            return Number.isNaN(e) ? 'nan' : 'number';
          case 'boolean':
            return 'boolean';
          case 'function':
            return 'function';
          case 'bigint':
            return 'bigint';
          case 'symbol':
            return 'symbol';
          case 'object':
            if (Array.isArray(e)) return 'array';
            if (null === e) return 'null';
            if (e.then && 'function' == typeof e.then && e.catch && 'function' == typeof e.catch)
              return 'promise';
            if ('undefined' != typeof Map && e instanceof Map) return 'map';
            if ('undefined' != typeof Set && e instanceof Set) return 'set';
            if ('undefined' != typeof Date && e instanceof Date) return 'date';
            if ('undefined' != typeof File && e instanceof File) return 'file';
            return 'object';
          default:
            throw Error(`Unknown data type: ${t}`);
        }
      },
      $ = new Set(['string', 'number', 'symbol']),
      B = new Set(['string', 'number', 'bigint', 'boolean', 'symbol', 'undefined']);
    function H(e) {
      return e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function j(e, t, n) {
      let r = new e._zod.constr(t ?? e._zod.def);
      return ((!t || n?.parent) && (r._zod.parent = e), r);
    }
    function F(e) {
      if (!e) return {};
      if ('string' == typeof e) return { error: () => e };
      if (e?.message !== void 0) {
        if (e?.error !== void 0) throw Error('Cannot specify both `message` and `error` params');
        e.error = e.message;
      }
      return (delete e.message, 'string' == typeof e.error) ? { ...e, error: () => e.error } : e;
    }
    function Z(e) {
      let t;
      return new Proxy(
        {},
        {
          get: (n, r, i) => (t ?? (t = e()), Reflect.get(t, r, i)),
          set: (n, r, i, o) => (t ?? (t = e()), Reflect.set(t, r, i, o)),
          has: (n, r) => (t ?? (t = e()), Reflect.has(t, r)),
          deleteProperty: (n, r) => (t ?? (t = e()), Reflect.deleteProperty(t, r)),
          ownKeys: (n) => (t ?? (t = e()), Reflect.ownKeys(t)),
          getOwnPropertyDescriptor: (n, r) => (
            t ?? (t = e()),
            Reflect.getOwnPropertyDescriptor(t, r)
          ),
          defineProperty: (n, r, i) => (t ?? (t = e()), Reflect.defineProperty(t, r, i)),
        }
      );
    }
    function Y(e) {
      return 'bigint' == typeof e ? e.toString() + 'n' : 'string' == typeof e ? `"${e}"` : `${e}`;
    }
    function W(e) {
      return Object.keys(e).filter(
        (t) => 'optional' === e[t]._zod.optin && 'optional' === e[t]._zod.optout
      );
    }
    let K = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-0x80000000, 0x7fffffff],
        uint32: [0, 0xffffffff],
        float32: [-34028234663852886e22, 34028234663852886e22],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
      },
      z = {
        int64: [BigInt('-9223372036854775808'), BigInt('9223372036854775807')],
        uint64: [BigInt(0), BigInt('18446744073709551615')],
      };
    function X(e, t) {
      let n = e._zod.def,
        r = O(e._zod.def, {
          get shape() {
            let e = {};
            for (let r in t) {
              if (!(r in n.shape)) throw Error(`Unrecognized key: "${r}"`);
              t[r] && (e[r] = n.shape[r]);
            }
            return (N(this, 'shape', e), e);
          },
          checks: [],
        });
      return j(e, r);
    }
    function J(e, t) {
      let n = e._zod.def,
        r = O(e._zod.def, {
          get shape() {
            let r = { ...e._zod.def.shape };
            for (let e in t) {
              if (!(e in n.shape)) throw Error(`Unrecognized key: "${e}"`);
              t[e] && delete r[e];
            }
            return (N(this, 'shape', r), r);
          },
          checks: [],
        });
      return j(e, r);
    }
    function Q(e, t) {
      if (!w(t)) throw Error('Invalid input to extend: expected a plain object');
      let n = e._zod.def.checks;
      if (n && n.length > 0)
        throw Error(
          'Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.'
        );
      let r = O(e._zod.def, {
        get shape() {
          let n = { ...e._zod.def.shape, ...t };
          return (N(this, 'shape', n), n);
        },
        checks: [],
      });
      return j(e, r);
    }
    function q(e, t) {
      if (!w(t)) throw Error('Invalid input to safeExtend: expected a plain object');
      let n = {
        ...e._zod.def,
        get shape() {
          let n = { ...e._zod.def.shape, ...t };
          return (N(this, 'shape', n), n);
        },
        checks: e._zod.def.checks,
      };
      return j(e, n);
    }
    function ee(e, t) {
      let n = O(e._zod.def, {
        get shape() {
          let n = { ...e._zod.def.shape, ...t._zod.def.shape };
          return (N(this, 'shape', n), n);
        },
        get catchall() {
          return t._zod.def.catchall;
        },
        checks: [],
      });
      return j(e, n);
    }
    function et(e, t, n) {
      let r = O(t._zod.def, {
        get shape() {
          let r = t._zod.def.shape,
            i = { ...r };
          if (n)
            for (let t in n) {
              if (!(t in r)) throw Error(`Unrecognized key: "${t}"`);
              n[t] && (i[t] = e ? new e({ type: 'optional', innerType: r[t] }) : r[t]);
            }
          else for (let t in r) i[t] = e ? new e({ type: 'optional', innerType: r[t] }) : r[t];
          return (N(this, 'shape', i), i);
        },
        checks: [],
      });
      return j(t, r);
    }
    function en(e, t, n) {
      let r = O(t._zod.def, {
        get shape() {
          let r = t._zod.def.shape,
            i = { ...r };
          if (n)
            for (let t in n) {
              if (!(t in i)) throw Error(`Unrecognized key: "${t}"`);
              n[t] && (i[t] = new e({ type: 'nonoptional', innerType: r[t] }));
            }
          else for (let t in r) i[t] = new e({ type: 'nonoptional', innerType: r[t] });
          return (N(this, 'shape', i), i);
        },
        checks: [],
      });
      return j(t, r);
    }
    function er(e, t = 0) {
      if (!0 === e.aborted) return !0;
      for (let n = t; n < e.issues.length; n++) if (e.issues[n]?.continue !== !0) return !0;
      return !1;
    }
    function ei(e, t) {
      return t.map((t) => (t.path ?? (t.path = []), t.path.unshift(e), t));
    }
    function eo(e) {
      return 'string' == typeof e ? e : e?.message;
    }
    function ea(e, t, n) {
      let r = { ...e, path: e.path ?? [] };
      return (
        e.message ||
          (r.message =
            eo(e.inst?._zod.def?.error?.(e)) ??
            eo(t?.error?.(e)) ??
            eo(n.customError?.(e)) ??
            eo(n.localeError?.(e)) ??
            'Invalid input'),
        delete r.inst,
        delete r.continue,
        t?.reportInput || delete r.input,
        r
      );
    }
    function es(e) {
      return e instanceof Set
        ? 'set'
        : e instanceof Map
          ? 'map'
          : e instanceof File
            ? 'file'
            : 'unknown';
    }
    function eu(e) {
      return Array.isArray(e) ? 'array' : 'string' == typeof e ? 'string' : 'unknown';
    }
    function el(...e) {
      let [t, n, r] = e;
      return 'string' == typeof t ? { message: t, code: 'custom', input: n, inst: r } : { ...t };
    }
    function ec(e) {
      return Object.entries(e)
        .filter(([e, t]) => Number.isNaN(Number.parseInt(e, 10)))
        .map((e) => e[1]);
    }
    function ed(e) {
      let t = atob(e),
        n = new Uint8Array(t.length);
      for (let e = 0; e < t.length; e++) n[e] = t.charCodeAt(e);
      return n;
    }
    function ep(e) {
      let t = '';
      for (let n = 0; n < e.length; n++) t += String.fromCharCode(e[n]);
      return btoa(t);
    }
    function e_(e) {
      let t = e.replace(/-/g, '+').replace(/_/g, '/'),
        n = '='.repeat((4 - (t.length % 4)) % 4);
      return ed(t + n);
    }
    function eS(e) {
      return ep(e).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    function eE(e) {
      let t = e.replace(/^0x/, '');
      if (t.length % 2 != 0) throw Error('Invalid hex string length');
      let n = new Uint8Array(t.length / 2);
      for (let e = 0; e < t.length; e += 2) n[e / 2] = Number.parseInt(t.slice(e, e + 2), 16);
      return n;
    }
    function eT(e) {
      return Array.from(e)
        .map((e) => e.toString(16).padStart(2, '0'))
        .join('');
    }
    class em {
      constructor(...e) {}
    }
    function eg() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'characters', verb: 'to have' },
              file: { unit: 'bytes', verb: 'to have' },
              array: { unit: 'items', verb: 'to have' },
              set: { unit: 'items', verb: 'to have' },
            },
            t = {
              regex: 'input',
              email: 'email address',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datetime',
              date: 'ISO date',
              time: 'ISO time',
              duration: 'ISO duration',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded string',
              base64url: 'base64url-encoded string',
              json_string: 'JSON string',
              e164: 'E.164 number',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Invalid input: expected ${n.expected}, received ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Invalid input: expected ${Y(n.values[0])}`;
                return `Invalid option: expected one of ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Too big: expected ${n.origin ?? 'value'} to have ${t}${n.maximum.toString()} ${r.unit ?? 'elements'}`;
                return `Too big: expected ${n.origin ?? 'value'} to be ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Too small: expected ${n.origin} to have ${t}${n.minimum.toString()} ${r.unit}`;
                return `Too small: expected ${n.origin} to be ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Invalid string: must start with "${n.prefix}"`;
                if ('ends_with' === n.format) return `Invalid string: must end with "${n.suffix}"`;
                if ('includes' === n.format) return `Invalid string: must include "${n.includes}"`;
                if ('regex' === n.format) return `Invalid string: must match pattern ${n.pattern}`;
                return `Invalid ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Invalid number: must be a multiple of ${n.divisor}`;
              case 'unrecognized_keys':
                return `Unrecognized key${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Invalid key in ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Invalid input';
              case 'invalid_element':
                return `Invalid value in ${n.origin}`;
            }
          };
        })(),
      };
    }
    (c(eg()),
      e.i(52439),
      e.s(
        [
          '$ZodAny',
          () => nK,
          '$ZodArray',
          () => n0,
          '$ZodAsyncError',
          () => s,
          '$ZodBase64',
          () => nU,
          '$ZodBase64URL',
          () => nx,
          '$ZodBigInt',
          () => nj,
          '$ZodBigIntFormat',
          () => nF,
          '$ZodBoolean',
          () => nH,
          '$ZodCIDRv4',
          () => nP,
          '$ZodCIDRv6',
          () => nM,
          '$ZodCUID',
          () => nf,
          '$ZodCUID2',
          () => nh,
          '$ZodCatch',
          () => rA,
          '$ZodCheck',
          () => tK,
          '$ZodCheckBigIntFormat',
          () => t0,
          '$ZodCheckEndsWith',
          () => nr,
          '$ZodCheckGreaterThan',
          () => tJ,
          '$ZodCheckIncludes',
          () => nt,
          '$ZodCheckLengthEquals',
          () => t3,
          '$ZodCheckLessThan',
          () => tX,
          '$ZodCheckLowerCase',
          () => t8,
          '$ZodCheckMaxLength',
          () => t4,
          '$ZodCheckMaxSize',
          () => t1,
          '$ZodCheckMimeType',
          () => na,
          '$ZodCheckMinLength',
          () => t9,
          '$ZodCheckMinSize',
          () => t2,
          '$ZodCheckMultipleOf',
          () => tQ,
          '$ZodCheckNumberFormat',
          () => tq,
          '$ZodCheckOverwrite',
          () => ns,
          '$ZodCheckProperty',
          () => no,
          '$ZodCheckRegex',
          () => t7,
          '$ZodCheckSizeEquals',
          () => t5,
          '$ZodCheckStartsWith',
          () => nn,
          '$ZodCheckStringFormat',
          () => t6,
          '$ZodCheckUpperCase',
          () => ne,
          '$ZodCodec',
          () => rb,
          '$ZodCustom',
          () => rD,
          '$ZodCustomStringFormat',
          () => nV,
          '$ZodDate',
          () => nQ,
          '$ZodDefault',
          () => rE,
          '$ZodDiscriminatedUnion',
          () => n7,
          '$ZodE164',
          () => nw,
          '$ZodEmail',
          () => nE,
          '$ZodEmoji',
          () => nm,
          '$ZodEncodeError',
          () => u,
          '$ZodEnum',
          () => ru,
          '$ZodError',
          () => eh,
          '$ZodFile',
          () => rc,
          '$ZodFunction',
          () => rM,
          '$ZodGUID',
          () => n_,
          '$ZodIPv4',
          () => nv,
          '$ZodIPv6',
          () => nC,
          '$ZodISODate',
          () => nb,
          '$ZodISODateTime',
          () => nI,
          '$ZodISODuration',
          () => nO,
          '$ZodISOTime',
          () => nN,
          '$ZodIntersection',
          () => n8,
          '$ZodJWT',
          () => nG,
          '$ZodKSUID',
          () => ny,
          '$ZodLazy',
          () => rU,
          '$ZodLiteral',
          () => rl,
          '$ZodMap',
          () => ri,
          '$ZodNaN',
          () => rR,
          '$ZodNanoID',
          () => ng,
          '$ZodNever',
          () => nX,
          '$ZodNonOptional',
          () => rg,
          '$ZodNull',
          () => nW,
          '$ZodNullable',
          () => rS,
          '$ZodNumber',
          () => n$,
          '$ZodNumberFormat',
          () => nB,
          '$ZodObject',
          () => n4,
          '$ZodObjectJIT',
          () => n9,
          '$ZodOptional',
          () => r_,
          '$ZodPipe',
          () => ry,
          '$ZodPrefault',
          () => rm,
          '$ZodPromise',
          () => rL,
          '$ZodReadonly',
          () => rv,
          '$ZodRealError',
          () => eA,
          '$ZodRecord',
          () => rr,
          '$ZodRegistry',
          () => iR,
          '$ZodSet',
          () => ra,
          '$ZodString',
          () => nd,
          '$ZodStringFormat',
          () => np,
          '$ZodSuccess',
          () => rh,
          '$ZodSymbol',
          () => nZ,
          '$ZodTemplateLiteral',
          () => rP,
          '$ZodTransform',
          () => rd,
          '$ZodTuple',
          () => rt,
          '$ZodType',
          () => nc,
          '$ZodULID',
          () => nA,
          '$ZodURL',
          () => nT,
          '$ZodUUID',
          () => nS,
          '$ZodUndefined',
          () => nY,
          '$ZodUnion',
          () => n6,
          '$ZodUnknown',
          () => nz,
          '$ZodVoid',
          () => nJ,
          '$ZodXID',
          () => nR,
          '$brand',
          () => a,
          '$constructor',
          () => o,
          '$input',
          () => iA,
          '$output',
          () => ih,
          'Doc',
          () => nu,
          'JSONSchema',
          () => al,
          'JSONSchemaGenerator',
          () => as,
          'NEVER',
          () => i,
          'TimePrecision',
          () => iz,
          '_any',
          () => oa,
          '_array',
          () => oB,
          '_base64',
          () => iZ,
          '_base64url',
          () => iY,
          '_bigint',
          () => i8,
          '_boolean',
          () => i6,
          '_catch',
          () => o9,
          '_check',
          () => ai,
          '_cidrv4',
          () => ij,
          '_cidrv6',
          () => iF,
          '_coercedBigint',
          () => oe,
          '_coercedBoolean',
          () => i7,
          '_coercedDate',
          () => od,
          '_coercedNumber',
          () => i1,
          '_coercedString',
          () => iN,
          '_cuid',
          () => iw,
          '_cuid2',
          () => ik,
          '_custom',
          () => at,
          '_date',
          () => oc,
          '_decode',
          () => ek,
          '_decodeAsync',
          () => eB,
          '_default',
          () => o2,
          '_discriminatedUnion',
          () => oj,
          '_e164',
          () => iW,
          '_email',
          () => iO,
          '_emoji',
          () => iD,
          '_encode',
          () => ex,
          '_encodeAsync',
          () => eV,
          '_endsWith',
          () => oU,
          '_enum',
          () => oz,
          '_file',
          () => oQ,
          '_float32',
          () => i5,
          '_float64',
          () => i4,
          '_gt',
          () => oE,
          '_gte',
          () => oT,
          '_guid',
          () => iv,
          '_includes',
          () => oM,
          '_int',
          () => i2,
          '_int32',
          () => i9,
          '_int64',
          () => ot,
          '_intersection',
          () => oF,
          '_ipv4',
          () => iB,
          '_ipv6',
          () => iH,
          '_isoDate',
          () => iJ,
          '_isoDateTime',
          () => iX,
          '_isoDuration',
          () => iq,
          '_isoTime',
          () => iQ,
          '_jwt',
          () => iK,
          '_ksuid',
          () => i$,
          '_lazy',
          () => o8,
          '_length',
          () => oO,
          '_literal',
          () => oJ,
          '_lowercase',
          () => oC,
          '_lt',
          () => o_,
          '_lte',
          () => oS,
          '_map',
          () => oW,
          '_max',
          () => oS,
          '_maxLength',
          () => ob,
          '_maxSize',
          () => oR,
          '_mime',
          () => ox,
          '_min',
          () => oT,
          '_minLength',
          () => oN,
          '_minSize',
          () => oy,
          '_multipleOf',
          () => oA,
          '_nan',
          () => op,
          '_nanoid',
          () => ix,
          '_nativeEnum',
          () => oX,
          '_negative',
          () => og,
          '_never',
          () => ou,
          '_nonnegative',
          () => oh,
          '_nonoptional',
          () => o5,
          '_nonpositive',
          () => of,
          '_normalize',
          () => ok,
          '_null',
          () => oo,
          '_nullable',
          () => o1,
          '_number',
          () => i0,
          '_optional',
          () => o0,
          '_overwrite',
          () => ow,
          '_parse',
          () => eO,
          '_parseAsync',
          () => eC,
          '_pipe',
          () => o3,
          '_positive',
          () => om,
          '_promise',
          () => ae,
          '_property',
          () => oD,
          '_readonly',
          () => o6,
          '_record',
          () => oY,
          '_refine',
          () => an,
          '_regex',
          () => ov,
          '_safeDecode',
          () => eZ,
          '_safeDecodeAsync',
          () => ez,
          '_safeEncode',
          () => ej,
          '_safeEncodeAsync',
          () => eW,
          '_safeParse',
          () => eM,
          '_safeParseAsync',
          () => eU,
          '_set',
          () => oK,
          '_size',
          () => oI,
          '_startsWith',
          () => oL,
          '_string',
          () => ib,
          '_stringFormat',
          () => aa,
          '_stringbool',
          () => ao,
          '_success',
          () => o4,
          '_superRefine',
          () => ar,
          '_symbol',
          () => or,
          '_templateLiteral',
          () => o7,
          '_toLowerCase',
          () => oV,
          '_toUpperCase',
          () => o$,
          '_transform',
          () => oq,
          '_trim',
          () => oG,
          '_tuple',
          () => oZ,
          '_uint32',
          () => i3,
          '_uint64',
          () => on,
          '_ulid',
          () => iG,
          '_undefined',
          () => oi,
          '_union',
          () => oH,
          '_unknown',
          () => os,
          '_uppercase',
          () => oP,
          '_url',
          () => iU,
          '_uuid',
          () => iC,
          '_uuidv4',
          () => iP,
          '_uuidv6',
          () => iM,
          '_uuidv7',
          () => iL,
          '_void',
          () => ol,
          '_xid',
          () => iV,
          'clone',
          () => j,
          'config',
          () => c,
          'decode',
          () => eG,
          'decodeAsync',
          () => eH,
          'encode',
          () => ew,
          'encodeAsync',
          () => e$,
          'flattenError',
          () => eR,
          'formatError',
          () => ey,
          'globalConfig',
          () => l,
          'globalRegistry',
          () => iI,
          'isValidBase64',
          () => nL,
          'isValidBase64URL',
          () => nD,
          'isValidJWT',
          () => nk,
          'locales',
          () => ig,
          'parse',
          () => ev,
          'parseAsync',
          () => eP,
          'prettifyError',
          () => eN,
          'regexes',
          () => rk,
          'registry',
          () => iy,
          'safeDecode',
          () => eY,
          'safeDecodeAsync',
          () => eX,
          'safeEncode',
          () => eF,
          'safeEncodeAsync',
          () => eK,
          'safeParse',
          () => eL,
          'safeParseAsync',
          () => eD,
          'toDotPath',
          () => eb,
          'toJSONSchema',
          () => au,
          'treeifyError',
          () => eI,
          'util',
          () => rw,
          'version',
          () => nl,
        ],
        47392
      ),
      e.s([], 32004),
      e.i(32004),
      e.i(97423),
      e.s(
        [
          '_decode',
          () => ek,
          '_decodeAsync',
          () => eB,
          '_encode',
          () => ex,
          '_encodeAsync',
          () => eV,
          '_parse',
          () => eO,
          '_parseAsync',
          () => eC,
          '_safeDecode',
          () => eZ,
          '_safeDecodeAsync',
          () => ez,
          '_safeEncode',
          () => ej,
          '_safeEncodeAsync',
          () => eW,
          '_safeParse',
          () => eM,
          '_safeParseAsync',
          () => eU,
          'decode',
          () => eG,
          'decodeAsync',
          () => eH,
          'encode',
          () => ew,
          'encodeAsync',
          () => e$,
          'parse',
          () => ev,
          'parseAsync',
          () => eP,
          'safeDecode',
          () => eY,
          'safeDecodeAsync',
          () => eX,
          'safeEncode',
          () => eF,
          'safeEncodeAsync',
          () => eK,
          'safeParse',
          () => eL,
          'safeParseAsync',
          () => eD,
        ],
        10918
      ),
      e.s(
        [
          '$ZodError',
          () => eh,
          '$ZodRealError',
          () => eA,
          'flattenError',
          () => eR,
          'formatError',
          () => ey,
          'prettifyError',
          () => eN,
          'toDotPath',
          () => eb,
          'treeifyError',
          () => eI,
        ],
        32842
      ));
    let ef = (e, t) => {
        ((e.name = '$ZodError'),
          Object.defineProperty(e, '_zod', { value: e._zod, enumerable: !1 }),
          Object.defineProperty(e, 'issues', { value: t, enumerable: !1 }),
          (e.message = JSON.stringify(t, g, 2)),
          Object.defineProperty(e, 'toString', { value: () => e.message, enumerable: !1 }));
      },
      eh = o('$ZodError', ef),
      eA = o('$ZodError', ef, { Parent: Error });
    function eR(e, t = (e) => e.message) {
      let n = {},
        r = [];
      for (let i of e.issues)
        i.path.length > 0
          ? ((n[i.path[0]] = n[i.path[0]] || []), n[i.path[0]].push(t(i)))
          : r.push(t(i));
      return { formErrors: r, fieldErrors: n };
    }
    function ey(e, t) {
      let n =
          t ||
          function (e) {
            return e.message;
          },
        r = { _errors: [] },
        i = (e) => {
          for (let t of e.issues)
            if ('invalid_union' === t.code && t.errors.length)
              t.errors.map((e) => i({ issues: e }));
            else if ('invalid_key' === t.code) i({ issues: t.issues });
            else if ('invalid_element' === t.code) i({ issues: t.issues });
            else if (0 === t.path.length) r._errors.push(n(t));
            else {
              let e = r,
                i = 0;
              for (; i < t.path.length; ) {
                let r = t.path[i];
                (i === t.path.length - 1
                  ? ((e[r] = e[r] || { _errors: [] }), e[r]._errors.push(n(t)))
                  : (e[r] = e[r] || { _errors: [] }),
                  (e = e[r]),
                  i++);
              }
            }
        };
      return (i(e), r);
    }
    function eI(e, t) {
      let n =
          t ||
          function (e) {
            return e.message;
          },
        r = { errors: [] },
        i = (e, t = []) => {
          var o, a;
          for (let s of e.issues)
            if ('invalid_union' === s.code && s.errors.length)
              s.errors.map((e) => i({ issues: e }, s.path));
            else if ('invalid_key' === s.code) i({ issues: s.issues }, s.path);
            else if ('invalid_element' === s.code) i({ issues: s.issues }, s.path);
            else {
              let e = [...t, ...s.path];
              if (0 === e.length) {
                r.errors.push(n(s));
                continue;
              }
              let i = r,
                u = 0;
              for (; u < e.length; ) {
                let t = e[u],
                  r = u === e.length - 1;
                ('string' == typeof t
                  ? (i.properties ?? (i.properties = {}),
                    (o = i.properties)[t] ?? (o[t] = { errors: [] }),
                    (i = i.properties[t]))
                  : (i.items ?? (i.items = []),
                    (a = i.items)[t] ?? (a[t] = { errors: [] }),
                    (i = i.items[t])),
                  r && i.errors.push(n(s)),
                  u++);
              }
            }
        };
      return (i(e), r);
    }
    function eb(e) {
      let t = [];
      for (let n of e.map((e) => ('object' == typeof e ? e.key : e)))
        'number' == typeof n
          ? t.push(`[${n}]`)
          : 'symbol' == typeof n
            ? t.push(`[${JSON.stringify(String(n))}]`)
            : /[^\w$]/.test(n)
              ? t.push(`[${JSON.stringify(n)}]`)
              : (t.length && t.push('.'), t.push(n));
      return t.join('');
    }
    function eN(e) {
      let t = [];
      for (let n of [...e.issues].sort((e, t) => (e.path ?? []).length - (t.path ?? []).length))
        (t.push(`✖ ${n.message}`), n.path?.length && t.push(`  → at ${eb(n.path)}`));
      return t.join('\n');
    }
    let eO = (e) => (t, n, r, i) => {
        let o = r ? Object.assign(r, { async: !1 }) : { async: !1 },
          a = t._zod.run({ value: n, issues: [] }, o);
        if (a instanceof Promise) throw new s();
        if (a.issues.length) {
          let t = new (i?.Err ?? e)(a.issues.map((e) => ea(e, o, c())));
          throw (U(t, i?.callee), t);
        }
        return a.value;
      },
      ev = eO(eA),
      eC = (e) => async (t, n, r, i) => {
        let o = r ? Object.assign(r, { async: !0 }) : { async: !0 },
          a = t._zod.run({ value: n, issues: [] }, o);
        if ((a instanceof Promise && (a = await a), a.issues.length)) {
          let t = new (i?.Err ?? e)(a.issues.map((e) => ea(e, o, c())));
          throw (U(t, i?.callee), t);
        }
        return a.value;
      },
      eP = eC(eA),
      eM = (e) => (t, n, r) => {
        let i = r ? { ...r, async: !1 } : { async: !1 },
          o = t._zod.run({ value: n, issues: [] }, i);
        if (o instanceof Promise) throw new s();
        return o.issues.length
          ? { success: !1, error: new (e ?? eh)(o.issues.map((e) => ea(e, i, c()))) }
          : { success: !0, data: o.value };
      },
      eL = eM(eA),
      eU = (e) => async (t, n, r) => {
        let i = r ? Object.assign(r, { async: !0 }) : { async: !0 },
          o = t._zod.run({ value: n, issues: [] }, i);
        return (
          o instanceof Promise && (o = await o),
          o.issues.length
            ? { success: !1, error: new e(o.issues.map((e) => ea(e, i, c()))) }
            : { success: !0, data: o.value }
        );
      },
      eD = eU(eA),
      ex = (e) => (t, n, r) => {
        let i = r ? Object.assign(r, { direction: 'backward' }) : { direction: 'backward' };
        return eO(e)(t, n, i);
      },
      ew = ex(eA),
      ek = (e) => (t, n, r) => eO(e)(t, n, r),
      eG = ek(eA),
      eV = (e) => async (t, n, r) => {
        let i = r ? Object.assign(r, { direction: 'backward' }) : { direction: 'backward' };
        return eC(e)(t, n, i);
      },
      e$ = eV(eA),
      eB = (e) => async (t, n, r) => eC(e)(t, n, r),
      eH = eB(eA),
      ej = (e) => (t, n, r) => {
        let i = r ? Object.assign(r, { direction: 'backward' }) : { direction: 'backward' };
        return eM(e)(t, n, i);
      },
      eF = ej(eA),
      eZ = (e) => (t, n, r) => eM(e)(t, n, r),
      eY = eZ(eA),
      eW = (e) => async (t, n, r) => {
        let i = r ? Object.assign(r, { direction: 'backward' }) : { direction: 'backward' };
        return eU(e)(t, n, i);
      },
      eK = eW(eA),
      ez = (e) => async (t, n, r) => eU(e)(t, n, r),
      eX = ez(eA);
    (e.i(10918),
      e.i(32842),
      e.s(
        [
          '$ZodAny',
          () => nK,
          '$ZodArray',
          () => n0,
          '$ZodBase64',
          () => nU,
          '$ZodBase64URL',
          () => nx,
          '$ZodBigInt',
          () => nj,
          '$ZodBigIntFormat',
          () => nF,
          '$ZodBoolean',
          () => nH,
          '$ZodCIDRv4',
          () => nP,
          '$ZodCIDRv6',
          () => nM,
          '$ZodCUID',
          () => nf,
          '$ZodCUID2',
          () => nh,
          '$ZodCatch',
          () => rA,
          '$ZodCodec',
          () => rb,
          '$ZodCustom',
          () => rD,
          '$ZodCustomStringFormat',
          () => nV,
          '$ZodDate',
          () => nQ,
          '$ZodDefault',
          () => rE,
          '$ZodDiscriminatedUnion',
          () => n7,
          '$ZodE164',
          () => nw,
          '$ZodEmail',
          () => nE,
          '$ZodEmoji',
          () => nm,
          '$ZodEnum',
          () => ru,
          '$ZodFile',
          () => rc,
          '$ZodFunction',
          () => rM,
          '$ZodGUID',
          () => n_,
          '$ZodIPv4',
          () => nv,
          '$ZodIPv6',
          () => nC,
          '$ZodISODate',
          () => nb,
          '$ZodISODateTime',
          () => nI,
          '$ZodISODuration',
          () => nO,
          '$ZodISOTime',
          () => nN,
          '$ZodIntersection',
          () => n8,
          '$ZodJWT',
          () => nG,
          '$ZodKSUID',
          () => ny,
          '$ZodLazy',
          () => rU,
          '$ZodLiteral',
          () => rl,
          '$ZodMap',
          () => ri,
          '$ZodNaN',
          () => rR,
          '$ZodNanoID',
          () => ng,
          '$ZodNever',
          () => nX,
          '$ZodNonOptional',
          () => rg,
          '$ZodNull',
          () => nW,
          '$ZodNullable',
          () => rS,
          '$ZodNumber',
          () => n$,
          '$ZodNumberFormat',
          () => nB,
          '$ZodObject',
          () => n4,
          '$ZodObjectJIT',
          () => n9,
          '$ZodOptional',
          () => r_,
          '$ZodPipe',
          () => ry,
          '$ZodPrefault',
          () => rm,
          '$ZodPromise',
          () => rL,
          '$ZodReadonly',
          () => rv,
          '$ZodRecord',
          () => rr,
          '$ZodSet',
          () => ra,
          '$ZodString',
          () => nd,
          '$ZodStringFormat',
          () => np,
          '$ZodSuccess',
          () => rh,
          '$ZodSymbol',
          () => nZ,
          '$ZodTemplateLiteral',
          () => rP,
          '$ZodTransform',
          () => rd,
          '$ZodTuple',
          () => rt,
          '$ZodType',
          () => nc,
          '$ZodULID',
          () => nA,
          '$ZodURL',
          () => nT,
          '$ZodUUID',
          () => nS,
          '$ZodUndefined',
          () => nY,
          '$ZodUnion',
          () => n6,
          '$ZodUnknown',
          () => nz,
          '$ZodVoid',
          () => nJ,
          '$ZodXID',
          () => nR,
          'clone',
          () => j,
          'isValidBase64',
          () => nL,
          'isValidBase64URL',
          () => nD,
          'isValidJWT',
          () => nk,
        ],
        3177
      ),
      e.s(
        [
          '$ZodAny',
          () => nK,
          '$ZodArray',
          () => n0,
          '$ZodBase64',
          () => nU,
          '$ZodBase64URL',
          () => nx,
          '$ZodBigInt',
          () => nj,
          '$ZodBigIntFormat',
          () => nF,
          '$ZodBoolean',
          () => nH,
          '$ZodCIDRv4',
          () => nP,
          '$ZodCIDRv6',
          () => nM,
          '$ZodCUID',
          () => nf,
          '$ZodCUID2',
          () => nh,
          '$ZodCatch',
          () => rA,
          '$ZodCodec',
          () => rb,
          '$ZodCustom',
          () => rD,
          '$ZodCustomStringFormat',
          () => nV,
          '$ZodDate',
          () => nQ,
          '$ZodDefault',
          () => rE,
          '$ZodDiscriminatedUnion',
          () => n7,
          '$ZodE164',
          () => nw,
          '$ZodEmail',
          () => nE,
          '$ZodEmoji',
          () => nm,
          '$ZodEnum',
          () => ru,
          '$ZodFile',
          () => rc,
          '$ZodFunction',
          () => rM,
          '$ZodGUID',
          () => n_,
          '$ZodIPv4',
          () => nv,
          '$ZodIPv6',
          () => nC,
          '$ZodISODate',
          () => nb,
          '$ZodISODateTime',
          () => nI,
          '$ZodISODuration',
          () => nO,
          '$ZodISOTime',
          () => nN,
          '$ZodIntersection',
          () => n8,
          '$ZodJWT',
          () => nG,
          '$ZodKSUID',
          () => ny,
          '$ZodLazy',
          () => rU,
          '$ZodLiteral',
          () => rl,
          '$ZodMap',
          () => ri,
          '$ZodNaN',
          () => rR,
          '$ZodNanoID',
          () => ng,
          '$ZodNever',
          () => nX,
          '$ZodNonOptional',
          () => rg,
          '$ZodNull',
          () => nW,
          '$ZodNullable',
          () => rS,
          '$ZodNumber',
          () => n$,
          '$ZodNumberFormat',
          () => nB,
          '$ZodObject',
          () => n4,
          '$ZodObjectJIT',
          () => n9,
          '$ZodOptional',
          () => r_,
          '$ZodPipe',
          () => ry,
          '$ZodPrefault',
          () => rm,
          '$ZodPromise',
          () => rL,
          '$ZodReadonly',
          () => rv,
          '$ZodRecord',
          () => rr,
          '$ZodSet',
          () => ra,
          '$ZodString',
          () => nd,
          '$ZodStringFormat',
          () => np,
          '$ZodSuccess',
          () => rh,
          '$ZodSymbol',
          () => nZ,
          '$ZodTemplateLiteral',
          () => rP,
          '$ZodTransform',
          () => rd,
          '$ZodTuple',
          () => rt,
          '$ZodType',
          () => nc,
          '$ZodULID',
          () => nA,
          '$ZodURL',
          () => nT,
          '$ZodUUID',
          () => nS,
          '$ZodUndefined',
          () => nY,
          '$ZodUnion',
          () => n6,
          '$ZodUnknown',
          () => nz,
          '$ZodVoid',
          () => nJ,
          '$ZodXID',
          () => nR,
          'isValidBase64',
          () => nL,
          'isValidBase64URL',
          () => nD,
          'isValidJWT',
          () => nk,
        ],
        16663
      ),
      e.s(
        [
          '$ZodCheck',
          () => tK,
          '$ZodCheckBigIntFormat',
          () => t0,
          '$ZodCheckEndsWith',
          () => nr,
          '$ZodCheckGreaterThan',
          () => tJ,
          '$ZodCheckIncludes',
          () => nt,
          '$ZodCheckLengthEquals',
          () => t3,
          '$ZodCheckLessThan',
          () => tX,
          '$ZodCheckLowerCase',
          () => t8,
          '$ZodCheckMaxLength',
          () => t4,
          '$ZodCheckMaxSize',
          () => t1,
          '$ZodCheckMimeType',
          () => na,
          '$ZodCheckMinLength',
          () => t9,
          '$ZodCheckMinSize',
          () => t2,
          '$ZodCheckMultipleOf',
          () => tQ,
          '$ZodCheckNumberFormat',
          () => tq,
          '$ZodCheckOverwrite',
          () => ns,
          '$ZodCheckProperty',
          () => no,
          '$ZodCheckRegex',
          () => t7,
          '$ZodCheckSizeEquals',
          () => t5,
          '$ZodCheckStartsWith',
          () => nn,
          '$ZodCheckStringFormat',
          () => t6,
          '$ZodCheckUpperCase',
          () => ne,
        ],
        66089
      ),
      e.s(
        [
          'base64',
          () => td,
          'base64url',
          () => tp,
          'bigint',
          () => tR,
          'boolean',
          () => tb,
          'browserEmail',
          () => to,
          'cidrv4',
          () => tl,
          'cidrv6',
          () => tc,
          'cuid',
          () => eJ,
          'cuid2',
          () => eQ,
          'date',
          () => tm,
          'datetime',
          () => th,
          'domain',
          () => tS,
          'duration',
          () => e5,
          'e164',
          () => tE,
          'email',
          () => te,
          'emoji',
          () => ta,
          'extendedDuration',
          () => e4,
          'guid',
          () => e9,
          'hex',
          () => tP,
          'hostname',
          () => t_,
          'html5Email',
          () => tt,
          'idnEmail',
          () => ti,
          'integer',
          () => ty,
          'ipv4',
          () => ts,
          'ipv6',
          () => tu,
          'ksuid',
          () => e1,
          'lowercase',
          () => tv,
          'md5_base64',
          () => tD,
          'md5_base64url',
          () => tx,
          'md5_hex',
          () => tU,
          'nanoid',
          () => e2,
          'null',
          () => tN,
          'number',
          () => tI,
          'rfc5322Email',
          () => tn,
          'sha1_base64',
          () => tk,
          'sha1_base64url',
          () => tG,
          'sha1_hex',
          () => tw,
          'sha256_base64',
          () => t$,
          'sha256_base64url',
          () => tB,
          'sha256_hex',
          () => tV,
          'sha384_base64',
          () => tj,
          'sha384_base64url',
          () => tF,
          'sha384_hex',
          () => tH,
          'sha512_base64',
          () => tY,
          'sha512_base64url',
          () => tW,
          'sha512_hex',
          () => tZ,
          'string',
          () => tA,
          'time',
          () => tf,
          'ulid',
          () => eq,
          'undefined',
          () => tO,
          'unicodeEmail',
          () => tr,
          'uppercase',
          () => tC,
          'uuid',
          () => e3,
          'uuid4',
          () => e6,
          'uuid6',
          () => e7,
          'uuid7',
          () => e8,
          'xid',
          () => e0,
        ],
        20876
      ));
    let eJ = /^[cC][^\s-]{8,}$/,
      eQ = /^[0-9a-z]+$/,
      eq = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
      e0 = /^[0-9a-vA-V]{20}$/,
      e1 = /^[A-Za-z0-9]{27}$/,
      e2 = /^[a-zA-Z0-9_-]{21}$/,
      e5 =
        /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
      e4 =
        /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
      e9 = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
      e3 = (e) =>
        e
          ? RegExp(
              `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`
            )
          : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      e6 = e3(4),
      e7 = e3(6),
      e8 = e3(7),
      te =
        /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
      tt =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
      tn =
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
      tr = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
      ti = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
      to =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    function ta() {
      return RegExp('^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$', 'u');
    }
    let ts =
        /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      tu =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
      tl =
        /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
      tc =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      td = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
      tp = /^[A-Za-z0-9_-]*$/,
      t_ =
        /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/,
      tS = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
      tE = /^\+(?:[0-9]){6,14}[0-9]$/,
      tT =
        '(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))',
      tm = RegExp(`^${tT}$`);
    function tg(e) {
      let t = '(?:[01]\\d|2[0-3]):[0-5]\\d';
      return 'number' == typeof e.precision
        ? -1 === e.precision
          ? `${t}`
          : 0 === e.precision
            ? `${t}:[0-5]\\d`
            : `${t}:[0-5]\\d\\.\\d{${e.precision}}`
        : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    }
    function tf(e) {
      return RegExp(`^${tg(e)}$`);
    }
    function th(e) {
      let t = tg({ precision: e.precision }),
        n = ['Z'];
      (e.local && n.push(''), e.offset && n.push('([+-](?:[01]\\d|2[0-3]):[0-5]\\d)'));
      let r = `${t}(?:${n.join('|')})`;
      return RegExp(`^${tT}T(?:${r})$`);
    }
    let tA = (e) => {
        let t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ''}}` : '[\\s\\S]*';
        return RegExp(`^${t}$`);
      },
      tR = /^\d+n?$/,
      ty = /^\d+$/,
      tI = /^-?\d+(?:\.\d+)?/i,
      tb = /true|false/i,
      tN = /null/i,
      tO = /undefined/i,
      tv = /^[^A-Z]*$/,
      tC = /^[^a-z]*$/,
      tP = /^[0-9a-fA-F]*$/;
    function tM(e, t) {
      return RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
    }
    function tL(e) {
      return RegExp(`^[A-Za-z0-9-_]{${e}}$`);
    }
    let tU = /^[0-9a-fA-F]{32}$/,
      tD = tM(22, '=='),
      tx = tL(22),
      tw = /^[0-9a-fA-F]{40}$/,
      tk = tM(27, '='),
      tG = tL(27),
      tV = /^[0-9a-fA-F]{64}$/,
      t$ = tM(43, '='),
      tB = tL(43),
      tH = /^[0-9a-fA-F]{96}$/,
      tj = tM(64, ''),
      tF = tL(64),
      tZ = /^[0-9a-fA-F]{128}$/,
      tY = tM(86, '=='),
      tW = tL(86),
      tK = o('$ZodCheck', (e, t) => {
        var n;
        (e._zod ?? (e._zod = {}), (e._zod.def = t), (n = e._zod).onattach ?? (n.onattach = []));
      }),
      tz = { number: 'number', bigint: 'bigint', object: 'date' },
      tX = o('$ZodCheckLessThan', (e, t) => {
        tK.init(e, t);
        let n = tz[typeof t.value];
        (e._zod.onattach.push((e) => {
          let n = e._zod.bag,
            r = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? 1 / 0;
          t.value < r && (t.inclusive ? (n.maximum = t.value) : (n.exclusiveMaximum = t.value));
        }),
          (e._zod.check = (r) => {
            (t.inclusive ? r.value <= t.value : r.value < t.value) ||
              r.issues.push({
                origin: n,
                code: 'too_big',
                maximum: t.value,
                input: r.value,
                inclusive: t.inclusive,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      tJ = o('$ZodCheckGreaterThan', (e, t) => {
        tK.init(e, t);
        let n = tz[typeof t.value];
        (e._zod.onattach.push((e) => {
          let n = e._zod.bag,
            r = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? -1 / 0;
          t.value > r && (t.inclusive ? (n.minimum = t.value) : (n.exclusiveMinimum = t.value));
        }),
          (e._zod.check = (r) => {
            (t.inclusive ? r.value >= t.value : r.value > t.value) ||
              r.issues.push({
                origin: n,
                code: 'too_small',
                minimum: t.value,
                input: r.value,
                inclusive: t.inclusive,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      tQ = o('$ZodCheckMultipleOf', (e, t) => {
        (tK.init(e, t),
          e._zod.onattach.push((e) => {
            var n;
            (n = e._zod.bag).multipleOf ?? (n.multipleOf = t.value);
          }),
          (e._zod.check = (n) => {
            if (typeof n.value != typeof t.value)
              throw Error('Cannot mix number and bigint in multiple_of check.');
            ('bigint' == typeof n.value
              ? n.value % t.value === BigInt(0)
              : 0 === R(n.value, t.value)) ||
              n.issues.push({
                origin: typeof n.value,
                code: 'not_multiple_of',
                divisor: t.value,
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      tq = o('$ZodCheckNumberFormat', (e, t) => {
        (tK.init(e, t), (t.format = t.format || 'float64'));
        let n = t.format?.includes('int'),
          r = n ? 'int' : 'number',
          [i, o] = K[t.format];
        (e._zod.onattach.push((e) => {
          let r = e._zod.bag;
          ((r.format = t.format), (r.minimum = i), (r.maximum = o), n && (r.pattern = ty));
        }),
          (e._zod.check = (a) => {
            let s = a.value;
            if (n) {
              if (!Number.isInteger(s))
                return void a.issues.push({
                  expected: r,
                  format: t.format,
                  code: 'invalid_type',
                  continue: !1,
                  input: s,
                  inst: e,
                });
              if (!Number.isSafeInteger(s))
                return void (s > 0
                  ? a.issues.push({
                      input: s,
                      code: 'too_big',
                      maximum: Number.MAX_SAFE_INTEGER,
                      note: 'Integers must be within the safe integer range.',
                      inst: e,
                      origin: r,
                      continue: !t.abort,
                    })
                  : a.issues.push({
                      input: s,
                      code: 'too_small',
                      minimum: Number.MIN_SAFE_INTEGER,
                      note: 'Integers must be within the safe integer range.',
                      inst: e,
                      origin: r,
                      continue: !t.abort,
                    }));
            }
            (s < i &&
              a.issues.push({
                origin: 'number',
                input: s,
                code: 'too_small',
                minimum: i,
                inclusive: !0,
                inst: e,
                continue: !t.abort,
              }),
              s > o &&
                a.issues.push({
                  origin: 'number',
                  input: s,
                  code: 'too_big',
                  maximum: o,
                  inst: e,
                }));
          }));
      }),
      t0 = o('$ZodCheckBigIntFormat', (e, t) => {
        tK.init(e, t);
        let [n, r] = z[t.format];
        (e._zod.onattach.push((e) => {
          let i = e._zod.bag;
          ((i.format = t.format), (i.minimum = n), (i.maximum = r));
        }),
          (e._zod.check = (i) => {
            let o = i.value;
            (o < n &&
              i.issues.push({
                origin: 'bigint',
                input: o,
                code: 'too_small',
                minimum: n,
                inclusive: !0,
                inst: e,
                continue: !t.abort,
              }),
              o > r &&
                i.issues.push({
                  origin: 'bigint',
                  input: o,
                  code: 'too_big',
                  maximum: r,
                  inst: e,
                }));
          }));
      }),
      t1 = o('$ZodCheckMaxSize', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag.maximum ?? 1 / 0;
            t.maximum < n && (e._zod.bag.maximum = t.maximum);
          }),
          (e._zod.check = (n) => {
            let r = n.value;
            r.size <= t.maximum ||
              n.issues.push({
                origin: es(r),
                code: 'too_big',
                maximum: t.maximum,
                inclusive: !0,
                input: r,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      t2 = o('$ZodCheckMinSize', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag.minimum ?? -1 / 0;
            t.minimum > n && (e._zod.bag.minimum = t.minimum);
          }),
          (e._zod.check = (n) => {
            let r = n.value;
            r.size >= t.minimum ||
              n.issues.push({
                origin: es(r),
                code: 'too_small',
                minimum: t.minimum,
                inclusive: !0,
                input: r,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      t5 = o('$ZodCheckSizeEquals', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag;
            ((n.minimum = t.size), (n.maximum = t.size), (n.size = t.size));
          }),
          (e._zod.check = (n) => {
            let r = n.value,
              i = r.size;
            if (i === t.size) return;
            let o = i > t.size;
            n.issues.push({
              origin: es(r),
              ...(o
                ? { code: 'too_big', maximum: t.size }
                : { code: 'too_small', minimum: t.size }),
              inclusive: !0,
              exact: !0,
              input: n.value,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      t4 = o('$ZodCheckMaxLength', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag.maximum ?? 1 / 0;
            t.maximum < n && (e._zod.bag.maximum = t.maximum);
          }),
          (e._zod.check = (n) => {
            let r = n.value;
            if (r.length <= t.maximum) return;
            let i = eu(r);
            n.issues.push({
              origin: i,
              code: 'too_big',
              maximum: t.maximum,
              inclusive: !0,
              input: r,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      t9 = o('$ZodCheckMinLength', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag.minimum ?? -1 / 0;
            t.minimum > n && (e._zod.bag.minimum = t.minimum);
          }),
          (e._zod.check = (n) => {
            let r = n.value;
            if (r.length >= t.minimum) return;
            let i = eu(r);
            n.issues.push({
              origin: i,
              code: 'too_small',
              minimum: t.minimum,
              inclusive: !0,
              input: r,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      t3 = o('$ZodCheckLengthEquals', (e, t) => {
        var n;
        (tK.init(e, t),
          (n = e._zod.def).when ??
            (n.when = (e) => {
              let t = e.value;
              return !h(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag;
            ((n.minimum = t.length), (n.maximum = t.length), (n.length = t.length));
          }),
          (e._zod.check = (n) => {
            let r = n.value,
              i = r.length;
            if (i === t.length) return;
            let o = eu(r),
              a = i > t.length;
            n.issues.push({
              origin: o,
              ...(a
                ? { code: 'too_big', maximum: t.length }
                : { code: 'too_small', minimum: t.length }),
              inclusive: !0,
              exact: !0,
              input: n.value,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      t6 = o('$ZodCheckStringFormat', (e, t) => {
        var n, r;
        (tK.init(e, t),
          e._zod.onattach.push((e) => {
            let n = e._zod.bag;
            ((n.format = t.format),
              t.pattern && (n.patterns ?? (n.patterns = new Set()), n.patterns.add(t.pattern)));
          }),
          t.pattern
            ? ((n = e._zod).check ??
              (n.check = (n) => {
                ((t.pattern.lastIndex = 0),
                  t.pattern.test(n.value) ||
                    n.issues.push({
                      origin: 'string',
                      code: 'invalid_format',
                      format: t.format,
                      input: n.value,
                      ...(t.pattern ? { pattern: t.pattern.toString() } : {}),
                      inst: e,
                      continue: !t.abort,
                    }));
              }))
            : ((r = e._zod).check ?? (r.check = () => {})));
      }),
      t7 = o('$ZodCheckRegex', (e, t) => {
        (t6.init(e, t),
          (e._zod.check = (n) => {
            ((t.pattern.lastIndex = 0),
              t.pattern.test(n.value) ||
                n.issues.push({
                  origin: 'string',
                  code: 'invalid_format',
                  format: 'regex',
                  input: n.value,
                  pattern: t.pattern.toString(),
                  inst: e,
                  continue: !t.abort,
                }));
          }));
      }),
      t8 = o('$ZodCheckLowerCase', (e, t) => {
        (t.pattern ?? (t.pattern = tv), t6.init(e, t));
      }),
      ne = o('$ZodCheckUpperCase', (e, t) => {
        (t.pattern ?? (t.pattern = tC), t6.init(e, t));
      }),
      nt = o('$ZodCheckIncludes', (e, t) => {
        tK.init(e, t);
        let n = H(t.includes),
          r = new RegExp('number' == typeof t.position ? `^.{${t.position}}${n}` : n);
        ((t.pattern = r),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(r));
          }),
          (e._zod.check = (n) => {
            n.value.includes(t.includes, t.position) ||
              n.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'includes',
                includes: t.includes,
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nn = o('$ZodCheckStartsWith', (e, t) => {
        tK.init(e, t);
        let n = RegExp(`^${H(t.prefix)}.*`);
        (t.pattern ?? (t.pattern = n),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(n));
          }),
          (e._zod.check = (n) => {
            n.value.startsWith(t.prefix) ||
              n.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'starts_with',
                prefix: t.prefix,
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nr = o('$ZodCheckEndsWith', (e, t) => {
        tK.init(e, t);
        let n = RegExp(`.*${H(t.suffix)}$`);
        (t.pattern ?? (t.pattern = n),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(n));
          }),
          (e._zod.check = (n) => {
            n.value.endsWith(t.suffix) ||
              n.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'ends_with',
                suffix: t.suffix,
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      });
    function ni(e, t, n) {
      e.issues.length && t.issues.push(...ei(n, e.issues));
    }
    let no = o('$ZodCheckProperty', (e, t) => {
        (tK.init(e, t),
          (e._zod.check = (e) => {
            let n = t.schema._zod.run({ value: e.value[t.property], issues: [] }, {});
            if (n instanceof Promise) return n.then((n) => ni(n, e, t.property));
            ni(n, e, t.property);
          }));
      }),
      na = o('$ZodCheckMimeType', (e, t) => {
        tK.init(e, t);
        let n = new Set(t.mime);
        (e._zod.onattach.push((e) => {
          e._zod.bag.mime = t.mime;
        }),
          (e._zod.check = (r) => {
            n.has(r.value.type) ||
              r.issues.push({
                code: 'invalid_value',
                values: t.mime,
                input: r.value.type,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      ns = o('$ZodCheckOverwrite', (e, t) => {
        (tK.init(e, t),
          (e._zod.check = (e) => {
            e.value = t.tx(e.value);
          }));
      });
    e.s(['Doc', () => nu], 86369);
    class nu {
      constructor(e = []) {
        ((this.content = []), (this.indent = 0), this && (this.args = e));
      }
      indented(e) {
        ((this.indent += 1), e(this), (this.indent -= 1));
      }
      write(e) {
        if ('function' == typeof e) {
          (e(this, { execution: 'sync' }), e(this, { execution: 'async' }));
          return;
        }
        let t = e.split('\n').filter((e) => e),
          n = Math.min(...t.map((e) => e.length - e.trimStart().length));
        for (let e of t.map((e) => e.slice(n)).map((e) => ' '.repeat(2 * this.indent) + e))
          this.content.push(e);
      }
      compile() {
        return Function(
          ...this?.args,
          [...(this?.content ?? ['']).map((e) => `  ${e}`)].join('\n')
        );
      }
    }
    e.s(['version', () => nl], 9744);
    let nl = { major: 4, minor: 1, patch: 5 },
      nc = o('$ZodType', (e, t) => {
        var n;
        (e ?? (e = {}), (e._zod.def = t), (e._zod.bag = e._zod.bag || {}), (e._zod.version = nl));
        let r = [...(e._zod.def.checks ?? [])];
        for (let t of (e._zod.traits.has('$ZodCheck') && r.unshift(e), r))
          for (let n of t._zod.onattach) n(e);
        if (0 === r.length)
          ((n = e._zod).deferred ?? (n.deferred = []),
            e._zod.deferred?.push(() => {
              e._zod.run = e._zod.parse;
            }));
        else {
          let t = (e, t, n) => {
              let r,
                i = er(e);
              for (let o of t) {
                if (o._zod.def.when) {
                  if (!o._zod.def.when(e)) continue;
                } else if (i) continue;
                let t = e.issues.length,
                  a = o._zod.check(e);
                if (a instanceof Promise && n?.async === !1) throw new s();
                if (r || a instanceof Promise)
                  r = (r ?? Promise.resolve()).then(async () => {
                    (await a, e.issues.length !== t && (i || (i = er(e, t))));
                  });
                else {
                  if (e.issues.length === t) continue;
                  i || (i = er(e, t));
                }
              }
              return r ? r.then(() => e) : e;
            },
            n = (n, i, o) => {
              if (er(n)) return ((n.aborted = !0), n);
              let a = t(i, r, o);
              if (a instanceof Promise) {
                if (!1 === o.async) throw new s();
                return a.then((t) => e._zod.parse(t, o));
              }
              return e._zod.parse(a, o);
            };
          e._zod.run = (i, o) => {
            if (o.skipChecks) return e._zod.parse(i, o);
            if ('backward' === o.direction) {
              let t = e._zod.parse({ value: i.value, issues: [] }, { ...o, skipChecks: !0 });
              return t instanceof Promise ? t.then((e) => n(e, i, o)) : n(t, i, o);
            }
            let a = e._zod.parse(i, o);
            if (a instanceof Promise) {
              if (!1 === o.async) throw new s();
              return a.then((e) => t(e, r, o));
            }
            return t(a, r, o);
          };
        }
        e['~standard'] = {
          validate: (t) => {
            try {
              let n = eL(e, t);
              return n.success ? { value: n.data } : { issues: n.error?.issues };
            } catch (n) {
              return eD(e, t).then((e) =>
                e.success ? { value: e.data } : { issues: e.error?.issues }
              );
            }
          },
          vendor: 'zod',
          version: 1,
        };
      }),
      nd = o('$ZodString', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = [...(e?._zod.bag?.patterns ?? [])].pop() ?? tA(e._zod.bag)),
          (e._zod.parse = (n, r) => {
            if (t.coerce)
              try {
                n.value = String(n.value);
              } catch (e) {}
            return (
              'string' == typeof n.value ||
                n.issues.push({
                  expected: 'string',
                  code: 'invalid_type',
                  input: n.value,
                  inst: e,
                }),
              n
            );
          }));
      }),
      np = o('$ZodStringFormat', (e, t) => {
        (t6.init(e, t), nd.init(e, t));
      }),
      n_ = o('$ZodGUID', (e, t) => {
        (t.pattern ?? (t.pattern = e9), np.init(e, t));
      }),
      nS = o('$ZodUUID', (e, t) => {
        if (t.version) {
          let e = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[t.version];
          if (void 0 === e) throw Error(`Invalid UUID version: "${t.version}"`);
          t.pattern ?? (t.pattern = e3(e));
        } else t.pattern ?? (t.pattern = e3());
        np.init(e, t);
      }),
      nE = o('$ZodEmail', (e, t) => {
        (t.pattern ?? (t.pattern = te), np.init(e, t));
      }),
      nT = o('$ZodURL', (e, t) => {
        (np.init(e, t),
          (e._zod.check = (n) => {
            try {
              let r = n.value.trim(),
                i = new URL(r);
              (t.hostname &&
                ((t.hostname.lastIndex = 0),
                t.hostname.test(i.hostname) ||
                  n.issues.push({
                    code: 'invalid_format',
                    format: 'url',
                    note: 'Invalid hostname',
                    pattern: t_.source,
                    input: n.value,
                    inst: e,
                    continue: !t.abort,
                  })),
                t.protocol &&
                  ((t.protocol.lastIndex = 0),
                  t.protocol.test(
                    i.protocol.endsWith(':') ? i.protocol.slice(0, -1) : i.protocol
                  ) ||
                    n.issues.push({
                      code: 'invalid_format',
                      format: 'url',
                      note: 'Invalid protocol',
                      pattern: t.protocol.source,
                      input: n.value,
                      inst: e,
                      continue: !t.abort,
                    })),
                t.normalize ? (n.value = i.href) : (n.value = r));
              return;
            } catch (r) {
              n.issues.push({
                code: 'invalid_format',
                format: 'url',
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      }),
      nm = o('$ZodEmoji', (e, t) => {
        (t.pattern ?? (t.pattern = ta()), np.init(e, t));
      }),
      ng = o('$ZodNanoID', (e, t) => {
        (t.pattern ?? (t.pattern = e2), np.init(e, t));
      }),
      nf = o('$ZodCUID', (e, t) => {
        (t.pattern ?? (t.pattern = eJ), np.init(e, t));
      }),
      nh = o('$ZodCUID2', (e, t) => {
        (t.pattern ?? (t.pattern = eQ), np.init(e, t));
      }),
      nA = o('$ZodULID', (e, t) => {
        (t.pattern ?? (t.pattern = eq), np.init(e, t));
      }),
      nR = o('$ZodXID', (e, t) => {
        (t.pattern ?? (t.pattern = e0), np.init(e, t));
      }),
      ny = o('$ZodKSUID', (e, t) => {
        (t.pattern ?? (t.pattern = e1), np.init(e, t));
      }),
      nI = o('$ZodISODateTime', (e, t) => {
        (t.pattern ?? (t.pattern = th(t)), np.init(e, t));
      }),
      nb = o('$ZodISODate', (e, t) => {
        (t.pattern ?? (t.pattern = tm), np.init(e, t));
      }),
      nN = o('$ZodISOTime', (e, t) => {
        (t.pattern ?? (t.pattern = tf(t)), np.init(e, t));
      }),
      nO = o('$ZodISODuration', (e, t) => {
        (t.pattern ?? (t.pattern = e5), np.init(e, t));
      }),
      nv = o('$ZodIPv4', (e, t) => {
        (t.pattern ?? (t.pattern = ts),
          np.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.format = 'ipv4';
          }));
      }),
      nC = o('$ZodIPv6', (e, t) => {
        (t.pattern ?? (t.pattern = tu),
          np.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.format = 'ipv6';
          }),
          (e._zod.check = (n) => {
            try {
              new URL(`http://[${n.value}]`);
            } catch {
              n.issues.push({
                code: 'invalid_format',
                format: 'ipv6',
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      }),
      nP = o('$ZodCIDRv4', (e, t) => {
        (t.pattern ?? (t.pattern = tl), np.init(e, t));
      }),
      nM = o('$ZodCIDRv6', (e, t) => {
        (t.pattern ?? (t.pattern = tc),
          np.init(e, t),
          (e._zod.check = (n) => {
            let [r, i] = n.value.split('/');
            try {
              if (!i) throw Error();
              let e = Number(i);
              if (`${e}` !== i || e < 0 || e > 128) throw Error();
              new URL(`http://[${r}]`);
            } catch {
              n.issues.push({
                code: 'invalid_format',
                format: 'cidrv6',
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      });
    function nL(e) {
      if ('' === e) return !0;
      if (e.length % 4 != 0) return !1;
      try {
        return (atob(e), !0);
      } catch {
        return !1;
      }
    }
    let nU = o('$ZodBase64', (e, t) => {
      (t.pattern ?? (t.pattern = td),
        np.init(e, t),
        e._zod.onattach.push((e) => {
          e._zod.bag.contentEncoding = 'base64';
        }),
        (e._zod.check = (n) => {
          nL(n.value) ||
            n.issues.push({
              code: 'invalid_format',
              format: 'base64',
              input: n.value,
              inst: e,
              continue: !t.abort,
            });
        }));
    });
    function nD(e) {
      if (!tp.test(e)) return !1;
      let t = e.replace(/[-_]/g, (e) => ('-' === e ? '+' : '/'));
      return nL(t.padEnd(4 * Math.ceil(t.length / 4), '='));
    }
    let nx = o('$ZodBase64URL', (e, t) => {
        (t.pattern ?? (t.pattern = tp),
          np.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.contentEncoding = 'base64url';
          }),
          (e._zod.check = (n) => {
            nD(n.value) ||
              n.issues.push({
                code: 'invalid_format',
                format: 'base64url',
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nw = o('$ZodE164', (e, t) => {
        (t.pattern ?? (t.pattern = tE), np.init(e, t));
      });
    function nk(e, t = null) {
      try {
        let n = e.split('.');
        if (3 !== n.length) return !1;
        let [r] = n;
        if (!r) return !1;
        let i = JSON.parse(atob(r));
        if (('typ' in i && i?.typ !== 'JWT') || !i.alg || (t && (!('alg' in i) || i.alg !== t)))
          return !1;
        return !0;
      } catch {
        return !1;
      }
    }
    let nG = o('$ZodJWT', (e, t) => {
        (np.init(e, t),
          (e._zod.check = (n) => {
            nk(n.value, t.alg) ||
              n.issues.push({
                code: 'invalid_format',
                format: 'jwt',
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nV = o('$ZodCustomStringFormat', (e, t) => {
        (np.init(e, t),
          (e._zod.check = (n) => {
            t.fn(n.value) ||
              n.issues.push({
                code: 'invalid_format',
                format: t.format,
                input: n.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      n$ = o('$ZodNumber', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = e._zod.bag.pattern ?? tI),
          (e._zod.parse = (n, r) => {
            if (t.coerce)
              try {
                n.value = Number(n.value);
              } catch (e) {}
            let i = n.value;
            if ('number' == typeof i && !Number.isNaN(i) && Number.isFinite(i)) return n;
            let o =
              'number' == typeof i
                ? Number.isNaN(i)
                  ? 'NaN'
                  : Number.isFinite(i)
                    ? void 0
                    : 'Infinity'
                : void 0;
            return (
              n.issues.push({
                expected: 'number',
                code: 'invalid_type',
                input: i,
                inst: e,
                ...(o ? { received: o } : {}),
              }),
              n
            );
          }));
      }),
      nB = o('$ZodNumber', (e, t) => {
        (tq.init(e, t), n$.init(e, t));
      }),
      nH = o('$ZodBoolean', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = tb),
          (e._zod.parse = (n, r) => {
            if (t.coerce)
              try {
                n.value = !!n.value;
              } catch (e) {}
            let i = n.value;
            return (
              'boolean' == typeof i ||
                n.issues.push({ expected: 'boolean', code: 'invalid_type', input: i, inst: e }),
              n
            );
          }));
      }),
      nj = o('$ZodBigInt', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = tR),
          (e._zod.parse = (n, r) => {
            if (t.coerce)
              try {
                n.value = BigInt(n.value);
              } catch (e) {}
            return (
              'bigint' == typeof n.value ||
                n.issues.push({
                  expected: 'bigint',
                  code: 'invalid_type',
                  input: n.value,
                  inst: e,
                }),
              n
            );
          }));
      }),
      nF = o('$ZodBigInt', (e, t) => {
        (t0.init(e, t), nj.init(e, t));
      }),
      nZ = o('$ZodSymbol', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (t, n) => {
            let r = t.value;
            return (
              'symbol' == typeof r ||
                t.issues.push({ expected: 'symbol', code: 'invalid_type', input: r, inst: e }),
              t
            );
          }));
      }),
      nY = o('$ZodUndefined', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = tO),
          (e._zod.values = new Set([void 0])),
          (e._zod.optin = 'optional'),
          (e._zod.optout = 'optional'),
          (e._zod.parse = (t, n) => {
            let r = t.value;
            return (
              void 0 === r ||
                t.issues.push({ expected: 'undefined', code: 'invalid_type', input: r, inst: e }),
              t
            );
          }));
      }),
      nW = o('$ZodNull', (e, t) => {
        (nc.init(e, t),
          (e._zod.pattern = tN),
          (e._zod.values = new Set([null])),
          (e._zod.parse = (t, n) => {
            let r = t.value;
            return (
              null === r ||
                t.issues.push({ expected: 'null', code: 'invalid_type', input: r, inst: e }),
              t
            );
          }));
      }),
      nK = o('$ZodAny', (e, t) => {
        (nc.init(e, t), (e._zod.parse = (e) => e));
      }),
      nz = o('$ZodUnknown', (e, t) => {
        (nc.init(e, t), (e._zod.parse = (e) => e));
      }),
      nX = o('$ZodNever', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (t, n) => (
            t.issues.push({ expected: 'never', code: 'invalid_type', input: t.value, inst: e }),
            t
          )));
      }),
      nJ = o('$ZodVoid', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (t, n) => {
            let r = t.value;
            return (
              void 0 === r ||
                t.issues.push({ expected: 'void', code: 'invalid_type', input: r, inst: e }),
              t
            );
          }));
      }),
      nQ = o('$ZodDate', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (n, r) => {
            if (t.coerce)
              try {
                n.value = new Date(n.value);
              } catch (e) {}
            let i = n.value,
              o = i instanceof Date;
            return (
              (o && !Number.isNaN(i.getTime())) ||
                n.issues.push({
                  expected: 'date',
                  code: 'invalid_type',
                  input: i,
                  ...(o ? { received: 'Invalid Date' } : {}),
                  inst: e,
                }),
              n
            );
          }));
      });
    function nq(e, t, n) {
      (e.issues.length && t.issues.push(...ei(n, e.issues)), (t.value[n] = e.value));
    }
    let n0 = o('$ZodArray', (e, t) => {
      (nc.init(e, t),
        (e._zod.parse = (n, r) => {
          let i = n.value;
          if (!Array.isArray(i))
            return (
              n.issues.push({ expected: 'array', code: 'invalid_type', input: i, inst: e }),
              n
            );
          n.value = Array(i.length);
          let o = [];
          for (let e = 0; e < i.length; e++) {
            let a = i[e],
              s = t.element._zod.run({ value: a, issues: [] }, r);
            s instanceof Promise ? o.push(s.then((t) => nq(t, n, e))) : nq(s, n, e);
          }
          return o.length ? Promise.all(o).then(() => n) : n;
        }));
    });
    function n1(e, t, n, r) {
      (e.issues.length && t.issues.push(...ei(n, e.issues)),
        void 0 === e.value ? n in r && (t.value[n] = void 0) : (t.value[n] = e.value));
    }
    function n2(e) {
      let t = Object.keys(e.shape);
      for (let n of t)
        if (!e.shape[n]._zod.traits.has('$ZodType'))
          throw Error(`Invalid element at key "${n}": expected a Zod schema`);
      let n = W(e.shape);
      return { ...e, keys: t, keySet: new Set(t), numKeys: t.length, optionalKeys: new Set(n) };
    }
    function n5(e, t, n, r, i, o) {
      let a = [],
        s = i.keySet,
        u = i.catchall._zod,
        l = u.def.type;
      for (let i of Object.keys(t)) {
        if (s.has(i)) continue;
        if ('never' === l) {
          a.push(i);
          continue;
        }
        let o = u.run({ value: t[i], issues: [] }, r);
        o instanceof Promise ? e.push(o.then((e) => n1(e, n, i, t))) : n1(o, n, i, t);
      }
      return (a.length && n.issues.push({ code: 'unrecognized_keys', keys: a, input: t, inst: o }),
      e.length)
        ? Promise.all(e).then(() => n)
        : n;
    }
    let n4 = o('$ZodObject', (e, t) => {
        let n;
        nc.init(e, t);
        let r = f(() => n2(t));
        I(e._zod, 'propValues', () => {
          let e = t.shape,
            n = {};
          for (let t in e) {
            let r = e[t]._zod;
            if (r.values) for (let e of (n[t] ?? (n[t] = new Set()), r.values)) n[t].add(e);
          }
          return n;
        });
        let i = t.catchall;
        e._zod.parse = (t, o) => {
          n ?? (n = r.value);
          let a = t.value;
          if (!D(a))
            return (
              t.issues.push({ expected: 'object', code: 'invalid_type', input: a, inst: e }),
              t
            );
          t.value = {};
          let s = [],
            u = n.shape;
          for (let e of n.keys) {
            let n = u[e]._zod.run({ value: a[e], issues: [] }, o);
            n instanceof Promise ? s.push(n.then((n) => n1(n, t, e, a))) : n1(n, t, e, a);
          }
          return i ? n5(s, a, t, o, r.value, e) : s.length ? Promise.all(s).then(() => t) : t;
        };
      }),
      n9 = o('$ZodObjectJIT', (e, t) => {
        let n, r;
        n4.init(e, t);
        let i = e._zod.parse,
          o = f(() => n2(t)),
          a = !l.jitless,
          s = a && x.value,
          u = t.catchall;
        e._zod.parse = (l, c) => {
          r ?? (r = o.value);
          let d = l.value;
          return D(d)
            ? a && s && c?.async === !1 && !0 !== c.jitless
              ? (n ||
                  (n = ((e) => {
                    let t = new nu(['shape', 'payload', 'ctx']),
                      n = o.value,
                      r = (e) => {
                        let t = L(e);
                        return `shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)`;
                      };
                    t.write('const input = payload.value;');
                    let i = Object.create(null),
                      a = 0;
                    for (let e of n.keys) i[e] = `key_${a++}`;
                    for (let e of (t.write('const newResult = {}'), n.keys)) {
                      let n = i[e],
                        o = L(e);
                      (t.write(`const ${n} = ${r(e)};`),
                        t.write(`
        if (${n}.issues.length) {
          payload.issues = payload.issues.concat(${n}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${o}, ...iss.path] : [${o}]
          })));
        }
        
        if (${n}.value === undefined) {
          if (${o} in input) {
            newResult[${o}] = undefined;
          }
        } else {
          newResult[${o}] = ${n}.value;
        }
      `));
                    }
                    (t.write('payload.value = newResult;'), t.write('return payload;'));
                    let s = t.compile();
                    return (t, n) => s(e, t, n);
                  })(t.shape)),
                (l = n(l, c)),
                u)
                ? n5([], d, l, c, r, e)
                : l
              : i(l, c)
            : (l.issues.push({ expected: 'object', code: 'invalid_type', input: d, inst: e }), l);
        };
      });
    function n3(e, t, n, r) {
      for (let n of e) if (0 === n.issues.length) return ((t.value = n.value), t);
      let i = e.filter((e) => !er(e));
      return 1 === i.length
        ? ((t.value = i[0].value), i[0])
        : (t.issues.push({
            code: 'invalid_union',
            input: t.value,
            inst: n,
            errors: e.map((e) => e.issues.map((e) => ea(e, r, c()))),
          }),
          t);
    }
    let n6 = o('$ZodUnion', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'optin', () =>
            t.options.some((e) => 'optional' === e._zod.optin) ? 'optional' : void 0
          ),
          I(e._zod, 'optout', () =>
            t.options.some((e) => 'optional' === e._zod.optout) ? 'optional' : void 0
          ),
          I(e._zod, 'values', () => {
            if (t.options.every((e) => e._zod.values))
              return new Set(t.options.flatMap((e) => Array.from(e._zod.values)));
          }),
          I(e._zod, 'pattern', () => {
            if (t.options.every((e) => e._zod.pattern)) {
              let e = t.options.map((e) => e._zod.pattern);
              return RegExp(`^(${e.map((e) => A(e.source)).join('|')})$`);
            }
          }));
        let n = 1 === t.options.length,
          r = t.options[0]._zod.run;
        e._zod.parse = (i, o) => {
          if (n) return r(i, o);
          let a = !1,
            s = [];
          for (let e of t.options) {
            let t = e._zod.run({ value: i.value, issues: [] }, o);
            if (t instanceof Promise) (s.push(t), (a = !0));
            else {
              if (0 === t.issues.length) return t;
              s.push(t);
            }
          }
          return a ? Promise.all(s).then((t) => n3(t, i, e, o)) : n3(s, i, e, o);
        };
      }),
      n7 = o('$ZodDiscriminatedUnion', (e, t) => {
        n6.init(e, t);
        let n = e._zod.parse;
        I(e._zod, 'propValues', () => {
          let e = {};
          for (let n of t.options) {
            let r = n._zod.propValues;
            if (!r || 0 === Object.keys(r).length)
              throw Error(`Invalid discriminated union option at index "${t.options.indexOf(n)}"`);
            for (let [t, n] of Object.entries(r))
              for (let r of (e[t] || (e[t] = new Set()), n)) e[t].add(r);
          }
          return e;
        });
        let r = f(() => {
          let e = t.options,
            n = new Map();
          for (let r of e) {
            let e = r._zod.propValues?.[t.discriminator];
            if (!e || 0 === e.size)
              throw Error(`Invalid discriminated union option at index "${t.options.indexOf(r)}"`);
            for (let t of e) {
              if (n.has(t)) throw Error(`Duplicate discriminator value "${String(t)}"`);
              n.set(t, r);
            }
          }
          return n;
        });
        e._zod.parse = (i, o) => {
          let a = i.value;
          if (!D(a))
            return (
              i.issues.push({ code: 'invalid_type', expected: 'object', input: a, inst: e }),
              i
            );
          let s = r.value.get(a?.[t.discriminator]);
          return s
            ? s._zod.run(i, o)
            : t.unionFallback
              ? n(i, o)
              : (i.issues.push({
                  code: 'invalid_union',
                  errors: [],
                  note: 'No matching discriminator',
                  discriminator: t.discriminator,
                  input: a,
                  path: [t.discriminator],
                  inst: e,
                }),
                i);
        };
      }),
      n8 = o('$ZodIntersection', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (e, n) => {
            let r = e.value,
              i = t.left._zod.run({ value: r, issues: [] }, n),
              o = t.right._zod.run({ value: r, issues: [] }, n);
            return i instanceof Promise || o instanceof Promise
              ? Promise.all([i, o]).then(([t, n]) => re(e, t, n))
              : re(e, i, o);
          }));
      });
    function re(e, t, n) {
      if (
        (t.issues.length && e.issues.push(...t.issues),
        n.issues.length && e.issues.push(...n.issues),
        er(e))
      )
        return e;
      let r = (function e(t, n) {
        if (t === n || (t instanceof Date && n instanceof Date && +t == +n))
          return { valid: !0, data: t };
        if (w(t) && w(n)) {
          let r = Object.keys(n),
            i = Object.keys(t).filter((e) => -1 !== r.indexOf(e)),
            o = { ...t, ...n };
          for (let r of i) {
            let i = e(t[r], n[r]);
            if (!i.valid) return { valid: !1, mergeErrorPath: [r, ...i.mergeErrorPath] };
            o[r] = i.data;
          }
          return { valid: !0, data: o };
        }
        if (Array.isArray(t) && Array.isArray(n)) {
          if (t.length !== n.length) return { valid: !1, mergeErrorPath: [] };
          let r = [];
          for (let i = 0; i < t.length; i++) {
            let o = e(t[i], n[i]);
            if (!o.valid) return { valid: !1, mergeErrorPath: [i, ...o.mergeErrorPath] };
            r.push(o.data);
          }
          return { valid: !0, data: r };
        }
        return { valid: !1, mergeErrorPath: [] };
      })(t.value, n.value);
      if (!r.valid)
        throw Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
      return ((e.value = r.data), e);
    }
    let rt = o('$ZodTuple', (e, t) => {
      nc.init(e, t);
      let n = t.items,
        r = n.length - [...n].reverse().findIndex((e) => 'optional' !== e._zod.optin);
      e._zod.parse = (i, o) => {
        let a = i.value;
        if (!Array.isArray(a))
          return (i.issues.push({ input: a, inst: e, expected: 'tuple', code: 'invalid_type' }), i);
        i.value = [];
        let s = [];
        if (!t.rest) {
          let t = a.length > n.length,
            o = a.length < r - 1;
          if (t || o)
            return (
              i.issues.push({
                ...(t
                  ? { code: 'too_big', maximum: n.length }
                  : { code: 'too_small', minimum: n.length }),
                input: a,
                inst: e,
                origin: 'array',
              }),
              i
            );
        }
        let u = -1;
        for (let e of n) {
          if (++u >= a.length && u >= r) continue;
          let t = e._zod.run({ value: a[u], issues: [] }, o);
          t instanceof Promise ? s.push(t.then((e) => rn(e, i, u))) : rn(t, i, u);
        }
        if (t.rest)
          for (let e of a.slice(n.length)) {
            u++;
            let n = t.rest._zod.run({ value: e, issues: [] }, o);
            n instanceof Promise ? s.push(n.then((e) => rn(e, i, u))) : rn(n, i, u);
          }
        return s.length ? Promise.all(s).then(() => i) : i;
      };
    });
    function rn(e, t, n) {
      (e.issues.length && t.issues.push(...ei(n, e.issues)), (t.value[n] = e.value));
    }
    let rr = o('$ZodRecord', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (n, r) => {
            let i = n.value;
            if (!w(i))
              return (
                n.issues.push({ expected: 'record', code: 'invalid_type', input: i, inst: e }),
                n
              );
            let o = [];
            if (t.keyType._zod.values) {
              let a,
                s = t.keyType._zod.values;
              for (let e of ((n.value = {}), s))
                if ('string' == typeof e || 'number' == typeof e || 'symbol' == typeof e) {
                  let a = t.valueType._zod.run({ value: i[e], issues: [] }, r);
                  a instanceof Promise
                    ? o.push(
                        a.then((t) => {
                          (t.issues.length && n.issues.push(...ei(e, t.issues)),
                            (n.value[e] = t.value));
                        })
                      )
                    : (a.issues.length && n.issues.push(...ei(e, a.issues)),
                      (n.value[e] = a.value));
                }
              for (let e in i) s.has(e) || (a = a ?? []).push(e);
              a &&
                a.length > 0 &&
                n.issues.push({ code: 'unrecognized_keys', input: i, inst: e, keys: a });
            } else
              for (let a of ((n.value = {}), Reflect.ownKeys(i))) {
                if ('__proto__' === a) continue;
                let s = t.keyType._zod.run({ value: a, issues: [] }, r);
                if (s instanceof Promise)
                  throw Error('Async schemas not supported in object keys currently');
                if (s.issues.length) {
                  (n.issues.push({
                    code: 'invalid_key',
                    origin: 'record',
                    issues: s.issues.map((e) => ea(e, r, c())),
                    input: a,
                    path: [a],
                    inst: e,
                  }),
                    (n.value[s.value] = s.value));
                  continue;
                }
                let u = t.valueType._zod.run({ value: i[a], issues: [] }, r);
                u instanceof Promise
                  ? o.push(
                      u.then((e) => {
                        (e.issues.length && n.issues.push(...ei(a, e.issues)),
                          (n.value[s.value] = e.value));
                      })
                    )
                  : (u.issues.length && n.issues.push(...ei(a, u.issues)),
                    (n.value[s.value] = u.value));
              }
            return o.length ? Promise.all(o).then(() => n) : n;
          }));
      }),
      ri = o('$ZodMap', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (n, r) => {
            let i = n.value;
            if (!(i instanceof Map))
              return (
                n.issues.push({ expected: 'map', code: 'invalid_type', input: i, inst: e }),
                n
              );
            let o = [];
            for (let [a, s] of ((n.value = new Map()), i)) {
              let u = t.keyType._zod.run({ value: a, issues: [] }, r),
                l = t.valueType._zod.run({ value: s, issues: [] }, r);
              u instanceof Promise || l instanceof Promise
                ? o.push(
                    Promise.all([u, l]).then(([t, o]) => {
                      ro(t, o, n, a, i, e, r);
                    })
                  )
                : ro(u, l, n, a, i, e, r);
            }
            return o.length ? Promise.all(o).then(() => n) : n;
          }));
      });
    function ro(e, t, n, r, i, o, a) {
      (e.issues.length &&
        ($.has(typeof r)
          ? n.issues.push(...ei(r, e.issues))
          : n.issues.push({
              code: 'invalid_key',
              origin: 'map',
              input: i,
              inst: o,
              issues: e.issues.map((e) => ea(e, a, c())),
            })),
        t.issues.length &&
          ($.has(typeof r)
            ? n.issues.push(...ei(r, t.issues))
            : n.issues.push({
                origin: 'map',
                code: 'invalid_element',
                input: i,
                inst: o,
                key: r,
                issues: t.issues.map((e) => ea(e, a, c())),
              })),
        n.value.set(e.value, t.value));
    }
    let ra = o('$ZodSet', (e, t) => {
      (nc.init(e, t),
        (e._zod.parse = (n, r) => {
          let i = n.value;
          if (!(i instanceof Set))
            return (n.issues.push({ input: i, inst: e, expected: 'set', code: 'invalid_type' }), n);
          let o = [];
          for (let e of ((n.value = new Set()), i)) {
            let i = t.valueType._zod.run({ value: e, issues: [] }, r);
            i instanceof Promise ? o.push(i.then((e) => rs(e, n))) : rs(i, n);
          }
          return o.length ? Promise.all(o).then(() => n) : n;
        }));
    });
    function rs(e, t) {
      (e.issues.length && t.issues.push(...e.issues), t.value.add(e.value));
    }
    let ru = o('$ZodEnum', (e, t) => {
        nc.init(e, t);
        let n = T(t.entries),
          r = new Set(n);
        ((e._zod.values = r),
          (e._zod.pattern = RegExp(
            `^(${n
              .filter((e) => $.has(typeof e))
              .map((e) => ('string' == typeof e ? H(e) : e.toString()))
              .join('|')})$`
          )),
          (e._zod.parse = (t, i) => {
            let o = t.value;
            return (
              r.has(o) || t.issues.push({ code: 'invalid_value', values: n, input: o, inst: e }),
              t
            );
          }));
      }),
      rl = o('$ZodLiteral', (e, t) => {
        if ((nc.init(e, t), 0 === t.values.length))
          throw Error('Cannot create literal schema with no valid values');
        ((e._zod.values = new Set(t.values)),
          (e._zod.pattern = RegExp(
            `^(${t.values.map((e) => ('string' == typeof e ? H(e) : e ? H(e.toString()) : String(e))).join('|')})$`
          )),
          (e._zod.parse = (n, r) => {
            let i = n.value;
            return (
              e._zod.values.has(i) ||
                n.issues.push({ code: 'invalid_value', values: t.values, input: i, inst: e }),
              n
            );
          }));
      }),
      rc = o('$ZodFile', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (t, n) => {
            let r = t.value;
            return (
              r instanceof File ||
                t.issues.push({ expected: 'file', code: 'invalid_type', input: r, inst: e }),
              t
            );
          }));
      }),
      rd = o('$ZodTransform', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (n, r) => {
            if ('backward' === r.direction) throw new u(e.constructor.name);
            let i = t.transform(n.value, n);
            if (r.async)
              return (i instanceof Promise ? i : Promise.resolve(i)).then(
                (e) => ((n.value = e), n)
              );
            if (i instanceof Promise) throw new s();
            return ((n.value = i), n);
          }));
      });
    function rp(e, t) {
      return e.issues.length && void 0 === t ? { issues: [], value: void 0 } : e;
    }
    let r_ = o('$ZodOptional', (e, t) => {
        (nc.init(e, t),
          (e._zod.optin = 'optional'),
          (e._zod.optout = 'optional'),
          I(e._zod, 'values', () =>
            t.innerType._zod.values ? new Set([...t.innerType._zod.values, void 0]) : void 0
          ),
          I(e._zod, 'pattern', () => {
            let e = t.innerType._zod.pattern;
            return e ? RegExp(`^(${A(e.source)})?$`) : void 0;
          }),
          (e._zod.parse = (e, n) => {
            if ('optional' === t.innerType._zod.optin) {
              let r = t.innerType._zod.run(e, n);
              return r instanceof Promise ? r.then((t) => rp(t, e.value)) : rp(r, e.value);
            }
            return void 0 === e.value ? e : t.innerType._zod.run(e, n);
          }));
      }),
      rS = o('$ZodNullable', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'optin', () => t.innerType._zod.optin),
          I(e._zod, 'optout', () => t.innerType._zod.optout),
          I(e._zod, 'pattern', () => {
            let e = t.innerType._zod.pattern;
            return e ? RegExp(`^(${A(e.source)}|null)$`) : void 0;
          }),
          I(e._zod, 'values', () =>
            t.innerType._zod.values ? new Set([...t.innerType._zod.values, null]) : void 0
          ),
          (e._zod.parse = (e, n) => (null === e.value ? e : t.innerType._zod.run(e, n))));
      }),
      rE = o('$ZodDefault', (e, t) => {
        (nc.init(e, t),
          (e._zod.optin = 'optional'),
          I(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, n) => {
            if ('backward' === n.direction) return t.innerType._zod.run(e, n);
            if (void 0 === e.value) return ((e.value = t.defaultValue), e);
            let r = t.innerType._zod.run(e, n);
            return r instanceof Promise ? r.then((e) => rT(e, t)) : rT(r, t);
          }));
      });
    function rT(e, t) {
      return (void 0 === e.value && (e.value = t.defaultValue), e);
    }
    let rm = o('$ZodPrefault', (e, t) => {
        (nc.init(e, t),
          (e._zod.optin = 'optional'),
          I(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, n) => (
            'backward' === n.direction || (void 0 === e.value && (e.value = t.defaultValue)),
            t.innerType._zod.run(e, n)
          )));
      }),
      rg = o('$ZodNonOptional', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'values', () => {
            let e = t.innerType._zod.values;
            return e ? new Set([...e].filter((e) => void 0 !== e)) : void 0;
          }),
          (e._zod.parse = (n, r) => {
            let i = t.innerType._zod.run(n, r);
            return i instanceof Promise ? i.then((t) => rf(t, e)) : rf(i, e);
          }));
      });
    function rf(e, t) {
      return (
        e.issues.length ||
          void 0 !== e.value ||
          e.issues.push({ code: 'invalid_type', expected: 'nonoptional', input: e.value, inst: t }),
        e
      );
    }
    let rh = o('$ZodSuccess', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (e, n) => {
            if ('backward' === n.direction) throw new u('ZodSuccess');
            let r = t.innerType._zod.run(e, n);
            return r instanceof Promise
              ? r.then((t) => ((e.value = 0 === t.issues.length), e))
              : ((e.value = 0 === r.issues.length), e);
          }));
      }),
      rA = o('$ZodCatch', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'optin', () => t.innerType._zod.optin),
          I(e._zod, 'optout', () => t.innerType._zod.optout),
          I(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, n) => {
            if ('backward' === n.direction) return t.innerType._zod.run(e, n);
            let r = t.innerType._zod.run(e, n);
            return r instanceof Promise
              ? r.then(
                  (r) => (
                    (e.value = r.value),
                    r.issues.length &&
                      ((e.value = t.catchValue({
                        ...e,
                        error: { issues: r.issues.map((e) => ea(e, n, c())) },
                        input: e.value,
                      })),
                      (e.issues = [])),
                    e
                  )
                )
              : ((e.value = r.value),
                r.issues.length &&
                  ((e.value = t.catchValue({
                    ...e,
                    error: { issues: r.issues.map((e) => ea(e, n, c())) },
                    input: e.value,
                  })),
                  (e.issues = [])),
                e);
          }));
      }),
      rR = o('$ZodNaN', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (t, n) => (
            ('number' == typeof t.value && Number.isNaN(t.value)) ||
              t.issues.push({ input: t.value, inst: e, expected: 'nan', code: 'invalid_type' }),
            t
          )));
      }),
      ry = o('$ZodPipe', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'values', () => t.in._zod.values),
          I(e._zod, 'optin', () => t.in._zod.optin),
          I(e._zod, 'optout', () => t.out._zod.optout),
          I(e._zod, 'propValues', () => t.in._zod.propValues),
          (e._zod.parse = (e, n) => {
            if ('backward' === n.direction) {
              let r = t.out._zod.run(e, n);
              return r instanceof Promise ? r.then((e) => rI(e, t.in, n)) : rI(r, t.in, n);
            }
            let r = t.in._zod.run(e, n);
            return r instanceof Promise ? r.then((e) => rI(e, t.out, n)) : rI(r, t.out, n);
          }));
      });
    function rI(e, t, n) {
      return e.issues.length
        ? ((e.aborted = !0), e)
        : t._zod.run({ value: e.value, issues: e.issues }, n);
    }
    let rb = o('$ZodCodec', (e, t) => {
      (nc.init(e, t),
        I(e._zod, 'values', () => t.in._zod.values),
        I(e._zod, 'optin', () => t.in._zod.optin),
        I(e._zod, 'optout', () => t.out._zod.optout),
        I(e._zod, 'propValues', () => t.in._zod.propValues),
        (e._zod.parse = (e, n) => {
          if ('forward' === (n.direction || 'forward')) {
            let r = t.in._zod.run(e, n);
            return r instanceof Promise ? r.then((e) => rN(e, t, n)) : rN(r, t, n);
          }
          {
            let r = t.out._zod.run(e, n);
            return r instanceof Promise ? r.then((e) => rN(e, t, n)) : rN(r, t, n);
          }
        }));
    });
    function rN(e, t, n) {
      if (e.issues.length) return ((e.aborted = !0), e);
      if ('forward' === (n.direction || 'forward')) {
        let r = t.transform(e.value, e);
        return r instanceof Promise ? r.then((r) => rO(e, r, t.out, n)) : rO(e, r, t.out, n);
      }
      {
        let r = t.reverseTransform(e.value, e);
        return r instanceof Promise ? r.then((r) => rO(e, r, t.in, n)) : rO(e, r, t.in, n);
      }
    }
    function rO(e, t, n, r) {
      return e.issues.length
        ? ((e.aborted = !0), e)
        : n._zod.run({ value: t, issues: e.issues }, r);
    }
    let rv = o('$ZodReadonly', (e, t) => {
      (nc.init(e, t),
        I(e._zod, 'propValues', () => t.innerType._zod.propValues),
        I(e._zod, 'values', () => t.innerType._zod.values),
        I(e._zod, 'optin', () => t.innerType._zod.optin),
        I(e._zod, 'optout', () => t.innerType._zod.optout),
        (e._zod.parse = (e, n) => {
          if ('backward' === n.direction) return t.innerType._zod.run(e, n);
          let r = t.innerType._zod.run(e, n);
          return r instanceof Promise ? r.then(rC) : rC(r);
        }));
    });
    function rC(e) {
      return ((e.value = Object.freeze(e.value)), e);
    }
    let rP = o('$ZodTemplateLiteral', (e, t) => {
        nc.init(e, t);
        let n = [];
        for (let e of t.parts)
          if ('object' == typeof e && null !== e) {
            if (!e._zod.pattern)
              throw Error(
                `Invalid template literal part, no pattern found: ${[...e._zod.traits].shift()}`
              );
            let t = e._zod.pattern instanceof RegExp ? e._zod.pattern.source : e._zod.pattern;
            if (!t) throw Error(`Invalid template literal part: ${e._zod.traits}`);
            let r = +!!t.startsWith('^'),
              i = t.endsWith('$') ? t.length - 1 : t.length;
            n.push(t.slice(r, i));
          } else if (null === e || B.has(typeof e)) n.push(H(`${e}`));
          else throw Error(`Invalid template literal part: ${e}`);
        ((e._zod.pattern = RegExp(`^${n.join('')}$`)),
          (e._zod.parse = (n, r) => (
            'string' != typeof n.value
              ? n.issues.push({
                  input: n.value,
                  inst: e,
                  expected: 'template_literal',
                  code: 'invalid_type',
                })
              : ((e._zod.pattern.lastIndex = 0),
                e._zod.pattern.test(n.value) ||
                  n.issues.push({
                    input: n.value,
                    inst: e,
                    code: 'invalid_format',
                    format: t.format ?? 'template_literal',
                    pattern: e._zod.pattern.source,
                  })),
            n
          )));
      }),
      rM = o(
        '$ZodFunction',
        (e, t) => (
          nc.init(e, t),
          (e._def = t),
          (e._zod.def = t),
          (e.implement = (t) => {
            if ('function' != typeof t) throw Error('implement() must be called with a function');
            return function (...n) {
              let r = Reflect.apply(t, this, e._def.input ? ev(e._def.input, n) : n);
              return e._def.output ? ev(e._def.output, r) : r;
            };
          }),
          (e.implementAsync = (t) => {
            if ('function' != typeof t)
              throw Error('implementAsync() must be called with a function');
            return async function (...n) {
              let r = e._def.input ? await eP(e._def.input, n) : n,
                i = await Reflect.apply(t, this, r);
              return e._def.output ? await eP(e._def.output, i) : i;
            };
          }),
          (e._zod.parse = (t, n) => (
            'function' != typeof t.value
              ? t.issues.push({
                  code: 'invalid_type',
                  expected: 'function',
                  input: t.value,
                  inst: e,
                })
              : e._def.output && 'promise' === e._def.output._zod.def.type
                ? (t.value = e.implementAsync(t.value))
                : (t.value = e.implement(t.value)),
            t
          )),
          (e.input = (...t) => {
            let n = e.constructor;
            return new n(
              Array.isArray(t[0])
                ? {
                    type: 'function',
                    input: new rt({ type: 'tuple', items: t[0], rest: t[1] }),
                    output: e._def.output,
                  }
                : { type: 'function', input: t[0], output: e._def.output }
            );
          }),
          (e.output = (t) =>
            new e.constructor({ type: 'function', input: e._def.input, output: t })),
          e
        )
      ),
      rL = o('$ZodPromise', (e, t) => {
        (nc.init(e, t),
          (e._zod.parse = (e, n) =>
            Promise.resolve(e.value).then((e) =>
              t.innerType._zod.run({ value: e, issues: [] }, n)
            )));
      }),
      rU = o('$ZodLazy', (e, t) => {
        (nc.init(e, t),
          I(e._zod, 'innerType', () => t.getter()),
          I(e._zod, 'pattern', () => e._zod.innerType._zod.pattern),
          I(e._zod, 'propValues', () => e._zod.innerType._zod.propValues),
          I(e._zod, 'optin', () => e._zod.innerType._zod.optin ?? void 0),
          I(e._zod, 'optout', () => e._zod.innerType._zod.optout ?? void 0),
          (e._zod.parse = (t, n) => e._zod.innerType._zod.run(t, n)));
      }),
      rD = o('$ZodCustom', (e, t) => {
        (tK.init(e, t),
          nc.init(e, t),
          (e._zod.parse = (e, t) => e),
          (e._zod.check = (n) => {
            let r = n.value,
              i = t.fn(r);
            if (i instanceof Promise) return i.then((t) => rx(t, n, r, e));
            rx(i, n, r, e);
          }));
      });
    function rx(e, t, n, r) {
      if (!e) {
        let e = {
          code: 'custom',
          input: n,
          inst: r,
          path: [...(r._zod.def.path ?? [])],
          continue: !r._zod.def.abort,
        };
        (r._zod.def.params && (e.params = r._zod.def.params), t.issues.push(el(e)));
      }
    }
    (e.i(16663), e.i(3177), e.i(66089), e.i(9744));
    var rw = e.i(42540),
      rk = e.i(20876);
    function rG() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'حرف', verb: 'أن يحوي' },
              file: { unit: 'بايت', verb: 'أن يحوي' },
              array: { unit: 'عنصر', verb: 'أن يحوي' },
              set: { unit: 'عنصر', verb: 'أن يحوي' },
            },
            t = {
              regex: 'مدخل',
              email: 'بريد إلكتروني',
              url: 'رابط',
              emoji: 'إيموجي',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'تاريخ ووقت بمعيار ISO',
              date: 'تاريخ بمعيار ISO',
              time: 'وقت بمعيار ISO',
              duration: 'مدة بمعيار ISO',
              ipv4: 'عنوان IPv4',
              ipv6: 'عنوان IPv6',
              cidrv4: 'مدى عناوين بصيغة IPv4',
              cidrv6: 'مدى عناوين بصيغة IPv6',
              base64: 'نَص بترميز base64-encoded',
              base64url: 'نَص بترميز base64url-encoded',
              json_string: 'نَص على هيئة JSON',
              e164: 'رقم هاتف بمعيار E.164',
              jwt: 'JWT',
              template_literal: 'مدخل',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `مدخلات غير مقبولة: يفترض إدخال ${n.expected}، ولكن تم إدخال ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `مدخلات غير مقبولة: يفترض إدخال ${Y(n.values[0])}`;
                return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return ` أكبر من اللازم: يفترض أن تكون ${n.origin ?? 'القيمة'} ${t} ${n.maximum.toString()} ${r.unit ?? 'عنصر'}`;
                return `أكبر من اللازم: يفترض أن تكون ${n.origin ?? 'القيمة'} ${t} ${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${t} ${n.minimum.toString()} ${r.unit}`;
                return `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${t} ${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `نَص غير مقبول: يجب أن يبدأ بـ "${n.prefix}"`;
                if ('ends_with' === n.format) return `نَص غير مقبول: يجب أن ينتهي بـ "${n.suffix}"`;
                if ('includes' === n.format) return `نَص غير مقبول: يجب أن يتضمَّن "${n.includes}"`;
                if ('regex' === n.format) return `نَص غير مقبول: يجب أن يطابق النمط ${n.pattern}`;
                return `${t[n.format] ?? n.format} غير مقبول`;
              case 'not_multiple_of':
                return `رقم غير مقبول: يجب أن يكون من مضاعفات ${n.divisor}`;
              case 'unrecognized_keys':
                return `معرف${n.keys.length > 1 ? 'ات' : ''} غريب${n.keys.length > 1 ? 'ة' : ''}: ${m(n.keys, '، ')}`;
              case 'invalid_key':
                return `معرف غير مقبول في ${n.origin}`;
              case 'invalid_union':
              default:
                return 'مدخل غير مقبول';
              case 'invalid_element':
                return `مدخل غير مقبول في ${n.origin}`;
            }
          };
        })(),
      };
    }
    function rV() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'simvol', verb: 'olmalıdır' },
              file: { unit: 'bayt', verb: 'olmalıdır' },
              array: { unit: 'element', verb: 'olmalıdır' },
              set: { unit: 'element', verb: 'olmalıdır' },
            },
            t = {
              regex: 'input',
              email: 'email address',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datetime',
              date: 'ISO date',
              time: 'ISO time',
              duration: 'ISO duration',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded string',
              base64url: 'base64url-encoded string',
              json_string: 'JSON string',
              e164: 'E.164 number',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Yanlış dəyər: g\xf6zlənilən ${n.expected}, daxil olan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Yanlış dəyər: g\xf6zlənilən ${Y(n.values[0])}`;
                return `Yanlış se\xe7im: aşağıdakılardan biri olmalıdır: ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `\xc7ox b\xf6y\xfck: g\xf6zlənilən ${n.origin ?? 'dəyər'} ${t}${n.maximum.toString()} ${r.unit ?? 'element'}`;
                return `\xc7ox b\xf6y\xfck: g\xf6zlənilən ${n.origin ?? 'dəyər'} ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `\xc7ox ki\xe7ik: g\xf6zlənilən ${n.origin} ${t}${n.minimum.toString()} ${r.unit}`;
                return `\xc7ox ki\xe7ik: g\xf6zlənilən ${n.origin} ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Yanlış mətn: "${n.prefix}" ilə başlamalıdır`;
                if ('ends_with' === n.format) return `Yanlış mətn: "${n.suffix}" ilə bitməlidir`;
                if ('includes' === n.format) return `Yanlış mətn: "${n.includes}" daxil olmalıdır`;
                if ('regex' === n.format)
                  return `Yanlış mətn: ${n.pattern} şablonuna uyğun olmalıdır`;
                return `Yanlış ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Yanlış ədəd: ${n.divisor} ilə b\xf6l\xfcnə bilən olmalıdır`;
              case 'unrecognized_keys':
                return `Tanınmayan a\xe7ar${n.keys.length > 1 ? 'lar' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `${n.origin} daxilində yanlış a\xe7ar`;
              case 'invalid_union':
                return 'Yanlış dəyər';
              case 'invalid_element':
                return `${n.origin} daxilində yanlış dəyər`;
              default:
                return `Yanlış dəyər`;
            }
          };
        })(),
      };
    }
    function r$(e, t, n, r) {
      let i = Math.abs(e),
        o = i % 10,
        a = i % 100;
      return a >= 11 && a <= 19 ? r : 1 === o ? t : o >= 2 && o <= 4 ? n : r;
    }
    function rB() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: { one: 'сімвал', few: 'сімвалы', many: 'сімвалаў' }, verb: 'мець' },
              array: { unit: { one: 'элемент', few: 'элементы', many: 'элементаў' }, verb: 'мець' },
              set: { unit: { one: 'элемент', few: 'элементы', many: 'элементаў' }, verb: 'мець' },
              file: { unit: { one: 'байт', few: 'байты', many: 'байтаў' }, verb: 'мець' },
            },
            t = {
              regex: 'увод',
              email: 'email адрас',
              url: 'URL',
              emoji: 'эмодзі',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO дата і час',
              date: 'ISO дата',
              time: 'ISO час',
              duration: 'ISO працягласць',
              ipv4: 'IPv4 адрас',
              ipv6: 'IPv6 адрас',
              cidrv4: 'IPv4 дыяпазон',
              cidrv6: 'IPv6 дыяпазон',
              base64: 'радок у фармаце base64',
              base64url: 'радок у фармаце base64url',
              json_string: 'JSON радок',
              e164: 'нумар E.164',
              jwt: 'JWT',
              template_literal: 'увод',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Няправільны ўвод: чакаўся ${n.expected}, атрымана ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'лік';
                    case 'object':
                      if (Array.isArray(e)) return 'масіў';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Няправільны ўвод: чакалася ${Y(n.values[0])}`;
                return `Няправільны варыянт: чакаўся адзін з ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r) {
                  let e = r$(Number(n.maximum), r.unit.one, r.unit.few, r.unit.many);
                  return `Занадта вялікі: чакалася, што ${n.origin ?? 'значэнне'} павінна ${r.verb} ${t}${n.maximum.toString()} ${e}`;
                }
                return `Занадта вялікі: чакалася, што ${n.origin ?? 'значэнне'} павінна быць ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r) {
                  let e = r$(Number(n.minimum), r.unit.one, r.unit.few, r.unit.many);
                  return `Занадта малы: чакалася, што ${n.origin} павінна ${r.verb} ${t}${n.minimum.toString()} ${e}`;
                }
                return `Занадта малы: чакалася, што ${n.origin} павінна быць ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Няправільны радок: павінен пачынацца з "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Няправільны радок: павінен заканчвацца на "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Няправільны радок: павінен змяшчаць "${n.includes}"`;
                if ('regex' === n.format)
                  return `Няправільны радок: павінен адпавядаць шаблону ${n.pattern}`;
                return `Няправільны ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Няправільны лік: павінен быць кратным ${n.divisor}`;
              case 'unrecognized_keys':
                return `Нераспазнаны ${n.keys.length > 1 ? 'ключы' : 'ключ'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Няправільны ключ у ${n.origin}`;
              case 'invalid_union':
                return 'Няправільны ўвод';
              case 'invalid_element':
                return `Няправільнае значэнне ў ${n.origin}`;
              default:
                return `Няправільны ўвод`;
            }
          };
        })(),
      };
    }
    function rH() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caràcters', verb: 'contenir' },
              file: { unit: 'bytes', verb: 'contenir' },
              array: { unit: 'elements', verb: 'contenir' },
              set: { unit: 'elements', verb: 'contenir' },
            },
            t = {
              regex: 'entrada',
              email: 'adreça electrònica',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data i hora ISO',
              date: 'data ISO',
              time: 'hora ISO',
              duration: 'durada ISO',
              ipv4: 'adreça IPv4',
              ipv6: 'adreça IPv6',
              cidrv4: 'rang IPv4',
              cidrv6: 'rang IPv6',
              base64: 'cadena codificada en base64',
              base64url: 'cadena codificada en base64url',
              json_string: 'cadena JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Tipus inv\xe0lid: s'esperava ${n.expected}, s'ha rebut ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Valor inv\xe0lid: s'esperava ${Y(n.values[0])}`;
                return `Opci\xf3 inv\xe0lida: s'esperava una de ${m(n.values, ' o ')}`;
              case 'too_big': {
                let t = n.inclusive ? 'com a màxim' : 'menys de',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Massa gran: s'esperava que ${n.origin ?? 'el valor'} contingu\xe9s ${t} ${n.maximum.toString()} ${r.unit ?? 'elements'}`;
                return `Massa gran: s'esperava que ${n.origin ?? 'el valor'} fos ${t} ${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? 'com a mínim' : 'més de',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Massa petit: s'esperava que ${n.origin} contingu\xe9s ${t} ${n.minimum.toString()} ${r.unit}`;
                return `Massa petit: s'esperava que ${n.origin} fos ${t} ${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Format inv\xe0lid: ha de comen\xe7ar amb "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Format inv\xe0lid: ha d'acabar amb "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Format inv\xe0lid: ha d'incloure "${n.includes}"`;
                if ('regex' === n.format)
                  return `Format inv\xe0lid: ha de coincidir amb el patr\xf3 ${n.pattern}`;
                return `Format inv\xe0lid per a ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe0lid: ha de ser m\xfaltiple de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Clau${n.keys.length > 1 ? 's' : ''} no reconeguda${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Clau inv\xe0lida a ${n.origin}`;
              case 'invalid_union':
                return 'Entrada invàlida';
              case 'invalid_element':
                return `Element inv\xe0lid a ${n.origin}`;
              default:
                return `Entrada inv\xe0lida`;
            }
          };
        })(),
      };
    }
    function rj() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znaků', verb: 'mít' },
              file: { unit: 'bajtů', verb: 'mít' },
              array: { unit: 'prvků', verb: 'mít' },
              set: { unit: 'prvků', verb: 'mít' },
            },
            t = {
              regex: 'regulární výraz',
              email: 'e-mailová adresa',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'datum a čas ve formátu ISO',
              date: 'datum ve formátu ISO',
              time: 'čas ve formátu ISO',
              duration: 'doba trvání ISO',
              ipv4: 'IPv4 adresa',
              ipv6: 'IPv6 adresa',
              cidrv4: 'rozsah IPv4',
              cidrv6: 'rozsah IPv6',
              base64: 'řetězec zakódovaný ve formátu base64',
              base64url: 'řetězec zakódovaný ve formátu base64url',
              json_string: 'řetězec ve formátu JSON',
              e164: 'číslo E.164',
              jwt: 'JWT',
              template_literal: 'vstup',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Neplatn\xfd vstup: oček\xe1v\xe1no ${n.expected}, obdrženo ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'číslo';
                    case 'string':
                      return 'řetězec';
                    case 'boolean':
                      return 'boolean';
                    case 'bigint':
                      return 'bigint';
                    case 'function':
                      return 'funkce';
                    case 'symbol':
                      return 'symbol';
                    case 'undefined':
                      return 'undefined';
                    case 'object':
                      if (Array.isArray(e)) return 'pole';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Neplatn\xfd vstup: oček\xe1v\xe1no ${Y(n.values[0])}`;
                return `Neplatn\xe1 možnost: oček\xe1v\xe1na jedna z hodnot ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Hodnota je př\xedliš velk\xe1: ${n.origin ?? 'hodnota'} mus\xed m\xedt ${t}${n.maximum.toString()} ${r.unit ?? 'prvků'}`;
                return `Hodnota je př\xedliš velk\xe1: ${n.origin ?? 'hodnota'} mus\xed b\xfdt ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Hodnota je př\xedliš mal\xe1: ${n.origin ?? 'hodnota'} mus\xed m\xedt ${t}${n.minimum.toString()} ${r.unit ?? 'prvků'}`;
                return `Hodnota je př\xedliš mal\xe1: ${n.origin ?? 'hodnota'} mus\xed b\xfdt ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Neplatn\xfd řetězec: mus\xed zač\xednat na "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Neplatn\xfd řetězec: mus\xed končit na "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Neplatn\xfd řetězec: mus\xed obsahovat "${n.includes}"`;
                if ('regex' === n.format)
                  return `Neplatn\xfd řetězec: mus\xed odpov\xeddat vzoru ${n.pattern}`;
                return `Neplatn\xfd form\xe1t ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Neplatn\xe9 č\xedslo: mus\xed b\xfdt n\xe1sobkem ${n.divisor}`;
              case 'unrecognized_keys':
                return `Nezn\xe1m\xe9 kl\xedče: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Neplatn\xfd kl\xedč v ${n.origin}`;
              case 'invalid_union':
                return 'Neplatný vstup';
              case 'invalid_element':
                return `Neplatn\xe1 hodnota v ${n.origin}`;
              default:
                return `Neplatn\xfd vstup`;
            }
          };
        })(),
      };
    }
    function rF() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tegn', verb: 'havde' },
              file: { unit: 'bytes', verb: 'havde' },
              array: { unit: 'elementer', verb: 'indeholdt' },
              set: { unit: 'elementer', verb: 'indeholdt' },
            },
            t = {
              string: 'streng',
              number: 'tal',
              boolean: 'boolean',
              array: 'liste',
              object: 'objekt',
              set: 'sæt',
              file: 'fil',
            },
            n = {
              regex: 'input',
              email: 'e-mailadresse',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dato- og klokkeslæt',
              date: 'ISO-dato',
              time: 'ISO-klokkeslæt',
              duration: 'ISO-varighed',
              ipv4: 'IPv4-område',
              ipv6: 'IPv6-område',
              cidrv4: 'IPv4-spektrum',
              cidrv6: 'IPv6-spektrum',
              base64: 'base64-kodet streng',
              base64url: 'base64url-kodet streng',
              json_string: 'JSON-streng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            var i, o, a, s;
            switch (r.code) {
              case 'invalid_type':
                return `Ugyldigt input: forventede ${t[(i = r.expected)] ?? i}, fik ${
                  t[
                    (o = ((e) => {
                      let t = typeof e;
                      switch (t) {
                        case 'number':
                          return Number.isNaN(e) ? 'NaN' : 'tal';
                        case 'object':
                          if (Array.isArray(e)) return 'liste';
                          if (null === e) return 'null';
                          if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                            return e.constructor.name;
                          return 'objekt';
                      }
                      return t;
                    })(r.input))
                  ] ?? o
                }`;
              case 'invalid_value':
                if (1 === r.values.length) return `Ugyldig v\xe6rdi: forventede ${Y(r.values[0])}`;
                return `Ugyldigt valg: forventede en af f\xf8lgende ${m(r.values, '|')}`;
              case 'too_big': {
                let n = r.inclusive ? '<=' : '<',
                  i = e[r.origin] ?? null,
                  o = t[(a = r.origin)] ?? a;
                if (i)
                  return `For stor: forventede ${o ?? 'value'} ${i.verb} ${n} ${r.maximum.toString()} ${i.unit ?? 'elementer'}`;
                return `For stor: forventede ${o ?? 'value'} havde ${n} ${r.maximum.toString()}`;
              }
              case 'too_small': {
                let n = r.inclusive ? '>=' : '>',
                  i = e[r.origin] ?? null,
                  o = t[(s = r.origin)] ?? s;
                if (i)
                  return `For lille: forventede ${o} ${i.verb} ${n} ${r.minimum.toString()} ${i.unit}`;
                return `For lille: forventede ${o} havde ${n} ${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ugyldig streng: skal starte med "${r.prefix}"`;
                if ('ends_with' === r.format) return `Ugyldig streng: skal ende med "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Ugyldig streng: skal indeholde "${r.includes}"`;
                if ('regex' === r.format)
                  return `Ugyldig streng: skal matche m\xf8nsteret ${r.pattern}`;
                return `Ugyldig ${n[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ugyldigt tal: skal v\xe6re deleligt med ${r.divisor}`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Ukendte nøgler' : 'Ukendt nøgle'}: ${m(r.keys, ', ')}`;
              case 'invalid_key':
                return `Ugyldig n\xf8gle i ${r.origin}`;
              case 'invalid_union':
                return 'Ugyldigt input: matcher ingen af de tilladte typer';
              case 'invalid_element':
                return `Ugyldig v\xe6rdi i ${r.origin}`;
              default:
                return 'Ugyldigt input';
            }
          };
        })(),
      };
    }
    function rZ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'Zeichen', verb: 'zu haben' },
              file: { unit: 'Bytes', verb: 'zu haben' },
              array: { unit: 'Elemente', verb: 'zu haben' },
              set: { unit: 'Elemente', verb: 'zu haben' },
            },
            t = {
              regex: 'Eingabe',
              email: 'E-Mail-Adresse',
              url: 'URL',
              emoji: 'Emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-Datum und -Uhrzeit',
              date: 'ISO-Datum',
              time: 'ISO-Uhrzeit',
              duration: 'ISO-Dauer',
              ipv4: 'IPv4-Adresse',
              ipv6: 'IPv6-Adresse',
              cidrv4: 'IPv4-Bereich',
              cidrv6: 'IPv6-Bereich',
              base64: 'Base64-codierter String',
              base64url: 'Base64-URL-codierter String',
              json_string: 'JSON-String',
              e164: 'E.164-Nummer',
              jwt: 'JWT',
              template_literal: 'Eingabe',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Ung\xfcltige Eingabe: erwartet ${n.expected}, erhalten ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'Zahl';
                    case 'object':
                      if (Array.isArray(e)) return 'Array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Ung\xfcltige Eingabe: erwartet ${Y(n.values[0])}`;
                return `Ung\xfcltige Option: erwartet eine von ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Zu gro\xdf: erwartet, dass ${n.origin ?? 'Wert'} ${t}${n.maximum.toString()} ${r.unit ?? 'Elemente'} hat`;
                return `Zu gro\xdf: erwartet, dass ${n.origin ?? 'Wert'} ${t}${n.maximum.toString()} ist`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Zu klein: erwartet, dass ${n.origin} ${t}${n.minimum.toString()} ${r.unit} hat`;
                return `Zu klein: erwartet, dass ${n.origin} ${t}${n.minimum.toString()} ist`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ung\xfcltiger String: muss mit "${n.prefix}" beginnen`;
                if ('ends_with' === n.format)
                  return `Ung\xfcltiger String: muss mit "${n.suffix}" enden`;
                if ('includes' === n.format)
                  return `Ung\xfcltiger String: muss "${n.includes}" enthalten`;
                if ('regex' === n.format)
                  return `Ung\xfcltiger String: muss dem Muster ${n.pattern} entsprechen`;
                return `Ung\xfcltig: ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ung\xfcltige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Unbekannte Schlüssel' : 'Unbekannter Schlüssel'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Ung\xfcltiger Schl\xfcssel in ${n.origin}`;
              case 'invalid_union':
                return 'Ungültige Eingabe';
              case 'invalid_element':
                return `Ung\xfcltiger Wert in ${n.origin}`;
              default:
                return `Ung\xfcltige Eingabe`;
            }
          };
        })(),
      };
    }
    function rY() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karaktrojn', verb: 'havi' },
              file: { unit: 'bajtojn', verb: 'havi' },
              array: { unit: 'elementojn', verb: 'havi' },
              set: { unit: 'elementojn', verb: 'havi' },
            },
            t = {
              regex: 'enigo',
              email: 'retadreso',
              url: 'URL',
              emoji: 'emoĝio',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-datotempo',
              date: 'ISO-dato',
              time: 'ISO-tempo',
              duration: 'ISO-daŭro',
              ipv4: 'IPv4-adreso',
              ipv6: 'IPv6-adreso',
              cidrv4: 'IPv4-rango',
              cidrv6: 'IPv6-rango',
              base64: '64-ume kodita karaktraro',
              base64url: 'URL-64-ume kodita karaktraro',
              json_string: 'JSON-karaktraro',
              e164: 'E.164-nombro',
              jwt: 'JWT',
              template_literal: 'enigo',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Nevalida enigo: atendiĝis ${n.expected}, riceviĝis ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombro';
                    case 'object':
                      if (Array.isArray(e)) return 'tabelo';
                      if (null === e) return 'senvalora';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Nevalida enigo: atendiĝis ${Y(n.values[0])}`;
                return `Nevalida opcio: atendiĝis unu el ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Tro granda: atendiĝis ke ${n.origin ?? 'valoro'} havu ${t}${n.maximum.toString()} ${r.unit ?? 'elementojn'}`;
                return `Tro granda: atendiĝis ke ${n.origin ?? 'valoro'} havu ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Tro malgranda: atendiĝis ke ${n.origin} havu ${t}${n.minimum.toString()} ${r.unit}`;
                return `Tro malgranda: atendiĝis ke ${n.origin} estu ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Nevalida karaktraro: devas komenciĝi per "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Nevalida karaktraro: devas finiĝi per "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Nevalida karaktraro: devas inkluzivi "${n.includes}"`;
                if ('regex' === n.format)
                  return `Nevalida karaktraro: devas kongrui kun la modelo ${n.pattern}`;
                return `Nevalida ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Nevalida nombro: devas esti oblo de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Nekonata${n.keys.length > 1 ? 'j' : ''} ŝlosilo${n.keys.length > 1 ? 'j' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Nevalida ŝlosilo en ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Nevalida enigo';
              case 'invalid_element':
                return `Nevalida valoro en ${n.origin}`;
            }
          };
        })(),
      };
    }
    function rW() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caracteres', verb: 'tener' },
              file: { unit: 'bytes', verb: 'tener' },
              array: { unit: 'elementos', verb: 'tener' },
              set: { unit: 'elementos', verb: 'tener' },
            },
            t = {
              regex: 'entrada',
              email: 'dirección de correo electrónico',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'fecha y hora ISO',
              date: 'fecha ISO',
              time: 'hora ISO',
              duration: 'duración ISO',
              ipv4: 'dirección IPv4',
              ipv6: 'dirección IPv6',
              cidrv4: 'rango IPv4',
              cidrv6: 'rango IPv6',
              base64: 'cadena codificada en base64',
              base64url: 'URL codificada en base64',
              json_string: 'cadena JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Entrada inv\xe1lida: se esperaba ${n.expected}, recibido ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'número';
                    case 'object':
                      if (Array.isArray(e)) return 'arreglo';
                      if (null === e) return 'nulo';
                      if (Object.getPrototypeOf(e) !== Object.prototype) return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Entrada inv\xe1lida: se esperaba ${Y(n.values[0])}`;
                return `Opci\xf3n inv\xe1lida: se esperaba una de ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Demasiado grande: se esperaba que ${n.origin ?? 'valor'} tuviera ${t}${n.maximum.toString()} ${r.unit ?? 'elementos'}`;
                return `Demasiado grande: se esperaba que ${n.origin ?? 'valor'} fuera ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Demasiado peque\xf1o: se esperaba que ${n.origin} tuviera ${t}${n.minimum.toString()} ${r.unit}`;
                return `Demasiado peque\xf1o: se esperaba que ${n.origin} fuera ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Cadena inv\xe1lida: debe comenzar con "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Cadena inv\xe1lida: debe terminar en "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Cadena inv\xe1lida: debe incluir "${n.includes}"`;
                if ('regex' === n.format)
                  return `Cadena inv\xe1lida: debe coincidir con el patr\xf3n ${n.pattern}`;
                return `Inv\xe1lido ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe1lido: debe ser m\xfaltiplo de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Llave${n.keys.length > 1 ? 's' : ''} desconocida${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Llave inv\xe1lida en ${n.origin}`;
              case 'invalid_union':
                return 'Entrada inválida';
              case 'invalid_element':
                return `Valor inv\xe1lido en ${n.origin}`;
              default:
                return `Entrada inv\xe1lida`;
            }
          };
        })(),
      };
    }
    function rK() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'کاراکتر', verb: 'داشته باشد' },
              file: { unit: 'بایت', verb: 'داشته باشد' },
              array: { unit: 'آیتم', verb: 'داشته باشد' },
              set: { unit: 'آیتم', verb: 'داشته باشد' },
            },
            t = {
              regex: 'ورودی',
              email: 'آدرس ایمیل',
              url: 'URL',
              emoji: 'ایموجی',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'تاریخ و زمان ایزو',
              date: 'تاریخ ایزو',
              time: 'زمان ایزو',
              duration: 'مدت زمان ایزو',
              ipv4: 'IPv4 آدرس',
              ipv6: 'IPv6 آدرس',
              cidrv4: 'IPv4 دامنه',
              cidrv6: 'IPv6 دامنه',
              base64: 'base64-encoded رشته',
              base64url: 'base64url-encoded رشته',
              json_string: 'JSON رشته',
              e164: 'E.164 عدد',
              jwt: 'JWT',
              template_literal: 'ورودی',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `ورودی نامعتبر: می‌بایست ${n.expected} می‌بود، ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'عدد';
                    case 'object':
                      if (Array.isArray(e)) return 'آرایه';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)} دریافت شد`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `ورودی نامعتبر: می‌بایست ${Y(n.values[0])} می‌بود`;
                return `گزینه نامعتبر: می‌بایست یکی از ${m(n.values, '|')} می‌بود`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `خیلی بزرگ: ${n.origin ?? 'مقدار'} باید ${t}${n.maximum.toString()} ${r.unit ?? 'عنصر'} باشد`;
                return `خیلی بزرگ: ${n.origin ?? 'مقدار'} باید ${t}${n.maximum.toString()} باشد`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `خیلی کوچک: ${n.origin} باید ${t}${n.minimum.toString()} ${r.unit} باشد`;
                return `خیلی کوچک: ${n.origin} باید ${t}${n.minimum.toString()} باشد`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `رشته نامعتبر: باید با "${n.prefix}" شروع شود`;
                if ('ends_with' === n.format) return `رشته نامعتبر: باید با "${n.suffix}" تمام شود`;
                if ('includes' === n.format) return `رشته نامعتبر: باید شامل "${n.includes}" باشد`;
                if ('regex' === n.format)
                  return `رشته نامعتبر: باید با الگوی ${n.pattern} مطابقت داشته باشد`;
                return `${t[n.format] ?? n.format} نامعتبر`;
              case 'not_multiple_of':
                return `عدد نامعتبر: باید مضرب ${n.divisor} باشد`;
              case 'unrecognized_keys':
                return `کلید${n.keys.length > 1 ? 'های' : ''} ناشناس: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `کلید ناشناس در ${n.origin}`;
              case 'invalid_union':
              default:
                return `ورودی نامعتبر`;
              case 'invalid_element':
                return `مقدار نامعتبر در ${n.origin}`;
            }
          };
        })(),
      };
    }
    function rz() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'merkkiä', subject: 'merkkijonon' },
              file: { unit: 'tavua', subject: 'tiedoston' },
              array: { unit: 'alkiota', subject: 'listan' },
              set: { unit: 'alkiota', subject: 'joukon' },
              number: { unit: '', subject: 'luvun' },
              bigint: { unit: '', subject: 'suuren kokonaisluvun' },
              int: { unit: '', subject: 'kokonaisluvun' },
              date: { unit: '', subject: 'päivämäärän' },
            },
            t = {
              regex: 'säännöllinen lauseke',
              email: 'sähköpostiosoite',
              url: 'URL-osoite',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-aikaleima',
              date: 'ISO-päivämäärä',
              time: 'ISO-aika',
              duration: 'ISO-kesto',
              ipv4: 'IPv4-osoite',
              ipv6: 'IPv6-osoite',
              cidrv4: 'IPv4-alue',
              cidrv6: 'IPv6-alue',
              base64: 'base64-koodattu merkkijono',
              base64url: 'base64url-koodattu merkkijono',
              json_string: 'JSON-merkkijono',
              e164: 'E.164-luku',
              jwt: 'JWT',
              template_literal: 'templaattimerkkijono',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Virheellinen tyyppi: odotettiin ${n.expected}, oli ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Virheellinen sy\xf6te: t\xe4ytyy olla ${Y(n.values[0])}`;
                return `Virheellinen valinta: t\xe4ytyy olla yksi seuraavista: ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Liian suuri: ${r.subject} t\xe4ytyy olla ${t}${n.maximum.toString()} ${r.unit}`.trim();
                return `Liian suuri: arvon t\xe4ytyy olla ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Liian pieni: ${r.subject} t\xe4ytyy olla ${t}${n.minimum.toString()} ${r.unit}`.trim();
                return `Liian pieni: arvon t\xe4ytyy olla ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy alkaa "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy loppua "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy sis\xe4lt\xe4\xe4 "${n.includes}"`;
                if ('regex' === n.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy vastata s\xe4\xe4nn\xf6llist\xe4 lauseketta ${n.pattern}`;
                return `Virheellinen ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Virheellinen luku: t\xe4ytyy olla luvun ${n.divisor} monikerta`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Tuntemattomat avaimet' : 'Tuntematon avain'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return 'Virheellinen avain tietueessa';
              case 'invalid_union':
                return 'Virheellinen unioni';
              case 'invalid_element':
                return 'Virheellinen arvo joukossa';
              default:
                return `Virheellinen sy\xf6te`;
            }
          };
        })(),
      };
    }
    function rX() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caractères', verb: 'avoir' },
              file: { unit: 'octets', verb: 'avoir' },
              array: { unit: 'éléments', verb: 'avoir' },
              set: { unit: 'éléments', verb: 'avoir' },
            },
            t = {
              regex: 'entrée',
              email: 'adresse e-mail',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'date et heure ISO',
              date: 'date ISO',
              time: 'heure ISO',
              duration: 'durée ISO',
              ipv4: 'adresse IPv4',
              ipv6: 'adresse IPv6',
              cidrv4: 'plage IPv4',
              cidrv6: 'plage IPv6',
              base64: 'chaîne encodée en base64',
              base64url: 'chaîne encodée en base64url',
              json_string: 'chaîne JSON',
              e164: 'numéro E.164',
              jwt: 'JWT',
              template_literal: 'entrée',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Entr\xe9e invalide : ${n.expected} attendu, ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombre';
                    case 'object':
                      if (Array.isArray(e)) return 'tableau';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)} re\xe7u`;
              case 'invalid_value':
                if (1 === n.values.length) return `Entr\xe9e invalide : ${Y(n.values[0])} attendu`;
                return `Option invalide : une valeur parmi ${m(n.values, '|')} attendue`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Trop grand : ${n.origin ?? 'valeur'} doit ${r.verb} ${t}${n.maximum.toString()} ${r.unit ?? 'élément(s)'}`;
                return `Trop grand : ${n.origin ?? 'valeur'} doit \xeatre ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Trop petit : ${n.origin} doit ${r.verb} ${t}${n.minimum.toString()} ${r.unit}`;
                return `Trop petit : ${n.origin} doit \xeatre ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Cha\xeene invalide : doit commencer par "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Cha\xeene invalide : doit se terminer par "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Cha\xeene invalide : doit inclure "${n.includes}"`;
                if ('regex' === n.format)
                  return `Cha\xeene invalide : doit correspondre au mod\xe8le ${n.pattern}`;
                return `${t[n.format] ?? n.format} invalide`;
              case 'not_multiple_of':
                return `Nombre invalide : doit \xeatre un multiple de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Cl\xe9${n.keys.length > 1 ? 's' : ''} non reconnue${n.keys.length > 1 ? 's' : ''} : ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Cl\xe9 invalide dans ${n.origin}`;
              case 'invalid_union':
                return 'Entrée invalide';
              case 'invalid_element':
                return `Valeur invalide dans ${n.origin}`;
              default:
                return `Entr\xe9e invalide`;
            }
          };
        })(),
      };
    }
    function rJ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caractères', verb: 'avoir' },
              file: { unit: 'octets', verb: 'avoir' },
              array: { unit: 'éléments', verb: 'avoir' },
              set: { unit: 'éléments', verb: 'avoir' },
            },
            t = {
              regex: 'entrée',
              email: 'adresse courriel',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'date-heure ISO',
              date: 'date ISO',
              time: 'heure ISO',
              duration: 'durée ISO',
              ipv4: 'adresse IPv4',
              ipv6: 'adresse IPv6',
              cidrv4: 'plage IPv4',
              cidrv6: 'plage IPv6',
              base64: 'chaîne encodée en base64',
              base64url: 'chaîne encodée en base64url',
              json_string: 'chaîne JSON',
              e164: 'numéro E.164',
              jwt: 'JWT',
              template_literal: 'entrée',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Entr\xe9e invalide : attendu ${n.expected}, re\xe7u ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Entr\xe9e invalide : attendu ${Y(n.values[0])}`;
                return `Option invalide : attendu l'une des valeurs suivantes ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '≤' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Trop grand : attendu que ${n.origin ?? 'la valeur'} ait ${t}${n.maximum.toString()} ${r.unit}`;
                return `Trop grand : attendu que ${n.origin ?? 'la valeur'} soit ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '≥' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Trop petit : attendu que ${n.origin} ait ${t}${n.minimum.toString()} ${r.unit}`;
                return `Trop petit : attendu que ${n.origin} soit ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Cha\xeene invalide : doit commencer par "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Cha\xeene invalide : doit se terminer par "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Cha\xeene invalide : doit inclure "${n.includes}"`;
                if ('regex' === n.format)
                  return `Cha\xeene invalide : doit correspondre au motif ${n.pattern}`;
                return `${t[n.format] ?? n.format} invalide`;
              case 'not_multiple_of':
                return `Nombre invalide : doit \xeatre un multiple de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Cl\xe9${n.keys.length > 1 ? 's' : ''} non reconnue${n.keys.length > 1 ? 's' : ''} : ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Cl\xe9 invalide dans ${n.origin}`;
              case 'invalid_union':
                return 'Entrée invalide';
              case 'invalid_element':
                return `Valeur invalide dans ${n.origin}`;
              default:
                return `Entr\xe9e invalide`;
            }
          };
        })(),
      };
    }
    function rQ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'אותיות', verb: 'לכלול' },
              file: { unit: 'בייטים', verb: 'לכלול' },
              array: { unit: 'פריטים', verb: 'לכלול' },
              set: { unit: 'פריטים', verb: 'לכלול' },
            },
            t = {
              regex: 'קלט',
              email: 'כתובת אימייל',
              url: 'כתובת רשת',
              emoji: "אימוג'י",
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'תאריך וזמן ISO',
              date: 'תאריך ISO',
              time: 'זמן ISO',
              duration: 'משך זמן ISO',
              ipv4: 'כתובת IPv4',
              ipv6: 'כתובת IPv6',
              cidrv4: 'טווח IPv4',
              cidrv6: 'טווח IPv6',
              base64: 'מחרוזת בבסיס 64',
              base64url: 'מחרוזת בבסיס 64 לכתובות רשת',
              json_string: 'מחרוזת JSON',
              e164: 'מספר E.164',
              jwt: 'JWT',
              template_literal: 'קלט',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `קלט לא תקין: צריך ${n.expected}, התקבל ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `קלט לא תקין: צריך ${Y(n.values[0])}`;
                return `קלט לא תקין: צריך אחת מהאפשרויות  ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `גדול מדי: ${n.origin ?? 'value'} צריך להיות ${t}${n.maximum.toString()} ${r.unit ?? 'elements'}`;
                return `גדול מדי: ${n.origin ?? 'value'} צריך להיות ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `קטן מדי: ${n.origin} צריך להיות ${t}${n.minimum.toString()} ${r.unit}`;
                return `קטן מדי: ${n.origin} צריך להיות ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `מחרוזת לא תקינה: חייבת להתחיל ב"${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `מחרוזת לא תקינה: חייבת להסתיים ב "${n.suffix}"`;
                if ('includes' === n.format) return `מחרוזת לא תקינה: חייבת לכלול "${n.includes}"`;
                if ('regex' === n.format)
                  return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${n.pattern}`;
                return `${t[n.format] ?? n.format} לא תקין`;
              case 'not_multiple_of':
                return `מספר לא תקין: חייב להיות מכפלה של ${n.divisor}`;
              case 'unrecognized_keys':
                return `מפתח${n.keys.length > 1 ? 'ות' : ''} לא מזוה${n.keys.length > 1 ? 'ים' : 'ה'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `מפתח לא תקין ב${n.origin}`;
              case 'invalid_union':
                return 'קלט לא תקין';
              case 'invalid_element':
                return `ערך לא תקין ב${n.origin}`;
              default:
                return `קלט לא תקין`;
            }
          };
        })(),
      };
    }
    function rq() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'legyen' },
              file: { unit: 'byte', verb: 'legyen' },
              array: { unit: 'elem', verb: 'legyen' },
              set: { unit: 'elem', verb: 'legyen' },
            },
            t = {
              regex: 'bemenet',
              email: 'email cím',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO időbélyeg',
              date: 'ISO dátum',
              time: 'ISO idő',
              duration: 'ISO időintervallum',
              ipv4: 'IPv4 cím',
              ipv6: 'IPv6 cím',
              cidrv4: 'IPv4 tartomány',
              cidrv6: 'IPv6 tartomány',
              base64: 'base64-kódolt string',
              base64url: 'base64url-kódolt string',
              json_string: 'JSON string',
              e164: 'E.164 szám',
              jwt: 'JWT',
              template_literal: 'bemenet',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `\xc9rv\xe9nytelen bemenet: a v\xe1rt \xe9rt\xe9k ${n.expected}, a kapott \xe9rt\xe9k ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'szám';
                    case 'object':
                      if (Array.isArray(e)) return 'tömb';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `\xc9rv\xe9nytelen bemenet: a v\xe1rt \xe9rt\xe9k ${Y(n.values[0])}`;
                return `\xc9rv\xe9nytelen opci\xf3: valamelyik \xe9rt\xe9k v\xe1rt ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `T\xfal nagy: ${n.origin ?? 'érték'} m\xe9rete t\xfal nagy ${t}${n.maximum.toString()} ${r.unit ?? 'elem'}`;
                return `T\xfal nagy: a bemeneti \xe9rt\xe9k ${n.origin ?? 'érték'} t\xfal nagy: ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `T\xfal kicsi: a bemeneti \xe9rt\xe9k ${n.origin} m\xe9rete t\xfal kicsi ${t}${n.minimum.toString()} ${r.unit}`;
                return `T\xfal kicsi: a bemeneti \xe9rt\xe9k ${n.origin} t\xfal kicsi ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `\xc9rv\xe9nytelen string: "${n.prefix}" \xe9rt\xe9kkel kell kezdődnie`;
                if ('ends_with' === n.format)
                  return `\xc9rv\xe9nytelen string: "${n.suffix}" \xe9rt\xe9kkel kell v\xe9gződnie`;
                if ('includes' === n.format)
                  return `\xc9rv\xe9nytelen string: "${n.includes}" \xe9rt\xe9ket kell tartalmaznia`;
                if ('regex' === n.format)
                  return `\xc9rv\xe9nytelen string: ${n.pattern} mint\xe1nak kell megfelelnie`;
                return `\xc9rv\xe9nytelen ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `\xc9rv\xe9nytelen sz\xe1m: ${n.divisor} t\xf6bbsz\xf6r\xf6s\xe9nek kell lennie`;
              case 'unrecognized_keys':
                return `Ismeretlen kulcs${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `\xc9rv\xe9nytelen kulcs ${n.origin}`;
              case 'invalid_union':
                return 'Érvénytelen bemenet';
              case 'invalid_element':
                return `\xc9rv\xe9nytelen \xe9rt\xe9k: ${n.origin}`;
              default:
                return `\xc9rv\xe9nytelen bemenet`;
            }
          };
        })(),
      };
    }
    function r0() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'memiliki' },
              file: { unit: 'byte', verb: 'memiliki' },
              array: { unit: 'item', verb: 'memiliki' },
              set: { unit: 'item', verb: 'memiliki' },
            },
            t = {
              regex: 'input',
              email: 'alamat email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'tanggal dan waktu format ISO',
              date: 'tanggal format ISO',
              time: 'jam format ISO',
              duration: 'durasi format ISO',
              ipv4: 'alamat IPv4',
              ipv6: 'alamat IPv6',
              cidrv4: 'rentang alamat IPv4',
              cidrv6: 'rentang alamat IPv6',
              base64: 'string dengan enkode base64',
              base64url: 'string dengan enkode base64url',
              json_string: 'string JSON',
              e164: 'angka E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Input tidak valid: diharapkan ${n.expected}, diterima ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Input tidak valid: diharapkan ${Y(n.values[0])}`;
                return `Pilihan tidak valid: diharapkan salah satu dari ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Terlalu besar: diharapkan ${n.origin ?? 'value'} memiliki ${t}${n.maximum.toString()} ${r.unit ?? 'elemen'}`;
                return `Terlalu besar: diharapkan ${n.origin ?? 'value'} menjadi ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Terlalu kecil: diharapkan ${n.origin} memiliki ${t}${n.minimum.toString()} ${r.unit}`;
                return `Terlalu kecil: diharapkan ${n.origin} menjadi ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `String tidak valid: harus dimulai dengan "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `String tidak valid: harus berakhir dengan "${n.suffix}"`;
                if ('includes' === n.format)
                  return `String tidak valid: harus menyertakan "${n.includes}"`;
                if ('regex' === n.format)
                  return `String tidak valid: harus sesuai pola ${n.pattern}`;
                return `${t[n.format] ?? n.format} tidak valid`;
              case 'not_multiple_of':
                return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
              case 'unrecognized_keys':
                return `Kunci tidak dikenali ${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Kunci tidak valid di ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Input tidak valid';
              case 'invalid_element':
                return `Nilai tidak valid di ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r1() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'stafi', verb: 'að hafa' },
              file: { unit: 'bæti', verb: 'að hafa' },
              array: { unit: 'hluti', verb: 'að hafa' },
              set: { unit: 'hluti', verb: 'að hafa' },
            },
            t = {
              regex: 'gildi',
              email: 'netfang',
              url: 'vefslóð',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dagsetning og tími',
              date: 'ISO dagsetning',
              time: 'ISO tími',
              duration: 'ISO tímalengd',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded strengur',
              base64url: 'base64url-encoded strengur',
              json_string: 'JSON strengur',
              e164: 'E.164 tölugildi',
              jwt: 'JWT',
              template_literal: 'gildi',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Rangt gildi: \xde\xfa sl\xf3st inn ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'númer';
                    case 'object':
                      if (Array.isArray(e)) return 'fylki';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)} \xfear sem \xe1 a\xf0 vera ${n.expected}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Rangt gildi: gert r\xe1\xf0 fyrir ${Y(n.values[0])}`;
                return `\xd3gilt val: m\xe1 vera eitt af eftirfarandi ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Of st\xf3rt: gert er r\xe1\xf0 fyrir a\xf0 ${n.origin ?? 'gildi'} hafi ${t}${n.maximum.toString()} ${r.unit ?? 'hluti'}`;
                return `Of st\xf3rt: gert er r\xe1\xf0 fyrir a\xf0 ${n.origin ?? 'gildi'} s\xe9 ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Of l\xedti\xf0: gert er r\xe1\xf0 fyrir a\xf0 ${n.origin} hafi ${t}${n.minimum.toString()} ${r.unit}`;
                return `Of l\xedti\xf0: gert er r\xe1\xf0 fyrir a\xf0 ${n.origin} s\xe9 ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 byrja \xe1 "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 enda \xe1 "${n.suffix}"`;
                if ('includes' === n.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 innihalda "${n.includes}"`;
                if ('regex' === n.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 fylgja mynstri ${n.pattern}`;
                return `Rangt ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `R\xf6ng tala: ver\xf0ur a\xf0 vera margfeldi af ${n.divisor}`;
              case 'unrecognized_keys':
                return `\xd3\xfeekkt ${n.keys.length > 1 ? 'ir lyklar' : 'ur lykill'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Rangur lykill \xed ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Rangt gildi';
              case 'invalid_element':
                return `Rangt gildi \xed ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r2() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caratteri', verb: 'avere' },
              file: { unit: 'byte', verb: 'avere' },
              array: { unit: 'elementi', verb: 'avere' },
              set: { unit: 'elementi', verb: 'avere' },
            },
            t = {
              regex: 'input',
              email: 'indirizzo email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data e ora ISO',
              date: 'data ISO',
              time: 'ora ISO',
              duration: 'durata ISO',
              ipv4: 'indirizzo IPv4',
              ipv6: 'indirizzo IPv6',
              cidrv4: 'intervallo IPv4',
              cidrv6: 'intervallo IPv6',
              base64: 'stringa codificata in base64',
              base64url: 'URL codificata in base64',
              json_string: 'stringa JSON',
              e164: 'numero E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Input non valido: atteso ${n.expected}, ricevuto ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'numero';
                    case 'object':
                      if (Array.isArray(e)) return 'vettore';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Input non valido: atteso ${Y(n.values[0])}`;
                return `Opzione non valida: atteso uno tra ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Troppo grande: ${n.origin ?? 'valore'} deve avere ${t}${n.maximum.toString()} ${r.unit ?? 'elementi'}`;
                return `Troppo grande: ${n.origin ?? 'valore'} deve essere ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Troppo piccolo: ${n.origin} deve avere ${t}${n.minimum.toString()} ${r.unit}`;
                return `Troppo piccolo: ${n.origin} deve essere ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Stringa non valida: deve iniziare con "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Stringa non valida: deve terminare con "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Stringa non valida: deve includere "${n.includes}"`;
                if ('regex' === n.format)
                  return `Stringa non valida: deve corrispondere al pattern ${n.pattern}`;
                return `Invalid ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
              case 'unrecognized_keys':
                return `Chiav${n.keys.length > 1 ? 'i' : 'e'} non riconosciut${n.keys.length > 1 ? 'e' : 'a'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Chiave non valida in ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Input non valido';
              case 'invalid_element':
                return `Valore non valido in ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r5() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '文字', verb: 'である' },
              file: { unit: 'バイト', verb: 'である' },
              array: { unit: '要素', verb: 'である' },
              set: { unit: '要素', verb: 'である' },
            },
            t = {
              regex: '入力値',
              email: 'メールアドレス',
              url: 'URL',
              emoji: '絵文字',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO日時',
              date: 'ISO日付',
              time: 'ISO時刻',
              duration: 'ISO期間',
              ipv4: 'IPv4アドレス',
              ipv6: 'IPv6アドレス',
              cidrv4: 'IPv4範囲',
              cidrv6: 'IPv6範囲',
              base64: 'base64エンコード文字列',
              base64url: 'base64urlエンコード文字列',
              json_string: 'JSON文字列',
              e164: 'E.164番号',
              jwt: 'JWT',
              template_literal: '入力値',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `無効な入力: ${n.expected}が期待されましたが、${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : '数値';
                    case 'object':
                      if (Array.isArray(e)) return '配列';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}が入力されました`;
              case 'invalid_value':
                if (1 === n.values.length) return `無効な入力: ${Y(n.values[0])}が期待されました`;
                return `無効な選択: ${m(n.values, '、')}のいずれかである必要があります`;
              case 'too_big': {
                let t = n.inclusive ? '以下である' : 'より小さい',
                  r = e[n.origin] ?? null;
                if (r)
                  return `大きすぎる値: ${n.origin ?? '値'}は${n.maximum.toString()}${r.unit ?? '要素'}${t}必要があります`;
                return `大きすぎる値: ${n.origin ?? '値'}は${n.maximum.toString()}${t}必要があります`;
              }
              case 'too_small': {
                let t = n.inclusive ? '以上である' : 'より大きい',
                  r = e[n.origin] ?? null;
                if (r)
                  return `小さすぎる値: ${n.origin}は${n.minimum.toString()}${r.unit}${t}必要があります`;
                return `小さすぎる値: ${n.origin}は${n.minimum.toString()}${t}必要があります`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `無効な文字列: "${n.prefix}"で始まる必要があります`;
                if ('ends_with' === n.format)
                  return `無効な文字列: "${n.suffix}"で終わる必要があります`;
                if ('includes' === n.format)
                  return `無効な文字列: "${n.includes}"を含む必要があります`;
                if ('regex' === n.format)
                  return `無効な文字列: パターン${n.pattern}に一致する必要があります`;
                return `無効な${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `無効な数値: ${n.divisor}の倍数である必要があります`;
              case 'unrecognized_keys':
                return `認識されていないキー${n.keys.length > 1 ? '群' : ''}: ${m(n.keys, '、')}`;
              case 'invalid_key':
                return `${n.origin}内の無効なキー`;
              case 'invalid_union':
                return '無効な入力';
              case 'invalid_element':
                return `${n.origin}内の無効な値`;
              default:
                return `無効な入力`;
            }
          };
        })(),
      };
    }
    function r4() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'តួអក្សរ', verb: 'គួរមាន' },
              file: { unit: 'បៃ', verb: 'គួរមាន' },
              array: { unit: 'ធាតុ', verb: 'គួរមាន' },
              set: { unit: 'ធាតុ', verb: 'គួរមាន' },
            },
            t = {
              regex: 'ទិន្នន័យបញ្ចូល',
              email: 'អាសយដ្ឋានអ៊ីមែល',
              url: 'URL',
              emoji: 'សញ្ញាអារម្មណ៍',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'កាលបរិច្ឆេទ និងម៉ោង ISO',
              date: 'កាលបរិច្ឆេទ ISO',
              time: 'ម៉ោង ISO',
              duration: 'រយៈពេល ISO',
              ipv4: 'អាសយដ្ឋាន IPv4',
              ipv6: 'អាសយដ្ឋាន IPv6',
              cidrv4: 'ដែនអាសយដ្ឋាន IPv4',
              cidrv6: 'ដែនអាសយដ្ឋាន IPv6',
              base64: 'ខ្សែអក្សរអ៊ិកូដ base64',
              base64url: 'ខ្សែអក្សរអ៊ិកូដ base64url',
              json_string: 'ខ្សែអក្សរ JSON',
              e164: 'លេខ E.164',
              jwt: 'JWT',
              template_literal: 'ទិន្នន័យបញ្ចូល',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${n.expected} ប៉ុន្តែទទួលបាន ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'មិនមែនជាលេខ (NaN)' : 'លេខ';
                    case 'object':
                      if (Array.isArray(e)) return 'អារេ (Array)';
                      if (null === e) return 'គ្មានតម្លៃ (null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${Y(n.values[0])}`;
                return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `ធំពេក៖ ត្រូវការ ${n.origin ?? 'តម្លៃ'} ${t} ${n.maximum.toString()} ${r.unit ?? 'ធាតុ'}`;
                return `ធំពេក៖ ត្រូវការ ${n.origin ?? 'តម្លៃ'} ${t} ${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r) return `តូចពេក៖ ត្រូវការ ${n.origin} ${t} ${n.minimum.toString()} ${r.unit}`;
                return `តូចពេក៖ ត្រូវការ ${n.origin} ${t} ${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${n.suffix}"`;
                if ('includes' === n.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${n.includes}"`;
                if ('regex' === n.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${n.pattern}`;
                return `មិនត្រឹមត្រូវ៖ ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${n.divisor}`;
              case 'unrecognized_keys':
                return `រកឃើញសោមិនស្គាល់៖ ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `សោមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
              case 'invalid_union':
              default:
                return `ទិន្នន័យមិនត្រឹមត្រូវ`;
              case 'invalid_element':
                return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r9() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '문자', verb: 'to have' },
              file: { unit: '바이트', verb: 'to have' },
              array: { unit: '개', verb: 'to have' },
              set: { unit: '개', verb: 'to have' },
            },
            t = {
              regex: '입력',
              email: '이메일 주소',
              url: 'URL',
              emoji: '이모지',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO 날짜시간',
              date: 'ISO 날짜',
              time: 'ISO 시간',
              duration: 'ISO 기간',
              ipv4: 'IPv4 주소',
              ipv6: 'IPv6 주소',
              cidrv4: 'IPv4 범위',
              cidrv6: 'IPv6 범위',
              base64: 'base64 인코딩 문자열',
              base64url: 'base64url 인코딩 문자열',
              json_string: 'JSON 문자열',
              e164: 'E.164 번호',
              jwt: 'JWT',
              template_literal: '입력',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `잘못된 입력: 예상 타입은 ${n.expected}, 받은 타입은 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}입니다`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `잘못된 입력: 값은 ${Y(n.values[0])} 이어야 합니다`;
                return `잘못된 옵션: ${m(n.values, '또는 ')} 중 하나여야 합니다`;
              case 'too_big': {
                let t = n.inclusive ? '이하' : '미만',
                  r = '미만' === t ? '이어야 합니다' : '여야 합니다',
                  i = e[n.origin] ?? null,
                  o = i?.unit ?? '요소';
                if (i)
                  return `${n.origin ?? '값'}이 너무 큽니다: ${n.maximum.toString()}${o} ${t}${r}`;
                return `${n.origin ?? '값'}이 너무 큽니다: ${n.maximum.toString()} ${t}${r}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '이상' : '초과',
                  r = '이상' === t ? '이어야 합니다' : '여야 합니다',
                  i = e[n.origin] ?? null,
                  o = i?.unit ?? '요소';
                if (i)
                  return `${n.origin ?? '값'}이 너무 작습니다: ${n.minimum.toString()}${o} ${t}${r}`;
                return `${n.origin ?? '값'}이 너무 작습니다: ${n.minimum.toString()} ${t}${r}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `잘못된 문자열: "${n.prefix}"(으)로 시작해야 합니다`;
                if ('ends_with' === n.format)
                  return `잘못된 문자열: "${n.suffix}"(으)로 끝나야 합니다`;
                if ('includes' === n.format)
                  return `잘못된 문자열: "${n.includes}"을(를) 포함해야 합니다`;
                if ('regex' === n.format)
                  return `잘못된 문자열: 정규식 ${n.pattern} 패턴과 일치해야 합니다`;
                return `잘못된 ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `잘못된 숫자: ${n.divisor}의 배수여야 합니다`;
              case 'unrecognized_keys':
                return `인식할 수 없는 키: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `잘못된 키: ${n.origin}`;
              case 'invalid_union':
              default:
                return `잘못된 입력`;
              case 'invalid_element':
                return `잘못된 값: ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r3() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'знаци', verb: 'да имаат' },
              file: { unit: 'бајти', verb: 'да имаат' },
              array: { unit: 'ставки', verb: 'да имаат' },
              set: { unit: 'ставки', verb: 'да имаат' },
            },
            t = {
              regex: 'внес',
              email: 'адреса на е-пошта',
              url: 'URL',
              emoji: 'емоџи',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO датум и време',
              date: 'ISO датум',
              time: 'ISO време',
              duration: 'ISO времетраење',
              ipv4: 'IPv4 адреса',
              ipv6: 'IPv6 адреса',
              cidrv4: 'IPv4 опсег',
              cidrv6: 'IPv6 опсег',
              base64: 'base64-енкодирана низа',
              base64url: 'base64url-енкодирана низа',
              json_string: 'JSON низа',
              e164: 'E.164 број',
              jwt: 'JWT',
              template_literal: 'внес',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Грешен внес: се очекува ${n.expected}, примено ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'број';
                    case 'object':
                      if (Array.isArray(e)) return 'низа';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Invalid input: expected ${Y(n.values[0])}`;
                return `Грешана опција: се очекува една ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Премногу голем: се очекува ${n.origin ?? 'вредноста'} да има ${t}${n.maximum.toString()} ${r.unit ?? 'елементи'}`;
                return `Премногу голем: се очекува ${n.origin ?? 'вредноста'} да биде ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Премногу мал: се очекува ${n.origin} да има ${t}${n.minimum.toString()} ${r.unit}`;
                return `Премногу мал: се очекува ${n.origin} да биде ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Неважечка низа: мора да започнува со "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Неважечка низа: мора да завршува со "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Неважечка низа: мора да вклучува "${n.includes}"`;
                if ('regex' === n.format)
                  return `Неважечка низа: мора да одгоара на патернот ${n.pattern}`;
                return `Invalid ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Грешен број: мора да биде делив со ${n.divisor}`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Непрепознаени клучеви' : 'Непрепознаен клуч'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Грешен клуч во ${n.origin}`;
              case 'invalid_union':
                return 'Грешен внес';
              case 'invalid_element':
                return `Грешна вредност во ${n.origin}`;
              default:
                return `Грешен внес`;
            }
          };
        })(),
      };
    }
    function r6() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'aksara', verb: 'mempunyai' },
              file: { unit: 'bait', verb: 'mempunyai' },
              array: { unit: 'elemen', verb: 'mempunyai' },
              set: { unit: 'elemen', verb: 'mempunyai' },
            },
            t = {
              regex: 'input',
              email: 'alamat e-mel',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'tarikh masa ISO',
              date: 'tarikh ISO',
              time: 'masa ISO',
              duration: 'tempoh ISO',
              ipv4: 'alamat IPv4',
              ipv6: 'alamat IPv6',
              cidrv4: 'julat IPv4',
              cidrv6: 'julat IPv6',
              base64: 'string dikodkan base64',
              base64url: 'string dikodkan base64url',
              json_string: 'string JSON',
              e164: 'nombor E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Input tidak sah: dijangka ${n.expected}, diterima ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombor';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Input tidak sah: dijangka ${Y(n.values[0])}`;
                return `Pilihan tidak sah: dijangka salah satu daripada ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Terlalu besar: dijangka ${n.origin ?? 'nilai'} ${r.verb} ${t}${n.maximum.toString()} ${r.unit ?? 'elemen'}`;
                return `Terlalu besar: dijangka ${n.origin ?? 'nilai'} adalah ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Terlalu kecil: dijangka ${n.origin} ${r.verb} ${t}${n.minimum.toString()} ${r.unit}`;
                return `Terlalu kecil: dijangka ${n.origin} adalah ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `String tidak sah: mesti bermula dengan "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `String tidak sah: mesti berakhir dengan "${n.suffix}"`;
                if ('includes' === n.format)
                  return `String tidak sah: mesti mengandungi "${n.includes}"`;
                if ('regex' === n.format)
                  return `String tidak sah: mesti sepadan dengan corak ${n.pattern}`;
                return `${t[n.format] ?? n.format} tidak sah`;
              case 'not_multiple_of':
                return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
              case 'unrecognized_keys':
                return `Kunci tidak dikenali: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Kunci tidak sah dalam ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Input tidak sah';
              case 'invalid_element':
                return `Nilai tidak sah dalam ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r7() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tekens' },
              file: { unit: 'bytes' },
              array: { unit: 'elementen' },
              set: { unit: 'elementen' },
            },
            t = {
              regex: 'invoer',
              email: 'emailadres',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datum en tijd',
              date: 'ISO datum',
              time: 'ISO tijd',
              duration: 'ISO duur',
              ipv4: 'IPv4-adres',
              ipv6: 'IPv6-adres',
              cidrv4: 'IPv4-bereik',
              cidrv6: 'IPv6-bereik',
              base64: 'base64-gecodeerde tekst',
              base64url: 'base64 URL-gecodeerde tekst',
              json_string: 'JSON string',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'invoer',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Ongeldige invoer: verwacht ${n.expected}, ontving ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'getal';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Ongeldige invoer: verwacht ${Y(n.values[0])}`;
                return `Ongeldige optie: verwacht \xe9\xe9n van ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Te lang: verwacht dat ${n.origin ?? 'waarde'} ${t}${n.maximum.toString()} ${r.unit ?? 'elementen'} bevat`;
                return `Te lang: verwacht dat ${n.origin ?? 'waarde'} ${t}${n.maximum.toString()} is`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Te kort: verwacht dat ${n.origin} ${t}${n.minimum.toString()} ${r.unit} bevat`;
                return `Te kort: verwacht dat ${n.origin} ${t}${n.minimum.toString()} is`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ongeldige tekst: moet met "${n.prefix}" beginnen`;
                if ('ends_with' === n.format)
                  return `Ongeldige tekst: moet op "${n.suffix}" eindigen`;
                if ('includes' === n.format)
                  return `Ongeldige tekst: moet "${n.includes}" bevatten`;
                if ('regex' === n.format)
                  return `Ongeldige tekst: moet overeenkomen met patroon ${n.pattern}`;
                return `Ongeldig: ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
              case 'unrecognized_keys':
                return `Onbekende key${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Ongeldige key in ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Ongeldige invoer';
              case 'invalid_element':
                return `Ongeldige waarde in ${n.origin}`;
            }
          };
        })(),
      };
    }
    function r8() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tegn', verb: 'å ha' },
              file: { unit: 'bytes', verb: 'å ha' },
              array: { unit: 'elementer', verb: 'å inneholde' },
              set: { unit: 'elementer', verb: 'å inneholde' },
            },
            t = {
              regex: 'input',
              email: 'e-postadresse',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dato- og klokkeslett',
              date: 'ISO-dato',
              time: 'ISO-klokkeslett',
              duration: 'ISO-varighet',
              ipv4: 'IPv4-område',
              ipv6: 'IPv6-område',
              cidrv4: 'IPv4-spekter',
              cidrv6: 'IPv6-spekter',
              base64: 'base64-enkodet streng',
              base64url: 'base64url-enkodet streng',
              json_string: 'JSON-streng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Ugyldig input: forventet ${n.expected}, fikk ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'tall';
                    case 'object':
                      if (Array.isArray(e)) return 'liste';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Ugyldig verdi: forventet ${Y(n.values[0])}`;
                return `Ugyldig valg: forventet en av ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `For stor(t): forventet ${n.origin ?? 'value'} til \xe5 ha ${t}${n.maximum.toString()} ${r.unit ?? 'elementer'}`;
                return `For stor(t): forventet ${n.origin ?? 'value'} til \xe5 ha ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `For lite(n): forventet ${n.origin} til \xe5 ha ${t}${n.minimum.toString()} ${r.unit}`;
                return `For lite(n): forventet ${n.origin} til \xe5 ha ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ugyldig streng: m\xe5 starte med "${n.prefix}"`;
                if ('ends_with' === n.format) return `Ugyldig streng: m\xe5 ende med "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Ugyldig streng: m\xe5 inneholde "${n.includes}"`;
                if ('regex' === n.format)
                  return `Ugyldig streng: m\xe5 matche m\xf8nsteret ${n.pattern}`;
                return `Ugyldig ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ugyldig tall: m\xe5 v\xe6re et multiplum av ${n.divisor}`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Ukjente nøkler' : 'Ukjent nøkkel'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Ugyldig n\xf8kkel i ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Ugyldig input';
              case 'invalid_element':
                return `Ugyldig verdi i ${n.origin}`;
            }
          };
        })(),
      };
    }
    function ie() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'harf', verb: 'olmalıdır' },
              file: { unit: 'bayt', verb: 'olmalıdır' },
              array: { unit: 'unsur', verb: 'olmalıdır' },
              set: { unit: 'unsur', verb: 'olmalıdır' },
            },
            t = {
              regex: 'giren',
              email: 'epostagâh',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO hengâmı',
              date: 'ISO tarihi',
              time: 'ISO zamanı',
              duration: 'ISO müddeti',
              ipv4: 'IPv4 nişânı',
              ipv6: 'IPv6 nişânı',
              cidrv4: 'IPv4 menzili',
              cidrv6: 'IPv6 menzili',
              base64: 'base64-şifreli metin',
              base64url: 'base64url-şifreli metin',
              json_string: 'JSON metin',
              e164: 'E.164 sayısı',
              jwt: 'JWT',
              template_literal: 'giren',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `F\xe2sit giren: umulan ${n.expected}, alınan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'numara';
                    case 'object':
                      if (Array.isArray(e)) return 'saf';
                      if (null === e) return 'gayb';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `F\xe2sit giren: umulan ${Y(n.values[0])}`;
                return `F\xe2sit tercih: m\xfbteberler ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Fazla b\xfcy\xfck: ${n.origin ?? 'value'}, ${t}${n.maximum.toString()} ${r.unit ?? 'elements'} sahip olmalıydı.`;
                return `Fazla b\xfcy\xfck: ${n.origin ?? 'value'}, ${t}${n.maximum.toString()} olmalıydı.`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Fazla k\xfc\xe7\xfck: ${n.origin}, ${t}${n.minimum.toString()} ${r.unit} sahip olmalıydı.`;
                return `Fazla k\xfc\xe7\xfck: ${n.origin}, ${t}${n.minimum.toString()} olmalıydı.`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `F\xe2sit metin: "${n.prefix}" ile başlamalı.`;
                if ('ends_with' === n.format) return `F\xe2sit metin: "${n.suffix}" ile bitmeli.`;
                if ('includes' === n.format)
                  return `F\xe2sit metin: "${n.includes}" ihtiv\xe2 etmeli.`;
                if ('regex' === n.format) return `F\xe2sit metin: ${n.pattern} nakşına uymalı.`;
                return `F\xe2sit ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `F\xe2sit sayı: ${n.divisor} katı olmalıydı.`;
              case 'unrecognized_keys':
                return `Tanınmayan anahtar ${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `${n.origin} i\xe7in tanınmayan anahtar var.`;
              case 'invalid_union':
                return 'Giren tanınamadı.';
              case 'invalid_element':
                return `${n.origin} i\xe7in tanınmayan kıymet var.`;
              default:
                return `Kıymet tanınamadı.`;
            }
          };
        })(),
      };
    }
    function it() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'توکي', verb: 'ولري' },
              file: { unit: 'بایټس', verb: 'ولري' },
              array: { unit: 'توکي', verb: 'ولري' },
              set: { unit: 'توکي', verb: 'ولري' },
            },
            t = {
              regex: 'ورودي',
              email: 'بریښنالیک',
              url: 'یو آر ال',
              emoji: 'ایموجي',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'نیټه او وخت',
              date: 'نېټه',
              time: 'وخت',
              duration: 'موده',
              ipv4: 'د IPv4 پته',
              ipv6: 'د IPv6 پته',
              cidrv4: 'د IPv4 ساحه',
              cidrv6: 'د IPv6 ساحه',
              base64: 'base64-encoded متن',
              base64url: 'base64url-encoded متن',
              json_string: 'JSON متن',
              e164: 'د E.164 شمېره',
              jwt: 'JWT',
              template_literal: 'ورودي',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `ناسم ورودي: باید ${n.expected} وای, مګر ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'عدد';
                    case 'object':
                      if (Array.isArray(e)) return 'ارې';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)} ترلاسه شو`;
              case 'invalid_value':
                if (1 === n.values.length) return `ناسم ورودي: باید ${Y(n.values[0])} وای`;
                return `ناسم انتخاب: باید یو له ${m(n.values, '|')} څخه وای`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `ډیر لوی: ${n.origin ?? 'ارزښت'} باید ${t}${n.maximum.toString()} ${r.unit ?? 'عنصرونه'} ولري`;
                return `ډیر لوی: ${n.origin ?? 'ارزښت'} باید ${t}${n.maximum.toString()} وي`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `ډیر کوچنی: ${n.origin} باید ${t}${n.minimum.toString()} ${r.unit} ولري`;
                return `ډیر کوچنی: ${n.origin} باید ${t}${n.minimum.toString()} وي`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format) return `ناسم متن: باید د "${n.prefix}" سره پیل شي`;
                if ('ends_with' === n.format)
                  return `ناسم متن: باید د "${n.suffix}" سره پای ته ورسيږي`;
                if ('includes' === n.format) return `ناسم متن: باید "${n.includes}" ولري`;
                if ('regex' === n.format) return `ناسم متن: باید د ${n.pattern} سره مطابقت ولري`;
                return `${t[n.format] ?? n.format} ناسم دی`;
              case 'not_multiple_of':
                return `ناسم عدد: باید د ${n.divisor} مضرب وي`;
              case 'unrecognized_keys':
                return `ناسم ${n.keys.length > 1 ? 'کلیډونه' : 'کلیډ'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `ناسم کلیډ په ${n.origin} کې`;
              case 'invalid_union':
              default:
                return `ناسمه ورودي`;
              case 'invalid_element':
                return `ناسم عنصر په ${n.origin} کې`;
            }
          };
        })(),
      };
    }
    function ir() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znaków', verb: 'mieć' },
              file: { unit: 'bajtów', verb: 'mieć' },
              array: { unit: 'elementów', verb: 'mieć' },
              set: { unit: 'elementów', verb: 'mieć' },
            },
            t = {
              regex: 'wyrażenie',
              email: 'adres email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data i godzina w formacie ISO',
              date: 'data w formacie ISO',
              time: 'godzina w formacie ISO',
              duration: 'czas trwania ISO',
              ipv4: 'adres IPv4',
              ipv6: 'adres IPv6',
              cidrv4: 'zakres IPv4',
              cidrv6: 'zakres IPv6',
              base64: 'ciąg znaków zakodowany w formacie base64',
              base64url: 'ciąg znaków zakodowany w formacie base64url',
              json_string: 'ciąg znaków w formacie JSON',
              e164: 'liczba E.164',
              jwt: 'JWT',
              template_literal: 'wejście',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Nieprawidłowe dane wejściowe: oczekiwano ${n.expected}, otrzymano ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'liczba';
                    case 'object':
                      if (Array.isArray(e)) return 'tablica';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Nieprawidłowe dane wejściowe: oczekiwano ${Y(n.values[0])}`;
                return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Za duża wartość: oczekiwano, że ${n.origin ?? 'wartość'} będzie mieć ${t}${n.maximum.toString()} ${r.unit ?? 'elementów'}`;
                return `Zbyt duż(y/a/e): oczekiwano, że ${n.origin ?? 'wartość'} będzie wynosić ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Za mała wartość: oczekiwano, że ${n.origin ?? 'wartość'} będzie mieć ${t}${n.minimum.toString()} ${r.unit ?? 'elementów'}`;
                return `Zbyt mał(y/a/e): oczekiwano, że ${n.origin ?? 'wartość'} będzie wynosić ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi zaczynać się od "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi kończyć się na "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi zawierać "${n.includes}"`;
                if ('regex' === n.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi odpowiadać wzorcowi ${n.pattern}`;
                return `Nieprawidłow(y/a/e) ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Nieprawidłowa liczba: musi być wielokrotnością ${n.divisor}`;
              case 'unrecognized_keys':
                return `Nierozpoznane klucze${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Nieprawidłowy klucz w ${n.origin}`;
              case 'invalid_union':
                return 'Nieprawidłowe dane wejściowe';
              case 'invalid_element':
                return `Nieprawidłowa wartość w ${n.origin}`;
              default:
                return `Nieprawidłowe dane wejściowe`;
            }
          };
        })(),
      };
    }
    function ii() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caracteres', verb: 'ter' },
              file: { unit: 'bytes', verb: 'ter' },
              array: { unit: 'itens', verb: 'ter' },
              set: { unit: 'itens', verb: 'ter' },
            },
            t = {
              regex: 'padrão',
              email: 'endereço de e-mail',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data e hora ISO',
              date: 'data ISO',
              time: 'hora ISO',
              duration: 'duração ISO',
              ipv4: 'endereço IPv4',
              ipv6: 'endereço IPv6',
              cidrv4: 'faixa de IPv4',
              cidrv6: 'faixa de IPv6',
              base64: 'texto codificado em base64',
              base64url: 'URL codificada em base64',
              json_string: 'texto JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Tipo inv\xe1lido: esperado ${n.expected}, recebido ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'número';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'nulo';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Entrada inv\xe1lida: esperado ${Y(n.values[0])}`;
                return `Op\xe7\xe3o inv\xe1lida: esperada uma das ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Muito grande: esperado que ${n.origin ?? 'valor'} tivesse ${t}${n.maximum.toString()} ${r.unit ?? 'elementos'}`;
                return `Muito grande: esperado que ${n.origin ?? 'valor'} fosse ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Muito pequeno: esperado que ${n.origin} tivesse ${t}${n.minimum.toString()} ${r.unit}`;
                return `Muito pequeno: esperado que ${n.origin} fosse ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Texto inv\xe1lido: deve come\xe7ar com "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Texto inv\xe1lido: deve terminar com "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Texto inv\xe1lido: deve incluir "${n.includes}"`;
                if ('regex' === n.format)
                  return `Texto inv\xe1lido: deve corresponder ao padr\xe3o ${n.pattern}`;
                return `${t[n.format] ?? n.format} inv\xe1lido`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe1lido: deve ser m\xfaltiplo de ${n.divisor}`;
              case 'unrecognized_keys':
                return `Chave${n.keys.length > 1 ? 's' : ''} desconhecida${n.keys.length > 1 ? 's' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Chave inv\xe1lida em ${n.origin}`;
              case 'invalid_union':
                return 'Entrada inválida';
              case 'invalid_element':
                return `Valor inv\xe1lido em ${n.origin}`;
              default:
                return `Campo inv\xe1lido`;
            }
          };
        })(),
      };
    }
    function io(e, t, n, r) {
      let i = Math.abs(e),
        o = i % 10,
        a = i % 100;
      return a >= 11 && a <= 19 ? r : 1 === o ? t : o >= 2 && o <= 4 ? n : r;
    }
    function ia() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: { one: 'символ', few: 'символа', many: 'символов' }, verb: 'иметь' },
              file: { unit: { one: 'байт', few: 'байта', many: 'байт' }, verb: 'иметь' },
              array: {
                unit: { one: 'элемент', few: 'элемента', many: 'элементов' },
                verb: 'иметь',
              },
              set: { unit: { one: 'элемент', few: 'элемента', many: 'элементов' }, verb: 'иметь' },
            },
            t = {
              regex: 'ввод',
              email: 'email адрес',
              url: 'URL',
              emoji: 'эмодзи',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO дата и время',
              date: 'ISO дата',
              time: 'ISO время',
              duration: 'ISO длительность',
              ipv4: 'IPv4 адрес',
              ipv6: 'IPv6 адрес',
              cidrv4: 'IPv4 диапазон',
              cidrv6: 'IPv6 диапазон',
              base64: 'строка в формате base64',
              base64url: 'строка в формате base64url',
              json_string: 'JSON строка',
              e164: 'номер E.164',
              jwt: 'JWT',
              template_literal: 'ввод',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Неверный ввод: ожидалось ${n.expected}, получено ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'число';
                    case 'object':
                      if (Array.isArray(e)) return 'массив';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Неверный ввод: ожидалось ${Y(n.values[0])}`;
                return `Неверный вариант: ожидалось одно из ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r) {
                  let e = io(Number(n.maximum), r.unit.one, r.unit.few, r.unit.many);
                  return `Слишком большое значение: ожидалось, что ${n.origin ?? 'значение'} будет иметь ${t}${n.maximum.toString()} ${e}`;
                }
                return `Слишком большое значение: ожидалось, что ${n.origin ?? 'значение'} будет ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r) {
                  let e = io(Number(n.minimum), r.unit.one, r.unit.few, r.unit.many);
                  return `Слишком маленькое значение: ожидалось, что ${n.origin} будет иметь ${t}${n.minimum.toString()} ${e}`;
                }
                return `Слишком маленькое значение: ожидалось, что ${n.origin} будет ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Неверная строка: должна начинаться с "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Неверная строка: должна заканчиваться на "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Неверная строка: должна содержать "${n.includes}"`;
                if ('regex' === n.format)
                  return `Неверная строка: должна соответствовать шаблону ${n.pattern}`;
                return `Неверный ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Неверное число: должно быть кратным ${n.divisor}`;
              case 'unrecognized_keys':
                return `Нераспознанн${n.keys.length > 1 ? 'ые' : 'ый'} ключ${n.keys.length > 1 ? 'и' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Неверный ключ в ${n.origin}`;
              case 'invalid_union':
                return 'Неверные входные данные';
              case 'invalid_element':
                return `Неверное значение в ${n.origin}`;
              default:
                return `Неверные входные данные`;
            }
          };
        })(),
      };
    }
    function is() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znakov', verb: 'imeti' },
              file: { unit: 'bajtov', verb: 'imeti' },
              array: { unit: 'elementov', verb: 'imeti' },
              set: { unit: 'elementov', verb: 'imeti' },
            },
            t = {
              regex: 'vnos',
              email: 'e-poštni naslov',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datum in čas',
              date: 'ISO datum',
              time: 'ISO čas',
              duration: 'ISO trajanje',
              ipv4: 'IPv4 naslov',
              ipv6: 'IPv6 naslov',
              cidrv4: 'obseg IPv4',
              cidrv6: 'obseg IPv6',
              base64: 'base64 kodiran niz',
              base64url: 'base64url kodiran niz',
              json_string: 'JSON niz',
              e164: 'E.164 številka',
              jwt: 'JWT',
              template_literal: 'vnos',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Neveljaven vnos: pričakovano ${n.expected}, prejeto ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'število';
                    case 'object':
                      if (Array.isArray(e)) return 'tabela';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Neveljaven vnos: pričakovano ${Y(n.values[0])}`;
                return `Neveljavna možnost: pričakovano eno izmed ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Preveliko: pričakovano, da bo ${n.origin ?? 'vrednost'} imelo ${t}${n.maximum.toString()} ${r.unit ?? 'elementov'}`;
                return `Preveliko: pričakovano, da bo ${n.origin ?? 'vrednost'} ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Premajhno: pričakovano, da bo ${n.origin} imelo ${t}${n.minimum.toString()} ${r.unit}`;
                return `Premajhno: pričakovano, da bo ${n.origin} ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Neveljaven niz: mora se začeti z "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Neveljaven niz: mora se končati z "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Neveljaven niz: mora vsebovati "${n.includes}"`;
                if ('regex' === n.format)
                  return `Neveljaven niz: mora ustrezati vzorcu ${n.pattern}`;
                return `Neveljaven ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Neveljavno število: mora biti večkratnik ${n.divisor}`;
              case 'unrecognized_keys':
                return `Neprepoznan${n.keys.length > 1 ? 'i ključi' : ' ključ'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Neveljaven ključ v ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Neveljaven vnos';
              case 'invalid_element':
                return `Neveljavna vrednost v ${n.origin}`;
            }
          };
        })(),
      };
    }
    function iu() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tecken', verb: 'att ha' },
              file: { unit: 'bytes', verb: 'att ha' },
              array: { unit: 'objekt', verb: 'att innehålla' },
              set: { unit: 'objekt', verb: 'att innehålla' },
            },
            t = {
              regex: 'reguljärt uttryck',
              email: 'e-postadress',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-datum och tid',
              date: 'ISO-datum',
              time: 'ISO-tid',
              duration: 'ISO-varaktighet',
              ipv4: 'IPv4-intervall',
              ipv6: 'IPv6-intervall',
              cidrv4: 'IPv4-spektrum',
              cidrv6: 'IPv6-spektrum',
              base64: 'base64-kodad sträng',
              base64url: 'base64url-kodad sträng',
              json_string: 'JSON-sträng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'mall-literal',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Ogiltig inmatning: f\xf6rv\xe4ntat ${n.expected}, fick ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'antal';
                    case 'object':
                      if (Array.isArray(e)) return 'lista';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Ogiltig inmatning: f\xf6rv\xe4ntat ${Y(n.values[0])}`;
                return `Ogiltigt val: f\xf6rv\xe4ntade en av ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `F\xf6r stor(t): f\xf6rv\xe4ntade ${n.origin ?? 'värdet'} att ha ${t}${n.maximum.toString()} ${r.unit ?? 'element'}`;
                return `F\xf6r stor(t): f\xf6rv\xe4ntat ${n.origin ?? 'värdet'} att ha ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `F\xf6r lite(t): f\xf6rv\xe4ntade ${n.origin ?? 'värdet'} att ha ${t}${n.minimum.toString()} ${r.unit}`;
                return `F\xf6r lite(t): f\xf6rv\xe4ntade ${n.origin ?? 'värdet'} att ha ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ogiltig str\xe4ng: m\xe5ste b\xf6rja med "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Ogiltig str\xe4ng: m\xe5ste sluta med "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Ogiltig str\xe4ng: m\xe5ste inneh\xe5lla "${n.includes}"`;
                if ('regex' === n.format)
                  return `Ogiltig str\xe4ng: m\xe5ste matcha m\xf6nstret "${n.pattern}"`;
                return `Ogiltig(t) ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ogiltigt tal: m\xe5ste vara en multipel av ${n.divisor}`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Okända nycklar' : 'Okänd nyckel'}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Ogiltig nyckel i ${n.origin ?? 'värdet'}`;
              case 'invalid_union':
              default:
                return 'Ogiltig input';
              case 'invalid_element':
                return `Ogiltigt v\xe4rde i ${n.origin ?? 'värdet'}`;
            }
          };
        })(),
      };
    }
    function il() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'எழுத்துக்கள்', verb: 'கொண்டிருக்க வேண்டும்' },
              file: { unit: 'பைட்டுகள்', verb: 'கொண்டிருக்க வேண்டும்' },
              array: { unit: 'உறுப்புகள்', verb: 'கொண்டிருக்க வேண்டும்' },
              set: { unit: 'உறுப்புகள்', verb: 'கொண்டிருக்க வேண்டும்' },
            },
            t = {
              regex: 'உள்ளீடு',
              email: 'மின்னஞ்சல் முகவரி',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO தேதி நேரம்',
              date: 'ISO தேதி',
              time: 'ISO நேரம்',
              duration: 'ISO கால அளவு',
              ipv4: 'IPv4 முகவரி',
              ipv6: 'IPv6 முகவரி',
              cidrv4: 'IPv4 வரம்பு',
              cidrv6: 'IPv6 வரம்பு',
              base64: 'base64-encoded சரம்',
              base64url: 'base64url-encoded சரம்',
              json_string: 'JSON சரம்',
              e164: 'E.164 எண்',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${n.expected}, பெறப்பட்டது ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'எண் அல்லாதது' : 'எண்';
                    case 'object':
                      if (Array.isArray(e)) return 'அணி';
                      if (null === e) return 'வெறுமை';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${Y(n.values[0])}`;
                return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${m(n.values, '|')} இல் ஒன்று`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? 'மதிப்பு'} ${t}${n.maximum.toString()} ${r.unit ?? 'உறுப்புகள்'} ஆக இருக்க வேண்டும்`;
                return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? 'மதிப்பு'} ${t}${n.maximum.toString()} ஆக இருக்க வேண்டும்`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${t}${n.minimum.toString()} ${r.unit} ஆக இருக்க வேண்டும்`;
                return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${t}${n.minimum.toString()} ஆக இருக்க வேண்டும்`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `தவறான சரம்: "${n.prefix}" இல் தொடங்க வேண்டும்`;
                if ('ends_with' === n.format)
                  return `தவறான சரம்: "${n.suffix}" இல் முடிவடைய வேண்டும்`;
                if ('includes' === n.format)
                  return `தவறான சரம்: "${n.includes}" ஐ உள்ளடக்க வேண்டும்`;
                if ('regex' === n.format)
                  return `தவறான சரம்: ${n.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
                return `தவறான ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `தவறான எண்: ${n.divisor} இன் பலமாக இருக்க வேண்டும்`;
              case 'unrecognized_keys':
                return `அடையாளம் தெரியாத விசை${n.keys.length > 1 ? 'கள்' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `${n.origin} இல் தவறான விசை`;
              case 'invalid_union':
                return 'தவறான உள்ளீடு';
              case 'invalid_element':
                return `${n.origin} இல் தவறான மதிப்பு`;
              default:
                return `தவறான உள்ளீடு`;
            }
          };
        })(),
      };
    }
    function ic() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'ตัวอักษร', verb: 'ควรมี' },
              file: { unit: 'ไบต์', verb: 'ควรมี' },
              array: { unit: 'รายการ', verb: 'ควรมี' },
              set: { unit: 'รายการ', verb: 'ควรมี' },
            },
            t = {
              regex: 'ข้อมูลที่ป้อน',
              email: 'ที่อยู่อีเมล',
              url: 'URL',
              emoji: 'อิโมจิ',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'วันที่เวลาแบบ ISO',
              date: 'วันที่แบบ ISO',
              time: 'เวลาแบบ ISO',
              duration: 'ช่วงเวลาแบบ ISO',
              ipv4: 'ที่อยู่ IPv4',
              ipv6: 'ที่อยู่ IPv6',
              cidrv4: 'ช่วง IP แบบ IPv4',
              cidrv6: 'ช่วง IP แบบ IPv6',
              base64: 'ข้อความแบบ Base64',
              base64url: 'ข้อความแบบ Base64 สำหรับ URL',
              json_string: 'ข้อความแบบ JSON',
              e164: 'เบอร์โทรศัพท์ระหว่างประเทศ (E.164)',
              jwt: 'โทเคน JWT',
              template_literal: 'ข้อมูลที่ป้อน',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${n.expected} แต่ได้รับ ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'ไม่ใช่ตัวเลข (NaN)' : 'ตัวเลข';
                    case 'object':
                      if (Array.isArray(e)) return 'อาร์เรย์ (Array)';
                      if (null === e) return 'ไม่มีค่า (null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `ค่าไม่ถูกต้อง: ควรเป็น ${Y(n.values[0])}`;
                return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? 'ไม่เกิน' : 'น้อยกว่า',
                  r = e[n.origin] ?? null;
                if (r)
                  return `เกินกำหนด: ${n.origin ?? 'ค่า'} ควรมี${t} ${n.maximum.toString()} ${r.unit ?? 'รายการ'}`;
                return `เกินกำหนด: ${n.origin ?? 'ค่า'} ควรมี${t} ${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? 'อย่างน้อย' : 'มากกว่า',
                  r = e[n.origin] ?? null;
                if (r)
                  return `น้อยกว่ากำหนด: ${n.origin} ควรมี${t} ${n.minimum.toString()} ${r.unit}`;
                return `น้อยกว่ากำหนด: ${n.origin} ควรมี${t} ${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${n.suffix}"`;
                if ('includes' === n.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${n.includes}" อยู่ในข้อความ`;
                if ('regex' === n.format)
                  return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${n.pattern}`;
                return `รูปแบบไม่ถูกต้อง: ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${n.divisor} ได้ลงตัว`;
              case 'unrecognized_keys':
                return `พบคีย์ที่ไม่รู้จัก: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `คีย์ไม่ถูกต้องใน ${n.origin}`;
              case 'invalid_union':
                return 'ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้';
              case 'invalid_element':
                return `ข้อมูลไม่ถูกต้องใน ${n.origin}`;
              default:
                return `ข้อมูลไม่ถูกต้อง`;
            }
          };
        })(),
      };
    }
    function id() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'olmalı' },
              file: { unit: 'bayt', verb: 'olmalı' },
              array: { unit: 'öğe', verb: 'olmalı' },
              set: { unit: 'öğe', verb: 'olmalı' },
            },
            t = {
              regex: 'girdi',
              email: 'e-posta adresi',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO tarih ve saat',
              date: 'ISO tarih',
              time: 'ISO saat',
              duration: 'ISO süre',
              ipv4: 'IPv4 adresi',
              ipv6: 'IPv6 adresi',
              cidrv4: 'IPv4 aralığı',
              cidrv6: 'IPv6 aralığı',
              base64: 'base64 ile şifrelenmiş metin',
              base64url: 'base64url ile şifrelenmiş metin',
              json_string: 'JSON dizesi',
              e164: 'E.164 sayısı',
              jwt: 'JWT',
              template_literal: 'Şablon dizesi',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Ge\xe7ersiz değer: beklenen ${n.expected}, alınan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `Ge\xe7ersiz değer: beklenen ${Y(n.values[0])}`;
                return `Ge\xe7ersiz se\xe7enek: aşağıdakilerden biri olmalı: ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `\xc7ok b\xfcy\xfck: beklenen ${n.origin ?? 'değer'} ${t}${n.maximum.toString()} ${r.unit ?? 'öğe'}`;
                return `\xc7ok b\xfcy\xfck: beklenen ${n.origin ?? 'değer'} ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `\xc7ok k\xfc\xe7\xfck: beklenen ${n.origin} ${t}${n.minimum.toString()} ${r.unit}`;
                return `\xc7ok k\xfc\xe7\xfck: beklenen ${n.origin} ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ge\xe7ersiz metin: "${n.prefix}" ile başlamalı`;
                if ('ends_with' === n.format) return `Ge\xe7ersiz metin: "${n.suffix}" ile bitmeli`;
                if ('includes' === n.format)
                  return `Ge\xe7ersiz metin: "${n.includes}" i\xe7ermeli`;
                if ('regex' === n.format) return `Ge\xe7ersiz metin: ${n.pattern} desenine uymalı`;
                return `Ge\xe7ersiz ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ge\xe7ersiz sayı: ${n.divisor} ile tam b\xf6l\xfcnebilmeli`;
              case 'unrecognized_keys':
                return `Tanınmayan anahtar${n.keys.length > 1 ? 'lar' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `${n.origin} i\xe7inde ge\xe7ersiz anahtar`;
              case 'invalid_union':
                return 'Geçersiz değer';
              case 'invalid_element':
                return `${n.origin} i\xe7inde ge\xe7ersiz değer`;
              default:
                return `Ge\xe7ersiz değer`;
            }
          };
        })(),
      };
    }
    function ip() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'символів', verb: 'матиме' },
              file: { unit: 'байтів', verb: 'матиме' },
              array: { unit: 'елементів', verb: 'матиме' },
              set: { unit: 'елементів', verb: 'матиме' },
            },
            t = {
              regex: 'вхідні дані',
              email: 'адреса електронної пошти',
              url: 'URL',
              emoji: 'емодзі',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'дата та час ISO',
              date: 'дата ISO',
              time: 'час ISO',
              duration: 'тривалість ISO',
              ipv4: 'адреса IPv4',
              ipv6: 'адреса IPv6',
              cidrv4: 'діапазон IPv4',
              cidrv6: 'діапазон IPv6',
              base64: 'рядок у кодуванні base64',
              base64url: 'рядок у кодуванні base64url',
              json_string: 'рядок JSON',
              e164: 'номер E.164',
              jwt: 'JWT',
              template_literal: 'вхідні дані',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Неправильні вхідні дані: очікується ${n.expected}, отримано ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'число';
                    case 'object':
                      if (Array.isArray(e)) return 'масив';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Неправильні вхідні дані: очікується ${Y(n.values[0])}`;
                return `Неправильна опція: очікується одне з ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Занадто велике: очікується, що ${n.origin ?? 'значення'} ${r.verb} ${t}${n.maximum.toString()} ${r.unit ?? 'елементів'}`;
                return `Занадто велике: очікується, що ${n.origin ?? 'значення'} буде ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Занадто мале: очікується, що ${n.origin} ${r.verb} ${t}${n.minimum.toString()} ${r.unit}`;
                return `Занадто мале: очікується, що ${n.origin} буде ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Неправильний рядок: повинен починатися з "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Неправильний рядок: повинен закінчуватися на "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Неправильний рядок: повинен містити "${n.includes}"`;
                if ('regex' === n.format)
                  return `Неправильний рядок: повинен відповідати шаблону ${n.pattern}`;
                return `Неправильний ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Неправильне число: повинно бути кратним ${n.divisor}`;
              case 'unrecognized_keys':
                return `Нерозпізнаний ключ${n.keys.length > 1 ? 'і' : ''}: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Неправильний ключ у ${n.origin}`;
              case 'invalid_union':
                return 'Неправильні вхідні дані';
              case 'invalid_element':
                return `Неправильне значення у ${n.origin}`;
              default:
                return `Неправильні вхідні дані`;
            }
          };
        })(),
      };
    }
    function i_() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'حروف', verb: 'ہونا' },
              file: { unit: 'بائٹس', verb: 'ہونا' },
              array: { unit: 'آئٹمز', verb: 'ہونا' },
              set: { unit: 'آئٹمز', verb: 'ہونا' },
            },
            t = {
              regex: 'ان پٹ',
              email: 'ای میل ایڈریس',
              url: 'یو آر ایل',
              emoji: 'ایموجی',
              uuid: 'یو یو آئی ڈی',
              uuidv4: 'یو یو آئی ڈی وی 4',
              uuidv6: 'یو یو آئی ڈی وی 6',
              nanoid: 'نینو آئی ڈی',
              guid: 'جی یو آئی ڈی',
              cuid: 'سی یو آئی ڈی',
              cuid2: 'سی یو آئی ڈی 2',
              ulid: 'یو ایل آئی ڈی',
              xid: 'ایکس آئی ڈی',
              ksuid: 'کے ایس یو آئی ڈی',
              datetime: 'آئی ایس او ڈیٹ ٹائم',
              date: 'آئی ایس او تاریخ',
              time: 'آئی ایس او وقت',
              duration: 'آئی ایس او مدت',
              ipv4: 'آئی پی وی 4 ایڈریس',
              ipv6: 'آئی پی وی 6 ایڈریس',
              cidrv4: 'آئی پی وی 4 رینج',
              cidrv6: 'آئی پی وی 6 رینج',
              base64: 'بیس 64 ان کوڈڈ سٹرنگ',
              base64url: 'بیس 64 یو آر ایل ان کوڈڈ سٹرنگ',
              json_string: 'جے ایس او این سٹرنگ',
              e164: 'ای 164 نمبر',
              jwt: 'جے ڈبلیو ٹی',
              template_literal: 'ان پٹ',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `غلط ان پٹ: ${n.expected} متوقع تھا، ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'نمبر';
                    case 'object':
                      if (Array.isArray(e)) return 'آرے';
                      if (null === e) return 'نل';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)} موصول ہوا`;
              case 'invalid_value':
                if (1 === n.values.length) return `غلط ان پٹ: ${Y(n.values[0])} متوقع تھا`;
                return `غلط آپشن: ${m(n.values, '|')} میں سے ایک متوقع تھا`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `بہت بڑا: ${n.origin ?? 'ویلیو'} کے ${t}${n.maximum.toString()} ${r.unit ?? 'عناصر'} ہونے متوقع تھے`;
                return `بہت بڑا: ${n.origin ?? 'ویلیو'} کا ${t}${n.maximum.toString()} ہونا متوقع تھا`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `بہت چھوٹا: ${n.origin} کے ${t}${n.minimum.toString()} ${r.unit} ہونے متوقع تھے`;
                return `بہت چھوٹا: ${n.origin} کا ${t}${n.minimum.toString()} ہونا متوقع تھا`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `غلط سٹرنگ: "${n.prefix}" سے شروع ہونا چاہیے`;
                if ('ends_with' === n.format) return `غلط سٹرنگ: "${n.suffix}" پر ختم ہونا چاہیے`;
                if ('includes' === n.format) return `غلط سٹرنگ: "${n.includes}" شامل ہونا چاہیے`;
                if ('regex' === n.format) return `غلط سٹرنگ: پیٹرن ${n.pattern} سے میچ ہونا چاہیے`;
                return `غلط ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `غلط نمبر: ${n.divisor} کا مضاعف ہونا چاہیے`;
              case 'unrecognized_keys':
                return `غیر تسلیم شدہ کی${n.keys.length > 1 ? 'ز' : ''}: ${m(n.keys, '، ')}`;
              case 'invalid_key':
                return `${n.origin} میں غلط کی`;
              case 'invalid_union':
                return 'غلط ان پٹ';
              case 'invalid_element':
                return `${n.origin} میں غلط ویلیو`;
              default:
                return `غلط ان پٹ`;
            }
          };
        })(),
      };
    }
    function iS() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'ký tự', verb: 'có' },
              file: { unit: 'byte', verb: 'có' },
              array: { unit: 'phần tử', verb: 'có' },
              set: { unit: 'phần tử', verb: 'có' },
            },
            t = {
              regex: 'đầu vào',
              email: 'địa chỉ email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ngày giờ ISO',
              date: 'ngày ISO',
              time: 'giờ ISO',
              duration: 'khoảng thời gian ISO',
              ipv4: 'địa chỉ IPv4',
              ipv6: 'địa chỉ IPv6',
              cidrv4: 'dải IPv4',
              cidrv6: 'dải IPv6',
              base64: 'chuỗi mã hóa base64',
              base64url: 'chuỗi mã hóa base64url',
              json_string: 'chuỗi JSON',
              e164: 'số E.164',
              jwt: 'JWT',
              template_literal: 'đầu vào',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `Đầu v\xe0o kh\xf4ng hợp lệ: mong đợi ${n.expected}, nhận được ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'số';
                    case 'object':
                      if (Array.isArray(e)) return 'mảng';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `Đầu v\xe0o kh\xf4ng hợp lệ: mong đợi ${Y(n.values[0])}`;
                return `T\xf9y chọn kh\xf4ng hợp lệ: mong đợi một trong c\xe1c gi\xe1 trị ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Qu\xe1 lớn: mong đợi ${n.origin ?? 'giá trị'} ${r.verb} ${t}${n.maximum.toString()} ${r.unit ?? 'phần tử'}`;
                return `Qu\xe1 lớn: mong đợi ${n.origin ?? 'giá trị'} ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `Qu\xe1 nhỏ: mong đợi ${n.origin} ${r.verb} ${t}${n.minimum.toString()} ${r.unit}`;
                return `Qu\xe1 nhỏ: mong đợi ${n.origin} ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải bắt đầu bằng "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải kết th\xfac bằng "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải bao gồm "${n.includes}"`;
                if ('regex' === n.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải khớp với mẫu ${n.pattern}`;
                return `${t[n.format] ?? n.format} kh\xf4ng hợp lệ`;
              case 'not_multiple_of':
                return `Số kh\xf4ng hợp lệ: phải l\xe0 bội số của ${n.divisor}`;
              case 'unrecognized_keys':
                return `Kh\xf3a kh\xf4ng được nhận dạng: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Kh\xf3a kh\xf4ng hợp lệ trong ${n.origin}`;
              case 'invalid_union':
                return 'Đầu vào không hợp lệ';
              case 'invalid_element':
                return `Gi\xe1 trị kh\xf4ng hợp lệ trong ${n.origin}`;
              default:
                return `Đầu v\xe0o kh\xf4ng hợp lệ`;
            }
          };
        })(),
      };
    }
    function iE() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '字符', verb: '包含' },
              file: { unit: '字节', verb: '包含' },
              array: { unit: '项', verb: '包含' },
              set: { unit: '项', verb: '包含' },
            },
            t = {
              regex: '输入',
              email: '电子邮件',
              url: 'URL',
              emoji: '表情符号',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO日期时间',
              date: 'ISO日期',
              time: 'ISO时间',
              duration: 'ISO时长',
              ipv4: 'IPv4地址',
              ipv6: 'IPv6地址',
              cidrv4: 'IPv4网段',
              cidrv6: 'IPv6网段',
              base64: 'base64编码字符串',
              base64url: 'base64url编码字符串',
              json_string: 'JSON字符串',
              e164: 'E.164号码',
              jwt: 'JWT',
              template_literal: '输入',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `无效输入：期望 ${n.expected}，实际接收 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? '非数字(NaN)' : '数字';
                    case 'object':
                      if (Array.isArray(e)) return '数组';
                      if (null === e) return '空值(null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `无效输入：期望 ${Y(n.values[0])}`;
                return `无效选项：期望以下之一 ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `数值过大：期望 ${n.origin ?? '值'} ${t}${n.maximum.toString()} ${r.unit ?? '个元素'}`;
                return `数值过大：期望 ${n.origin ?? '值'} ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r) return `数值过小：期望 ${n.origin} ${t}${n.minimum.toString()} ${r.unit}`;
                return `数值过小：期望 ${n.origin} ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format) return `无效字符串：必须以 "${n.prefix}" 开头`;
                if ('ends_with' === n.format) return `无效字符串：必须以 "${n.suffix}" 结尾`;
                if ('includes' === n.format) return `无效字符串：必须包含 "${n.includes}"`;
                if ('regex' === n.format) return `无效字符串：必须满足正则表达式 ${n.pattern}`;
                return `无效${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `无效数字：必须是 ${n.divisor} 的倍数`;
              case 'unrecognized_keys':
                return `出现未知的键(key): ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `${n.origin} 中的键(key)无效`;
              case 'invalid_union':
                return '无效输入';
              case 'invalid_element':
                return `${n.origin} 中包含无效值(value)`;
              default:
                return `无效输入`;
            }
          };
        })(),
      };
    }
    function iT() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '字元', verb: '擁有' },
              file: { unit: '位元組', verb: '擁有' },
              array: { unit: '項目', verb: '擁有' },
              set: { unit: '項目', verb: '擁有' },
            },
            t = {
              regex: '輸入',
              email: '郵件地址',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO 日期時間',
              date: 'ISO 日期',
              time: 'ISO 時間',
              duration: 'ISO 期間',
              ipv4: 'IPv4 位址',
              ipv6: 'IPv6 位址',
              cidrv4: 'IPv4 範圍',
              cidrv6: 'IPv6 範圍',
              base64: 'base64 編碼字串',
              base64url: 'base64url 編碼字串',
              json_string: 'JSON 字串',
              e164: 'E.164 數值',
              jwt: 'JWT',
              template_literal: '輸入',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `無效的輸入值：預期為 ${n.expected}，但收到 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length) return `無效的輸入值：預期為 ${Y(n.values[0])}`;
                return `無效的選項：預期為以下其中之一 ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `數值過大：預期 ${n.origin ?? '值'} 應為 ${t}${n.maximum.toString()} ${r.unit ?? '個元素'}`;
                return `數值過大：預期 ${n.origin ?? '值'} 應為 ${t}${n.maximum.toString()}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `數值過小：預期 ${n.origin} 應為 ${t}${n.minimum.toString()} ${r.unit}`;
                return `數值過小：預期 ${n.origin} 應為 ${t}${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format) return `無效的字串：必須以 "${n.prefix}" 開頭`;
                if ('ends_with' === n.format) return `無效的字串：必須以 "${n.suffix}" 結尾`;
                if ('includes' === n.format) return `無效的字串：必須包含 "${n.includes}"`;
                if ('regex' === n.format) return `無效的字串：必須符合格式 ${n.pattern}`;
                return `無效的 ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `無效的數字：必須為 ${n.divisor} 的倍數`;
              case 'unrecognized_keys':
                return `無法識別的鍵值${n.keys.length > 1 ? '們' : ''}：${m(n.keys, '、')}`;
              case 'invalid_key':
                return `${n.origin} 中有無效的鍵值`;
              case 'invalid_union':
                return '無效的輸入值';
              case 'invalid_element':
                return `${n.origin} 中有無效的值`;
              default:
                return `無效的輸入值`;
            }
          };
        })(),
      };
    }
    function im() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'àmi', verb: 'ní' },
              file: { unit: 'bytes', verb: 'ní' },
              array: { unit: 'nkan', verb: 'ní' },
              set: { unit: 'nkan', verb: 'ní' },
            },
            t = {
              regex: 'ẹ̀rọ ìbáwọlé',
              email: 'àdírẹ́sì ìmẹ́lì',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'àkókò ISO',
              date: 'ọjọ́ ISO',
              time: 'àkókò ISO',
              duration: 'àkókò tó pé ISO',
              ipv4: 'àdírẹ́sì IPv4',
              ipv6: 'àdírẹ́sì IPv6',
              cidrv4: 'àgbègbè IPv4',
              cidrv6: 'àgbègbè IPv6',
              base64: 'ọ̀rọ̀ tí a kọ́ ní base64',
              base64url: 'ọ̀rọ̀ base64url',
              json_string: 'ọ̀rọ̀ JSON',
              e164: 'nọ́mbà E.164',
              jwt: 'JWT',
              template_literal: 'ẹ̀rọ ìbáwọlé',
            };
          return (n) => {
            switch (n.code) {
              case 'invalid_type':
                return `\xccb\xe1wọl\xe9 aṣ\xecṣe: a n\xed l\xe1ti fi ${n.expected}, \xe0mọ̀ a r\xed ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nọ́mbà';
                    case 'object':
                      if (Array.isArray(e)) return 'akopọ';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(n.input)}`;
              case 'invalid_value':
                if (1 === n.values.length)
                  return `\xccb\xe1wọl\xe9 aṣ\xecṣe: a n\xed l\xe1ti fi ${Y(n.values[0])}`;
                return `\xc0ṣ\xe0y\xe0n aṣ\xecṣe: yan ọ̀kan l\xe1ra ${m(n.values, '|')}`;
              case 'too_big': {
                let t = n.inclusive ? '<=' : '<',
                  r = e[n.origin] ?? null;
                if (r)
                  return `T\xf3 pọ̀ j\xf9: a n\xed l\xe1ti jẹ́ p\xe9 ${n.origin ?? 'iye'} ${r.verb} ${t}${n.maximum} ${r.unit}`;
                return `T\xf3 pọ̀ j\xf9: a n\xed l\xe1ti jẹ́ ${t}${n.maximum}`;
              }
              case 'too_small': {
                let t = n.inclusive ? '>=' : '>',
                  r = e[n.origin] ?? null;
                if (r)
                  return `K\xe9r\xe9 ju: a n\xed l\xe1ti jẹ́ p\xe9 ${n.origin} ${r.verb} ${t}${n.minimum} ${r.unit}`;
                return `K\xe9r\xe9 ju: a n\xed l\xe1ti jẹ́ ${t}${n.minimum}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀l\xfa "${n.prefix}"`;
                if ('ends_with' === n.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ par\xed pẹ̀l\xfa "${n.suffix}"`;
                if ('includes' === n.format) return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ n\xed "${n.includes}"`;
                if ('regex' === n.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ b\xe1 \xe0pẹẹrẹ mu ${n.pattern}`;
                return `Aṣ\xecṣe: ${t[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Nọ́mb\xe0 aṣ\xecṣe: gbọ́dọ̀ jẹ́ \xe8y\xe0 p\xedp\xedn ti ${n.divisor}`;
              case 'unrecognized_keys':
                return `Bọt\xecn\xec \xe0\xecmọ̀: ${m(n.keys, ', ')}`;
              case 'invalid_key':
                return `Bọt\xecn\xec aṣ\xecṣe n\xedn\xfa ${n.origin}`;
              case 'invalid_union':
              default:
                return 'Ìbáwọlé aṣìṣe';
              case 'invalid_element':
                return `Iye aṣ\xecṣe n\xedn\xfa ${n.origin}`;
            }
          };
        })(),
      };
    }
    (e.s(
      [
        'ar',
        () => rG,
        'az',
        () => rV,
        'be',
        () => rB,
        'ca',
        () => rH,
        'cs',
        () => rj,
        'da',
        () => rF,
        'de',
        () => rZ,
        'en',
        () => eg,
        'eo',
        () => rY,
        'es',
        () => rW,
        'fa',
        () => rK,
        'fi',
        () => rz,
        'fr',
        () => rX,
        'frCA',
        () => rJ,
        'he',
        () => rQ,
        'hu',
        () => rq,
        'id',
        () => r0,
        'is',
        () => r1,
        'it',
        () => r2,
        'ja',
        () => r5,
        'kh',
        () => r4,
        'ko',
        () => r9,
        'mk',
        () => r3,
        'ms',
        () => r6,
        'nl',
        () => r7,
        'no',
        () => r8,
        'ota',
        () => ie,
        'pl',
        () => ir,
        'ps',
        () => it,
        'pt',
        () => ii,
        'ru',
        () => ia,
        'sl',
        () => is,
        'sv',
        () => iu,
        'ta',
        () => il,
        'th',
        () => ic,
        'tr',
        () => id,
        'ua',
        () => ip,
        'ur',
        () => i_,
        'vi',
        () => iS,
        'yo',
        () => im,
        'zhCN',
        () => iE,
        'zhTW',
        () => iT,
      ],
      5322
    ),
      e.s([], 32705),
      e.i(32705));
    var ig = e.i(5322);
    e.s(
      [
        '$ZodRegistry',
        () => iR,
        '$input',
        () => iA,
        '$output',
        () => ih,
        'globalRegistry',
        () => iI,
        'registry',
        () => iy,
      ],
      39245
    );
    let ih = Symbol('ZodOutput'),
      iA = Symbol('ZodInput');
    class iR {
      constructor() {
        ((this._map = new Map()), (this._idmap = new Map()));
      }
      add(e, ...t) {
        let n = t[0];
        if ((this._map.set(e, n), n && 'object' == typeof n && 'id' in n)) {
          if (this._idmap.has(n.id)) throw Error(`ID ${n.id} already exists in the registry`);
          this._idmap.set(n.id, e);
        }
        return this;
      }
      clear() {
        return ((this._map = new Map()), (this._idmap = new Map()), this);
      }
      remove(e) {
        let t = this._map.get(e);
        return (
          t && 'object' == typeof t && 'id' in t && this._idmap.delete(t.id),
          this._map.delete(e),
          this
        );
      }
      get(e) {
        let t = e._zod.parent;
        if (t) {
          let n = { ...(this.get(t) ?? {}) };
          delete n.id;
          let r = { ...n, ...this._map.get(e) };
          return Object.keys(r).length ? r : void 0;
        }
        return this._map.get(e);
      }
      has(e) {
        return this._map.has(e);
      }
    }
    function iy() {
      return new iR();
    }
    let iI = iy();
    function ib(e, t) {
      return new e({ type: 'string', ...F(t) });
    }
    function iN(e, t) {
      return new e({ type: 'string', coerce: !0, ...F(t) });
    }
    function iO(e, t) {
      return new e({ type: 'string', format: 'email', check: 'string_format', abort: !1, ...F(t) });
    }
    function iv(e, t) {
      return new e({ type: 'string', format: 'guid', check: 'string_format', abort: !1, ...F(t) });
    }
    function iC(e, t) {
      return new e({ type: 'string', format: 'uuid', check: 'string_format', abort: !1, ...F(t) });
    }
    function iP(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v4',
        ...F(t),
      });
    }
    function iM(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v6',
        ...F(t),
      });
    }
    function iL(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v7',
        ...F(t),
      });
    }
    function iU(e, t) {
      return new e({ type: 'string', format: 'url', check: 'string_format', abort: !1, ...F(t) });
    }
    function iD(e, t) {
      return new e({ type: 'string', format: 'emoji', check: 'string_format', abort: !1, ...F(t) });
    }
    function ix(e, t) {
      return new e({
        type: 'string',
        format: 'nanoid',
        check: 'string_format',
        abort: !1,
        ...F(t),
      });
    }
    function iw(e, t) {
      return new e({ type: 'string', format: 'cuid', check: 'string_format', abort: !1, ...F(t) });
    }
    function ik(e, t) {
      return new e({ type: 'string', format: 'cuid2', check: 'string_format', abort: !1, ...F(t) });
    }
    function iG(e, t) {
      return new e({ type: 'string', format: 'ulid', check: 'string_format', abort: !1, ...F(t) });
    }
    function iV(e, t) {
      return new e({ type: 'string', format: 'xid', check: 'string_format', abort: !1, ...F(t) });
    }
    function i$(e, t) {
      return new e({ type: 'string', format: 'ksuid', check: 'string_format', abort: !1, ...F(t) });
    }
    function iB(e, t) {
      return new e({ type: 'string', format: 'ipv4', check: 'string_format', abort: !1, ...F(t) });
    }
    function iH(e, t) {
      return new e({ type: 'string', format: 'ipv6', check: 'string_format', abort: !1, ...F(t) });
    }
    function ij(e, t) {
      return new e({
        type: 'string',
        format: 'cidrv4',
        check: 'string_format',
        abort: !1,
        ...F(t),
      });
    }
    function iF(e, t) {
      return new e({
        type: 'string',
        format: 'cidrv6',
        check: 'string_format',
        abort: !1,
        ...F(t),
      });
    }
    function iZ(e, t) {
      return new e({
        type: 'string',
        format: 'base64',
        check: 'string_format',
        abort: !1,
        ...F(t),
      });
    }
    function iY(e, t) {
      return new e({
        type: 'string',
        format: 'base64url',
        check: 'string_format',
        abort: !1,
        ...F(t),
      });
    }
    function iW(e, t) {
      return new e({ type: 'string', format: 'e164', check: 'string_format', abort: !1, ...F(t) });
    }
    function iK(e, t) {
      return new e({ type: 'string', format: 'jwt', check: 'string_format', abort: !1, ...F(t) });
    }
    (e.i(39245),
      e.i(86369),
      e.s(
        [
          'TimePrecision',
          () => iz,
          '_any',
          () => oa,
          '_array',
          () => oB,
          '_base64',
          () => iZ,
          '_base64url',
          () => iY,
          '_bigint',
          () => i8,
          '_boolean',
          () => i6,
          '_catch',
          () => o9,
          '_check',
          () => ai,
          '_cidrv4',
          () => ij,
          '_cidrv6',
          () => iF,
          '_coercedBigint',
          () => oe,
          '_coercedBoolean',
          () => i7,
          '_coercedDate',
          () => od,
          '_coercedNumber',
          () => i1,
          '_coercedString',
          () => iN,
          '_cuid',
          () => iw,
          '_cuid2',
          () => ik,
          '_custom',
          () => at,
          '_date',
          () => oc,
          '_default',
          () => o2,
          '_discriminatedUnion',
          () => oj,
          '_e164',
          () => iW,
          '_email',
          () => iO,
          '_emoji',
          () => iD,
          '_endsWith',
          () => oU,
          '_enum',
          () => oz,
          '_file',
          () => oQ,
          '_float32',
          () => i5,
          '_float64',
          () => i4,
          '_gt',
          () => oE,
          '_gte',
          () => oT,
          '_guid',
          () => iv,
          '_includes',
          () => oM,
          '_int',
          () => i2,
          '_int32',
          () => i9,
          '_int64',
          () => ot,
          '_intersection',
          () => oF,
          '_ipv4',
          () => iB,
          '_ipv6',
          () => iH,
          '_isoDate',
          () => iJ,
          '_isoDateTime',
          () => iX,
          '_isoDuration',
          () => iq,
          '_isoTime',
          () => iQ,
          '_jwt',
          () => iK,
          '_ksuid',
          () => i$,
          '_lazy',
          () => o8,
          '_length',
          () => oO,
          '_literal',
          () => oJ,
          '_lowercase',
          () => oC,
          '_lt',
          () => o_,
          '_lte',
          () => oS,
          '_map',
          () => oW,
          '_max',
          () => oS,
          '_maxLength',
          () => ob,
          '_maxSize',
          () => oR,
          '_mime',
          () => ox,
          '_min',
          () => oT,
          '_minLength',
          () => oN,
          '_minSize',
          () => oy,
          '_multipleOf',
          () => oA,
          '_nan',
          () => op,
          '_nanoid',
          () => ix,
          '_nativeEnum',
          () => oX,
          '_negative',
          () => og,
          '_never',
          () => ou,
          '_nonnegative',
          () => oh,
          '_nonoptional',
          () => o5,
          '_nonpositive',
          () => of,
          '_normalize',
          () => ok,
          '_null',
          () => oo,
          '_nullable',
          () => o1,
          '_number',
          () => i0,
          '_optional',
          () => o0,
          '_overwrite',
          () => ow,
          '_pipe',
          () => o3,
          '_positive',
          () => om,
          '_promise',
          () => ae,
          '_property',
          () => oD,
          '_readonly',
          () => o6,
          '_record',
          () => oY,
          '_refine',
          () => an,
          '_regex',
          () => ov,
          '_set',
          () => oK,
          '_size',
          () => oI,
          '_startsWith',
          () => oL,
          '_string',
          () => ib,
          '_stringFormat',
          () => aa,
          '_stringbool',
          () => ao,
          '_success',
          () => o4,
          '_superRefine',
          () => ar,
          '_symbol',
          () => or,
          '_templateLiteral',
          () => o7,
          '_toLowerCase',
          () => oV,
          '_toUpperCase',
          () => o$,
          '_transform',
          () => oq,
          '_trim',
          () => oG,
          '_tuple',
          () => oZ,
          '_uint32',
          () => i3,
          '_uint64',
          () => on,
          '_ulid',
          () => iG,
          '_undefined',
          () => oi,
          '_union',
          () => oH,
          '_unknown',
          () => os,
          '_uppercase',
          () => oP,
          '_url',
          () => iU,
          '_uuid',
          () => iC,
          '_uuidv4',
          () => iP,
          '_uuidv6',
          () => iM,
          '_uuidv7',
          () => iL,
          '_void',
          () => ol,
          '_xid',
          () => iV,
        ],
        93863
      ));
    let iz = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
    function iX(e, t) {
      return new e({
        type: 'string',
        format: 'datetime',
        check: 'string_format',
        offset: !1,
        local: !1,
        precision: null,
        ...F(t),
      });
    }
    function iJ(e, t) {
      return new e({ type: 'string', format: 'date', check: 'string_format', ...F(t) });
    }
    function iQ(e, t) {
      return new e({
        type: 'string',
        format: 'time',
        check: 'string_format',
        precision: null,
        ...F(t),
      });
    }
    function iq(e, t) {
      return new e({ type: 'string', format: 'duration', check: 'string_format', ...F(t) });
    }
    function i0(e, t) {
      return new e({ type: 'number', checks: [], ...F(t) });
    }
    function i1(e, t) {
      return new e({ type: 'number', coerce: !0, checks: [], ...F(t) });
    }
    function i2(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'safeint',
        ...F(t),
      });
    }
    function i5(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float32',
        ...F(t),
      });
    }
    function i4(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float64',
        ...F(t),
      });
    }
    function i9(e, t) {
      return new e({ type: 'number', check: 'number_format', abort: !1, format: 'int32', ...F(t) });
    }
    function i3(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'uint32',
        ...F(t),
      });
    }
    function i6(e, t) {
      return new e({ type: 'boolean', ...F(t) });
    }
    function i7(e, t) {
      return new e({ type: 'boolean', coerce: !0, ...F(t) });
    }
    function i8(e, t) {
      return new e({ type: 'bigint', ...F(t) });
    }
    function oe(e, t) {
      return new e({ type: 'bigint', coerce: !0, ...F(t) });
    }
    function ot(e, t) {
      return new e({ type: 'bigint', check: 'bigint_format', abort: !1, format: 'int64', ...F(t) });
    }
    function on(e, t) {
      return new e({
        type: 'bigint',
        check: 'bigint_format',
        abort: !1,
        format: 'uint64',
        ...F(t),
      });
    }
    function or(e, t) {
      return new e({ type: 'symbol', ...F(t) });
    }
    function oi(e, t) {
      return new e({ type: 'undefined', ...F(t) });
    }
    function oo(e, t) {
      return new e({ type: 'null', ...F(t) });
    }
    function oa(e) {
      return new e({ type: 'any' });
    }
    function os(e) {
      return new e({ type: 'unknown' });
    }
    function ou(e, t) {
      return new e({ type: 'never', ...F(t) });
    }
    function ol(e, t) {
      return new e({ type: 'void', ...F(t) });
    }
    function oc(e, t) {
      return new e({ type: 'date', ...F(t) });
    }
    function od(e, t) {
      return new e({ type: 'date', coerce: !0, ...F(t) });
    }
    function op(e, t) {
      return new e({ type: 'nan', ...F(t) });
    }
    function o_(e, t) {
      return new tX({ check: 'less_than', ...F(t), value: e, inclusive: !1 });
    }
    function oS(e, t) {
      return new tX({ check: 'less_than', ...F(t), value: e, inclusive: !0 });
    }
    function oE(e, t) {
      return new tJ({ check: 'greater_than', ...F(t), value: e, inclusive: !1 });
    }
    function oT(e, t) {
      return new tJ({ check: 'greater_than', ...F(t), value: e, inclusive: !0 });
    }
    function om(e) {
      return oE(0, e);
    }
    function og(e) {
      return o_(0, e);
    }
    function of(e) {
      return oS(0, e);
    }
    function oh(e) {
      return oT(0, e);
    }
    function oA(e, t) {
      return new tQ({ check: 'multiple_of', ...F(t), value: e });
    }
    function oR(e, t) {
      return new t1({ check: 'max_size', ...F(t), maximum: e });
    }
    function oy(e, t) {
      return new t2({ check: 'min_size', ...F(t), minimum: e });
    }
    function oI(e, t) {
      return new t5({ check: 'size_equals', ...F(t), size: e });
    }
    function ob(e, t) {
      return new t4({ check: 'max_length', ...F(t), maximum: e });
    }
    function oN(e, t) {
      return new t9({ check: 'min_length', ...F(t), minimum: e });
    }
    function oO(e, t) {
      return new t3({ check: 'length_equals', ...F(t), length: e });
    }
    function ov(e, t) {
      return new t7({ check: 'string_format', format: 'regex', ...F(t), pattern: e });
    }
    function oC(e) {
      return new t8({ check: 'string_format', format: 'lowercase', ...F(e) });
    }
    function oP(e) {
      return new ne({ check: 'string_format', format: 'uppercase', ...F(e) });
    }
    function oM(e, t) {
      return new nt({ check: 'string_format', format: 'includes', ...F(t), includes: e });
    }
    function oL(e, t) {
      return new nn({ check: 'string_format', format: 'starts_with', ...F(t), prefix: e });
    }
    function oU(e, t) {
      return new nr({ check: 'string_format', format: 'ends_with', ...F(t), suffix: e });
    }
    function oD(e, t, n) {
      return new no({ check: 'property', property: e, schema: t, ...F(n) });
    }
    function ox(e, t) {
      return new na({ check: 'mime_type', mime: e, ...F(t) });
    }
    function ow(e) {
      return new ns({ check: 'overwrite', tx: e });
    }
    function ok(e) {
      return ow((t) => t.normalize(e));
    }
    function oG() {
      return ow((e) => e.trim());
    }
    function oV() {
      return ow((e) => e.toLowerCase());
    }
    function o$() {
      return ow((e) => e.toUpperCase());
    }
    function oB(e, t, n) {
      return new e({ type: 'array', element: t, ...F(n) });
    }
    function oH(e, t, n) {
      return new e({ type: 'union', options: t, ...F(n) });
    }
    function oj(e, t, n, r) {
      return new e({ type: 'union', options: n, discriminator: t, ...F(r) });
    }
    function oF(e, t, n) {
      return new e({ type: 'intersection', left: t, right: n });
    }
    function oZ(e, t, n, r) {
      let i = n instanceof nc,
        o = i ? r : n;
      return new e({ type: 'tuple', items: t, rest: i ? n : null, ...F(o) });
    }
    function oY(e, t, n, r) {
      return new e({ type: 'record', keyType: t, valueType: n, ...F(r) });
    }
    function oW(e, t, n, r) {
      return new e({ type: 'map', keyType: t, valueType: n, ...F(r) });
    }
    function oK(e, t, n) {
      return new e({ type: 'set', valueType: t, ...F(n) });
    }
    function oz(e, t, n) {
      return new e({
        type: 'enum',
        entries: Array.isArray(t) ? Object.fromEntries(t.map((e) => [e, e])) : t,
        ...F(n),
      });
    }
    function oX(e, t, n) {
      return new e({ type: 'enum', entries: t, ...F(n) });
    }
    function oJ(e, t, n) {
      return new e({ type: 'literal', values: Array.isArray(t) ? t : [t], ...F(n) });
    }
    function oQ(e, t) {
      return new e({ type: 'file', ...F(t) });
    }
    function oq(e, t) {
      return new e({ type: 'transform', transform: t });
    }
    function o0(e, t) {
      return new e({ type: 'optional', innerType: t });
    }
    function o1(e, t) {
      return new e({ type: 'nullable', innerType: t });
    }
    function o2(e, t, n) {
      return new e({
        type: 'default',
        innerType: t,
        get defaultValue() {
          return 'function' == typeof n ? n() : k(n);
        },
      });
    }
    function o5(e, t, n) {
      return new e({ type: 'nonoptional', innerType: t, ...F(n) });
    }
    function o4(e, t) {
      return new e({ type: 'success', innerType: t });
    }
    function o9(e, t, n) {
      return new e({
        type: 'catch',
        innerType: t,
        catchValue: 'function' == typeof n ? n : () => n,
      });
    }
    function o3(e, t, n) {
      return new e({ type: 'pipe', in: t, out: n });
    }
    function o6(e, t) {
      return new e({ type: 'readonly', innerType: t });
    }
    function o7(e, t, n) {
      return new e({ type: 'template_literal', parts: t, ...F(n) });
    }
    function o8(e, t) {
      return new e({ type: 'lazy', getter: t });
    }
    function ae(e, t) {
      return new e({ type: 'promise', innerType: t });
    }
    function at(e, t, n) {
      let r = F(n);
      return (r.abort ?? (r.abort = !0), new e({ type: 'custom', check: 'custom', fn: t, ...r }));
    }
    function an(e, t, n) {
      return new e({ type: 'custom', check: 'custom', fn: t, ...F(n) });
    }
    function ar(e) {
      let t = ai(
        (n) => (
          (n.addIssue = (e) => {
            'string' == typeof e
              ? n.issues.push(el(e, n.value, t._zod.def))
              : (e.fatal && (e.continue = !1),
                e.code ?? (e.code = 'custom'),
                e.input ?? (e.input = n.value),
                e.inst ?? (e.inst = t),
                e.continue ?? (e.continue = !t._zod.def.abort),
                n.issues.push(el(e)));
          }),
          e(n.value, n)
        )
      );
      return t;
    }
    function ai(e, t) {
      let n = new tK({ check: 'custom', ...F(t) });
      return ((n._zod.check = e), n);
    }
    function ao(e, t) {
      let n = F(t),
        r = n.truthy ?? ['true', '1', 'yes', 'on', 'y', 'enabled'],
        i = n.falsy ?? ['false', '0', 'no', 'off', 'n', 'disabled'];
      'sensitive' !== n.case &&
        ((r = r.map((e) => ('string' == typeof e ? e.toLowerCase() : e))),
        (i = i.map((e) => ('string' == typeof e ? e.toLowerCase() : e))));
      let o = new Set(r),
        a = new Set(i),
        s = e.Codec ?? rb,
        u = e.Boolean ?? nH,
        l = new s({
          type: 'pipe',
          in: new (e.String ?? nd)({ type: 'string', error: n.error }),
          out: new u({ type: 'boolean', error: n.error }),
          transform: (e, t) => {
            let r = e;
            return (
              'sensitive' !== n.case && (r = r.toLowerCase()),
              !!o.has(r) ||
                (!a.has(r) &&
                  (t.issues.push({
                    code: 'invalid_value',
                    expected: 'stringbool',
                    values: [...o, ...a],
                    input: t.value,
                    inst: l,
                    continue: !1,
                  }),
                  {}))
            );
          },
          reverseTransform: (e, t) => (!0 === e ? r[0] || 'true' : i[0] || 'false'),
          error: n.error,
        });
      return l;
    }
    function aa(e, t, n, r = {}) {
      let i = F(r),
        o = {
          ...F(r),
          check: 'string_format',
          type: 'string',
          format: t,
          fn: 'function' == typeof n ? n : (e) => n.test(e),
          ...i,
        };
      return (n instanceof RegExp && (o.pattern = n), new e(o));
    }
    (e.i(93863), e.s(['JSONSchemaGenerator', () => as, 'toJSONSchema', () => au], 61941));
    class as {
      constructor(e) {
        ((this.counter = 0),
          (this.metadataRegistry = e?.metadata ?? iI),
          (this.target = e?.target ?? 'draft-2020-12'),
          (this.unrepresentable = e?.unrepresentable ?? 'throw'),
          (this.override = e?.override ?? (() => {})),
          (this.io = e?.io ?? 'output'),
          (this.seen = new Map()));
      }
      process(e, t = { path: [], schemaPath: [] }) {
        var n;
        let r = e._zod.def,
          i = this.seen.get(e);
        if (i) return (i.count++, t.schemaPath.includes(e) && (i.cycle = t.path), i.schema);
        let o = { schema: {}, count: 1, cycle: void 0, path: t.path };
        this.seen.set(e, o);
        let a = e._zod.toJSONSchema?.();
        if (a) o.schema = a;
        else {
          let n = { ...t, schemaPath: [...t.schemaPath, e], path: t.path },
            i = e._zod.parent;
          if (i) ((o.ref = i), this.process(i, n), (this.seen.get(i).isParent = !0));
          else {
            let t = o.schema;
            switch (r.type) {
              case 'string': {
                t.type = 'string';
                let {
                  minimum: n,
                  maximum: r,
                  format: i,
                  patterns: a,
                  contentEncoding: s,
                } = e._zod.bag;
                if (
                  ('number' == typeof n && (t.minLength = n),
                  'number' == typeof r && (t.maxLength = r),
                  i &&
                    ((t.format =
                      {
                        guid: 'uuid',
                        url: 'uri',
                        datetime: 'date-time',
                        json_string: 'json-string',
                        regex: '',
                      }[i] ?? i),
                    '' === t.format && delete t.format),
                  s && (t.contentEncoding = s),
                  a && a.size > 0)
                ) {
                  let e = [...a];
                  1 === e.length
                    ? (t.pattern = e[0].source)
                    : e.length > 1 &&
                      (o.schema.allOf = [
                        ...e.map((e) => ({
                          ...('draft-7' === this.target ||
                          'draft-4' === this.target ||
                          'openapi-3.0' === this.target
                            ? { type: 'string' }
                            : {}),
                          pattern: e.source,
                        })),
                      ]);
                }
                break;
              }
              case 'number': {
                let {
                  minimum: n,
                  maximum: r,
                  format: i,
                  multipleOf: o,
                  exclusiveMaximum: a,
                  exclusiveMinimum: s,
                } = e._zod.bag;
                ('string' == typeof i && i.includes('int')
                  ? (t.type = 'integer')
                  : (t.type = 'number'),
                  'number' == typeof s &&
                    ('draft-4' === this.target || 'openapi-3.0' === this.target
                      ? ((t.minimum = s), (t.exclusiveMinimum = !0))
                      : (t.exclusiveMinimum = s)),
                  'number' == typeof n &&
                    ((t.minimum = n),
                    'number' == typeof s &&
                      'draft-4' !== this.target &&
                      (s >= n ? delete t.minimum : delete t.exclusiveMinimum)),
                  'number' == typeof a &&
                    ('draft-4' === this.target || 'openapi-3.0' === this.target
                      ? ((t.maximum = a), (t.exclusiveMaximum = !0))
                      : (t.exclusiveMaximum = a)),
                  'number' == typeof r &&
                    ((t.maximum = r),
                    'number' == typeof a &&
                      'draft-4' !== this.target &&
                      (a <= r ? delete t.maximum : delete t.exclusiveMaximum)),
                  'number' == typeof o && (t.multipleOf = o));
                break;
              }
              case 'boolean':
              case 'success':
                t.type = 'boolean';
                break;
              case 'bigint':
                if ('throw' === this.unrepresentable)
                  throw Error('BigInt cannot be represented in JSON Schema');
                break;
              case 'symbol':
                if ('throw' === this.unrepresentable)
                  throw Error('Symbols cannot be represented in JSON Schema');
                break;
              case 'null':
                'openapi-3.0' === this.target
                  ? ((t.type = 'string'), (t.nullable = !0), (t.enum = [null]))
                  : (t.type = 'null');
                break;
              case 'any':
              case 'unknown':
                break;
              case 'undefined':
                if ('throw' === this.unrepresentable)
                  throw Error('Undefined cannot be represented in JSON Schema');
                break;
              case 'void':
                if ('throw' === this.unrepresentable)
                  throw Error('Void cannot be represented in JSON Schema');
                break;
              case 'never':
                t.not = {};
                break;
              case 'date':
                if ('throw' === this.unrepresentable)
                  throw Error('Date cannot be represented in JSON Schema');
                break;
              case 'array': {
                let { minimum: i, maximum: o } = e._zod.bag;
                ('number' == typeof i && (t.minItems = i),
                  'number' == typeof o && (t.maxItems = o),
                  (t.type = 'array'),
                  (t.items = this.process(r.element, { ...n, path: [...n.path, 'items'] })));
                break;
              }
              case 'object': {
                ((t.type = 'object'), (t.properties = {}));
                let e = r.shape;
                for (let r in e)
                  t.properties[r] = this.process(e[r], {
                    ...n,
                    path: [...n.path, 'properties', r],
                  });
                let i = new Set(
                  [...new Set(Object.keys(e))].filter((e) => {
                    let t = r.shape[e]._zod;
                    return 'input' === this.io ? void 0 === t.optin : void 0 === t.optout;
                  })
                );
                (i.size > 0 && (t.required = Array.from(i)),
                  r.catchall?._zod.def.type === 'never'
                    ? (t.additionalProperties = !1)
                    : r.catchall
                      ? r.catchall &&
                        (t.additionalProperties = this.process(r.catchall, {
                          ...n,
                          path: [...n.path, 'additionalProperties'],
                        }))
                      : 'output' === this.io && (t.additionalProperties = !1));
                break;
              }
              case 'union':
                t.anyOf = r.options.map((e, t) =>
                  this.process(e, { ...n, path: [...n.path, 'anyOf', t] })
                );
                break;
              case 'intersection': {
                let e = this.process(r.left, { ...n, path: [...n.path, 'allOf', 0] }),
                  i = this.process(r.right, { ...n, path: [...n.path, 'allOf', 1] }),
                  o = (e) => 'allOf' in e && 1 === Object.keys(e).length;
                t.allOf = [...(o(e) ? e.allOf : [e]), ...(o(i) ? i.allOf : [i])];
                break;
              }
              case 'tuple': {
                t.type = 'array';
                let i = 'draft-2020-12' === this.target ? 'prefixItems' : 'items',
                  o =
                    'draft-2020-12' === this.target || 'openapi-3.0' === this.target
                      ? 'items'
                      : 'additionalItems',
                  a = r.items.map((e, t) => this.process(e, { ...n, path: [...n.path, i, t] })),
                  s = r.rest
                    ? this.process(r.rest, {
                        ...n,
                        path: [
                          ...n.path,
                          o,
                          ...('openapi-3.0' === this.target ? [r.items.length] : []),
                        ],
                      })
                    : null;
                'draft-2020-12' === this.target
                  ? ((t.prefixItems = a), s && (t.items = s))
                  : 'openapi-3.0' === this.target
                    ? ((t.items = { anyOf: a }),
                      s && t.items.anyOf.push(s),
                      (t.minItems = a.length),
                      s || (t.maxItems = a.length))
                    : ((t.items = a), s && (t.additionalItems = s));
                let { minimum: u, maximum: l } = e._zod.bag;
                ('number' == typeof u && (t.minItems = u),
                  'number' == typeof l && (t.maxItems = l));
                break;
              }
              case 'record':
                ((t.type = 'object'),
                  ('draft-7' === this.target || 'draft-2020-12' === this.target) &&
                    (t.propertyNames = this.process(r.keyType, {
                      ...n,
                      path: [...n.path, 'propertyNames'],
                    })),
                  (t.additionalProperties = this.process(r.valueType, {
                    ...n,
                    path: [...n.path, 'additionalProperties'],
                  })));
                break;
              case 'map':
                if ('throw' === this.unrepresentable)
                  throw Error('Map cannot be represented in JSON Schema');
                break;
              case 'set':
                if ('throw' === this.unrepresentable)
                  throw Error('Set cannot be represented in JSON Schema');
                break;
              case 'enum': {
                let e = T(r.entries);
                (e.every((e) => 'number' == typeof e) && (t.type = 'number'),
                  e.every((e) => 'string' == typeof e) && (t.type = 'string'),
                  (t.enum = e));
                break;
              }
              case 'literal': {
                let e = [];
                for (let t of r.values)
                  if (void 0 === t) {
                    if ('throw' === this.unrepresentable)
                      throw Error('Literal `undefined` cannot be represented in JSON Schema');
                  } else if ('bigint' == typeof t)
                    if ('throw' === this.unrepresentable)
                      throw Error('BigInt literals cannot be represented in JSON Schema');
                    else e.push(Number(t));
                  else e.push(t);
                if (0 === e.length);
                else if (1 === e.length) {
                  let n = e[0];
                  ((t.type = null === n ? 'null' : typeof n),
                    'draft-4' === this.target || 'openapi-3.0' === this.target
                      ? (t.enum = [n])
                      : (t.const = n));
                } else
                  (e.every((e) => 'number' == typeof e) && (t.type = 'number'),
                    e.every((e) => 'string' == typeof e) && (t.type = 'string'),
                    e.every((e) => 'boolean' == typeof e) && (t.type = 'string'),
                    e.every((e) => null === e) && (t.type = 'null'),
                    (t.enum = e));
                break;
              }
              case 'file': {
                let n = { type: 'string', format: 'binary', contentEncoding: 'binary' },
                  { minimum: r, maximum: i, mime: o } = e._zod.bag;
                (void 0 !== r && (n.minLength = r),
                  void 0 !== i && (n.maxLength = i),
                  o
                    ? 1 === o.length
                      ? ((n.contentMediaType = o[0]), Object.assign(t, n))
                      : (t.anyOf = o.map((e) => ({ ...n, contentMediaType: e })))
                    : Object.assign(t, n));
                break;
              }
              case 'transform':
                if ('throw' === this.unrepresentable)
                  throw Error('Transforms cannot be represented in JSON Schema');
                break;
              case 'nullable': {
                let e = this.process(r.innerType, n);
                'openapi-3.0' === this.target
                  ? ((o.ref = r.innerType), (t.nullable = !0))
                  : (t.anyOf = [e, { type: 'null' }]);
                break;
              }
              case 'nonoptional':
              case 'promise':
              case 'optional':
                (this.process(r.innerType, n), (o.ref = r.innerType));
                break;
              case 'default':
                (this.process(r.innerType, n),
                  (o.ref = r.innerType),
                  (t.default = JSON.parse(JSON.stringify(r.defaultValue))));
                break;
              case 'prefault':
                (this.process(r.innerType, n),
                  (o.ref = r.innerType),
                  'input' === this.io &&
                    (t._prefault = JSON.parse(JSON.stringify(r.defaultValue))));
                break;
              case 'catch': {
                let e;
                (this.process(r.innerType, n), (o.ref = r.innerType));
                try {
                  e = r.catchValue(void 0);
                } catch {
                  throw Error('Dynamic catch values are not supported in JSON Schema');
                }
                t.default = e;
                break;
              }
              case 'nan':
                if ('throw' === this.unrepresentable)
                  throw Error('NaN cannot be represented in JSON Schema');
                break;
              case 'template_literal': {
                let n = e._zod.pattern;
                if (!n) throw Error('Pattern not found in template literal');
                ((t.type = 'string'), (t.pattern = n.source));
                break;
              }
              case 'pipe': {
                let e =
                  'input' === this.io ? ('transform' === r.in._zod.def.type ? r.out : r.in) : r.out;
                (this.process(e, n), (o.ref = e));
                break;
              }
              case 'readonly':
                (this.process(r.innerType, n), (o.ref = r.innerType), (t.readOnly = !0));
                break;
              case 'lazy': {
                let t = e._zod.innerType;
                (this.process(t, n), (o.ref = t));
                break;
              }
              case 'custom':
                if ('throw' === this.unrepresentable)
                  throw Error('Custom types cannot be represented in JSON Schema');
                break;
              case 'function':
                if ('throw' === this.unrepresentable)
                  throw Error('Function types cannot be represented in JSON Schema');
            }
          }
        }
        let s = this.metadataRegistry.get(e);
        return (
          s && Object.assign(o.schema, s),
          'input' === this.io &&
            (function e(t, n) {
              let r = n ?? { seen: new Set() };
              if (r.seen.has(t)) return !1;
              r.seen.add(t);
              let i = t._zod.def;
              switch (i.type) {
                case 'string':
                case 'number':
                case 'bigint':
                case 'boolean':
                case 'date':
                case 'symbol':
                case 'undefined':
                case 'null':
                case 'any':
                case 'unknown':
                case 'never':
                case 'void':
                case 'literal':
                case 'enum':
                case 'nan':
                case 'file':
                case 'template_literal':
                case 'custom':
                case 'success':
                case 'catch':
                case 'function':
                  return !1;
                case 'array':
                  return e(i.element, r);
                case 'object':
                  for (let t in i.shape) if (e(i.shape[t], r)) return !0;
                  return !1;
                case 'union':
                  for (let t of i.options) if (e(t, r)) return !0;
                  return !1;
                case 'intersection':
                  return e(i.left, r) || e(i.right, r);
                case 'tuple':
                  for (let t of i.items) if (e(t, r)) return !0;
                  if (i.rest && e(i.rest, r)) return !0;
                  return !1;
                case 'record':
                case 'map':
                  return e(i.keyType, r) || e(i.valueType, r);
                case 'set':
                  return e(i.valueType, r);
                case 'promise':
                case 'optional':
                case 'nonoptional':
                case 'nullable':
                case 'readonly':
                case 'default':
                case 'prefault':
                  return e(i.innerType, r);
                case 'lazy':
                  return e(i.getter(), r);
                case 'transform':
                  return !0;
                case 'pipe':
                  return e(i.in, r) || e(i.out, r);
              }
              throw Error(`Unknown schema type: ${i.type}`);
            })(e) &&
            (delete o.schema.examples, delete o.schema.default),
          'input' === this.io &&
            o.schema._prefault &&
            ((n = o.schema).default ?? (n.default = o.schema._prefault)),
          delete o.schema._prefault,
          this.seen.get(e).schema
        );
      }
      emit(e, t) {
        let n = {
            cycles: t?.cycles ?? 'ref',
            reused: t?.reused ?? 'inline',
            external: t?.external ?? void 0,
          },
          r = this.seen.get(e);
        if (!r) throw Error('Unprocessed schema. This is a bug in Zod.');
        let i = (e) => {
            let t = 'draft-2020-12' === this.target ? '$defs' : 'definitions';
            if (n.external) {
              let r = n.external.registry.get(e[0])?.id,
                i = n.external.uri ?? ((e) => e);
              if (r) return { ref: i(r) };
              let o = e[1].defId ?? e[1].schema.id ?? `schema${this.counter++}`;
              return ((e[1].defId = o), { defId: o, ref: `${i('__shared')}#/${t}/${o}` });
            }
            if (e[1] === r) return { ref: '#' };
            let i = `#/${t}/`,
              o = e[1].schema.id ?? `__schema${this.counter++}`;
            return { defId: o, ref: i + o };
          },
          o = (e) => {
            if (e[1].schema.$ref) return;
            let t = e[1],
              { ref: n, defId: r } = i(e);
            ((t.def = { ...t.schema }), r && (t.defId = r));
            let o = t.schema;
            for (let e in o) delete o[e];
            o.$ref = n;
          };
        if ('throw' === n.cycles)
          for (let e of this.seen.entries()) {
            let t = e[1];
            if (t.cycle)
              throw Error(`Cycle detected: #/${t.cycle?.join('/')}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
          }
        for (let t of this.seen.entries()) {
          let r = t[1];
          if (e === t[0]) {
            o(t);
            continue;
          }
          if (n.external) {
            let r = n.external.registry.get(t[0])?.id;
            if (e !== t[0] && r) {
              o(t);
              continue;
            }
          }
          if (
            this.metadataRegistry.get(t[0])?.id ||
            r.cycle ||
            (r.count > 1 && 'ref' === n.reused)
          ) {
            o(t);
            continue;
          }
        }
        let a = (e, t) => {
          let n = this.seen.get(e),
            r = n.def ?? n.schema,
            i = { ...r };
          if (null === n.ref) return;
          let o = n.ref;
          if (((n.ref = null), o)) {
            a(o, t);
            let e = this.seen.get(o).schema;
            e.$ref &&
            ('draft-7' === t.target || 'draft-4' === t.target || 'openapi-3.0' === t.target)
              ? ((r.allOf = r.allOf ?? []), r.allOf.push(e))
              : (Object.assign(r, e), Object.assign(r, i));
          }
          n.isParent || this.override({ zodSchema: e, jsonSchema: r, path: n.path ?? [] });
        };
        for (let e of [...this.seen.entries()].reverse()) a(e[0], { target: this.target });
        let s = {};
        if (
          ('draft-2020-12' === this.target
            ? (s.$schema = 'https://json-schema.org/draft/2020-12/schema')
            : 'draft-7' === this.target
              ? (s.$schema = 'http://json-schema.org/draft-07/schema#')
              : 'draft-4' === this.target
                ? (s.$schema = 'http://json-schema.org/draft-04/schema#')
                : 'openapi-3.0' === this.target || console.warn(`Invalid target: ${this.target}`),
          n.external?.uri)
        ) {
          let t = n.external.registry.get(e)?.id;
          if (!t) throw Error('Schema is missing an `id` property');
          s.$id = n.external.uri(t);
        }
        Object.assign(s, r.def);
        let u = n.external?.defs ?? {};
        for (let e of this.seen.entries()) {
          let t = e[1];
          t.def && t.defId && (u[t.defId] = t.def);
        }
        n.external ||
          (Object.keys(u).length > 0 &&
            ('draft-2020-12' === this.target ? (s.$defs = u) : (s.definitions = u)));
        try {
          return JSON.parse(JSON.stringify(s));
        } catch (e) {
          throw Error('Error converting schema to JSON.');
        }
      }
    }
    function au(e, t) {
      if (e instanceof iR) {
        let n = new as(t),
          r = {};
        for (let t of e._idmap.entries()) {
          let [e, r] = t;
          n.process(r);
        }
        let i = {},
          o = { registry: e, uri: t?.uri, defs: r };
        for (let r of e._idmap.entries()) {
          let [e, a] = r;
          i[e] = n.emit(a, { ...t, external: o });
        }
        return (
          Object.keys(r).length > 0 &&
            (i.__shared = { ['draft-2020-12' === n.target ? '$defs' : 'definitions']: r }),
          { schemas: i }
        );
      }
      let n = new as(t);
      return (n.process(e), n.emit(e, t));
    }
    (e.i(61941), e.s([], 66689));
    var al = e.i(66689),
      ac = e.i(47392);
    e.s(
      [
        'ZodAny',
        () => sZ,
        'ZodArray',
        () => s1,
        'ZodBase64',
        () => sd,
        'ZodBase64URL',
        () => s_,
        'ZodBigInt',
        () => sD,
        'ZodBigIntFormat',
        () => sw,
        'ZodBoolean',
        () => sL,
        'ZodCIDRv4',
        () => ss,
        'ZodCIDRv6',
        () => sl,
        'ZodCUID',
        () => a5,
        'ZodCUID2',
        () => a9,
        'ZodCatch',
        () => ux,
        'ZodCodec',
        () => uB,
        'ZodCustom',
        () => uq,
        'ZodCustomStringFormat',
        () => sf,
        'ZodDate',
        () => sq,
        'ZodDefault',
        () => uO,
        'ZodDiscriminatedUnion',
        () => ue,
        'ZodE164',
        () => sE,
        'ZodEmail',
        () => aB,
        'ZodEmoji',
        () => aq,
        'ZodEnum',
        () => u_,
        'ZodFile',
        () => ug,
        'ZodFunction',
        () => uJ,
        'ZodGUID',
        () => aj,
        'ZodIPv4',
        () => sr,
        'ZodIPv6',
        () => so,
        'ZodIntersection',
        () => un,
        'ZodJWT',
        () => sm,
        'ZodKSUID',
        () => st,
        'ZodLazy',
        () => uW,
        'ZodLiteral',
        () => uT,
        'ZodMap',
        () => ul,
        'ZodNaN',
        () => uk,
        'ZodNanoID',
        () => a1,
        'ZodNever',
        () => sz,
        'ZodNonOptional',
        () => uM,
        'ZodNull',
        () => sj,
        'ZodNullable',
        () => uI,
        'ZodNumber',
        () => sI,
        'ZodNumberFormat',
        () => sN,
        'ZodObject',
        () => s4,
        'ZodOptional',
        () => uR,
        'ZodPipe',
        () => uV,
        'ZodPrefault',
        () => uC,
        'ZodPromise',
        () => uz,
        'ZodReadonly',
        () => uj,
        'ZodRecord',
        () => ua,
        'ZodSet',
        () => ud,
        'ZodString',
        () => aG,
        'ZodStringFormat',
        () => a$,
        'ZodSuccess',
        () => uU,
        'ZodSymbol',
        () => sV,
        'ZodTemplateLiteral',
        () => uZ,
        'ZodTransform',
        () => uh,
        'ZodTuple',
        () => ui,
        'ZodType',
        () => aw,
        'ZodULID',
        () => a6,
        'ZodURL',
        () => aX,
        'ZodUUID',
        () => aZ,
        'ZodUndefined',
        () => sB,
        'ZodUnion',
        () => s7,
        'ZodUnknown',
        () => sW,
        'ZodVoid',
        () => sJ,
        'ZodXID',
        () => a8,
        '_ZodString',
        () => ak,
        '_default',
        () => uv,
        '_function',
        () => uQ,
        'any',
        () => sY,
        'array',
        () => s2,
        'base64',
        () => sp,
        'base64url',
        () => sS,
        'bigint',
        () => sx,
        'boolean',
        () => sU,
        'catch',
        () => uw,
        'check',
        () => u0,
        'cidrv4',
        () => su,
        'cidrv6',
        () => sc,
        'codec',
        () => uH,
        'cuid',
        () => a4,
        'cuid2',
        () => a3,
        'custom',
        () => u1,
        'date',
        () => s0,
        'discriminatedUnion',
        () => ut,
        'e164',
        () => sT,
        'email',
        () => aH,
        'emoji',
        () => a0,
        'enum',
        () => uS,
        'file',
        () => uf,
        'float32',
        () => sv,
        'float64',
        () => sC,
        'function',
        () => uQ,
        'guid',
        () => aF,
        'hash',
        () => sy,
        'hex',
        () => sR,
        'hostname',
        () => sA,
        'httpUrl',
        () => aQ,
        'instanceof',
        () => u4,
        'int',
        () => sO,
        'int32',
        () => sP,
        'int64',
        () => sk,
        'intersection',
        () => ur,
        'ipv4',
        () => si,
        'ipv6',
        () => sa,
        'json',
        () => u3,
        'jwt',
        () => sg,
        'keyof',
        () => s5,
        'ksuid',
        () => sn,
        'lazy',
        () => uK,
        'literal',
        () => um,
        'looseObject',
        () => s6,
        'map',
        () => uc,
        'nan',
        () => uG,
        'nanoid',
        () => a2,
        'nativeEnum',
        () => uE,
        'never',
        () => sX,
        'nonoptional',
        () => uL,
        'null',
        () => sF,
        'nullable',
        () => ub,
        'nullish',
        () => uN,
        'number',
        () => sb,
        'object',
        () => s9,
        'optional',
        () => uy,
        'partialRecord',
        () => uu,
        'pipe',
        () => u$,
        'prefault',
        () => uP,
        'preprocess',
        () => u6,
        'promise',
        () => uX,
        'readonly',
        () => uF,
        'record',
        () => us,
        'refine',
        () => u2,
        'set',
        () => up,
        'strictObject',
        () => s3,
        'string',
        () => aV,
        'stringFormat',
        () => sh,
        'stringbool',
        () => u9,
        'success',
        () => uD,
        'superRefine',
        () => u5,
        'symbol',
        () => s$,
        'templateLiteral',
        () => uY,
        'transform',
        () => uA,
        'tuple',
        () => uo,
        'uint32',
        () => sM,
        'uint64',
        () => sG,
        'ulid',
        () => a7,
        'undefined',
        () => sH,
        'union',
        () => s8,
        'unknown',
        () => sK,
        'url',
        () => aJ,
        'uuid',
        () => aY,
        'uuidv4',
        () => aW,
        'uuidv6',
        () => aK,
        'uuidv7',
        () => az,
        'void',
        () => sQ,
        'xid',
        () => se,
      ],
      23691
    );
    var ad = rk,
      ap = rw;
    e.s(
      [
        'ZodISODate',
        () => aE,
        'ZodISODateTime',
        () => a_,
        'ZodISODuration',
        () => af,
        'ZodISOTime',
        () => am,
        'date',
        () => aT,
        'datetime',
        () => aS,
        'duration',
        () => ah,
        'time',
        () => ag,
      ],
      69722
    );
    let a_ = o('ZodISODateTime', (e, t) => {
      (nI.init(e, t), a$.init(e, t));
    });
    function aS(e) {
      return iX(a_, e);
    }
    let aE = o('ZodISODate', (e, t) => {
      (nb.init(e, t), a$.init(e, t));
    });
    function aT(e) {
      return iJ(aE, e);
    }
    let am = o('ZodISOTime', (e, t) => {
      (nN.init(e, t), a$.init(e, t));
    });
    function ag(e) {
      return iQ(am, e);
    }
    let af = o('ZodISODuration', (e, t) => {
      (nO.init(e, t), a$.init(e, t));
    });
    function ah(e) {
      return iq(af, e);
    }
    (e.s(
      [
        'decode',
        () => aC,
        'decodeAsync',
        () => aM,
        'encode',
        () => av,
        'encodeAsync',
        () => aP,
        'parse',
        () => aI,
        'parseAsync',
        () => ab,
        'safeDecode',
        () => aU,
        'safeDecodeAsync',
        () => ax,
        'safeEncode',
        () => aL,
        'safeEncodeAsync',
        () => aD,
        'safeParse',
        () => aN,
        'safeParseAsync',
        () => aO,
      ],
      26752
    ),
      e.s(['ZodError', () => aR, 'ZodRealError', () => ay], 56136));
    let aA = (e, t) => {
        (eh.init(e, t),
          (e.name = 'ZodError'),
          Object.defineProperties(e, {
            format: { value: (t) => ey(e, t) },
            flatten: { value: (t) => eR(e, t) },
            addIssue: {
              value: (t) => {
                (e.issues.push(t), (e.message = JSON.stringify(e.issues, g, 2)));
              },
            },
            addIssues: {
              value: (t) => {
                (e.issues.push(...t), (e.message = JSON.stringify(e.issues, g, 2)));
              },
            },
            isEmpty: { get: () => 0 === e.issues.length },
          }));
      },
      aR = o('ZodError', aA),
      ay = o('ZodError', aA, { Parent: Error }),
      aI = eO(ay),
      ab = eC(ay),
      aN = eM(ay),
      aO = eU(ay),
      av = ex(ay),
      aC = ek(ay),
      aP = eV(ay),
      aM = eB(ay),
      aL = ej(ay),
      aU = eZ(ay),
      aD = eW(ay),
      ax = ez(ay),
      aw = o(
        'ZodType',
        (e, t) => (
          nc.init(e, t),
          (e.def = t),
          (e.type = t.type),
          Object.defineProperty(e, '_def', { value: t }),
          (e.check = (...n) =>
            e.clone({
              ...t,
              checks: [
                ...(t.checks ?? []),
                ...n.map((e) =>
                  'function' == typeof e
                    ? { _zod: { check: e, def: { check: 'custom' }, onattach: [] } }
                    : e
                ),
              ],
            })),
          (e.clone = (t, n) => j(e, t, n)),
          (e.brand = () => e),
          (e.register = (t, n) => (t.add(e, n), e)),
          (e.parse = (t, n) => aI(e, t, n, { callee: e.parse })),
          (e.safeParse = (t, n) => aN(e, t, n)),
          (e.parseAsync = async (t, n) => ab(e, t, n, { callee: e.parseAsync })),
          (e.safeParseAsync = async (t, n) => aO(e, t, n)),
          (e.spa = e.safeParseAsync),
          (e.encode = (t, n) => av(e, t, n)),
          (e.decode = (t, n) => aC(e, t, n)),
          (e.encodeAsync = async (t, n) => aP(e, t, n)),
          (e.decodeAsync = async (t, n) => aM(e, t, n)),
          (e.safeEncode = (t, n) => aL(e, t, n)),
          (e.safeDecode = (t, n) => aU(e, t, n)),
          (e.safeEncodeAsync = async (t, n) => aD(e, t, n)),
          (e.safeDecodeAsync = async (t, n) => ax(e, t, n)),
          (e.refine = (t, n) => e.check(u2(t, n))),
          (e.superRefine = (t) => e.check(ar(t))),
          (e.overwrite = (t) => e.check(ow(t))),
          (e.optional = () => uy(e)),
          (e.nullable = () => ub(e)),
          (e.nullish = () => uy(ub(e))),
          (e.nonoptional = (t) => uL(e, t)),
          (e.array = () => s2(e)),
          (e.or = (t) => s8([e, t])),
          (e.and = (t) => ur(e, t)),
          (e.transform = (t) => u$(e, uA(t))),
          (e.default = (t) => uv(e, t)),
          (e.prefault = (t) => uP(e, t)),
          (e.catch = (t) => uw(e, t)),
          (e.pipe = (t) => u$(e, t)),
          (e.readonly = () => uF(e)),
          (e.describe = (t) => {
            let n = e.clone();
            return (iI.add(n, { description: t }), n);
          }),
          Object.defineProperty(e, 'description', {
            get: () => iI.get(e)?.description,
            configurable: !0,
          }),
          (e.meta = (...t) => {
            if (0 === t.length) return iI.get(e);
            let n = e.clone();
            return (iI.add(n, t[0]), n);
          }),
          (e.isOptional = () => e.safeParse(void 0).success),
          (e.isNullable = () => e.safeParse(null).success),
          e
        )
      ),
      ak = o('_ZodString', (e, t) => {
        (nd.init(e, t), aw.init(e, t));
        let n = e._zod.bag;
        ((e.format = n.format ?? null),
          (e.minLength = n.minimum ?? null),
          (e.maxLength = n.maximum ?? null),
          (e.regex = (...t) => e.check(ov(...t))),
          (e.includes = (...t) => e.check(oM(...t))),
          (e.startsWith = (...t) => e.check(oL(...t))),
          (e.endsWith = (...t) => e.check(oU(...t))),
          (e.min = (...t) => e.check(oN(...t))),
          (e.max = (...t) => e.check(ob(...t))),
          (e.length = (...t) => e.check(oO(...t))),
          (e.nonempty = (...t) => e.check(oN(1, ...t))),
          (e.lowercase = (t) => e.check(oC(t))),
          (e.uppercase = (t) => e.check(oP(t))),
          (e.trim = () => e.check(oG())),
          (e.normalize = (...t) => e.check(ok(...t))),
          (e.toLowerCase = () => e.check(oV())),
          (e.toUpperCase = () => e.check(o$())));
      }),
      aG = o('ZodString', (e, t) => {
        (nd.init(e, t),
          ak.init(e, t),
          (e.email = (t) => e.check(iO(aB, t))),
          (e.url = (t) => e.check(iU(aX, t))),
          (e.jwt = (t) => e.check(iK(sm, t))),
          (e.emoji = (t) => e.check(iD(aq, t))),
          (e.guid = (t) => e.check(iv(aj, t))),
          (e.uuid = (t) => e.check(iC(aZ, t))),
          (e.uuidv4 = (t) => e.check(iP(aZ, t))),
          (e.uuidv6 = (t) => e.check(iM(aZ, t))),
          (e.uuidv7 = (t) => e.check(iL(aZ, t))),
          (e.nanoid = (t) => e.check(ix(a1, t))),
          (e.guid = (t) => e.check(iv(aj, t))),
          (e.cuid = (t) => e.check(iw(a5, t))),
          (e.cuid2 = (t) => e.check(ik(a9, t))),
          (e.ulid = (t) => e.check(iG(a6, t))),
          (e.base64 = (t) => e.check(iZ(sd, t))),
          (e.base64url = (t) => e.check(iY(s_, t))),
          (e.xid = (t) => e.check(iV(a8, t))),
          (e.ksuid = (t) => e.check(i$(st, t))),
          (e.ipv4 = (t) => e.check(iB(sr, t))),
          (e.ipv6 = (t) => e.check(iH(so, t))),
          (e.cidrv4 = (t) => e.check(ij(ss, t))),
          (e.cidrv6 = (t) => e.check(iF(sl, t))),
          (e.e164 = (t) => e.check(iW(sE, t))),
          (e.datetime = (t) => e.check(aS(t))),
          (e.date = (t) => e.check(aT(t))),
          (e.time = (t) => e.check(ag(t))),
          (e.duration = (t) => e.check(ah(t))));
      });
    function aV(e) {
      return ib(aG, e);
    }
    let a$ = o('ZodStringFormat', (e, t) => {
        (np.init(e, t), ak.init(e, t));
      }),
      aB = o('ZodEmail', (e, t) => {
        (nE.init(e, t), a$.init(e, t));
      });
    function aH(e) {
      return iO(aB, e);
    }
    let aj = o('ZodGUID', (e, t) => {
      (n_.init(e, t), a$.init(e, t));
    });
    function aF(e) {
      return iv(aj, e);
    }
    let aZ = o('ZodUUID', (e, t) => {
      (nS.init(e, t), a$.init(e, t));
    });
    function aY(e) {
      return iC(aZ, e);
    }
    function aW(e) {
      return iP(aZ, e);
    }
    function aK(e) {
      return iM(aZ, e);
    }
    function az(e) {
      return iL(aZ, e);
    }
    let aX = o('ZodURL', (e, t) => {
      (nT.init(e, t), a$.init(e, t));
    });
    function aJ(e) {
      return iU(aX, e);
    }
    function aQ(e) {
      return iU(aX, { protocol: /^https?$/, hostname: ad.domain, ...ap.normalizeParams(e) });
    }
    let aq = o('ZodEmoji', (e, t) => {
      (nm.init(e, t), a$.init(e, t));
    });
    function a0(e) {
      return iD(aq, e);
    }
    let a1 = o('ZodNanoID', (e, t) => {
      (ng.init(e, t), a$.init(e, t));
    });
    function a2(e) {
      return ix(a1, e);
    }
    let a5 = o('ZodCUID', (e, t) => {
      (nf.init(e, t), a$.init(e, t));
    });
    function a4(e) {
      return iw(a5, e);
    }
    let a9 = o('ZodCUID2', (e, t) => {
      (nh.init(e, t), a$.init(e, t));
    });
    function a3(e) {
      return ik(a9, e);
    }
    let a6 = o('ZodULID', (e, t) => {
      (nA.init(e, t), a$.init(e, t));
    });
    function a7(e) {
      return iG(a6, e);
    }
    let a8 = o('ZodXID', (e, t) => {
      (nR.init(e, t), a$.init(e, t));
    });
    function se(e) {
      return iV(a8, e);
    }
    let st = o('ZodKSUID', (e, t) => {
      (ny.init(e, t), a$.init(e, t));
    });
    function sn(e) {
      return i$(st, e);
    }
    let sr = o('ZodIPv4', (e, t) => {
      (nv.init(e, t), a$.init(e, t));
    });
    function si(e) {
      return iB(sr, e);
    }
    let so = o('ZodIPv6', (e, t) => {
      (nC.init(e, t), a$.init(e, t));
    });
    function sa(e) {
      return iH(so, e);
    }
    let ss = o('ZodCIDRv4', (e, t) => {
      (nP.init(e, t), a$.init(e, t));
    });
    function su(e) {
      return ij(ss, e);
    }
    let sl = o('ZodCIDRv6', (e, t) => {
      (nM.init(e, t), a$.init(e, t));
    });
    function sc(e) {
      return iF(sl, e);
    }
    let sd = o('ZodBase64', (e, t) => {
      (nU.init(e, t), a$.init(e, t));
    });
    function sp(e) {
      return iZ(sd, e);
    }
    let s_ = o('ZodBase64URL', (e, t) => {
      (nx.init(e, t), a$.init(e, t));
    });
    function sS(e) {
      return iY(s_, e);
    }
    let sE = o('ZodE164', (e, t) => {
      (nw.init(e, t), a$.init(e, t));
    });
    function sT(e) {
      return iW(sE, e);
    }
    let sm = o('ZodJWT', (e, t) => {
      (nG.init(e, t), a$.init(e, t));
    });
    function sg(e) {
      return iK(sm, e);
    }
    let sf = o('ZodCustomStringFormat', (e, t) => {
      (nV.init(e, t), a$.init(e, t));
    });
    function sh(e, t, n = {}) {
      return aa(sf, e, t, n);
    }
    function sA(e) {
      return aa(sf, 'hostname', ad.hostname, e);
    }
    function sR(e) {
      return aa(sf, 'hex', ad.hex, e);
    }
    function sy(e, t) {
      let n = t?.enc ?? 'hex',
        r = `${e}_${n}`,
        i = ad[r];
      if (!i) throw Error(`Unrecognized hash format: ${r}`);
      return aa(sf, r, i, t);
    }
    let sI = o('ZodNumber', (e, t) => {
      (n$.init(e, t),
        aw.init(e, t),
        (e.gt = (t, n) => e.check(oE(t, n))),
        (e.gte = (t, n) => e.check(oT(t, n))),
        (e.min = (t, n) => e.check(oT(t, n))),
        (e.lt = (t, n) => e.check(o_(t, n))),
        (e.lte = (t, n) => e.check(oS(t, n))),
        (e.max = (t, n) => e.check(oS(t, n))),
        (e.int = (t) => e.check(sO(t))),
        (e.safe = (t) => e.check(sO(t))),
        (e.positive = (t) => e.check(oE(0, t))),
        (e.nonnegative = (t) => e.check(oT(0, t))),
        (e.negative = (t) => e.check(o_(0, t))),
        (e.nonpositive = (t) => e.check(oS(0, t))),
        (e.multipleOf = (t, n) => e.check(oA(t, n))),
        (e.step = (t, n) => e.check(oA(t, n))),
        (e.finite = () => e));
      let n = e._zod.bag;
      ((e.minValue = Math.max(n.minimum ?? -1 / 0, n.exclusiveMinimum ?? -1 / 0) ?? null),
        (e.maxValue = Math.min(n.maximum ?? 1 / 0, n.exclusiveMaximum ?? 1 / 0) ?? null),
        (e.isInt = (n.format ?? '').includes('int') || Number.isSafeInteger(n.multipleOf ?? 0.5)),
        (e.isFinite = !0),
        (e.format = n.format ?? null));
    });
    function sb(e) {
      return i0(sI, e);
    }
    let sN = o('ZodNumberFormat', (e, t) => {
      (nB.init(e, t), sI.init(e, t));
    });
    function sO(e) {
      return i2(sN, e);
    }
    function sv(e) {
      return i5(sN, e);
    }
    function sC(e) {
      return i4(sN, e);
    }
    function sP(e) {
      return i9(sN, e);
    }
    function sM(e) {
      return i3(sN, e);
    }
    let sL = o('ZodBoolean', (e, t) => {
      (nH.init(e, t), aw.init(e, t));
    });
    function sU(e) {
      return i6(sL, e);
    }
    let sD = o('ZodBigInt', (e, t) => {
      (nj.init(e, t),
        aw.init(e, t),
        (e.gte = (t, n) => e.check(oT(t, n))),
        (e.min = (t, n) => e.check(oT(t, n))),
        (e.gt = (t, n) => e.check(oE(t, n))),
        (e.gte = (t, n) => e.check(oT(t, n))),
        (e.min = (t, n) => e.check(oT(t, n))),
        (e.lt = (t, n) => e.check(o_(t, n))),
        (e.lte = (t, n) => e.check(oS(t, n))),
        (e.max = (t, n) => e.check(oS(t, n))),
        (e.positive = (t) => e.check(oE(BigInt(0), t))),
        (e.negative = (t) => e.check(o_(BigInt(0), t))),
        (e.nonpositive = (t) => e.check(oS(BigInt(0), t))),
        (e.nonnegative = (t) => e.check(oT(BigInt(0), t))),
        (e.multipleOf = (t, n) => e.check(oA(t, n))));
      let n = e._zod.bag;
      ((e.minValue = n.minimum ?? null),
        (e.maxValue = n.maximum ?? null),
        (e.format = n.format ?? null));
    });
    function sx(e) {
      return i8(sD, e);
    }
    let sw = o('ZodBigIntFormat', (e, t) => {
      (nF.init(e, t), sD.init(e, t));
    });
    function sk(e) {
      return ot(sw, e);
    }
    function sG(e) {
      return on(sw, e);
    }
    let sV = o('ZodSymbol', (e, t) => {
      (nZ.init(e, t), aw.init(e, t));
    });
    function s$(e) {
      return or(sV, e);
    }
    let sB = o('ZodUndefined', (e, t) => {
      (nY.init(e, t), aw.init(e, t));
    });
    function sH(e) {
      return oi(sB, e);
    }
    let sj = o('ZodNull', (e, t) => {
      (nW.init(e, t), aw.init(e, t));
    });
    function sF(e) {
      return oo(sj, e);
    }
    let sZ = o('ZodAny', (e, t) => {
      (nK.init(e, t), aw.init(e, t));
    });
    function sY() {
      return oa(sZ);
    }
    let sW = o('ZodUnknown', (e, t) => {
      (nz.init(e, t), aw.init(e, t));
    });
    function sK() {
      return os(sW);
    }
    let sz = o('ZodNever', (e, t) => {
      (nX.init(e, t), aw.init(e, t));
    });
    function sX(e) {
      return ou(sz, e);
    }
    let sJ = o('ZodVoid', (e, t) => {
      (nJ.init(e, t), aw.init(e, t));
    });
    function sQ(e) {
      return ol(sJ, e);
    }
    let sq = o('ZodDate', (e, t) => {
      (nQ.init(e, t),
        aw.init(e, t),
        (e.min = (t, n) => e.check(oT(t, n))),
        (e.max = (t, n) => e.check(oS(t, n))));
      let n = e._zod.bag;
      ((e.minDate = n.minimum ? new Date(n.minimum) : null),
        (e.maxDate = n.maximum ? new Date(n.maximum) : null));
    });
    function s0(e) {
      return oc(sq, e);
    }
    let s1 = o('ZodArray', (e, t) => {
      (n0.init(e, t),
        aw.init(e, t),
        (e.element = t.element),
        (e.min = (t, n) => e.check(oN(t, n))),
        (e.nonempty = (t) => e.check(oN(1, t))),
        (e.max = (t, n) => e.check(ob(t, n))),
        (e.length = (t, n) => e.check(oO(t, n))),
        (e.unwrap = () => e.element));
    });
    function s2(e, t) {
      return oB(s1, e, t);
    }
    function s5(e) {
      return uS(Object.keys(e._zod.def.shape));
    }
    let s4 = o('ZodObject', (e, t) => {
      (n9.init(e, t),
        aw.init(e, t),
        ap.defineLazy(e, 'shape', () => t.shape),
        (e.keyof = () => uS(Object.keys(e._zod.def.shape))),
        (e.catchall = (t) => e.clone({ ...e._zod.def, catchall: t })),
        (e.passthrough = () => e.clone({ ...e._zod.def, catchall: sK() })),
        (e.loose = () => e.clone({ ...e._zod.def, catchall: sK() })),
        (e.strict = () => e.clone({ ...e._zod.def, catchall: sX() })),
        (e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 })),
        (e.extend = (t) => ap.extend(e, t)),
        (e.safeExtend = (t) => ap.safeExtend(e, t)),
        (e.merge = (t) => ap.merge(e, t)),
        (e.pick = (t) => ap.pick(e, t)),
        (e.omit = (t) => ap.omit(e, t)),
        (e.partial = (...t) => ap.partial(uR, e, t[0])),
        (e.required = (...t) => ap.required(uM, e, t[0])));
    });
    function s9(e, t) {
      return new s4({
        type: 'object',
        get shape() {
          return (ap.assignProp(this, 'shape', e ? ap.objectClone(e) : {}), this.shape);
        },
        ...ap.normalizeParams(t),
      });
    }
    function s3(e, t) {
      return new s4({
        type: 'object',
        get shape() {
          return (ap.assignProp(this, 'shape', ap.objectClone(e)), this.shape);
        },
        catchall: sX(),
        ...ap.normalizeParams(t),
      });
    }
    function s6(e, t) {
      return new s4({
        type: 'object',
        get shape() {
          return (ap.assignProp(this, 'shape', ap.objectClone(e)), this.shape);
        },
        catchall: sK(),
        ...ap.normalizeParams(t),
      });
    }
    let s7 = o('ZodUnion', (e, t) => {
      (n6.init(e, t), aw.init(e, t), (e.options = t.options));
    });
    function s8(e, t) {
      return new s7({ type: 'union', options: e, ...ap.normalizeParams(t) });
    }
    let ue = o('ZodDiscriminatedUnion', (e, t) => {
      (s7.init(e, t), n7.init(e, t));
    });
    function ut(e, t, n) {
      return new ue({ type: 'union', options: t, discriminator: e, ...ap.normalizeParams(n) });
    }
    let un = o('ZodIntersection', (e, t) => {
      (n8.init(e, t), aw.init(e, t));
    });
    function ur(e, t) {
      return new un({ type: 'intersection', left: e, right: t });
    }
    let ui = o('ZodTuple', (e, t) => {
      (rt.init(e, t), aw.init(e, t), (e.rest = (t) => e.clone({ ...e._zod.def, rest: t })));
    });
    function uo(e, t, n) {
      let r = t instanceof nc,
        i = r ? n : t;
      return new ui({ type: 'tuple', items: e, rest: r ? t : null, ...ap.normalizeParams(i) });
    }
    let ua = o('ZodRecord', (e, t) => {
      (rr.init(e, t), aw.init(e, t), (e.keyType = t.keyType), (e.valueType = t.valueType));
    });
    function us(e, t, n) {
      return new ua({ type: 'record', keyType: e, valueType: t, ...ap.normalizeParams(n) });
    }
    function uu(e, t, n) {
      let r = j(e);
      return (
        (r._zod.values = void 0),
        new ua({ type: 'record', keyType: r, valueType: t, ...ap.normalizeParams(n) })
      );
    }
    let ul = o('ZodMap', (e, t) => {
      (ri.init(e, t), aw.init(e, t), (e.keyType = t.keyType), (e.valueType = t.valueType));
    });
    function uc(e, t, n) {
      return new ul({ type: 'map', keyType: e, valueType: t, ...ap.normalizeParams(n) });
    }
    let ud = o('ZodSet', (e, t) => {
      (ra.init(e, t),
        aw.init(e, t),
        (e.min = (...t) => e.check(oy(...t))),
        (e.nonempty = (t) => e.check(oy(1, t))),
        (e.max = (...t) => e.check(oR(...t))),
        (e.size = (...t) => e.check(oI(...t))));
    });
    function up(e, t) {
      return new ud({ type: 'set', valueType: e, ...ap.normalizeParams(t) });
    }
    let u_ = o('ZodEnum', (e, t) => {
      (ru.init(e, t), aw.init(e, t), (e.enum = t.entries), (e.options = Object.values(t.entries)));
      let n = new Set(Object.keys(t.entries));
      ((e.extract = (e, r) => {
        let i = {};
        for (let r of e)
          if (n.has(r)) i[r] = t.entries[r];
          else throw Error(`Key ${r} not found in enum`);
        return new u_({ ...t, checks: [], ...ap.normalizeParams(r), entries: i });
      }),
        (e.exclude = (e, r) => {
          let i = { ...t.entries };
          for (let t of e)
            if (n.has(t)) delete i[t];
            else throw Error(`Key ${t} not found in enum`);
          return new u_({ ...t, checks: [], ...ap.normalizeParams(r), entries: i });
        }));
    });
    function uS(e, t) {
      return new u_({
        type: 'enum',
        entries: Array.isArray(e) ? Object.fromEntries(e.map((e) => [e, e])) : e,
        ...ap.normalizeParams(t),
      });
    }
    function uE(e, t) {
      return new u_({ type: 'enum', entries: e, ...ap.normalizeParams(t) });
    }
    let uT = o('ZodLiteral', (e, t) => {
      (rl.init(e, t),
        aw.init(e, t),
        (e.values = new Set(t.values)),
        Object.defineProperty(e, 'value', {
          get() {
            if (t.values.length > 1)
              throw Error(
                'This schema contains multiple valid literal values. Use `.values` instead.'
              );
            return t.values[0];
          },
        }));
    });
    function um(e, t) {
      return new uT({
        type: 'literal',
        values: Array.isArray(e) ? e : [e],
        ...ap.normalizeParams(t),
      });
    }
    let ug = o('ZodFile', (e, t) => {
      (rc.init(e, t),
        aw.init(e, t),
        (e.min = (t, n) => e.check(oy(t, n))),
        (e.max = (t, n) => e.check(oR(t, n))),
        (e.mime = (t, n) => e.check(ox(Array.isArray(t) ? t : [t], n))));
    });
    function uf(e) {
      return oQ(ug, e);
    }
    let uh = o('ZodTransform', (e, t) => {
      (rd.init(e, t),
        aw.init(e, t),
        (e._zod.parse = (n, r) => {
          if ('backward' === r.direction) throw new u(e.constructor.name);
          n.addIssue = (r) => {
            'string' == typeof r
              ? n.issues.push(ap.issue(r, n.value, t))
              : (r.fatal && (r.continue = !1),
                r.code ?? (r.code = 'custom'),
                r.input ?? (r.input = n.value),
                r.inst ?? (r.inst = e),
                n.issues.push(ap.issue(r)));
          };
          let i = t.transform(n.value, n);
          return i instanceof Promise ? i.then((e) => ((n.value = e), n)) : ((n.value = i), n);
        }));
    });
    function uA(e) {
      return new uh({ type: 'transform', transform: e });
    }
    let uR = o('ZodOptional', (e, t) => {
      (r_.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uy(e) {
      return new uR({ type: 'optional', innerType: e });
    }
    let uI = o('ZodNullable', (e, t) => {
      (rS.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function ub(e) {
      return new uI({ type: 'nullable', innerType: e });
    }
    function uN(e) {
      return uy(ub(e));
    }
    let uO = o('ZodDefault', (e, t) => {
      (rE.init(e, t),
        aw.init(e, t),
        (e.unwrap = () => e._zod.def.innerType),
        (e.removeDefault = e.unwrap));
    });
    function uv(e, t) {
      return new uO({
        type: 'default',
        innerType: e,
        get defaultValue() {
          return 'function' == typeof t ? t() : ap.shallowClone(t);
        },
      });
    }
    let uC = o('ZodPrefault', (e, t) => {
      (rm.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uP(e, t) {
      return new uC({
        type: 'prefault',
        innerType: e,
        get defaultValue() {
          return 'function' == typeof t ? t() : ap.shallowClone(t);
        },
      });
    }
    let uM = o('ZodNonOptional', (e, t) => {
      (rg.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uL(e, t) {
      return new uM({ type: 'nonoptional', innerType: e, ...ap.normalizeParams(t) });
    }
    let uU = o('ZodSuccess', (e, t) => {
      (rh.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uD(e) {
      return new uU({ type: 'success', innerType: e });
    }
    let ux = o('ZodCatch', (e, t) => {
      (rA.init(e, t),
        aw.init(e, t),
        (e.unwrap = () => e._zod.def.innerType),
        (e.removeCatch = e.unwrap));
    });
    function uw(e, t) {
      return new ux({
        type: 'catch',
        innerType: e,
        catchValue: 'function' == typeof t ? t : () => t,
      });
    }
    let uk = o('ZodNaN', (e, t) => {
      (rR.init(e, t), aw.init(e, t));
    });
    function uG(e) {
      return op(uk, e);
    }
    let uV = o('ZodPipe', (e, t) => {
      (ry.init(e, t), aw.init(e, t), (e.in = t.in), (e.out = t.out));
    });
    function u$(e, t) {
      return new uV({ type: 'pipe', in: e, out: t });
    }
    let uB = o('ZodCodec', (e, t) => {
      (uV.init(e, t), rb.init(e, t));
    });
    function uH(e, t, n) {
      return new uB({
        type: 'pipe',
        in: e,
        out: t,
        transform: n.decode,
        reverseTransform: n.encode,
      });
    }
    let uj = o('ZodReadonly', (e, t) => {
      (rv.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uF(e) {
      return new uj({ type: 'readonly', innerType: e });
    }
    let uZ = o('ZodTemplateLiteral', (e, t) => {
      (rP.init(e, t), aw.init(e, t));
    });
    function uY(e, t) {
      return new uZ({ type: 'template_literal', parts: e, ...ap.normalizeParams(t) });
    }
    let uW = o('ZodLazy', (e, t) => {
      (rU.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.getter()));
    });
    function uK(e) {
      return new uW({ type: 'lazy', getter: e });
    }
    let uz = o('ZodPromise', (e, t) => {
      (rL.init(e, t), aw.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function uX(e) {
      return new uz({ type: 'promise', innerType: e });
    }
    let uJ = o('ZodFunction', (e, t) => {
      (rM.init(e, t), aw.init(e, t));
    });
    function uQ(e) {
      return new uJ({
        type: 'function',
        input: Array.isArray(e?.input) ? uo(e?.input) : (e?.input ?? s2(sK())),
        output: e?.output ?? sK(),
      });
    }
    let uq = o('ZodCustom', (e, t) => {
      (rD.init(e, t), aw.init(e, t));
    });
    function u0(e) {
      let t = new tK({ check: 'custom' });
      return ((t._zod.check = e), t);
    }
    function u1(e, t) {
      return at(uq, e ?? (() => !0), t);
    }
    function u2(e, t = {}) {
      return an(uq, e, t);
    }
    function u5(e) {
      return ar(e);
    }
    function u4(e, t = { error: `Input not instance of ${e.name}` }) {
      let n = new uq({
        type: 'custom',
        check: 'custom',
        fn: (t) => t instanceof e,
        abort: !0,
        ...ap.normalizeParams(t),
      });
      return ((n._zod.bag.Class = e), n);
    }
    let u9 = (...e) => ao({ Codec: uB, Boolean: sL, String: aG }, ...e);
    function u3(e) {
      let t = uK(() => s8([aV(e), sb(), sU(), sF(), s2(t), us(aV(), t)]));
      return t;
    }
    function u6(e, t) {
      return u$(uA(e), t);
    }
    (e.i(23691),
      e.s(
        [
          'endsWith',
          () => oU,
          'gt',
          () => oE,
          'gte',
          () => oT,
          'includes',
          () => oM,
          'length',
          () => oO,
          'lowercase',
          () => oC,
          'lt',
          () => o_,
          'lte',
          () => oS,
          'maxLength',
          () => ob,
          'maxSize',
          () => oR,
          'mime',
          () => ox,
          'minLength',
          () => oN,
          'minSize',
          () => oy,
          'multipleOf',
          () => oA,
          'negative',
          () => og,
          'nonnegative',
          () => oh,
          'nonpositive',
          () => of,
          'normalize',
          () => ok,
          'overwrite',
          () => ow,
          'positive',
          () => om,
          'property',
          () => oD,
          'regex',
          () => ov,
          'size',
          () => oI,
          'startsWith',
          () => oL,
          'toLowerCase',
          () => oV,
          'toUpperCase',
          () => o$,
          'trim',
          () => oG,
          'uppercase',
          () => oP,
        ],
        290
      ),
      e.s([], 36528),
      e.i(36528),
      e.i(290),
      e.i(56136),
      e.i(26752),
      e.s(
        [
          '$brand',
          () => a,
          'ZodFirstPartyTypeKind',
          () => t,
          'ZodIssueCode',
          () => u7,
          'config',
          () => c,
          'getErrorMap',
          () => le,
          'setErrorMap',
          () => u8,
        ],
        53776
      ),
      e.s(
        [
          'ZodFirstPartyTypeKind',
          () => t,
          'ZodIssueCode',
          () => u7,
          'getErrorMap',
          () => le,
          'setErrorMap',
          () => u8,
        ],
        40815
      ));
    let u7 = {
      invalid_type: 'invalid_type',
      too_big: 'too_big',
      too_small: 'too_small',
      invalid_format: 'invalid_format',
      not_multiple_of: 'not_multiple_of',
      unrecognized_keys: 'unrecognized_keys',
      invalid_union: 'invalid_union',
      invalid_key: 'invalid_key',
      invalid_element: 'invalid_element',
      invalid_value: 'invalid_value',
      custom: 'custom',
    };
    function u8(e) {
      c({ customError: e });
    }
    function le() {
      return c().customError;
    }
    (t || (t = {}), e.i(40815), e.i(53776));
    var ad = rk,
      ap = rw,
      lt = ig,
      ln = e.i(69722);
    function lr(e) {
      return iN(aG, e);
    }
    function li(e) {
      return i1(sI, e);
    }
    function lo(e) {
      return i7(sL, e);
    }
    function la(e) {
      return oe(sD, e);
    }
    function ls(e) {
      return od(sq, e);
    }
    e.s(
      [
        'bigint',
        () => la,
        'boolean',
        () => lo,
        'date',
        () => ls,
        'number',
        () => li,
        'string',
        () => lr,
      ],
      17934
    );
    var lu = e.i(17934),
      ll = e.i(4542),
      ll = ll;
    let lc = (function (e) {
      let t = 'object' == typeof e.client ? e.client : {},
        n = 'object' == typeof e.server ? e.server : {},
        i = e.shared,
        o = e.runtimeEnv ? e.runtimeEnv : { ...process.env, ...e.experimental__runtimeEnv };
      return (function (e) {
        let t = e.runtimeEnvStrict ?? e.runtimeEnv ?? process.env;
        if (e.emptyStringAsUndefined) for (let [e, n] of Object.entries(t)) '' === n && delete t[e];
        if (e.skipValidation) return t;
        let n = 'object' == typeof e.client ? e.client : {},
          i = 'object' == typeof e.server ? e.server : {},
          o = 'object' == typeof e.shared ? e.shared : {},
          a = e.isServer ?? !0,
          s = a ? { ...i, ...o, ...n } : { ...n, ...o },
          u =
            e.createFinalSchema?.(s, a)['~standard'].validate(t) ??
            (function (e, t) {
              let n = {},
                i = [];
              for (let o in e) {
                let a = e[o]['~standard'].validate(t[o]);
                if (
                  (r(a, `Validation must be synchronous, but ${o} returned a Promise.`), a.issues)
                ) {
                  i.push(
                    ...a.issues.map((e) => ({
                      ...e,
                      message: e.message,
                      path: [o, ...(e.path ?? [])],
                    }))
                  );
                  continue;
                }
                n[o] = a.value;
              }
              return i.length ? { issues: i } : { value: n };
            })(s, t);
        r(u, 'Validation must be synchronous');
        let l =
            e.onValidationError ??
            ((e) => {
              throw (
                console.error('❌ Invalid environment variables:', e),
                Error('Invalid environment variables')
              );
            }),
          c =
            e.onInvalidAccess ??
            (() => {
              throw Error(
                '❌ Attempted to access a server-side environment variable on the client'
              );
            });
        return u.issues
          ? l(u.issues)
          : new Proxy(
              Object.assign(
                (e.extends ?? []).reduce((e, t) => Object.assign(e, t), {}),
                u.value
              ),
              {
                get(t, n) {
                  if ('string' == typeof n && '__esModule' !== n && '$$typeof' !== n)
                    return a || (e.clientPrefix && (n.startsWith(e.clientPrefix) || n in o))
                      ? Reflect.get(t, n)
                      : c(n);
                },
              }
            );
      })({ ...e, shared: i, client: t, server: n, clientPrefix: 'NEXT_PUBLIC_', runtimeEnv: o });
    })({
      server: {
        NODE_ENV: ll.enum(['development', 'test', 'production']).default('development'),
        SENTRY_DSN: ll.string().url().optional(),
        SENTRY_ORG: ll.string().optional(),
        SENTRY_PROJECT: ll.string().optional(),
        DATABASE_URL: ll.string().url().optional(),
        SUPABASE_URL: ll.string().url().optional(),
        SUPABASE_ANON_KEY: ll.string().min(1).optional(),
        STRIPE_WEBHOOK_SECRET: ll.string().optional(),
      },
      client: {
        NEXT_PUBLIC_APP_NAME: ll.string().default('DL Starter'),
        NEXT_PUBLIC_POSTHOG_KEY: ll.string().optional(),
        NEXT_PUBLIC_SENTRY_DSN: ll.string().url().optional(),
      },
      runtimeEnv: {
        NODE_ENV: 'production',
        SENTRY_DSN: process.env.SENTRY_DSN,
        SENTRY_ORG: process.env.SENTRY_ORG,
        SENTRY_PROJECT: process.env.SENTRY_PROJECT,
        DATABASE_URL: process.env.DATABASE_URL,
        SUPABASE_URL: process.env.SUPABASE_URL,
        SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
        STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
        NEXT_PUBLIC_APP_NAME: process.env.NEXT_PUBLIC_APP_NAME,
        NEXT_PUBLIC_POSTHOG_KEY: process.env.NEXT_PUBLIC_POSTHOG_KEY,
        NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
      },
      emptyStringAsUndefined: !0,
    });
    (lc.SENTRY_DSN || lc.NEXT_PUBLIC_SENTRY_DSN) &&
      n.init({
        dsn: lc.SENTRY_DSN || lc.NEXT_PUBLIC_SENTRY_DSN,
        sendDefaultPii: !0,
        tracesSampleRate: 'production' === lc.NODE_ENV ? 0.1 : 1,
        beforeSend(e, t) {
          if ('development' === lc.NODE_ENV) {
            let e = t.originalException;
            if (
              e instanceof Error &&
              (e.message.includes('ENOTFOUND') || e.message.includes('connect ECONNREFUSED'))
            )
              return null;
          }
          return e;
        },
      });
  },
];

//# sourceMappingURL=_d7d34528._.js.map
