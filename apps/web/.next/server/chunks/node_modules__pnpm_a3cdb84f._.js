module.exports = [
  22522,
  (e, t, r) => {
    t.exports = e.r(61724);
  },
  67173,
  (e) => {
    'use strict';
    function t(e) {
      return Symbol.for(e);
    }
    (e.s(
      [
        'DiagConsoleLogger',
        () => eW,
        'DiagLogLevel',
        () => r,
        'INVALID_SPANID',
        () => ex,
        'INVALID_SPAN_CONTEXT',
        () => ew,
        'INVALID_TRACEID',
        () => e$,
        'ProxyTracer',
        () => eM,
        'ProxyTracerProvider',
        () => eF,
        'ROOT_CONTEXT',
        () => u,
        'SamplingDecision',
        () => a,
        'SpanKind',
        () => o,
        'SpanStatusCode',
        () => s,
        'TraceFlags',
        () => n,
        'ValueType',
        () => i,
        'baggageEntryMetadataFromString',
        () => ev,
        'context',
        () => T,
        'createContextKey',
        () => t,
        'createNoopMeter',
        () => Q,
        'createTraceState',
        () => e0,
        'default',
        () => eX,
        'defaultTextMapGetter',
        () => ei,
        'defaultTextMapSetter',
        () => ea,
        'diag',
        () => j,
        'isSpanContextValid',
        () => eU,
        'isValidSpanId',
        () => eD,
        'isValidTraceId',
        () => eA,
        'metrics',
        () => er,
        'propagation',
        () => ey,
        'trace',
        () => eV,
      ],
      67173
    ),
      e.s(['default', () => eX], 40787));
    var r,
      n,
      i,
      a,
      o,
      s,
      u = new (function e(t) {
        var r = this;
        ((r._currentContext = t ? new Map(t) : new Map()),
          (r.getValue = function (e) {
            return r._currentContext.get(e);
          }),
          (r.setValue = function (t, n) {
            var i = new e(r._currentContext);
            return (i._currentContext.set(t, n), i);
          }),
          (r.deleteValue = function (t) {
            var n = new e(r._currentContext);
            return (n._currentContext.delete(t), n);
          }));
      })(),
      l = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          a = r.call(e),
          o = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = a.next()).done; ) o.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return o;
      },
      c = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, a = t.length; i < a; i++)
            (!n && i in t) || (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      d = (function () {
        function e() {}
        return (
          (e.prototype.active = function () {
            return u;
          }),
          (e.prototype.with = function (e, t, r) {
            for (var n = [], i = 3; i < arguments.length; i++) n[i - 3] = arguments[i];
            return t.call.apply(t, c([r], l(n), !1));
          }),
          (e.prototype.bind = function (e, t) {
            return t;
          }),
          (e.prototype.enable = function () {
            return this;
          }),
          (e.prototype.disable = function () {
            return this;
          }),
          e
        );
      })(),
      f = 'object' == typeof globalThis ? globalThis : e.g,
      p = '1.9.0',
      m = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/,
      g = (function (e) {
        var t = new Set([e]),
          r = new Set(),
          n = e.match(m);
        if (!n)
          return function () {
            return !1;
          };
        var i = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
        if (null != i.prerelease)
          return function (t) {
            return t === e;
          };
        function a(e) {
          return (r.add(e), !1);
        }
        return function (e) {
          if (t.has(e)) return !0;
          if (r.has(e)) return !1;
          var n = e.match(m);
          if (!n) return a(e);
          var o = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
          if (null != o.prerelease || i.major !== o.major) return a(e);
          if (0 === i.major)
            return i.minor === o.minor && i.patch <= o.patch ? (t.add(e), !0) : a(e);
          return i.minor <= o.minor ? (t.add(e), !0) : a(e);
        };
      })(p),
      h = Symbol.for('opentelemetry.js.api.' + p.split('.')[0]);
    function v(e, t, r, n) {
      void 0 === n && (n = !1);
      var i,
        a = (f[h] = null != (i = f[h]) ? i : { version: p });
      if (!n && a[e]) {
        var o = Error('@opentelemetry/api: Attempted duplicate registration of API: ' + e);
        return (r.error(o.stack || o.message), !1);
      }
      if (a.version !== p) {
        var o = Error(
          '@opentelemetry/api: Registration of version v' +
            a.version +
            ' for ' +
            e +
            ' does not match previously registered API v' +
            p
        );
        return (r.error(o.stack || o.message), !1);
      }
      return (
        (a[e] = t),
        r.debug('@opentelemetry/api: Registered a global for ' + e + ' v' + p + '.'),
        !0
      );
    }
    function b(e) {
      var t,
        r,
        n = null == (t = f[h]) ? void 0 : t.version;
      if (n && g(n)) return null == (r = f[h]) ? void 0 : r[e];
    }
    function _(e, t) {
      t.debug('@opentelemetry/api: Unregistering a global for ' + e + ' v' + p + '.');
      var r = f[h];
      r && delete r[e];
    }
    var y = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          a = r.call(e),
          o = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = a.next()).done; ) o.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return o;
      },
      x = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, a = t.length; i < a; i++)
            (!n && i in t) || (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      $ = (function () {
        function e(e) {
          this._namespace = e.namespace || 'DiagComponentLogger';
        }
        return (
          (e.prototype.debug = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return w('debug', this._namespace, e);
          }),
          (e.prototype.error = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return w('error', this._namespace, e);
          }),
          (e.prototype.info = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return w('info', this._namespace, e);
          }),
          (e.prototype.warn = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return w('warn', this._namespace, e);
          }),
          (e.prototype.verbose = function () {
            for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
            return w('verbose', this._namespace, e);
          }),
          e
        );
      })();
    function w(e, t, r) {
      var n = b('diag');
      if (n) return (r.unshift(t), n[e].apply(n, x([], y(r), !1)));
    }
    !(function (e) {
      ((e[(e.NONE = 0)] = 'NONE'),
        (e[(e.ERROR = 30)] = 'ERROR'),
        (e[(e.WARN = 50)] = 'WARN'),
        (e[(e.INFO = 60)] = 'INFO'),
        (e[(e.DEBUG = 70)] = 'DEBUG'),
        (e[(e.VERBOSE = 80)] = 'VERBOSE'),
        (e[(e.ALL = 9999)] = 'ALL'));
    })(r || (r = {}));
    var S = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          a = r.call(e),
          o = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = a.next()).done; ) o.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return o;
      },
      O = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, a = t.length; i < a; i++)
            (!n && i in t) || (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      E = (function () {
        function e() {
          function e(e) {
            return function () {
              for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
              var n = b('diag');
              if (n) return n[e].apply(n, O([], S(t), !1));
            };
          }
          var t = this;
          ((t.setLogger = function (e, n) {
            if ((void 0 === n && (n = { logLevel: r.INFO }), e === t)) {
              var i,
                a,
                o,
                s = Error(
                  'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                );
              return (t.error(null != (i = s.stack) ? i : s.message), !1);
            }
            'number' == typeof n && (n = { logLevel: n });
            var u = b('diag'),
              l = (function (e, t) {
                function n(r, n) {
                  var i = t[r];
                  return 'function' == typeof i && e >= n ? i.bind(t) : function () {};
                }
                return (
                  e < r.NONE ? (e = r.NONE) : e > r.ALL && (e = r.ALL),
                  (t = t || {}),
                  {
                    error: n('error', r.ERROR),
                    warn: n('warn', r.WARN),
                    info: n('info', r.INFO),
                    debug: n('debug', r.DEBUG),
                    verbose: n('verbose', r.VERBOSE),
                  }
                );
              })(null != (a = n.logLevel) ? a : r.INFO, e);
            if (u && !n.suppressOverrideMessage) {
              var c = null != (o = Error().stack) ? o : '<failed to generate stacktrace>';
              (u.warn('Current logger will be overwritten from ' + c),
                l.warn('Current logger will overwrite one already registered from ' + c));
            }
            return v('diag', l, t, !0);
          }),
            (t.disable = function () {
              _('diag', t);
            }),
            (t.createComponentLogger = function (e) {
              return new $(e);
            }),
            (t.verbose = e('verbose')),
            (t.debug = e('debug')),
            (t.info = e('info')),
            (t.warn = e('warn')),
            (t.error = e('error')));
        }
        return (
          (e.instance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          e
        );
      })(),
      k = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          a = r.call(e),
          o = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = a.next()).done; ) o.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return o;
      },
      I = function (e, t, r) {
        if (r || 2 == arguments.length)
          for (var n, i = 0, a = t.length; i < a; i++)
            (!n && i in t) || (n || (n = Array.prototype.slice.call(t, 0, i)), (n[i] = t[i]));
        return e.concat(n || Array.prototype.slice.call(t));
      },
      P = 'context',
      N = new d(),
      R = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalContextManager = function (e) {
            return v(P, e, E.instance());
          }),
          (e.prototype.active = function () {
            return this._getContextManager().active();
          }),
          (e.prototype.with = function (e, t, r) {
            for (var n, i = [], a = 3; a < arguments.length; a++) i[a - 3] = arguments[a];
            return (n = this._getContextManager()).with.apply(n, I([e, t, r], k(i), !1));
          }),
          (e.prototype.bind = function (e, t) {
            return this._getContextManager().bind(e, t);
          }),
          (e.prototype._getContextManager = function () {
            return b(P) || N;
          }),
          (e.prototype.disable = function () {
            (this._getContextManager().disable(), _(P, E.instance()));
          }),
          e
        );
      })(),
      T = R.getInstance(),
      j = E.instance(),
      A = (function () {
        var e = function (t, r) {
          return (e =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (e, t) {
                e.__proto__ = t;
              }) ||
            function (e, t) {
              for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
            })(t, r);
        };
        return function (t, r) {
          if ('function' != typeof r && null !== r)
            throw TypeError('Class extends value ' + String(r) + ' is not a constructor or null');
          function n() {
            this.constructor = t;
          }
          (e(t, r),
            (t.prototype = null === r ? Object.create(r) : ((n.prototype = r.prototype), new n())));
        };
      })(),
      D = (function () {
        function e() {}
        return (
          (e.prototype.createGauge = function (e, t) {
            return q;
          }),
          (e.prototype.createHistogram = function (e, t) {
            return W;
          }),
          (e.prototype.createCounter = function (e, t) {
            return X;
          }),
          (e.prototype.createUpDownCounter = function (e, t) {
            return H;
          }),
          (e.prototype.createObservableGauge = function (e, t) {
            return K;
          }),
          (e.prototype.createObservableCounter = function (e, t) {
            return J;
          }),
          (e.prototype.createObservableUpDownCounter = function (e, t) {
            return Y;
          }),
          (e.prototype.addBatchObservableCallback = function (e, t) {}),
          (e.prototype.removeBatchObservableCallback = function (e) {}),
          e
        );
      })(),
      U = function () {},
      z = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), (t.prototype.add = function (e, t) {}), t);
      })(U),
      C = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), (t.prototype.add = function (e, t) {}), t);
      })(U),
      Z = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), (t.prototype.record = function (e, t) {}), t);
      })(U),
      L = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), (t.prototype.record = function (e, t) {}), t);
      })(U),
      M = (function () {
        function e() {}
        return (
          (e.prototype.addCallback = function (e) {}),
          (e.prototype.removeCallback = function (e) {}),
          e
        );
      })(),
      B = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), t);
      })(M),
      F = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), t);
      })(M),
      G = (function (e) {
        function t() {
          return (null !== e && e.apply(this, arguments)) || this;
        }
        return (A(t, e), t);
      })(M),
      V = new D(),
      X = new z(),
      q = new Z(),
      W = new L(),
      H = new C(),
      J = new B(),
      K = new F(),
      Y = new G();
    function Q() {
      return V;
    }
    var ee = new ((function () {
        function e() {}
        return (
          (e.prototype.getMeter = function (e, t, r) {
            return V;
          }),
          e
        );
      })())(),
      et = 'metrics',
      er = (function () {
        function e() {}
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalMeterProvider = function (e) {
            return v(et, e, E.instance());
          }),
          (e.prototype.getMeterProvider = function () {
            return b(et) || ee;
          }),
          (e.prototype.getMeter = function (e, t, r) {
            return this.getMeterProvider().getMeter(e, t, r);
          }),
          (e.prototype.disable = function () {
            _(et, E.instance());
          }),
          e
        );
      })().getInstance(),
      en = (function () {
        function e() {}
        return (
          (e.prototype.inject = function (e, t) {}),
          (e.prototype.extract = function (e, t) {
            return e;
          }),
          (e.prototype.fields = function () {
            return [];
          }),
          e
        );
      })(),
      ei = {
        get: function (e, t) {
          if (null != e) return e[t];
        },
        keys: function (e) {
          return null == e ? [] : Object.keys(e);
        },
      },
      ea = {
        set: function (e, t, r) {
          null != e && (e[t] = r);
        },
      },
      eo = t('OpenTelemetry Baggage Key');
    function es(e) {
      return e.getValue(eo) || void 0;
    }
    function eu() {
      return es(R.getInstance().active());
    }
    function el(e, t) {
      return e.setValue(eo, t);
    }
    function ec(e) {
      return e.deleteValue(eo);
    }
    var ed = function (e, t) {
        var r = 'function' == typeof Symbol && e[Symbol.iterator];
        if (!r) return e;
        var n,
          i,
          a = r.call(e),
          o = [];
        try {
          for (; (void 0 === t || t-- > 0) && !(n = a.next()).done; ) o.push(n.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            n && !n.done && (r = a.return) && r.call(a);
          } finally {
            if (i) throw i.error;
          }
        }
        return o;
      },
      ef = function (e) {
        var t = 'function' == typeof Symbol && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && 'number' == typeof e.length)
          return {
            next: function () {
              return (e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e });
            },
          };
        throw TypeError(t ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
      },
      ep = (function () {
        function e(e) {
          this._entries = e ? new Map(e) : new Map();
        }
        return (
          (e.prototype.getEntry = function (e) {
            var t = this._entries.get(e);
            if (t) return Object.assign({}, t);
          }),
          (e.prototype.getAllEntries = function () {
            return Array.from(this._entries.entries()).map(function (e) {
              var t = ed(e, 2);
              return [t[0], t[1]];
            });
          }),
          (e.prototype.setEntry = function (t, r) {
            var n = new e(this._entries);
            return (n._entries.set(t, r), n);
          }),
          (e.prototype.removeEntry = function (t) {
            var r = new e(this._entries);
            return (r._entries.delete(t), r);
          }),
          (e.prototype.removeEntries = function () {
            for (var t, r, n = [], i = 0; i < arguments.length; i++) n[i] = arguments[i];
            var a = new e(this._entries);
            try {
              for (var o = ef(n), s = o.next(); !s.done; s = o.next()) {
                var u = s.value;
                a._entries.delete(u);
              }
            } catch (e) {
              t = { error: e };
            } finally {
              try {
                s && !s.done && (r = o.return) && r.call(o);
              } finally {
                if (t) throw t.error;
              }
            }
            return a;
          }),
          (e.prototype.clear = function () {
            return new e();
          }),
          e
        );
      })(),
      em = Symbol('BaggageEntryMetadata'),
      eg = E.instance();
    function eh(e) {
      return (void 0 === e && (e = {}), new ep(new Map(Object.entries(e))));
    }
    function ev(e) {
      return (
        'string' != typeof e &&
          (eg.error('Cannot create baggage metadata from unknown type: ' + typeof e), (e = '')),
        {
          __TYPE__: em,
          toString: function () {
            return e;
          },
        }
      );
    }
    var eb = 'propagation',
      e_ = new en(),
      ey = (function () {
        function e() {
          ((this.createBaggage = eh),
            (this.getBaggage = es),
            (this.getActiveBaggage = eu),
            (this.setBaggage = el),
            (this.deleteBaggage = ec));
        }
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalPropagator = function (e) {
            return v(eb, e, E.instance());
          }),
          (e.prototype.inject = function (e, t, r) {
            return (void 0 === r && (r = ea), this._getGlobalPropagator().inject(e, t, r));
          }),
          (e.prototype.extract = function (e, t, r) {
            return (void 0 === r && (r = ei), this._getGlobalPropagator().extract(e, t, r));
          }),
          (e.prototype.fields = function () {
            return this._getGlobalPropagator().fields();
          }),
          (e.prototype.disable = function () {
            _(eb, E.instance());
          }),
          (e.prototype._getGlobalPropagator = function () {
            return b(eb) || e_;
          }),
          e
        );
      })().getInstance();
    !(function (e) {
      ((e[(e.NONE = 0)] = 'NONE'), (e[(e.SAMPLED = 1)] = 'SAMPLED'));
    })(n || (n = {}));
    var ex = '0000000000000000',
      e$ = '00000000000000000000000000000000',
      ew = { traceId: e$, spanId: ex, traceFlags: n.NONE },
      eS = (function () {
        function e(e) {
          (void 0 === e && (e = ew), (this._spanContext = e));
        }
        return (
          (e.prototype.spanContext = function () {
            return this._spanContext;
          }),
          (e.prototype.setAttribute = function (e, t) {
            return this;
          }),
          (e.prototype.setAttributes = function (e) {
            return this;
          }),
          (e.prototype.addEvent = function (e, t) {
            return this;
          }),
          (e.prototype.addLink = function (e) {
            return this;
          }),
          (e.prototype.addLinks = function (e) {
            return this;
          }),
          (e.prototype.setStatus = function (e) {
            return this;
          }),
          (e.prototype.updateName = function (e) {
            return this;
          }),
          (e.prototype.end = function (e) {}),
          (e.prototype.isRecording = function () {
            return !1;
          }),
          (e.prototype.recordException = function (e, t) {}),
          e
        );
      })(),
      eO = t('OpenTelemetry Context Key SPAN');
    function eE(e) {
      return e.getValue(eO) || void 0;
    }
    function ek() {
      return eE(R.getInstance().active());
    }
    function eI(e, t) {
      return e.setValue(eO, t);
    }
    function eP(e) {
      return e.deleteValue(eO);
    }
    function eN(e, t) {
      return eI(e, new eS(t));
    }
    function eR(e) {
      var t;
      return null == (t = eE(e)) ? void 0 : t.spanContext();
    }
    var eT = /^([0-9a-f]{32})$/i,
      ej = /^[0-9a-f]{16}$/i;
    function eA(e) {
      return eT.test(e) && e !== e$;
    }
    function eD(e) {
      return ej.test(e) && e !== ex;
    }
    function eU(e) {
      return eA(e.traceId) && eD(e.spanId);
    }
    function ez(e) {
      return new eS(e);
    }
    var eC = R.getInstance(),
      eZ = (function () {
        function e() {}
        return (
          (e.prototype.startSpan = function (e, t, r) {
            if ((void 0 === r && (r = eC.active()), null == t ? void 0 : t.root)) return new eS();
            var n,
              i = r && eR(r);
            return 'object' == typeof (n = i) &&
              'string' == typeof n.spanId &&
              'string' == typeof n.traceId &&
              'number' == typeof n.traceFlags &&
              eU(i)
              ? new eS(i)
              : new eS();
          }),
          (e.prototype.startActiveSpan = function (e, t, r, n) {
            if (!(arguments.length < 2)) {
              2 == arguments.length
                ? (o = t)
                : 3 == arguments.length
                  ? ((i = t), (o = r))
                  : ((i = t), (a = r), (o = n));
              var i,
                a,
                o,
                s = null != a ? a : eC.active(),
                u = this.startSpan(e, i, s),
                l = eI(s, u);
              return eC.with(l, o, void 0, u);
            }
          }),
          e
        );
      })(),
      eL = new eZ(),
      eM = (function () {
        function e(e, t, r, n) {
          ((this._provider = e), (this.name = t), (this.version = r), (this.options = n));
        }
        return (
          (e.prototype.startSpan = function (e, t, r) {
            return this._getTracer().startSpan(e, t, r);
          }),
          (e.prototype.startActiveSpan = function (e, t, r, n) {
            var i = this._getTracer();
            return Reflect.apply(i.startActiveSpan, i, arguments);
          }),
          (e.prototype._getTracer = function () {
            if (this._delegate) return this._delegate;
            var e = this._provider.getDelegateTracer(this.name, this.version, this.options);
            return e ? ((this._delegate = e), this._delegate) : eL;
          }),
          e
        );
      })(),
      eB = new ((function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, r) {
            return new eZ();
          }),
          e
        );
      })())(),
      eF = (function () {
        function e() {}
        return (
          (e.prototype.getTracer = function (e, t, r) {
            var n;
            return null != (n = this.getDelegateTracer(e, t, r)) ? n : new eM(this, e, t, r);
          }),
          (e.prototype.getDelegate = function () {
            var e;
            return null != (e = this._delegate) ? e : eB;
          }),
          (e.prototype.setDelegate = function (e) {
            this._delegate = e;
          }),
          (e.prototype.getDelegateTracer = function (e, t, r) {
            var n;
            return null == (n = this._delegate) ? void 0 : n.getTracer(e, t, r);
          }),
          e
        );
      })(),
      eG = 'trace',
      eV = (function () {
        function e() {
          ((this._proxyTracerProvider = new eF()),
            (this.wrapSpanContext = ez),
            (this.isSpanContextValid = eU),
            (this.deleteSpan = eP),
            (this.getSpan = eE),
            (this.getActiveSpan = ek),
            (this.getSpanContext = eR),
            (this.setSpan = eI),
            (this.setSpanContext = eN));
        }
        return (
          (e.getInstance = function () {
            return (this._instance || (this._instance = new e()), this._instance);
          }),
          (e.prototype.setGlobalTracerProvider = function (e) {
            var t = v(eG, this._proxyTracerProvider, E.instance());
            return (t && this._proxyTracerProvider.setDelegate(e), t);
          }),
          (e.prototype.getTracerProvider = function () {
            return b(eG) || this._proxyTracerProvider;
          }),
          (e.prototype.getTracer = function (e, t) {
            return this.getTracerProvider().getTracer(e, t);
          }),
          (e.prototype.disable = function () {
            (_(eG, E.instance()), (this._proxyTracerProvider = new eF()));
          }),
          e
        );
      })().getInstance();
    let eX = { context: T, diag: j, metrics: er, propagation: ey, trace: eV };
    e.i(40787);
    var eq = [
        { n: 'error', c: 'error' },
        { n: 'warn', c: 'warn' },
        { n: 'info', c: 'info' },
        { n: 'debug', c: 'debug' },
        { n: 'verbose', c: 'trace' },
      ],
      eW = function () {
        for (var e = 0; e < eq.length; e++)
          this[eq[e].n] = (function (e) {
            return function () {
              for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
              if (console) {
                var n = console[e];
                if (('function' != typeof n && (n = console.log), 'function' == typeof n))
                  return n.apply(console, t);
              }
            };
          })(eq[e].c);
      };
    (!(function (e) {
      ((e[(e.INT = 0)] = 'INT'), (e[(e.DOUBLE = 1)] = 'DOUBLE'));
    })(i || (i = {})),
      (function (e) {
        ((e[(e.NOT_RECORD = 0)] = 'NOT_RECORD'),
          (e[(e.RECORD = 1)] = 'RECORD'),
          (e[(e.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'));
      })(a || (a = {})),
      (function (e) {
        ((e[(e.INTERNAL = 0)] = 'INTERNAL'),
          (e[(e.SERVER = 1)] = 'SERVER'),
          (e[(e.CLIENT = 2)] = 'CLIENT'),
          (e[(e.PRODUCER = 3)] = 'PRODUCER'),
          (e[(e.CONSUMER = 4)] = 'CONSUMER'));
      })(o || (o = {})),
      (function (e) {
        ((e[(e.UNSET = 0)] = 'UNSET'), (e[(e.OK = 1)] = 'OK'), (e[(e.ERROR = 2)] = 'ERROR'));
      })(s || (s = {})));
    var eH = '[_0-9a-z-*/]',
      eJ = RegExp(
        '^(?:[a-z]' + eH + '{0,255}|' + ('[a-z0-9]' + eH + '{0,240}@[a-z]') + eH + '{0,13})$'
      ),
      eK = /^[ -~]{0,255}[!-~]$/,
      eY = /,|=/,
      eQ = (function () {
        function e(e) {
          ((this._internalState = new Map()), e && this._parse(e));
        }
        return (
          (e.prototype.set = function (e, t) {
            var r = this._clone();
            return (
              r._internalState.has(e) && r._internalState.delete(e),
              r._internalState.set(e, t),
              r
            );
          }),
          (e.prototype.unset = function (e) {
            var t = this._clone();
            return (t._internalState.delete(e), t);
          }),
          (e.prototype.get = function (e) {
            return this._internalState.get(e);
          }),
          (e.prototype.serialize = function () {
            var e = this;
            return this._keys()
              .reduce(function (t, r) {
                return (t.push(r + '=' + e.get(r)), t);
              }, [])
              .join(',');
          }),
          (e.prototype._parse = function (e) {
            !(e.length > 512) &&
              ((this._internalState = e
                .split(',')
                .reverse()
                .reduce(function (e, t) {
                  var r = t.trim(),
                    n = r.indexOf('=');
                  if (-1 !== n) {
                    var i = r.slice(0, n),
                      a = r.slice(n + 1, t.length);
                    eJ.test(i) && eK.test(a) && !eY.test(a) && e.set(i, a);
                  }
                  return e;
                }, new Map())),
              this._internalState.size > 32 &&
                (this._internalState = new Map(
                  Array.from(this._internalState.entries()).reverse().slice(0, 32)
                )));
          }),
          (e.prototype._keys = function () {
            return Array.from(this._internalState.keys()).reverse();
          }),
          (e.prototype._clone = function () {
            var t = new e();
            return ((t._internalState = new Map(this._internalState)), t);
          }),
          e
        );
      })();
    function e0(e) {
      return new eQ(e);
    }
  },
  24773,
  (e, t, r) => {
    (() => {
      'use strict';
      var r = {
          491: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.ContextAPI = void 0));
            let n = r(223),
              i = r(172),
              a = r(930),
              o = 'context',
              s = new n.NoopContextManager();
            class u {
              constructor() {}
              static getInstance() {
                return (this._instance || (this._instance = new u()), this._instance);
              }
              setGlobalContextManager(e) {
                return (0, i.registerGlobal)(o, e, a.DiagAPI.instance());
              }
              active() {
                return this._getContextManager().active();
              }
              with(e, t, r, ...n) {
                return this._getContextManager().with(e, t, r, ...n);
              }
              bind(e, t) {
                return this._getContextManager().bind(e, t);
              }
              _getContextManager() {
                return (0, i.getGlobal)(o) || s;
              }
              disable() {
                (this._getContextManager().disable(),
                  (0, i.unregisterGlobal)(o, a.DiagAPI.instance()));
              }
            }
            t.ContextAPI = u;
          },
          930: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.DiagAPI = void 0));
            let n = r(56),
              i = r(912),
              a = r(957),
              o = r(172);
            class s {
              constructor() {
                function e(e) {
                  return function (...t) {
                    let r = (0, o.getGlobal)('diag');
                    if (r) return r[e](...t);
                  };
                }
                let t = this;
                ((t.setLogger = (e, r = { logLevel: a.DiagLogLevel.INFO }) => {
                  var n, s, u;
                  if (e === t) {
                    let e = Error(
                      'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'
                    );
                    return (t.error(null != (n = e.stack) ? n : e.message), !1);
                  }
                  'number' == typeof r && (r = { logLevel: r });
                  let l = (0, o.getGlobal)('diag'),
                    c = (0, i.createLogLevelDiagLogger)(
                      null != (s = r.logLevel) ? s : a.DiagLogLevel.INFO,
                      e
                    );
                  if (l && !r.suppressOverrideMessage) {
                    let e = null != (u = Error().stack) ? u : '<failed to generate stacktrace>';
                    (l.warn(`Current logger will be overwritten from ${e}`),
                      c.warn(`Current logger will overwrite one already registered from ${e}`));
                  }
                  return (0, o.registerGlobal)('diag', c, t, !0);
                }),
                  (t.disable = () => {
                    (0, o.unregisterGlobal)('diag', t);
                  }),
                  (t.createComponentLogger = (e) => new n.DiagComponentLogger(e)),
                  (t.verbose = e('verbose')),
                  (t.debug = e('debug')),
                  (t.info = e('info')),
                  (t.warn = e('warn')),
                  (t.error = e('error')));
              }
              static instance() {
                return (this._instance || (this._instance = new s()), this._instance);
              }
            }
            t.DiagAPI = s;
          },
          653: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.MetricsAPI = void 0));
            let n = r(660),
              i = r(172),
              a = r(930),
              o = 'metrics';
            class s {
              constructor() {}
              static getInstance() {
                return (this._instance || (this._instance = new s()), this._instance);
              }
              setGlobalMeterProvider(e) {
                return (0, i.registerGlobal)(o, e, a.DiagAPI.instance());
              }
              getMeterProvider() {
                return (0, i.getGlobal)(o) || n.NOOP_METER_PROVIDER;
              }
              getMeter(e, t, r) {
                return this.getMeterProvider().getMeter(e, t, r);
              }
              disable() {
                (0, i.unregisterGlobal)(o, a.DiagAPI.instance());
              }
            }
            t.MetricsAPI = s;
          },
          181: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.PropagationAPI = void 0));
            let n = r(172),
              i = r(874),
              a = r(194),
              o = r(277),
              s = r(369),
              u = r(930),
              l = 'propagation',
              c = new i.NoopTextMapPropagator();
            class d {
              constructor() {
                ((this.createBaggage = s.createBaggage),
                  (this.getBaggage = o.getBaggage),
                  (this.getActiveBaggage = o.getActiveBaggage),
                  (this.setBaggage = o.setBaggage),
                  (this.deleteBaggage = o.deleteBaggage));
              }
              static getInstance() {
                return (this._instance || (this._instance = new d()), this._instance);
              }
              setGlobalPropagator(e) {
                return (0, n.registerGlobal)(l, e, u.DiagAPI.instance());
              }
              inject(e, t, r = a.defaultTextMapSetter) {
                return this._getGlobalPropagator().inject(e, t, r);
              }
              extract(e, t, r = a.defaultTextMapGetter) {
                return this._getGlobalPropagator().extract(e, t, r);
              }
              fields() {
                return this._getGlobalPropagator().fields();
              }
              disable() {
                (0, n.unregisterGlobal)(l, u.DiagAPI.instance());
              }
              _getGlobalPropagator() {
                return (0, n.getGlobal)(l) || c;
              }
            }
            t.PropagationAPI = d;
          },
          997: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.TraceAPI = void 0));
            let n = r(172),
              i = r(846),
              a = r(139),
              o = r(607),
              s = r(930),
              u = 'trace';
            class l {
              constructor() {
                ((this._proxyTracerProvider = new i.ProxyTracerProvider()),
                  (this.wrapSpanContext = a.wrapSpanContext),
                  (this.isSpanContextValid = a.isSpanContextValid),
                  (this.deleteSpan = o.deleteSpan),
                  (this.getSpan = o.getSpan),
                  (this.getActiveSpan = o.getActiveSpan),
                  (this.getSpanContext = o.getSpanContext),
                  (this.setSpan = o.setSpan),
                  (this.setSpanContext = o.setSpanContext));
              }
              static getInstance() {
                return (this._instance || (this._instance = new l()), this._instance);
              }
              setGlobalTracerProvider(e) {
                let t = (0, n.registerGlobal)(u, this._proxyTracerProvider, s.DiagAPI.instance());
                return (t && this._proxyTracerProvider.setDelegate(e), t);
              }
              getTracerProvider() {
                return (0, n.getGlobal)(u) || this._proxyTracerProvider;
              }
              getTracer(e, t) {
                return this.getTracerProvider().getTracer(e, t);
              }
              disable() {
                ((0, n.unregisterGlobal)(u, s.DiagAPI.instance()),
                  (this._proxyTracerProvider = new i.ProxyTracerProvider()));
              }
            }
            t.TraceAPI = l;
          },
          277: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.deleteBaggage = t.setBaggage = t.getActiveBaggage = t.getBaggage = void 0));
            let n = r(491),
              i = (0, r(780).createContextKey)('OpenTelemetry Baggage Key');
            function a(e) {
              return e.getValue(i) || void 0;
            }
            ((t.getBaggage = a),
              (t.getActiveBaggage = function () {
                return a(n.ContextAPI.getInstance().active());
              }),
              (t.setBaggage = function (e, t) {
                return e.setValue(i, t);
              }),
              (t.deleteBaggage = function (e) {
                return e.deleteValue(i);
              }));
          },
          993: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.BaggageImpl = void 0));
            class r {
              constructor(e) {
                this._entries = e ? new Map(e) : new Map();
              }
              getEntry(e) {
                let t = this._entries.get(e);
                if (t) return Object.assign({}, t);
              }
              getAllEntries() {
                return Array.from(this._entries.entries()).map(([e, t]) => [e, t]);
              }
              setEntry(e, t) {
                let n = new r(this._entries);
                return (n._entries.set(e, t), n);
              }
              removeEntry(e) {
                let t = new r(this._entries);
                return (t._entries.delete(e), t);
              }
              removeEntries(...e) {
                let t = new r(this._entries);
                for (let r of e) t._entries.delete(r);
                return t;
              }
              clear() {
                return new r();
              }
            }
            t.BaggageImpl = r;
          },
          830: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.baggageEntryMetadataSymbol = void 0),
              (t.baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata')));
          },
          369: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.baggageEntryMetadataFromString = t.createBaggage = void 0));
            let n = r(930),
              i = r(993),
              a = r(830),
              o = n.DiagAPI.instance();
            ((t.createBaggage = function (e = {}) {
              return new i.BaggageImpl(new Map(Object.entries(e)));
            }),
              (t.baggageEntryMetadataFromString = function (e) {
                return (
                  'string' != typeof e &&
                    (o.error(`Cannot create baggage metadata from unknown type: ${typeof e}`),
                    (e = '')),
                  { __TYPE__: a.baggageEntryMetadataSymbol, toString: () => e }
                );
              }));
          },
          67: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.context = void 0),
              (t.context = r(491).ContextAPI.getInstance()));
          },
          223: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopContextManager = void 0));
            let n = r(780);
            t.NoopContextManager = class {
              active() {
                return n.ROOT_CONTEXT;
              }
              with(e, t, r, ...n) {
                return t.call(r, ...n);
              }
              bind(e, t) {
                return t;
              }
              enable() {
                return this;
              }
              disable() {
                return this;
              }
            };
          },
          780: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ROOT_CONTEXT = t.createContextKey = void 0),
              (t.createContextKey = function (e) {
                return Symbol.for(e);
              }));
            class r {
              constructor(e) {
                let t = this;
                ((t._currentContext = e ? new Map(e) : new Map()),
                  (t.getValue = (e) => t._currentContext.get(e)),
                  (t.setValue = (e, n) => {
                    let i = new r(t._currentContext);
                    return (i._currentContext.set(e, n), i);
                  }),
                  (t.deleteValue = (e) => {
                    let n = new r(t._currentContext);
                    return (n._currentContext.delete(e), n);
                  }));
              }
            }
            t.ROOT_CONTEXT = new r();
          },
          506: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.diag = void 0),
              (t.diag = r(930).DiagAPI.instance()));
          },
          56: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagComponentLogger = void 0));
            let n = r(172);
            function i(e, t, r) {
              let i = (0, n.getGlobal)('diag');
              if (i) return (r.unshift(t), i[e](...r));
            }
            t.DiagComponentLogger = class {
              constructor(e) {
                this._namespace = e.namespace || 'DiagComponentLogger';
              }
              debug(...e) {
                return i('debug', this._namespace, e);
              }
              error(...e) {
                return i('error', this._namespace, e);
              }
              info(...e) {
                return i('info', this._namespace, e);
              }
              warn(...e) {
                return i('warn', this._namespace, e);
              }
              verbose(...e) {
                return i('verbose', this._namespace, e);
              }
            };
          },
          972: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.DiagConsoleLogger = void 0));
            let r = [
              { n: 'error', c: 'error' },
              { n: 'warn', c: 'warn' },
              { n: 'info', c: 'info' },
              { n: 'debug', c: 'debug' },
              { n: 'verbose', c: 'trace' },
            ];
            t.DiagConsoleLogger = class {
              constructor() {
                for (let e = 0; e < r.length; e++)
                  this[r[e].n] = (function (e) {
                    return function (...t) {
                      if (console) {
                        let r = console[e];
                        if (('function' != typeof r && (r = console.log), 'function' == typeof r))
                          return r.apply(console, t);
                      }
                    };
                  })(r[e].c);
              }
            };
          },
          912: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createLogLevelDiagLogger = void 0));
            let n = r(957);
            t.createLogLevelDiagLogger = function (e, t) {
              function r(r, n) {
                let i = t[r];
                return 'function' == typeof i && e >= n ? i.bind(t) : function () {};
              }
              return (
                e < n.DiagLogLevel.NONE
                  ? (e = n.DiagLogLevel.NONE)
                  : e > n.DiagLogLevel.ALL && (e = n.DiagLogLevel.ALL),
                (t = t || {}),
                {
                  error: r('error', n.DiagLogLevel.ERROR),
                  warn: r('warn', n.DiagLogLevel.WARN),
                  info: r('info', n.DiagLogLevel.INFO),
                  debug: r('debug', n.DiagLogLevel.DEBUG),
                  verbose: r('verbose', n.DiagLogLevel.VERBOSE),
                }
              );
            };
          },
          957: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.DiagLogLevel = void 0),
              (function (e) {
                ((e[(e.NONE = 0)] = 'NONE'),
                  (e[(e.ERROR = 30)] = 'ERROR'),
                  (e[(e.WARN = 50)] = 'WARN'),
                  (e[(e.INFO = 60)] = 'INFO'),
                  (e[(e.DEBUG = 70)] = 'DEBUG'),
                  (e[(e.VERBOSE = 80)] = 'VERBOSE'),
                  (e[(e.ALL = 9999)] = 'ALL'));
              })(t.DiagLogLevel || (t.DiagLogLevel = {})));
          },
          172: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.unregisterGlobal = t.getGlobal = t.registerGlobal = void 0));
            let n = r(200),
              i = r(521),
              a = r(130),
              o = i.VERSION.split('.')[0],
              s = Symbol.for(`opentelemetry.js.api.${o}`),
              u = n._globalThis;
            ((t.registerGlobal = function (e, t, r, n = !1) {
              var a;
              let o = (u[s] = null != (a = u[s]) ? a : { version: i.VERSION });
              if (!n && o[e]) {
                let t = Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e}`);
                return (r.error(t.stack || t.message), !1);
              }
              if (o.version !== i.VERSION) {
                let t = Error(
                  `@opentelemetry/api: Registration of version v${o.version} for ${e} does not match previously registered API v${i.VERSION}`
                );
                return (r.error(t.stack || t.message), !1);
              }
              return (
                (o[e] = t),
                r.debug(`@opentelemetry/api: Registered a global for ${e} v${i.VERSION}.`),
                !0
              );
            }),
              (t.getGlobal = function (e) {
                var t, r;
                let n = null == (t = u[s]) ? void 0 : t.version;
                if (n && (0, a.isCompatible)(n)) return null == (r = u[s]) ? void 0 : r[e];
              }),
              (t.unregisterGlobal = function (e, t) {
                t.debug(`@opentelemetry/api: Unregistering a global for ${e} v${i.VERSION}.`);
                let r = u[s];
                r && delete r[e];
              }));
          },
          130: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.isCompatible = t._makeCompatibilityCheck = void 0));
            let n = r(521),
              i = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
            function a(e) {
              let t = new Set([e]),
                r = new Set(),
                n = e.match(i);
              if (!n) return () => !1;
              let a = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
              if (null != a.prerelease)
                return function (t) {
                  return t === e;
                };
              function o(e) {
                return (r.add(e), !1);
              }
              return function (e) {
                if (t.has(e)) return !0;
                if (r.has(e)) return !1;
                let n = e.match(i);
                if (!n) return o(e);
                let s = { major: +n[1], minor: +n[2], patch: +n[3], prerelease: n[4] };
                if (null != s.prerelease || a.major !== s.major) return o(e);
                if (0 === a.major)
                  return a.minor === s.minor && a.patch <= s.patch ? (t.add(e), !0) : o(e);
                return a.minor <= s.minor ? (t.add(e), !0) : o(e);
              };
            }
            ((t._makeCompatibilityCheck = a), (t.isCompatible = a(n.VERSION)));
          },
          886: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.metrics = void 0),
              (t.metrics = r(653).MetricsAPI.getInstance()));
          },
          901: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ValueType = void 0),
              (function (e) {
                ((e[(e.INT = 0)] = 'INT'), (e[(e.DOUBLE = 1)] = 'DOUBLE'));
              })(t.ValueType || (t.ValueType = {})));
          },
          102: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.createNoopMeter =
                t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC =
                t.NOOP_OBSERVABLE_GAUGE_METRIC =
                t.NOOP_OBSERVABLE_COUNTER_METRIC =
                t.NOOP_UP_DOWN_COUNTER_METRIC =
                t.NOOP_HISTOGRAM_METRIC =
                t.NOOP_COUNTER_METRIC =
                t.NOOP_METER =
                t.NoopObservableUpDownCounterMetric =
                t.NoopObservableGaugeMetric =
                t.NoopObservableCounterMetric =
                t.NoopObservableMetric =
                t.NoopHistogramMetric =
                t.NoopUpDownCounterMetric =
                t.NoopCounterMetric =
                t.NoopMetric =
                t.NoopMeter =
                  void 0));
            class r {
              constructor() {}
              createHistogram(e, r) {
                return t.NOOP_HISTOGRAM_METRIC;
              }
              createCounter(e, r) {
                return t.NOOP_COUNTER_METRIC;
              }
              createUpDownCounter(e, r) {
                return t.NOOP_UP_DOWN_COUNTER_METRIC;
              }
              createObservableGauge(e, r) {
                return t.NOOP_OBSERVABLE_GAUGE_METRIC;
              }
              createObservableCounter(e, r) {
                return t.NOOP_OBSERVABLE_COUNTER_METRIC;
              }
              createObservableUpDownCounter(e, r) {
                return t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
              }
              addBatchObservableCallback(e, t) {}
              removeBatchObservableCallback(e) {}
            }
            t.NoopMeter = r;
            class n {}
            t.NoopMetric = n;
            class i extends n {
              add(e, t) {}
            }
            t.NoopCounterMetric = i;
            class a extends n {
              add(e, t) {}
            }
            t.NoopUpDownCounterMetric = a;
            class o extends n {
              record(e, t) {}
            }
            t.NoopHistogramMetric = o;
            class s {
              addCallback(e) {}
              removeCallback(e) {}
            }
            t.NoopObservableMetric = s;
            class u extends s {}
            t.NoopObservableCounterMetric = u;
            class l extends s {}
            t.NoopObservableGaugeMetric = l;
            class c extends s {}
            ((t.NoopObservableUpDownCounterMetric = c),
              (t.NOOP_METER = new r()),
              (t.NOOP_COUNTER_METRIC = new i()),
              (t.NOOP_HISTOGRAM_METRIC = new o()),
              (t.NOOP_UP_DOWN_COUNTER_METRIC = new a()),
              (t.NOOP_OBSERVABLE_COUNTER_METRIC = new u()),
              (t.NOOP_OBSERVABLE_GAUGE_METRIC = new l()),
              (t.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new c()),
              (t.createNoopMeter = function () {
                return t.NOOP_METER;
              }));
          },
          660: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NOOP_METER_PROVIDER = t.NoopMeterProvider = void 0));
            let n = r(102);
            class i {
              getMeter(e, t, r) {
                return n.NOOP_METER;
              }
            }
            ((t.NoopMeterProvider = i), (t.NOOP_METER_PROVIDER = new i()));
          },
          200: function (e, t, r) {
            var n =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (e, t, r, n) {
                      (void 0 === n && (n = r),
                        Object.defineProperty(e, n, {
                          enumerable: !0,
                          get: function () {
                            return t[r];
                          },
                        }));
                    }
                  : function (e, t, r, n) {
                      (void 0 === n && (n = r), (e[n] = t[r]));
                    }),
              i =
                (this && this.__exportStar) ||
                function (e, t) {
                  for (var r in e)
                    'default' === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);
                };
            (Object.defineProperty(t, '__esModule', { value: !0 }), i(r(46), t));
          },
          651: (t, r) => {
            (Object.defineProperty(r, '__esModule', { value: !0 }),
              (r._globalThis = void 0),
              (r._globalThis = 'object' == typeof globalThis ? globalThis : e.g));
          },
          46: function (e, t, r) {
            var n =
                (this && this.__createBinding) ||
                (Object.create
                  ? function (e, t, r, n) {
                      (void 0 === n && (n = r),
                        Object.defineProperty(e, n, {
                          enumerable: !0,
                          get: function () {
                            return t[r];
                          },
                        }));
                    }
                  : function (e, t, r, n) {
                      (void 0 === n && (n = r), (e[n] = t[r]));
                    }),
              i =
                (this && this.__exportStar) ||
                function (e, t) {
                  for (var r in e)
                    'default' === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r);
                };
            (Object.defineProperty(t, '__esModule', { value: !0 }), i(r(651), t));
          },
          939: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.propagation = void 0),
              (t.propagation = r(181).PropagationAPI.getInstance()));
          },
          874: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopTextMapPropagator = void 0),
              (t.NoopTextMapPropagator = class {
                inject(e, t) {}
                extract(e, t) {
                  return e;
                }
                fields() {
                  return [];
                }
              }));
          },
          194: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.defaultTextMapSetter = t.defaultTextMapGetter = void 0),
              (t.defaultTextMapGetter = {
                get(e, t) {
                  if (null != e) return e[t];
                },
                keys: (e) => (null == e ? [] : Object.keys(e)),
              }),
              (t.defaultTextMapSetter = {
                set(e, t, r) {
                  null != e && (e[t] = r);
                },
              }));
          },
          845: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.trace = void 0),
              (t.trace = r(997).TraceAPI.getInstance()));
          },
          403: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.NonRecordingSpan = void 0));
            let n = r(476);
            t.NonRecordingSpan = class {
              constructor(e = n.INVALID_SPAN_CONTEXT) {
                this._spanContext = e;
              }
              spanContext() {
                return this._spanContext;
              }
              setAttribute(e, t) {
                return this;
              }
              setAttributes(e) {
                return this;
              }
              addEvent(e, t) {
                return this;
              }
              setStatus(e) {
                return this;
              }
              updateName(e) {
                return this;
              }
              end(e) {}
              isRecording() {
                return !1;
              }
              recordException(e, t) {}
            };
          },
          614: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.NoopTracer = void 0));
            let n = r(491),
              i = r(607),
              a = r(403),
              o = r(139),
              s = n.ContextAPI.getInstance();
            t.NoopTracer = class {
              startSpan(e, t, r = s.active()) {
                var n;
                if (null == t ? void 0 : t.root) return new a.NonRecordingSpan();
                let u = r && (0, i.getSpanContext)(r);
                return 'object' == typeof (n = u) &&
                  'string' == typeof n.spanId &&
                  'string' == typeof n.traceId &&
                  'number' == typeof n.traceFlags &&
                  (0, o.isSpanContextValid)(u)
                  ? new a.NonRecordingSpan(u)
                  : new a.NonRecordingSpan();
              }
              startActiveSpan(e, t, r, n) {
                let a, o, u;
                if (arguments.length < 2) return;
                2 == arguments.length
                  ? (u = t)
                  : 3 == arguments.length
                    ? ((a = t), (u = r))
                    : ((a = t), (o = r), (u = n));
                let l = null != o ? o : s.active(),
                  c = this.startSpan(e, a, l),
                  d = (0, i.setSpan)(l, c);
                return s.with(d, u, void 0, c);
              }
            };
          },
          124: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.NoopTracerProvider = void 0));
            let n = r(614);
            t.NoopTracerProvider = class {
              getTracer(e, t, r) {
                return new n.NoopTracer();
              }
            };
          },
          125: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.ProxyTracer = void 0));
            let n = new (r(614).NoopTracer)();
            t.ProxyTracer = class {
              constructor(e, t, r, n) {
                ((this._provider = e), (this.name = t), (this.version = r), (this.options = n));
              }
              startSpan(e, t, r) {
                return this._getTracer().startSpan(e, t, r);
              }
              startActiveSpan(e, t, r, n) {
                let i = this._getTracer();
                return Reflect.apply(i.startActiveSpan, i, arguments);
              }
              _getTracer() {
                if (this._delegate) return this._delegate;
                let e = this._provider.getDelegateTracer(this.name, this.version, this.options);
                return e ? ((this._delegate = e), this._delegate) : n;
              }
            };
          },
          846: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.ProxyTracerProvider = void 0));
            let n = r(125),
              i = new (r(124).NoopTracerProvider)();
            t.ProxyTracerProvider = class {
              getTracer(e, t, r) {
                var i;
                return null != (i = this.getDelegateTracer(e, t, r))
                  ? i
                  : new n.ProxyTracer(this, e, t, r);
              }
              getDelegate() {
                var e;
                return null != (e = this._delegate) ? e : i;
              }
              setDelegate(e) {
                this._delegate = e;
              }
              getDelegateTracer(e, t, r) {
                var n;
                return null == (n = this._delegate) ? void 0 : n.getTracer(e, t, r);
              }
            };
          },
          996: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SamplingDecision = void 0),
              (function (e) {
                ((e[(e.NOT_RECORD = 0)] = 'NOT_RECORD'),
                  (e[(e.RECORD = 1)] = 'RECORD'),
                  (e[(e.RECORD_AND_SAMPLED = 2)] = 'RECORD_AND_SAMPLED'));
              })(t.SamplingDecision || (t.SamplingDecision = {})));
          },
          607: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.getSpanContext =
                t.setSpanContext =
                t.deleteSpan =
                t.setSpan =
                t.getActiveSpan =
                t.getSpan =
                  void 0));
            let n = r(780),
              i = r(403),
              a = r(491),
              o = (0, n.createContextKey)('OpenTelemetry Context Key SPAN');
            function s(e) {
              return e.getValue(o) || void 0;
            }
            function u(e, t) {
              return e.setValue(o, t);
            }
            ((t.getSpan = s),
              (t.getActiveSpan = function () {
                return s(a.ContextAPI.getInstance().active());
              }),
              (t.setSpan = u),
              (t.deleteSpan = function (e) {
                return e.deleteValue(o);
              }),
              (t.setSpanContext = function (e, t) {
                return u(e, new i.NonRecordingSpan(t));
              }),
              (t.getSpanContext = function (e) {
                var t;
                return null == (t = s(e)) ? void 0 : t.spanContext();
              }));
          },
          325: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.TraceStateImpl = void 0));
            let n = r(564);
            class i {
              constructor(e) {
                ((this._internalState = new Map()), e && this._parse(e));
              }
              set(e, t) {
                let r = this._clone();
                return (
                  r._internalState.has(e) && r._internalState.delete(e),
                  r._internalState.set(e, t),
                  r
                );
              }
              unset(e) {
                let t = this._clone();
                return (t._internalState.delete(e), t);
              }
              get(e) {
                return this._internalState.get(e);
              }
              serialize() {
                return this._keys()
                  .reduce((e, t) => (e.push(t + '=' + this.get(t)), e), [])
                  .join(',');
              }
              _parse(e) {
                !(e.length > 512) &&
                  ((this._internalState = e
                    .split(',')
                    .reverse()
                    .reduce((e, t) => {
                      let r = t.trim(),
                        i = r.indexOf('=');
                      if (-1 !== i) {
                        let a = r.slice(0, i),
                          o = r.slice(i + 1, t.length);
                        (0, n.validateKey)(a) && (0, n.validateValue)(o) && e.set(a, o);
                      }
                      return e;
                    }, new Map())),
                  this._internalState.size > 32 &&
                    (this._internalState = new Map(
                      Array.from(this._internalState.entries()).reverse().slice(0, 32)
                    )));
              }
              _keys() {
                return Array.from(this._internalState.keys()).reverse();
              }
              _clone() {
                let e = new i();
                return ((e._internalState = new Map(this._internalState)), e);
              }
            }
            t.TraceStateImpl = i;
          },
          564: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.validateValue = t.validateKey = void 0));
            let r = '[_0-9a-z-*/]',
              n = `[a-z]${r}{0,255}`,
              i = `[a-z0-9]${r}{0,240}@[a-z]${r}{0,13}`,
              a = RegExp(`^(?:${n}|${i})$`),
              o = /^[ -~]{0,255}[!-~]$/,
              s = /,|=/;
            ((t.validateKey = function (e) {
              return a.test(e);
            }),
              (t.validateValue = function (e) {
                return o.test(e) && !s.test(e);
              }));
          },
          98: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }), (t.createTraceState = void 0));
            let n = r(325);
            t.createTraceState = function (e) {
              return new n.TraceStateImpl(e);
            };
          },
          476: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.INVALID_SPAN_CONTEXT = t.INVALID_TRACEID = t.INVALID_SPANID = void 0));
            let n = r(475);
            ((t.INVALID_SPANID = '0000000000000000'),
              (t.INVALID_TRACEID = '00000000000000000000000000000000'),
              (t.INVALID_SPAN_CONTEXT = {
                traceId: t.INVALID_TRACEID,
                spanId: t.INVALID_SPANID,
                traceFlags: n.TraceFlags.NONE,
              }));
          },
          357: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SpanKind = void 0),
              (function (e) {
                ((e[(e.INTERNAL = 0)] = 'INTERNAL'),
                  (e[(e.SERVER = 1)] = 'SERVER'),
                  (e[(e.CLIENT = 2)] = 'CLIENT'),
                  (e[(e.PRODUCER = 3)] = 'PRODUCER'),
                  (e[(e.CONSUMER = 4)] = 'CONSUMER'));
              })(t.SpanKind || (t.SpanKind = {})));
          },
          139: (e, t, r) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.wrapSpanContext =
                t.isSpanContextValid =
                t.isValidSpanId =
                t.isValidTraceId =
                  void 0));
            let n = r(476),
              i = r(403),
              a = /^([0-9a-f]{32})$/i,
              o = /^[0-9a-f]{16}$/i;
            function s(e) {
              return a.test(e) && e !== n.INVALID_TRACEID;
            }
            function u(e) {
              return o.test(e) && e !== n.INVALID_SPANID;
            }
            ((t.isValidTraceId = s),
              (t.isValidSpanId = u),
              (t.isSpanContextValid = function (e) {
                return s(e.traceId) && u(e.spanId);
              }),
              (t.wrapSpanContext = function (e) {
                return new i.NonRecordingSpan(e);
              }));
          },
          847: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.SpanStatusCode = void 0),
              (function (e) {
                ((e[(e.UNSET = 0)] = 'UNSET'),
                  (e[(e.OK = 1)] = 'OK'),
                  (e[(e.ERROR = 2)] = 'ERROR'));
              })(t.SpanStatusCode || (t.SpanStatusCode = {})));
          },
          475: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.TraceFlags = void 0),
              (function (e) {
                ((e[(e.NONE = 0)] = 'NONE'), (e[(e.SAMPLED = 1)] = 'SAMPLED'));
              })(t.TraceFlags || (t.TraceFlags = {})));
          },
          521: (e, t) => {
            (Object.defineProperty(t, '__esModule', { value: !0 }),
              (t.VERSION = void 0),
              (t.VERSION = '1.6.0'));
          },
        },
        n = {};
      function i(e) {
        var t = n[e];
        if (void 0 !== t) return t.exports;
        var a = (n[e] = { exports: {} }),
          o = !0;
        try {
          (r[e].call(a.exports, a, a.exports, i), (o = !1));
        } finally {
          o && delete n[e];
        }
        return a.exports;
      }
      i.ab =
        '/ROOT/node_modules/.pnpm/next@15.5.2_@babel+core@7.28.3_@opentelemetry+api@1.9.0_@playwright+test@1.55.0_react-d_e236737f00d0c8f73a9e6975c9f9321d/node_modules/next/dist/compiled/@opentelemetry/api/';
      var a = {};
      ((() => {
        (Object.defineProperty(a, '__esModule', { value: !0 }),
          (a.trace =
            a.propagation =
            a.metrics =
            a.diag =
            a.context =
            a.INVALID_SPAN_CONTEXT =
            a.INVALID_TRACEID =
            a.INVALID_SPANID =
            a.isValidSpanId =
            a.isValidTraceId =
            a.isSpanContextValid =
            a.createTraceState =
            a.TraceFlags =
            a.SpanStatusCode =
            a.SpanKind =
            a.SamplingDecision =
            a.ProxyTracerProvider =
            a.ProxyTracer =
            a.defaultTextMapSetter =
            a.defaultTextMapGetter =
            a.ValueType =
            a.createNoopMeter =
            a.DiagLogLevel =
            a.DiagConsoleLogger =
            a.ROOT_CONTEXT =
            a.createContextKey =
            a.baggageEntryMetadataFromString =
              void 0));
        var e = i(369);
        Object.defineProperty(a, 'baggageEntryMetadataFromString', {
          enumerable: !0,
          get: function () {
            return e.baggageEntryMetadataFromString;
          },
        });
        var t = i(780);
        (Object.defineProperty(a, 'createContextKey', {
          enumerable: !0,
          get: function () {
            return t.createContextKey;
          },
        }),
          Object.defineProperty(a, 'ROOT_CONTEXT', {
            enumerable: !0,
            get: function () {
              return t.ROOT_CONTEXT;
            },
          }));
        var r = i(972);
        Object.defineProperty(a, 'DiagConsoleLogger', {
          enumerable: !0,
          get: function () {
            return r.DiagConsoleLogger;
          },
        });
        var n = i(957);
        Object.defineProperty(a, 'DiagLogLevel', {
          enumerable: !0,
          get: function () {
            return n.DiagLogLevel;
          },
        });
        var o = i(102);
        Object.defineProperty(a, 'createNoopMeter', {
          enumerable: !0,
          get: function () {
            return o.createNoopMeter;
          },
        });
        var s = i(901);
        Object.defineProperty(a, 'ValueType', {
          enumerable: !0,
          get: function () {
            return s.ValueType;
          },
        });
        var u = i(194);
        (Object.defineProperty(a, 'defaultTextMapGetter', {
          enumerable: !0,
          get: function () {
            return u.defaultTextMapGetter;
          },
        }),
          Object.defineProperty(a, 'defaultTextMapSetter', {
            enumerable: !0,
            get: function () {
              return u.defaultTextMapSetter;
            },
          }));
        var l = i(125);
        Object.defineProperty(a, 'ProxyTracer', {
          enumerable: !0,
          get: function () {
            return l.ProxyTracer;
          },
        });
        var c = i(846);
        Object.defineProperty(a, 'ProxyTracerProvider', {
          enumerable: !0,
          get: function () {
            return c.ProxyTracerProvider;
          },
        });
        var d = i(996);
        Object.defineProperty(a, 'SamplingDecision', {
          enumerable: !0,
          get: function () {
            return d.SamplingDecision;
          },
        });
        var f = i(357);
        Object.defineProperty(a, 'SpanKind', {
          enumerable: !0,
          get: function () {
            return f.SpanKind;
          },
        });
        var p = i(847);
        Object.defineProperty(a, 'SpanStatusCode', {
          enumerable: !0,
          get: function () {
            return p.SpanStatusCode;
          },
        });
        var m = i(475);
        Object.defineProperty(a, 'TraceFlags', {
          enumerable: !0,
          get: function () {
            return m.TraceFlags;
          },
        });
        var g = i(98);
        Object.defineProperty(a, 'createTraceState', {
          enumerable: !0,
          get: function () {
            return g.createTraceState;
          },
        });
        var h = i(139);
        (Object.defineProperty(a, 'isSpanContextValid', {
          enumerable: !0,
          get: function () {
            return h.isSpanContextValid;
          },
        }),
          Object.defineProperty(a, 'isValidTraceId', {
            enumerable: !0,
            get: function () {
              return h.isValidTraceId;
            },
          }),
          Object.defineProperty(a, 'isValidSpanId', {
            enumerable: !0,
            get: function () {
              return h.isValidSpanId;
            },
          }));
        var v = i(476);
        (Object.defineProperty(a, 'INVALID_SPANID', {
          enumerable: !0,
          get: function () {
            return v.INVALID_SPANID;
          },
        }),
          Object.defineProperty(a, 'INVALID_TRACEID', {
            enumerable: !0,
            get: function () {
              return v.INVALID_TRACEID;
            },
          }),
          Object.defineProperty(a, 'INVALID_SPAN_CONTEXT', {
            enumerable: !0,
            get: function () {
              return v.INVALID_SPAN_CONTEXT;
            },
          }));
        let b = i(67);
        Object.defineProperty(a, 'context', {
          enumerable: !0,
          get: function () {
            return b.context;
          },
        });
        let _ = i(506);
        Object.defineProperty(a, 'diag', {
          enumerable: !0,
          get: function () {
            return _.diag;
          },
        });
        let y = i(886);
        Object.defineProperty(a, 'metrics', {
          enumerable: !0,
          get: function () {
            return y.metrics;
          },
        });
        let x = i(939);
        Object.defineProperty(a, 'propagation', {
          enumerable: !0,
          get: function () {
            return x.propagation;
          },
        });
        let $ = i(845);
        (Object.defineProperty(a, 'trace', {
          enumerable: !0,
          get: function () {
            return $.trace;
          },
        }),
          (a.default = {
            context: b.context,
            diag: _.diag,
            metrics: y.metrics,
            propagation: x.propagation,
            trace: $.trace,
          }));
      })(),
        (t.exports = a));
    })();
  },
  28196,
  (e, t, r) => {
    'use strict';
    t.exports = e.r(18622);
  },
  91392,
  (e, t, r) => {
    'use strict';
    t.exports = e.r(28196).vendored['react-rsc'].React;
  },
  82159,
  (e, t, r) => {
    'use strict';
    var n = Object.defineProperty,
      i = Object.getOwnPropertyDescriptor,
      a = Object.getOwnPropertyNames,
      o = Object.prototype.hasOwnProperty,
      s = {};
    function u(e) {
      var t;
      let r = [
          'path' in e && e.path && `Path=${e.path}`,
          'expires' in e &&
            (e.expires || 0 === e.expires) &&
            `Expires=${('number' == typeof e.expires ? new Date(e.expires) : e.expires).toUTCString()}`,
          'maxAge' in e && 'number' == typeof e.maxAge && `Max-Age=${e.maxAge}`,
          'domain' in e && e.domain && `Domain=${e.domain}`,
          'secure' in e && e.secure && 'Secure',
          'httpOnly' in e && e.httpOnly && 'HttpOnly',
          'sameSite' in e && e.sameSite && `SameSite=${e.sameSite}`,
          'partitioned' in e && e.partitioned && 'Partitioned',
          'priority' in e && e.priority && `Priority=${e.priority}`,
        ].filter(Boolean),
        n = `${e.name}=${encodeURIComponent(null != (t = e.value) ? t : '')}`;
      return 0 === r.length ? n : `${n}; ${r.join('; ')}`;
    }
    function l(e) {
      let t = new Map();
      for (let r of e.split(/; */)) {
        if (!r) continue;
        let e = r.indexOf('=');
        if (-1 === e) {
          t.set(r, 'true');
          continue;
        }
        let [n, i] = [r.slice(0, e), r.slice(e + 1)];
        try {
          t.set(n, decodeURIComponent(null != i ? i : 'true'));
        } catch {}
      }
      return t;
    }
    function c(e) {
      if (!e) return;
      let [[t, r], ...n] = l(e),
        {
          domain: i,
          expires: a,
          httponly: o,
          maxage: s,
          path: u,
          samesite: c,
          secure: p,
          partitioned: m,
          priority: g,
        } = Object.fromEntries(n.map(([e, t]) => [e.toLowerCase().replace(/-/g, ''), t]));
      {
        var h,
          v,
          b = {
            name: t,
            value: decodeURIComponent(r),
            domain: i,
            ...(a && { expires: new Date(a) }),
            ...(o && { httpOnly: !0 }),
            ...('string' == typeof s && { maxAge: Number(s) }),
            path: u,
            ...(c && { sameSite: d.includes((h = (h = c).toLowerCase())) ? h : void 0 }),
            ...(p && { secure: !0 }),
            ...(g && { priority: f.includes((v = (v = g).toLowerCase())) ? v : void 0 }),
            ...(m && { partitioned: !0 }),
          };
        let e = {};
        for (let t in b) b[t] && (e[t] = b[t]);
        return e;
      }
    }
    (((e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    })(s, {
      RequestCookies: () => p,
      ResponseCookies: () => m,
      parseCookie: () => l,
      parseSetCookie: () => c,
      stringifyCookie: () => u,
    }),
      (t.exports = ((e, t, r, s) => {
        if ((t && 'object' == typeof t) || 'function' == typeof t)
          for (let u of a(t))
            o.call(e, u) ||
              u === r ||
              n(e, u, { get: () => t[u], enumerable: !(s = i(t, u)) || s.enumerable });
        return e;
      })(n({}, '__esModule', { value: !0 }), s)));
    var d = ['strict', 'lax', 'none'],
      f = ['low', 'medium', 'high'],
      p = class {
        constructor(e) {
          ((this._parsed = new Map()), (this._headers = e));
          let t = e.get('cookie');
          if (t) for (let [e, r] of l(t)) this._parsed.set(e, { name: e, value: r });
        }
        [Symbol.iterator]() {
          return this._parsed[Symbol.iterator]();
        }
        get size() {
          return this._parsed.size;
        }
        get(...e) {
          let t = 'string' == typeof e[0] ? e[0] : e[0].name;
          return this._parsed.get(t);
        }
        getAll(...e) {
          var t;
          let r = Array.from(this._parsed);
          if (!e.length) return r.map(([e, t]) => t);
          let n = 'string' == typeof e[0] ? e[0] : null == (t = e[0]) ? void 0 : t.name;
          return r.filter(([e]) => e === n).map(([e, t]) => t);
        }
        has(e) {
          return this._parsed.has(e);
        }
        set(...e) {
          let [t, r] = 1 === e.length ? [e[0].name, e[0].value] : e,
            n = this._parsed;
          return (
            n.set(t, { name: t, value: r }),
            this._headers.set(
              'cookie',
              Array.from(n)
                .map(([e, t]) => u(t))
                .join('; ')
            ),
            this
          );
        }
        delete(e) {
          let t = this._parsed,
            r = Array.isArray(e) ? e.map((e) => t.delete(e)) : t.delete(e);
          return (
            this._headers.set(
              'cookie',
              Array.from(t)
                .map(([e, t]) => u(t))
                .join('; ')
            ),
            r
          );
        }
        clear() {
          return (this.delete(Array.from(this._parsed.keys())), this);
        }
        [Symbol.for('edge-runtime.inspect.custom')]() {
          return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
        }
        toString() {
          return [...this._parsed.values()]
            .map((e) => `${e.name}=${encodeURIComponent(e.value)}`)
            .join('; ');
        }
      },
      m = class {
        constructor(e) {
          var t, r, n;
          ((this._parsed = new Map()), (this._headers = e));
          let i =
            null !=
            (n =
              null != (r = null == (t = e.getSetCookie) ? void 0 : t.call(e))
                ? r
                : e.get('set-cookie'))
              ? n
              : [];
          for (let e of Array.isArray(i)
            ? i
            : (function (e) {
                if (!e) return [];
                var t,
                  r,
                  n,
                  i,
                  a,
                  o = [],
                  s = 0;
                function u() {
                  for (; s < e.length && /\s/.test(e.charAt(s)); ) s += 1;
                  return s < e.length;
                }
                for (; s < e.length; ) {
                  for (t = s, a = !1; u(); )
                    if (',' === (r = e.charAt(s))) {
                      for (
                        n = s, s += 1, u(), i = s;
                        s < e.length && '=' !== (r = e.charAt(s)) && ';' !== r && ',' !== r;

                      )
                        s += 1;
                      s < e.length && '=' === e.charAt(s)
                        ? ((a = !0), (s = i), o.push(e.substring(t, n)), (t = s))
                        : (s = n + 1);
                    } else s += 1;
                  (!a || s >= e.length) && o.push(e.substring(t, e.length));
                }
                return o;
              })(i)) {
            let t = c(e);
            t && this._parsed.set(t.name, t);
          }
        }
        get(...e) {
          let t = 'string' == typeof e[0] ? e[0] : e[0].name;
          return this._parsed.get(t);
        }
        getAll(...e) {
          var t;
          let r = Array.from(this._parsed.values());
          if (!e.length) return r;
          let n = 'string' == typeof e[0] ? e[0] : null == (t = e[0]) ? void 0 : t.name;
          return r.filter((e) => e.name === n);
        }
        has(e) {
          return this._parsed.has(e);
        }
        set(...e) {
          let [t, r, n] = 1 === e.length ? [e[0].name, e[0].value, e[0]] : e,
            i = this._parsed;
          return (
            i.set(
              t,
              (function (e = { name: '', value: '' }) {
                return (
                  'number' == typeof e.expires && (e.expires = new Date(e.expires)),
                  e.maxAge && (e.expires = new Date(Date.now() + 1e3 * e.maxAge)),
                  (null === e.path || void 0 === e.path) && (e.path = '/'),
                  e
                );
              })({ name: t, value: r, ...n })
            ),
            (function (e, t) {
              for (let [, r] of (t.delete('set-cookie'), e)) {
                let e = u(r);
                t.append('set-cookie', e);
              }
            })(i, this._headers),
            this
          );
        }
        delete(...e) {
          let [t, r] = 'string' == typeof e[0] ? [e[0]] : [e[0].name, e[0]];
          return this.set({ ...r, name: t, value: '', expires: new Date(0) });
        }
        [Symbol.for('edge-runtime.inspect.custom')]() {
          return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
        }
        toString() {
          return [...this._parsed.values()].map(u).join('; ');
        }
      };
  },
  40374,
  (e, t, r) => {
    (() => {
      'use strict';
      'undefined' != typeof __nccwpck_require__ &&
        (__nccwpck_require__.ab =
          '/ROOT/node_modules/.pnpm/next@15.5.2_@babel+core@7.28.3_@opentelemetry+api@1.9.0_@playwright+test@1.55.0_react-d_e236737f00d0c8f73a9e6975c9f9321d/node_modules/next/dist/compiled/cookie/');
      var e = {};
      ((() => {
        ((e.parse = function (e, r) {
          if ('string' != typeof e) throw TypeError('argument str must be a string');
          for (var i = {}, a = e.split(n), o = (r || {}).decode || t, s = 0; s < a.length; s++) {
            var u = a[s],
              l = u.indexOf('=');
            if (!(l < 0)) {
              var c = u.substr(0, l).trim(),
                d = u.substr(++l, u.length).trim();
              ('"' == d[0] && (d = d.slice(1, -1)),
                void 0 == i[c] &&
                  (i[c] = (function (e, t) {
                    try {
                      return t(e);
                    } catch (t) {
                      return e;
                    }
                  })(d, o)));
            }
          }
          return i;
        }),
          (e.serialize = function (e, t, n) {
            var a = n || {},
              o = a.encode || r;
            if ('function' != typeof o) throw TypeError('option encode is invalid');
            if (!i.test(e)) throw TypeError('argument name is invalid');
            var s = o(t);
            if (s && !i.test(s)) throw TypeError('argument val is invalid');
            var u = e + '=' + s;
            if (null != a.maxAge) {
              var l = a.maxAge - 0;
              if (isNaN(l) || !isFinite(l)) throw TypeError('option maxAge is invalid');
              u += '; Max-Age=' + Math.floor(l);
            }
            if (a.domain) {
              if (!i.test(a.domain)) throw TypeError('option domain is invalid');
              u += '; Domain=' + a.domain;
            }
            if (a.path) {
              if (!i.test(a.path)) throw TypeError('option path is invalid');
              u += '; Path=' + a.path;
            }
            if (a.expires) {
              if ('function' != typeof a.expires.toUTCString)
                throw TypeError('option expires is invalid');
              u += '; Expires=' + a.expires.toUTCString();
            }
            if ((a.httpOnly && (u += '; HttpOnly'), a.secure && (u += '; Secure'), a.sameSite))
              switch ('string' == typeof a.sameSite ? a.sameSite.toLowerCase() : a.sameSite) {
                case !0:
                case 'strict':
                  u += '; SameSite=Strict';
                  break;
                case 'lax':
                  u += '; SameSite=Lax';
                  break;
                case 'none':
                  u += '; SameSite=None';
                  break;
                default:
                  throw TypeError('option sameSite is invalid');
              }
            return u;
          }));
        var t = decodeURIComponent,
          r = encodeURIComponent,
          n = /; */,
          i = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
      })(),
        (t.exports = e));
    })();
  },
  24258,
  (e, t, r) => {
    'use strict';
    function n(e, t, r) {
      if (e)
        for (let a of (r && (r = r.toLowerCase()), e)) {
          var n, i;
          if (
            t === (null == (n = a.domain) ? void 0 : n.split(':', 1)[0].toLowerCase()) ||
            r === a.defaultLocale.toLowerCase() ||
            (null == (i = a.locales) ? void 0 : i.some((e) => e.toLowerCase() === r))
          )
            return a;
        }
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'detectDomainLocale', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  66033,
  (e, t, r) => {
    'use strict';
    function n(e) {
      return e.replace(/\/$/, '') || '/';
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'removeTrailingSlash', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  63425,
  (e, t, r) => {
    'use strict';
    function n(e) {
      let t = e.indexOf('#'),
        r = e.indexOf('?'),
        n = r > -1 && (t < 0 || r < t);
      return n || t > -1
        ? {
            pathname: e.substring(0, n ? r : t),
            query: n ? e.substring(r, t > -1 ? t : void 0) : '',
            hash: t > -1 ? e.slice(t) : '',
          }
        : { pathname: e, query: '', hash: '' };
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'parsePath', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  17854,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addPathPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(63425);
    function i(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: i, hash: a } = (0, n.parsePath)(e);
      return '' + t + r + i + a;
    }
  },
  59031,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addPathSuffix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(63425);
    function i(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: i, hash: a } = (0, n.parsePath)(e);
      return '' + r + t + i + a;
    }
  },
  76102,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'pathHasPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(63425);
    function i(e, t) {
      if ('string' != typeof e) return !1;
      let { pathname: r } = (0, n.parsePath)(e);
      return r === t || r.startsWith(t + '/');
    }
  },
  92755,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'addLocale', {
        enumerable: !0,
        get: function () {
          return a;
        },
      }));
    let n = e.r(17854),
      i = e.r(76102);
    function a(e, t, r, a) {
      if (!t || t === r) return e;
      let o = e.toLowerCase();
      return !a &&
        ((0, i.pathHasPrefix)(o, '/api') || (0, i.pathHasPrefix)(o, '/' + t.toLowerCase()))
        ? e
        : (0, n.addPathPrefix)(e, '/' + t);
    }
  },
  30800,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'formatNextPathnameInfo', {
        enumerable: !0,
        get: function () {
          return s;
        },
      }));
    let n = e.r(66033),
      i = e.r(17854),
      a = e.r(59031),
      o = e.r(92755);
    function s(e) {
      let t = (0, o.addLocale)(
        e.pathname,
        e.locale,
        e.buildId ? void 0 : e.defaultLocale,
        e.ignorePrefix
      );
      return (
        (e.buildId || !e.trailingSlash) && (t = (0, n.removeTrailingSlash)(t)),
        e.buildId &&
          (t = (0, a.addPathSuffix)(
            (0, i.addPathPrefix)(t, '/_next/data/' + e.buildId),
            '/' === e.pathname ? 'index.json' : '.json'
          )),
        (t = (0, i.addPathPrefix)(t, e.basePath)),
        !e.buildId && e.trailingSlash
          ? t.endsWith('/')
            ? t
            : (0, a.addPathSuffix)(t, '/')
          : (0, n.removeTrailingSlash)(t)
      );
    }
  },
  69569,
  (e, t, r) => {
    'use strict';
    function n(e, t) {
      let r;
      if ((null == t ? void 0 : t.host) && !Array.isArray(t.host))
        r = t.host.toString().split(':', 1)[0];
      else {
        if (!e.hostname) return;
        r = e.hostname;
      }
      return r.toLowerCase();
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'getHostname', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  9018,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'normalizeLocalePath', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = new WeakMap();
    function i(e, t) {
      let r;
      if (!t) return { pathname: e };
      let i = n.get(t);
      i || ((i = t.map((e) => e.toLowerCase())), n.set(t, i));
      let a = e.split('/', 2);
      if (!a[1]) return { pathname: e };
      let o = a[1].toLowerCase(),
        s = i.indexOf(o);
      return s < 0
        ? { pathname: e }
        : ((r = t[s]), { pathname: (e = e.slice(r.length + 1) || '/'), detectedLocale: r });
    }
  },
  46457,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'removePathPrefix', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(76102);
    function i(e, t) {
      if (!(0, n.pathHasPrefix)(e, t)) return e;
      let r = e.slice(t.length);
      return r.startsWith('/') ? r : '/' + r;
    }
  },
  41095,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'getNextPathnameInfo', {
        enumerable: !0,
        get: function () {
          return o;
        },
      }));
    let n = e.r(9018),
      i = e.r(46457),
      a = e.r(76102);
    function o(e, t) {
      var r, o;
      let { basePath: s, i18n: u, trailingSlash: l } = null != (r = t.nextConfig) ? r : {},
        c = { pathname: e, trailingSlash: '/' !== e ? e.endsWith('/') : l };
      s &&
        (0, a.pathHasPrefix)(c.pathname, s) &&
        ((c.pathname = (0, i.removePathPrefix)(c.pathname, s)), (c.basePath = s));
      let d = c.pathname;
      if (c.pathname.startsWith('/_next/data/') && c.pathname.endsWith('.json')) {
        let e = c.pathname
          .replace(/^\/_next\/data\//, '')
          .replace(/\.json$/, '')
          .split('/');
        ((c.buildId = e[0]),
          (d = 'index' !== e[1] ? '/' + e.slice(1).join('/') : '/'),
          !0 === t.parseData && (c.pathname = d));
      }
      if (u) {
        let e = t.i18nProvider
          ? t.i18nProvider.analyze(c.pathname)
          : (0, n.normalizeLocalePath)(c.pathname, u.locales);
        ((c.locale = e.detectedLocale),
          (c.pathname = null != (o = e.pathname) ? o : c.pathname),
          !e.detectedLocale &&
            c.buildId &&
            (e = t.i18nProvider
              ? t.i18nProvider.analyze(d)
              : (0, n.normalizeLocalePath)(d, u.locales)).detectedLocale &&
            (c.locale = e.detectedLocale));
      }
      return c;
    }
  },
  9398,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'NextURL', {
        enumerable: !0,
        get: function () {
          return c;
        },
      }));
    let n = e.r(24258),
      i = e.r(30800),
      a = e.r(69569),
      o = e.r(41095),
      s =
        /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function u(e, t) {
      return new URL(String(e).replace(s, 'localhost'), t && String(t).replace(s, 'localhost'));
    }
    let l = Symbol('NextURLInternal');
    class c {
      constructor(e, t, r) {
        let n, i;
        (('object' == typeof t && 'pathname' in t) || 'string' == typeof t
          ? ((n = t), (i = r || {}))
          : (i = r || t || {}),
          (this[l] = { url: u(e, n ?? i.base), options: i, basePath: '' }),
          this.analyze());
      }
      analyze() {
        var e, t, r, i, s;
        let u = (0, o.getNextPathnameInfo)(this[l].url.pathname, {
            nextConfig: this[l].options.nextConfig,
            parseData: !0,
            i18nProvider: this[l].options.i18nProvider,
          }),
          c = (0, a.getHostname)(this[l].url, this[l].options.headers);
        this[l].domainLocale = this[l].options.i18nProvider
          ? this[l].options.i18nProvider.detectDomainLocale(c)
          : (0, n.detectDomainLocale)(
              null == (t = this[l].options.nextConfig) || null == (e = t.i18n) ? void 0 : e.domains,
              c
            );
        let d =
          (null == (r = this[l].domainLocale) ? void 0 : r.defaultLocale) ||
          (null == (s = this[l].options.nextConfig) || null == (i = s.i18n)
            ? void 0
            : i.defaultLocale);
        ((this[l].url.pathname = u.pathname),
          (this[l].defaultLocale = d),
          (this[l].basePath = u.basePath ?? ''),
          (this[l].buildId = u.buildId),
          (this[l].locale = u.locale ?? d),
          (this[l].trailingSlash = u.trailingSlash));
      }
      formatPathname() {
        return (0, i.formatNextPathnameInfo)({
          basePath: this[l].basePath,
          buildId: this[l].buildId,
          defaultLocale: this[l].options.forceLocale ? void 0 : this[l].defaultLocale,
          locale: this[l].locale,
          pathname: this[l].url.pathname,
          trailingSlash: this[l].trailingSlash,
        });
      }
      formatSearch() {
        return this[l].url.search;
      }
      get buildId() {
        return this[l].buildId;
      }
      set buildId(e) {
        this[l].buildId = e;
      }
      get locale() {
        return this[l].locale ?? '';
      }
      set locale(e) {
        var t, r;
        if (
          !this[l].locale ||
          !(null == (r = this[l].options.nextConfig) || null == (t = r.i18n)
            ? void 0
            : t.locales.includes(e))
        )
          throw Object.defineProperty(
            TypeError(`The NextURL configuration includes no locale "${e}"`),
            '__NEXT_ERROR_CODE',
            { value: 'E597', enumerable: !1, configurable: !0 }
          );
        this[l].locale = e;
      }
      get defaultLocale() {
        return this[l].defaultLocale;
      }
      get domainLocale() {
        return this[l].domainLocale;
      }
      get searchParams() {
        return this[l].url.searchParams;
      }
      get host() {
        return this[l].url.host;
      }
      set host(e) {
        this[l].url.host = e;
      }
      get hostname() {
        return this[l].url.hostname;
      }
      set hostname(e) {
        this[l].url.hostname = e;
      }
      get port() {
        return this[l].url.port;
      }
      set port(e) {
        this[l].url.port = e;
      }
      get protocol() {
        return this[l].url.protocol;
      }
      set protocol(e) {
        this[l].url.protocol = e;
      }
      get href() {
        let e = this.formatPathname(),
          t = this.formatSearch();
        return `${this.protocol}//${this.host}${e}${t}${this.hash}`;
      }
      set href(e) {
        ((this[l].url = u(e)), this.analyze());
      }
      get origin() {
        return this[l].url.origin;
      }
      get pathname() {
        return this[l].url.pathname;
      }
      set pathname(e) {
        this[l].url.pathname = e;
      }
      get hash() {
        return this[l].url.hash;
      }
      set hash(e) {
        this[l].url.hash = e;
      }
      get search() {
        return this[l].url.search;
      }
      set search(e) {
        this[l].url.search = e;
      }
      get password() {
        return this[l].url.password;
      }
      set password(e) {
        this[l].url.password = e;
      }
      get username() {
        return this[l].url.username;
      }
      set username(e) {
        this[l].url.username = e;
      }
      get basePath() {
        return this[l].basePath;
      }
      set basePath(e) {
        this[l].basePath = e.startsWith('/') ? e : `/${e}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash,
        };
      }
      clone() {
        return new c(String(this), this[l].options);
      }
    }
  },
  71093,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        ACTION_SUFFIX: function () {
          return g;
        },
        APP_DIR_ALIAS: function () {
          return D;
        },
        CACHE_ONE_YEAR: function () {
          return k;
        },
        DOT_NEXT_ALIAS: function () {
          return j;
        },
        ESLINT_DEFAULT_DIRS: function () {
          return et;
        },
        GSP_NO_RETURNED_VALUE: function () {
          return H;
        },
        GSSP_COMPONENT_MEMBER_ERROR: function () {
          return Y;
        },
        GSSP_NO_RETURNED_VALUE: function () {
          return J;
        },
        HTML_CONTENT_TYPE_HEADER: function () {
          return i;
        },
        INFINITE_CACHE: function () {
          return I;
        },
        INSTRUMENTATION_HOOK_FILENAME: function () {
          return R;
        },
        JSON_CONTENT_TYPE_HEADER: function () {
          return a;
        },
        MATCHED_PATH_HEADER: function () {
          return u;
        },
        MIDDLEWARE_FILENAME: function () {
          return P;
        },
        MIDDLEWARE_LOCATION_REGEXP: function () {
          return N;
        },
        NEXT_BODY_SUFFIX: function () {
          return b;
        },
        NEXT_CACHE_IMPLICIT_TAG_ID: function () {
          return E;
        },
        NEXT_CACHE_REVALIDATED_TAGS_HEADER: function () {
          return y;
        },
        NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function () {
          return x;
        },
        NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function () {
          return O;
        },
        NEXT_CACHE_TAGS_HEADER: function () {
          return _;
        },
        NEXT_CACHE_TAG_MAX_ITEMS: function () {
          return w;
        },
        NEXT_CACHE_TAG_MAX_LENGTH: function () {
          return S;
        },
        NEXT_DATA_SUFFIX: function () {
          return h;
        },
        NEXT_INTERCEPTION_MARKER_PREFIX: function () {
          return s;
        },
        NEXT_META_SUFFIX: function () {
          return v;
        },
        NEXT_QUERY_PARAM_PREFIX: function () {
          return o;
        },
        NEXT_RESUME_HEADER: function () {
          return $;
        },
        NON_STANDARD_NODE_ENV: function () {
          return Q;
        },
        PAGES_DIR_ALIAS: function () {
          return T;
        },
        PRERENDER_REVALIDATE_HEADER: function () {
          return l;
        },
        PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function () {
          return c;
        },
        PUBLIC_DIR_MIDDLEWARE_CONFLICT: function () {
          return F;
        },
        ROOT_DIR_ALIAS: function () {
          return A;
        },
        RSC_ACTION_CLIENT_WRAPPER_ALIAS: function () {
          return B;
        },
        RSC_ACTION_ENCRYPTION_ALIAS: function () {
          return M;
        },
        RSC_ACTION_PROXY_ALIAS: function () {
          return C;
        },
        RSC_ACTION_VALIDATE_ALIAS: function () {
          return z;
        },
        RSC_CACHE_WRAPPER_ALIAS: function () {
          return Z;
        },
        RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: function () {
          return L;
        },
        RSC_MOD_REF_PROXY_ALIAS: function () {
          return U;
        },
        RSC_PREFETCH_SUFFIX: function () {
          return d;
        },
        RSC_SEGMENTS_DIR_SUFFIX: function () {
          return f;
        },
        RSC_SEGMENT_SUFFIX: function () {
          return p;
        },
        RSC_SUFFIX: function () {
          return m;
        },
        SERVER_PROPS_EXPORT_ERROR: function () {
          return W;
        },
        SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function () {
          return V;
        },
        SERVER_PROPS_SSG_CONFLICT: function () {
          return X;
        },
        SERVER_RUNTIME: function () {
          return er;
        },
        SSG_FALLBACK_EXPORT_ERROR: function () {
          return ee;
        },
        SSG_GET_INITIAL_PROPS_CONFLICT: function () {
          return G;
        },
        STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function () {
          return q;
        },
        TEXT_PLAIN_CONTENT_TYPE_HEADER: function () {
          return n;
        },
        UNSTABLE_REVALIDATE_RENAME_ERROR: function () {
          return K;
        },
        WEBPACK_LAYERS: function () {
          return ei;
        },
        WEBPACK_RESOURCE_QUERIES: function () {
          return ea;
        },
      }));
    let n = 'text/plain',
      i = 'text/html; charset=utf-8',
      a = 'application/json; charset=utf-8',
      o = 'nxtP',
      s = 'nxtI',
      u = 'x-matched-path',
      l = 'x-prerender-revalidate',
      c = 'x-prerender-revalidate-if-generated',
      d = '.prefetch.rsc',
      f = '.segments',
      p = '.segment.rsc',
      m = '.rsc',
      g = '.action',
      h = '.json',
      v = '.meta',
      b = '.body',
      _ = 'x-next-cache-tags',
      y = 'x-next-revalidated-tags',
      x = 'x-next-revalidate-tag-token',
      $ = 'next-resume',
      w = 128,
      S = 256,
      O = 1024,
      E = '_N_T_',
      k = 31536e3,
      I = 0xfffffffe,
      P = 'middleware',
      N = `(?:src/)?${P}`,
      R = 'instrumentation',
      T = 'private-next-pages',
      j = 'private-dot-next',
      A = 'private-next-root-dir',
      D = 'private-next-app-dir',
      U = 'private-next-rsc-mod-ref-proxy',
      z = 'private-next-rsc-action-validate',
      C = 'private-next-rsc-server-reference',
      Z = 'private-next-rsc-cache-wrapper',
      L = 'private-next-rsc-track-dynamic-import',
      M = 'private-next-rsc-action-encryption',
      B = 'private-next-rsc-action-client-wrapper',
      F =
        "You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict",
      G =
        'You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps',
      V = 'You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.',
      X =
        'You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps',
      q =
        'can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props',
      W =
        'pages with `getServerSideProps` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export',
      H =
        'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?',
      J =
        'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?',
      K =
        'The `unstable_revalidate` property is available for general use.\nPlease use `revalidate` instead.',
      Y =
        "can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member",
      Q =
        'You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env',
      ee =
        'Pages with `fallback` enabled in `getStaticPaths` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export',
      et = ['app', 'pages', 'components', 'lib', 'src'],
      er = { edge: 'edge', experimentalEdge: 'experimental-edge', nodejs: 'nodejs' },
      en = {
        shared: 'shared',
        reactServerComponents: 'rsc',
        serverSideRendering: 'ssr',
        actionBrowser: 'action-browser',
        apiNode: 'api-node',
        apiEdge: 'api-edge',
        middleware: 'middleware',
        instrument: 'instrument',
        edgeAsset: 'edge-asset',
        appPagesBrowser: 'app-pages-browser',
        pagesDirBrowser: 'pages-dir-browser',
        pagesDirEdge: 'pages-dir-edge',
        pagesDirNode: 'pages-dir-node',
      },
      ei = {
        ...en,
        GROUP: {
          builtinReact: [en.reactServerComponents, en.actionBrowser],
          serverOnly: [en.reactServerComponents, en.actionBrowser, en.instrument, en.middleware],
          neutralTarget: [en.apiNode, en.apiEdge],
          clientOnly: [en.serverSideRendering, en.appPagesBrowser],
          bundled: [
            en.reactServerComponents,
            en.actionBrowser,
            en.serverSideRendering,
            en.appPagesBrowser,
            en.shared,
            en.instrument,
            en.middleware,
          ],
          appPages: [
            en.reactServerComponents,
            en.serverSideRendering,
            en.appPagesBrowser,
            en.actionBrowser,
          ],
        },
      },
      ea = {
        edgeSSREntry: '__next_edge_ssr_entry__',
        metadata: '__next_metadata__',
        metadataRoute: '__next_metadata_route__',
        metadataImageMeta: '__next_metadata_image_meta__',
      };
  },
  18646,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        fromNodeOutgoingHttpHeaders: function () {
          return i;
        },
        normalizeNextQueryParam: function () {
          return u;
        },
        splitCookiesString: function () {
          return a;
        },
        toNodeOutgoingHttpHeaders: function () {
          return o;
        },
        validateURL: function () {
          return s;
        },
      }));
    let n = e.r(71093);
    function i(e) {
      let t = new Headers();
      for (let [r, n] of Object.entries(e))
        for (let e of Array.isArray(n) ? n : [n])
          void 0 !== e && ('number' == typeof e && (e = e.toString()), t.append(r, e));
      return t;
    }
    function a(e) {
      var t,
        r,
        n,
        i,
        a,
        o = [],
        s = 0;
      function u() {
        for (; s < e.length && /\s/.test(e.charAt(s)); ) s += 1;
        return s < e.length;
      }
      for (; s < e.length; ) {
        for (t = s, a = !1; u(); )
          if (',' === (r = e.charAt(s))) {
            for (
              n = s, s += 1, u(), i = s;
              s < e.length && '=' !== (r = e.charAt(s)) && ';' !== r && ',' !== r;

            )
              s += 1;
            s < e.length && '=' === e.charAt(s)
              ? ((a = !0), (s = i), o.push(e.substring(t, n)), (t = s))
              : (s = n + 1);
          } else s += 1;
        (!a || s >= e.length) && o.push(e.substring(t, e.length));
      }
      return o;
    }
    function o(e) {
      let t = {},
        r = [];
      if (e)
        for (let [n, i] of e.entries())
          'set-cookie' === n.toLowerCase()
            ? (r.push(...a(i)), (t[n] = 1 === r.length ? r[0] : r))
            : (t[n] = i);
      return t;
    }
    function s(e) {
      try {
        return String(new URL(String(e)));
      } catch (t) {
        throw Object.defineProperty(
          Error(
            `URL is malformed "${String(e)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,
            { cause: t }
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E61', enumerable: !1, configurable: !0 }
        );
      }
    }
    function u(e) {
      for (let t of [n.NEXT_QUERY_PARAM_PREFIX, n.NEXT_INTERCEPTION_MARKER_PREFIX])
        if (e !== t && e.startsWith(t)) return e.substring(t.length);
      return null;
    }
  },
  60012,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        PageSignatureError: function () {
          return n;
        },
        RemovedPageError: function () {
          return i;
        },
        RemovedUAError: function () {
          return a;
        },
      }));
    class n extends Error {
      constructor({ page: e }) {
        super(`The middleware "${e}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    }
    class i extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class a extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }
  },
  50327,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        RequestCookies: function () {
          return n.RequestCookies;
        },
        ResponseCookies: function () {
          return n.ResponseCookies;
        },
        stringifyCookie: function () {
          return n.stringifyCookie;
        },
      }));
    let n = e.r(82159);
  },
  56193,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        INTERNALS: function () {
          return s;
        },
        NextRequest: function () {
          return u;
        },
      }));
    let n = e.r(9398),
      i = e.r(18646),
      a = e.r(60012),
      o = e.r(50327),
      s = Symbol('internal request');
    class u extends Request {
      constructor(e, t = {}) {
        let r = 'string' != typeof e && 'url' in e ? e.url : String(e);
        ((0, i.validateURL)(r),
          t.body && 'half' !== t.duplex && (t.duplex = 'half'),
          e instanceof Request ? super(e, t) : super(r, t));
        let a = new n.NextURL(r, {
          headers: (0, i.toNodeOutgoingHttpHeaders)(this.headers),
          nextConfig: t.nextConfig,
        });
        this[s] = { cookies: new o.RequestCookies(this.headers), nextUrl: a, url: a.toString() };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal,
        };
      }
      get cookies() {
        return this[s].cookies;
      }
      get nextUrl() {
        return this[s].nextUrl;
      }
      get page() {
        throw new a.RemovedPageError();
      }
      get ua() {
        throw new a.RemovedUAError();
      }
      get url() {
        return this[s].url;
      }
    }
  },
  82969,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'ReflectAdapter', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    class n {
      static get(e, t, r) {
        let n = Reflect.get(e, t, r);
        return 'function' == typeof n ? n.bind(e) : n;
      }
      static set(e, t, r, n) {
        return Reflect.set(e, t, r, n);
      }
      static has(e, t) {
        return Reflect.has(e, t);
      }
      static deleteProperty(e, t) {
        return Reflect.deleteProperty(e, t);
      }
    }
  },
  20147,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'NextResponse', {
        enumerable: !0,
        get: function () {
          return d;
        },
      }));
    let n = e.r(50327),
      i = e.r(9398),
      a = e.r(18646),
      o = e.r(82969),
      s = e.r(50327),
      u = Symbol('internal response'),
      l = new Set([301, 302, 303, 307, 308]);
    function c(e, t) {
      var r;
      if (null == e || null == (r = e.request) ? void 0 : r.headers) {
        if (!(e.request.headers instanceof Headers))
          throw Object.defineProperty(
            Error('request.headers must be an instance of Headers'),
            '__NEXT_ERROR_CODE',
            { value: 'E119', enumerable: !1, configurable: !0 }
          );
        let r = [];
        for (let [n, i] of e.request.headers) (t.set('x-middleware-request-' + n, i), r.push(n));
        t.set('x-middleware-override-headers', r.join(','));
      }
    }
    class d extends Response {
      constructor(e, t = {}) {
        super(e, t);
        let r = this.headers,
          l = new Proxy(new s.ResponseCookies(r), {
            get(e, i, a) {
              switch (i) {
                case 'delete':
                case 'set':
                  return (...a) => {
                    let o = Reflect.apply(e[i], e, a),
                      u = new Headers(r);
                    return (
                      o instanceof s.ResponseCookies &&
                        r.set(
                          'x-middleware-set-cookie',
                          o
                            .getAll()
                            .map((e) => (0, n.stringifyCookie)(e))
                            .join(',')
                        ),
                      c(t, u),
                      o
                    );
                  };
                default:
                  return o.ReflectAdapter.get(e, i, a);
              }
            },
          });
        this[u] = {
          cookies: l,
          url: t.url
            ? new i.NextURL(t.url, {
                headers: (0, a.toNodeOutgoingHttpHeaders)(r),
                nextConfig: t.nextConfig,
              })
            : void 0,
        };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          url: this.url,
          body: this.body,
          bodyUsed: this.bodyUsed,
          headers: Object.fromEntries(this.headers),
          ok: this.ok,
          redirected: this.redirected,
          status: this.status,
          statusText: this.statusText,
          type: this.type,
        };
      }
      get cookies() {
        return this[u].cookies;
      }
      static json(e, t) {
        let r = Response.json(e, t);
        return new d(r.body, r);
      }
      static redirect(e, t) {
        let r = 'number' == typeof t ? t : ((null == t ? void 0 : t.status) ?? 307);
        if (!l.has(r))
          throw Object.defineProperty(
            RangeError('Failed to execute "redirect" on "response": Invalid status code'),
            '__NEXT_ERROR_CODE',
            { value: 'E529', enumerable: !1, configurable: !0 }
          );
        let n = 'object' == typeof t ? t : {},
          i = new Headers(null == n ? void 0 : n.headers);
        return (
          i.set('Location', (0, a.validateURL)(e)),
          new d(null, { ...n, headers: i, status: r })
        );
      }
      static rewrite(e, t) {
        let r = new Headers(null == t ? void 0 : t.headers);
        return (
          r.set('x-middleware-rewrite', (0, a.validateURL)(e)),
          c(t, r),
          new d(null, { ...t, headers: r })
        );
      }
      static next(e) {
        let t = new Headers(null == e ? void 0 : e.headers);
        return (t.set('x-middleware-next', '1'), c(e, t), new d(null, { ...e, headers: t }));
      }
    }
  },
  65190,
  (e, t, r) => {
    'use strict';
    function n() {
      throw Object.defineProperty(
        Error(
          'ImageResponse moved from "next/server" to "next/og" since Next.js 14, please import from "next/og" instead'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E183', enumerable: !1, configurable: !0 }
      );
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'ImageResponse', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
  },
  44094,
  (e, t, r) => {
    (() => {
      var r = {
          226: function (t, r) {
            !(function (n, i) {
              'use strict';
              var a = 'function',
                o = 'undefined',
                s = 'object',
                u = 'string',
                l = 'major',
                c = 'model',
                d = 'name',
                f = 'type',
                p = 'vendor',
                m = 'version',
                g = 'architecture',
                h = 'console',
                v = 'mobile',
                b = 'tablet',
                _ = 'smarttv',
                y = 'wearable',
                x = 'embedded',
                $ = 'Amazon',
                w = 'Apple',
                S = 'ASUS',
                O = 'BlackBerry',
                E = 'Browser',
                k = 'Chrome',
                I = 'Firefox',
                P = 'Google',
                N = 'Huawei',
                R = 'Microsoft',
                T = 'Motorola',
                j = 'Opera',
                A = 'Samsung',
                D = 'Sharp',
                U = 'Sony',
                z = 'Xiaomi',
                C = 'Zebra',
                Z = 'Facebook',
                L = 'Chromium OS',
                M = 'Mac OS',
                B = function (e, t) {
                  var r = {};
                  for (var n in e)
                    t[n] && t[n].length % 2 == 0 ? (r[n] = t[n].concat(e[n])) : (r[n] = e[n]);
                  return r;
                },
                F = function (e) {
                  for (var t = {}, r = 0; r < e.length; r++) t[e[r].toUpperCase()] = e[r];
                  return t;
                },
                G = function (e, t) {
                  return typeof e === u && -1 !== V(t).indexOf(V(e));
                },
                V = function (e) {
                  return e.toLowerCase();
                },
                X = function (e, t) {
                  if (typeof e === u)
                    return (
                      (e = e.replace(/^\s\s*/, '')),
                      typeof t === o ? e : e.substring(0, 350)
                    );
                },
                q = function (e, t) {
                  for (var r, n, o, u, l, c, d = 0; d < t.length && !l; ) {
                    var f = t[d],
                      p = t[d + 1];
                    for (r = n = 0; r < f.length && !l && f[r]; )
                      if ((l = f[r++].exec(e)))
                        for (o = 0; o < p.length; o++)
                          ((c = l[++n]),
                            typeof (u = p[o]) === s && u.length > 0
                              ? 2 === u.length
                                ? typeof u[1] == a
                                  ? (this[u[0]] = u[1].call(this, c))
                                  : (this[u[0]] = u[1])
                                : 3 === u.length
                                  ? typeof u[1] !== a || (u[1].exec && u[1].test)
                                    ? (this[u[0]] = c ? c.replace(u[1], u[2]) : void 0)
                                    : (this[u[0]] = c ? u[1].call(this, c, u[2]) : void 0)
                                  : 4 === u.length &&
                                    (this[u[0]] = c ? u[3].call(this, c.replace(u[1], u[2])) : i)
                              : (this[u] = c || i));
                    d += 2;
                  }
                },
                W = function (e, t) {
                  for (var r in t)
                    if (typeof t[r] === s && t[r].length > 0) {
                      for (var n = 0; n < t[r].length; n++)
                        if (G(t[r][n], e)) return '?' === r ? i : r;
                    } else if (G(t[r], e)) return '?' === r ? i : r;
                  return e;
                },
                H = {
                  ME: '4.90',
                  'NT 3.11': 'NT3.51',
                  'NT 4.0': 'NT4.0',
                  2e3: 'NT 5.0',
                  XP: ['NT 5.1', 'NT 5.2'],
                  Vista: 'NT 6.0',
                  7: 'NT 6.1',
                  8: 'NT 6.2',
                  8.1: 'NT 6.3',
                  10: ['NT 6.4', 'NT 10.0'],
                  RT: 'ARM',
                },
                J = {
                  browser: [
                    [/\b(?:crmo|crios)\/([\w\.]+)/i],
                    [m, [d, 'Chrome']],
                    [/edg(?:e|ios|a)?\/([\w\.]+)/i],
                    [m, [d, 'Edge']],
                    [
                      /(opera mini)\/([-\w\.]+)/i,
                      /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                      /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i,
                    ],
                    [d, m],
                    [/opios[\/ ]+([\w\.]+)/i],
                    [m, [d, j + ' Mini']],
                    [/\bopr\/([\w\.]+)/i],
                    [m, [d, j]],
                    [
                      /(kindle)\/([\w\.]+)/i,
                      /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                      /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                      /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                      /(?:ms|\()(ie) ([\w\.]+)/i,
                      /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
                      /(heytap|ovi)browser\/([\d\.]+)/i,
                      /(weibo)__([\d\.]+)/i,
                    ],
                    [d, m],
                    [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],
                    [m, [d, 'UC' + E]],
                    [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i],
                    [m, [d, 'WeChat(Win) Desktop']],
                    [/micromessenger\/([\w\.]+)/i],
                    [m, [d, 'WeChat']],
                    [/konqueror\/([\w\.]+)/i],
                    [m, [d, 'Konqueror']],
                    [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],
                    [m, [d, 'IE']],
                    [/ya(?:search)?browser\/([\w\.]+)/i],
                    [m, [d, 'Yandex']],
                    [/(avast|avg)\/([\w\.]+)/i],
                    [[d, /(.+)/, '$1 Secure ' + E], m],
                    [/\bfocus\/([\w\.]+)/i],
                    [m, [d, I + ' Focus']],
                    [/\bopt\/([\w\.]+)/i],
                    [m, [d, j + ' Touch']],
                    [/coc_coc\w+\/([\w\.]+)/i],
                    [m, [d, 'Coc Coc']],
                    [/dolfin\/([\w\.]+)/i],
                    [m, [d, 'Dolphin']],
                    [/coast\/([\w\.]+)/i],
                    [m, [d, j + ' Coast']],
                    [/miuibrowser\/([\w\.]+)/i],
                    [m, [d, 'MIUI ' + E]],
                    [/fxios\/([-\w\.]+)/i],
                    [m, [d, I]],
                    [/\bqihu|(qi?ho?o?|360)browser/i],
                    [[d, '360 ' + E]],
                    [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],
                    [[d, /(.+)/, '$1 ' + E], m],
                    [/(comodo_dragon)\/([\w\.]+)/i],
                    [[d, /_/g, ' '], m],
                    [
                      /(electron)\/([\w\.]+) safari/i,
                      /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                      /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i,
                    ],
                    [d, m],
                    [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i],
                    [d],
                    [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],
                    [[d, Z], m],
                    [
                      /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
                      /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
                      /safari (line)\/([\w\.]+)/i,
                      /\b(line)\/([\w\.]+)\/iab/i,
                      /(chromium|instagram)[\/ ]([-\w\.]+)/i,
                    ],
                    [d, m],
                    [/\bgsa\/([\w\.]+) .*safari\//i],
                    [m, [d, 'GSA']],
                    [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i],
                    [m, [d, 'TikTok']],
                    [/headlesschrome(?:\/([\w\.]+)| )/i],
                    [m, [d, k + ' Headless']],
                    [/ wv\).+(chrome)\/([\w\.]+)/i],
                    [[d, k + ' WebView'], m],
                    [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],
                    [m, [d, 'Android ' + E]],
                    [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],
                    [d, m],
                    [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],
                    [m, [d, 'Mobile Safari']],
                    [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],
                    [m, d],
                    [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],
                    [
                      d,
                      [
                        m,
                        W,
                        {
                          '1.0': '/8',
                          1.2: '/1',
                          1.3: '/3',
                          '2.0': '/412',
                          '2.0.2': '/416',
                          '2.0.3': '/417',
                          '2.0.4': '/419',
                          '?': '/',
                        },
                      ],
                    ],
                    [/(webkit|khtml)\/([\w\.]+)/i],
                    [d, m],
                    [/(navigator|netscape\d?)\/([-\w\.]+)/i],
                    [[d, 'Netscape'], m],
                    [/mobile vr; rv:([\w\.]+)\).+firefox/i],
                    [m, [d, I + ' Reality']],
                    [
                      /ekiohf.+(flow)\/([\w\.]+)/i,
                      /(swiftfox)/i,
                      /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                      /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                      /(firefox)\/([\w\.]+)/i,
                      /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                      /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                      /(links) \(([\w\.]+)/i,
                      /panasonic;(viera)/i,
                    ],
                    [d, m],
                    [/(cobalt)\/([\w\.]+)/i],
                    [d, [m, /master.|lts./, '']],
                  ],
                  cpu: [
                    [/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],
                    [[g, 'amd64']],
                    [/(ia32(?=;))/i],
                    [[g, V]],
                    [/((?:i[346]|x)86)[;\)]/i],
                    [[g, 'ia32']],
                    [/\b(aarch64|arm(v?8e?l?|_?64))\b/i],
                    [[g, 'arm64']],
                    [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],
                    [[g, 'armhf']],
                    [/windows (ce|mobile); ppc;/i],
                    [[g, 'arm']],
                    [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],
                    [[g, /ower/, '', V]],
                    [/(sun4\w)[;\)]/i],
                    [[g, 'sparc']],
                    [
                      /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i,
                    ],
                    [[g, V]],
                  ],
                  device: [
                    [
                      /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i,
                    ],
                    [c, [p, A], [f, b]],
                    [
                      /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
                      /samsung[- ]([-\w]+)/i,
                      /sec-(sgh\w+)/i,
                    ],
                    [c, [p, A], [f, v]],
                    [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i],
                    [c, [p, w], [f, v]],
                    [
                      /\((ipad);[-\w\),; ]+apple/i,
                      /applecoremedia\/[\w\.]+ \((ipad)/i,
                      /\b(ipad)\d\d?,\d\d?[;\]].+ios/i,
                    ],
                    [c, [p, w], [f, b]],
                    [/(macintosh);/i],
                    [c, [p, w]],
                    [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],
                    [c, [p, D], [f, v]],
                    [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],
                    [c, [p, N], [f, b]],
                    [
                      /(?:huawei|honor)([-\w ]+)[;\)]/i,
                      /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i,
                    ],
                    [c, [p, N], [f, v]],
                    [
                      /\b(poco[\w ]+)(?: bui|\))/i,
                      /\b; (\w+) build\/hm\1/i,
                      /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                      /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                      /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i,
                    ],
                    [
                      [c, /_/g, ' '],
                      [p, z],
                      [f, v],
                    ],
                    [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],
                    [
                      [c, /_/g, ' '],
                      [p, z],
                      [f, b],
                    ],
                    [
                      /; (\w+) bui.+ oppo/i,
                      /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i,
                    ],
                    [c, [p, 'OPPO'], [f, v]],
                    [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i],
                    [c, [p, 'Vivo'], [f, v]],
                    [/\b(rmx[12]\d{3})(?: bui|;|\))/i],
                    [c, [p, 'Realme'], [f, v]],
                    [
                      /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                      /\bmot(?:orola)?[- ](\w*)/i,
                      /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i,
                    ],
                    [c, [p, T], [f, v]],
                    [/\b(mz60\d|xoom[2 ]{0,2}) build\//i],
                    [c, [p, T], [f, b]],
                    [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],
                    [c, [p, 'LG'], [f, b]],
                    [
                      /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                      /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                      /\blg-?([\d\w]+) bui/i,
                    ],
                    [c, [p, 'LG'], [f, v]],
                    [
                      /(ideatab[-\w ]+)/i,
                      /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i,
                    ],
                    [c, [p, 'Lenovo'], [f, b]],
                    [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i],
                    [
                      [c, /_/g, ' '],
                      [p, 'Nokia'],
                      [f, v],
                    ],
                    [/(pixel c)\b/i],
                    [c, [p, P], [f, b]],
                    [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],
                    [c, [p, P], [f, v]],
                    [
                      /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i,
                    ],
                    [c, [p, U], [f, v]],
                    [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i],
                    [
                      [c, 'Xperia Tablet'],
                      [p, U],
                      [f, b],
                    ],
                    [
                      / (kb2005|in20[12]5|be20[12][59])\b/i,
                      /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i,
                    ],
                    [c, [p, 'OnePlus'], [f, v]],
                    [
                      /(alexa)webm/i,
                      /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
                      /(kf[a-z]+)( bui|\)).+silk\//i,
                    ],
                    [c, [p, $], [f, b]],
                    [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],
                    [
                      [c, /(.+)/g, 'Fire Phone $1'],
                      [p, $],
                      [f, v],
                    ],
                    [/(playbook);[-\w\),; ]+(rim)/i],
                    [c, p, [f, b]],
                    [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i],
                    [c, [p, O], [f, v]],
                    [
                      /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i,
                    ],
                    [c, [p, S], [f, b]],
                    [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],
                    [c, [p, S], [f, v]],
                    [/(nexus 9)/i],
                    [c, [p, 'HTC'], [f, b]],
                    [
                      /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                      /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                      /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i,
                    ],
                    [p, [c, /_/g, ' '], [f, v]],
                    [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],
                    [c, [p, 'Acer'], [f, b]],
                    [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i],
                    [c, [p, 'Meizu'], [f, v]],
                    [
                      /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                      /(hp) ([\w ]+\w)/i,
                      /(asus)-?(\w+)/i,
                      /(microsoft); (lumia[\w ]+)/i,
                      /(lenovo)[-_ ]?([-\w]+)/i,
                      /(jolla)/i,
                      /(oppo) ?([\w ]+) bui/i,
                    ],
                    [p, c, [f, v]],
                    [
                      /(kobo)\s(ereader|touch)/i,
                      /(archos) (gamepad2?)/i,
                      /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                      /(kindle)\/([\w\.]+)/i,
                      /(nook)[\w ]+build\/(\w+)/i,
                      /(dell) (strea[kpr\d ]*[\dko])/i,
                      /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                      /(trinity)[- ]*(t\d{3}) bui/i,
                      /(gigaset)[- ]+(q\w{1,9}) bui/i,
                      /(vodafone) ([\w ]+)(?:\)| bui)/i,
                    ],
                    [p, c, [f, b]],
                    [/(surface duo)/i],
                    [c, [p, R], [f, b]],
                    [/droid [\d\.]+; (fp\du?)(?: b|\))/i],
                    [c, [p, 'Fairphone'], [f, v]],
                    [/(u304aa)/i],
                    [c, [p, 'AT&T'], [f, v]],
                    [/\bsie-(\w*)/i],
                    [c, [p, 'Siemens'], [f, v]],
                    [/\b(rct\w+) b/i],
                    [c, [p, 'RCA'], [f, b]],
                    [/\b(venue[\d ]{2,7}) b/i],
                    [c, [p, 'Dell'], [f, b]],
                    [/\b(q(?:mv|ta)\w+) b/i],
                    [c, [p, 'Verizon'], [f, b]],
                    [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],
                    [c, [p, 'Barnes & Noble'], [f, b]],
                    [/\b(tm\d{3}\w+) b/i],
                    [c, [p, 'NuVision'], [f, b]],
                    [/\b(k88) b/i],
                    [c, [p, 'ZTE'], [f, b]],
                    [/\b(nx\d{3}j) b/i],
                    [c, [p, 'ZTE'], [f, v]],
                    [/\b(gen\d{3}) b.+49h/i],
                    [c, [p, 'Swiss'], [f, v]],
                    [/\b(zur\d{3}) b/i],
                    [c, [p, 'Swiss'], [f, b]],
                    [/\b((zeki)?tb.*\b) b/i],
                    [c, [p, 'Zeki'], [f, b]],
                    [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i],
                    [[p, 'Dragon Touch'], c, [f, b]],
                    [/\b(ns-?\w{0,9}) b/i],
                    [c, [p, 'Insignia'], [f, b]],
                    [/\b((nxa|next)-?\w{0,9}) b/i],
                    [c, [p, 'NextBook'], [f, b]],
                    [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],
                    [[p, 'Voice'], c, [f, v]],
                    [/\b(lvtel\-)?(v1[12]) b/i],
                    [[p, 'LvTel'], c, [f, v]],
                    [/\b(ph-1) /i],
                    [c, [p, 'Essential'], [f, v]],
                    [/\b(v(100md|700na|7011|917g).*\b) b/i],
                    [c, [p, 'Envizen'], [f, b]],
                    [/\b(trio[-\w\. ]+) b/i],
                    [c, [p, 'MachSpeed'], [f, b]],
                    [/\btu_(1491) b/i],
                    [c, [p, 'Rotor'], [f, b]],
                    [/(shield[\w ]+) b/i],
                    [c, [p, 'Nvidia'], [f, b]],
                    [/(sprint) (\w+)/i],
                    [p, c, [f, v]],
                    [/(kin\.[onetw]{3})/i],
                    [
                      [c, /\./g, ' '],
                      [p, R],
                      [f, v],
                    ],
                    [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],
                    [c, [p, C], [f, b]],
                    [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],
                    [c, [p, C], [f, v]],
                    [/smart-tv.+(samsung)/i],
                    [p, [f, _]],
                    [/hbbtv.+maple;(\d+)/i],
                    [
                      [c, /^/, 'SmartTV'],
                      [p, A],
                      [f, _],
                    ],
                    [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],
                    [
                      [p, 'LG'],
                      [f, _],
                    ],
                    [/(apple) ?tv/i],
                    [p, [c, w + ' TV'], [f, _]],
                    [/crkey/i],
                    [
                      [c, k + 'cast'],
                      [p, P],
                      [f, _],
                    ],
                    [/droid.+aft(\w)( bui|\))/i],
                    [c, [p, $], [f, _]],
                    [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i],
                    [c, [p, D], [f, _]],
                    [/(bravia[\w ]+)( bui|\))/i],
                    [c, [p, U], [f, _]],
                    [/(mitv-\w{5}) bui/i],
                    [c, [p, z], [f, _]],
                    [/Hbbtv.*(technisat) (.*);/i],
                    [p, c, [f, _]],
                    [
                      /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                      /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i,
                    ],
                    [
                      [p, X],
                      [c, X],
                      [f, _],
                    ],
                    [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],
                    [[f, _]],
                    [/(ouya)/i, /(nintendo) ([wids3utch]+)/i],
                    [p, c, [f, h]],
                    [/droid.+; (shield) bui/i],
                    [c, [p, 'Nvidia'], [f, h]],
                    [/(playstation [345portablevi]+)/i],
                    [c, [p, U], [f, h]],
                    [/\b(xbox(?: one)?(?!; xbox))[\); ]/i],
                    [c, [p, R], [f, h]],
                    [/((pebble))app/i],
                    [p, c, [f, y]],
                    [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],
                    [c, [p, w], [f, y]],
                    [/droid.+; (glass) \d/i],
                    [c, [p, P], [f, y]],
                    [/droid.+; (wt63?0{2,3})\)/i],
                    [c, [p, C], [f, y]],
                    [/(quest( 2| pro)?)/i],
                    [c, [p, Z], [f, y]],
                    [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],
                    [p, [f, x]],
                    [/(aeobc)\b/i],
                    [c, [p, $], [f, x]],
                    [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],
                    [c, [f, v]],
                    [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],
                    [c, [f, b]],
                    [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],
                    [[f, b]],
                    [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],
                    [[f, v]],
                    [/(android[-\w\. ]{0,9});.+buil/i],
                    [c, [p, 'Generic']],
                  ],
                  engine: [
                    [/windows.+ edge\/([\w\.]+)/i],
                    [m, [d, 'EdgeHTML']],
                    [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],
                    [m, [d, 'Blink']],
                    [
                      /(presto)\/([\w\.]+)/i,
                      /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                      /ekioh(flow)\/([\w\.]+)/i,
                      /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                      /(icab)[\/ ]([23]\.[\d\.]+)/i,
                      /\b(libweb)/i,
                    ],
                    [d, m],
                    [/rv\:([\w\.]{1,9})\b.+(gecko)/i],
                    [m, d],
                  ],
                  os: [
                    [/microsoft (windows) (vista|xp)/i],
                    [d, m],
                    [
                      /(windows) nt 6\.2; (arm)/i,
                      /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                      /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
                    ],
                    [d, [m, W, H]],
                    [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],
                    [
                      [d, 'Windows'],
                      [m, W, H],
                    ],
                    [
                      /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                      /ios;fbsv\/([\d\.]+)/i,
                      /cfnetwork\/.+darwin/i,
                    ],
                    [
                      [m, /_/g, '.'],
                      [d, 'iOS'],
                    ],
                    [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i],
                    [
                      [d, M],
                      [m, /_/g, '.'],
                    ],
                    [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],
                    [m, d],
                    [
                      /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                      /(blackberry)\w*\/([\w\.]*)/i,
                      /(tizen|kaios)[\/ ]([\w\.]+)/i,
                      /\((series40);/i,
                    ],
                    [d, m],
                    [/\(bb(10);/i],
                    [m, [d, O]],
                    [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],
                    [m, [d, 'Symbian']],
                    [
                      /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i,
                    ],
                    [m, [d, I + ' OS']],
                    [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],
                    [m, [d, 'webOS']],
                    [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],
                    [m, [d, 'watchOS']],
                    [/crkey\/([\d\.]+)/i],
                    [m, [d, k + 'cast']],
                    [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],
                    [[d, L], m],
                    [
                      /panasonic;(viera)/i,
                      /(netrange)mmh/i,
                      /(nettv)\/(\d+\.[\w\.]+)/i,
                      /(nintendo|playstation) ([wids345portablevuch]+)/i,
                      /(xbox); +xbox ([^\);]+)/i,
                      /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                      /(mint)[\/\(\) ]?(\w*)/i,
                      /(mageia|vectorlinux)[; ]/i,
                      /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                      /(hurd|linux) ?([\w\.]*)/i,
                      /(gnu) ?([\w\.]*)/i,
                      /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                      /(haiku) (\w+)/i,
                    ],
                    [d, m],
                    [/(sunos) ?([\w\.\d]*)/i],
                    [[d, 'Solaris'], m],
                    [
                      /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                      /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                      /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
                      /(unix) ?([\w\.]*)/i,
                    ],
                    [d, m],
                  ],
                },
                K = function (e, t) {
                  if ((typeof e === s && ((t = e), (e = i)), !(this instanceof K)))
                    return new K(e, t).getResult();
                  var r = typeof n !== o && n.navigator ? n.navigator : i,
                    h = e || (r && r.userAgent ? r.userAgent : ''),
                    _ = r && r.userAgentData ? r.userAgentData : i,
                    y = t ? B(J, t) : J,
                    x = r && r.userAgent == h;
                  return (
                    (this.getBrowser = function () {
                      var e,
                        t = {};
                      return (
                        (t[d] = i),
                        (t[m] = i),
                        q.call(t, h, y.browser),
                        (t[l] =
                          typeof (e = t[m]) === u ? e.replace(/[^\d\.]/g, '').split('.')[0] : i),
                        x && r && r.brave && typeof r.brave.isBrave == a && (t[d] = 'Brave'),
                        t
                      );
                    }),
                    (this.getCPU = function () {
                      var e = {};
                      return ((e[g] = i), q.call(e, h, y.cpu), e);
                    }),
                    (this.getDevice = function () {
                      var e = {};
                      return (
                        (e[p] = i),
                        (e[c] = i),
                        (e[f] = i),
                        q.call(e, h, y.device),
                        x && !e[f] && _ && _.mobile && (e[f] = v),
                        x &&
                          'Macintosh' == e[c] &&
                          r &&
                          typeof r.standalone !== o &&
                          r.maxTouchPoints &&
                          r.maxTouchPoints > 2 &&
                          ((e[c] = 'iPad'), (e[f] = b)),
                        e
                      );
                    }),
                    (this.getEngine = function () {
                      var e = {};
                      return ((e[d] = i), (e[m] = i), q.call(e, h, y.engine), e);
                    }),
                    (this.getOS = function () {
                      var e = {};
                      return (
                        (e[d] = i),
                        (e[m] = i),
                        q.call(e, h, y.os),
                        x &&
                          !e[d] &&
                          _ &&
                          'Unknown' != _.platform &&
                          (e[d] = _.platform.replace(/chrome os/i, L).replace(/macos/i, M)),
                        e
                      );
                    }),
                    (this.getResult = function () {
                      return {
                        ua: this.getUA(),
                        browser: this.getBrowser(),
                        engine: this.getEngine(),
                        os: this.getOS(),
                        device: this.getDevice(),
                        cpu: this.getCPU(),
                      };
                    }),
                    (this.getUA = function () {
                      return h;
                    }),
                    (this.setUA = function (e) {
                      return ((h = typeof e === u && e.length > 350 ? X(e, 350) : e), this);
                    }),
                    this.setUA(h),
                    this
                  );
                };
              if (
                ((K.VERSION = '1.0.35'),
                (K.BROWSER = F([d, m, l])),
                (K.CPU = F([g])),
                (K.DEVICE = F([c, p, f, h, v, _, b, y, x])),
                (K.ENGINE = K.OS = F([d, m])),
                typeof r !== o)
              )
                (t.exports && (r = t.exports = K), (r.UAParser = K));
              else if (typeof define === a && define.amd) (e.r, void 0 !== K && e.v(K));
              else typeof n !== o && (n.UAParser = K);
              var Y = typeof n !== o && (n.jQuery || n.Zepto);
              if (Y && !Y.ua) {
                var Q = new K();
                ((Y.ua = Q.getResult()),
                  (Y.ua.get = function () {
                    return Q.getUA();
                  }),
                  (Y.ua.set = function (e) {
                    Q.setUA(e);
                    var t = Q.getResult();
                    for (var r in t) Y.ua[r] = t[r];
                  }));
              }
            })(this);
          },
        },
        n = {};
      function i(e) {
        var t = n[e];
        if (void 0 !== t) return t.exports;
        var a = (n[e] = { exports: {} }),
          o = !0;
        try {
          (r[e].call(a.exports, a, a.exports, i), (o = !1));
        } finally {
          o && delete n[e];
        }
        return a.exports;
      }
      ((i.ab =
        '/ROOT/node_modules/.pnpm/next@15.5.2_@babel+core@7.28.3_@opentelemetry+api@1.9.0_@playwright+test@1.55.0_react-d_e236737f00d0c8f73a9e6975c9f9321d/node_modules/next/dist/compiled/ua-parser-js/'),
        (t.exports = i(226)));
    })();
  },
  22822,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        isBot: function () {
          return i;
        },
        userAgent: function () {
          return o;
        },
        userAgentFromString: function () {
          return a;
        },
      }));
    let n = (function (e) {
      return e && e.__esModule ? e : { default: e };
    })(e.r(44094));
    function i(e) {
      return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Google-InspectionTool|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(
        e
      );
    }
    function a(e) {
      return { ...(0, n.default)(e), isBot: void 0 !== e && i(e) };
    }
    function o({ headers: e }) {
      return a(e.get('user-agent') || void 0);
    }
  },
  73161,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'URLPattern', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    let n = 'undefined' == typeof URLPattern ? void 0 : URLPattern;
  },
  93504,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'after', {
        enumerable: !0,
        get: function () {
          return i;
        },
      }));
    let n = e.r(56704);
    function i(e) {
      let t = n.workAsyncStorage.getStore();
      if (!t)
        throw Object.defineProperty(
          Error(
            '`after` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context'
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E468', enumerable: !1, configurable: !0 }
        );
      let { afterContext: r } = t;
      return r.after(e);
    }
  },
  74171,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      (function (e, t) {
        Object.keys(e).forEach(function (r) {
          'default' === r ||
            Object.prototype.hasOwnProperty.call(t, r) ||
            Object.defineProperty(t, r, {
              enumerable: !0,
              get: function () {
                return e[r];
              },
            });
        });
      })(e.r(93504), r));
  },
  80690,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        DynamicServerError: function () {
          return i;
        },
        isDynamicServerError: function () {
          return a;
        },
      }));
    let n = 'DYNAMIC_SERVER_USAGE';
    class i extends Error {
      constructor(e) {
        (super('Dynamic server usage: ' + e), (this.description = e), (this.digest = n));
      }
    }
    function a(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        'digest' in e &&
        'string' == typeof e.digest &&
        e.digest === n
      );
    }
    ('function' == typeof r.default || ('object' == typeof r.default && null !== r.default)) &&
      void 0 === r.default.__esModule &&
      (Object.defineProperty(r.default, '__esModule', { value: !0 }),
      Object.assign(r.default, r),
      (t.exports = r.default));
  },
  36359,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        StaticGenBailoutError: function () {
          return i;
        },
        isStaticGenBailoutError: function () {
          return a;
        },
      }));
    let n = 'NEXT_STATIC_GEN_BAILOUT';
    class i extends Error {
      constructor(...e) {
        (super(...e), (this.code = n));
      }
    }
    function a(e) {
      return 'object' == typeof e && null !== e && 'code' in e && e.code === n;
    }
    ('function' == typeof r.default || ('object' == typeof r.default && null !== r.default)) &&
      void 0 === r.default.__esModule &&
      (Object.defineProperty(r.default, '__esModule', { value: !0 }),
      Object.assign(r.default, r),
      (t.exports = r.default));
  },
  77547,
  (e, t, r) => {
    'use strict';
    function n(e) {
      return 'object' == typeof e && null !== e && 'digest' in e && e.digest === i;
    }
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        isHangingPromiseRejectionError: function () {
          return n;
        },
        makeDevtoolsIOAwarePromise: function () {
          return l;
        },
        makeHangingPromise: function () {
          return s;
        },
      }));
    let i = 'HANGING_PROMISE_REJECTION';
    class a extends Error {
      constructor(e, t) {
        (super(
          `During prerendering, ${t} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${t} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route "${e}".`
        ),
          (this.route = e),
          (this.expression = t),
          (this.digest = i));
      }
    }
    let o = new WeakMap();
    function s(e, t, r) {
      if (e.aborted) return Promise.reject(new a(t, r));
      {
        let n = new Promise((n, i) => {
          let s = i.bind(null, new a(t, r)),
            u = o.get(e);
          if (u) u.push(s);
          else {
            let t = [s];
            (o.set(e, t),
              e.addEventListener(
                'abort',
                () => {
                  for (let e = 0; e < t.length; e++) t[e]();
                },
                { once: !0 }
              ));
          }
        });
        return (n.catch(u), n);
      }
    }
    function u() {}
    function l(e) {
      return new Promise((t) => {
        setTimeout(() => {
          t(e);
        }, 0);
      });
    }
  },
  29366,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        METADATA_BOUNDARY_NAME: function () {
          return n;
        },
        OUTLET_BOUNDARY_NAME: function () {
          return a;
        },
        ROOT_LAYOUT_BOUNDARY_NAME: function () {
          return o;
        },
        VIEWPORT_BOUNDARY_NAME: function () {
          return i;
        },
      }));
    let n = '__next_metadata_boundary__',
      i = '__next_viewport_boundary__',
      a = '__next_outlet_boundary__',
      o = '__next_root_layout_boundary__';
  },
  47050,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        atLeastOneTask: function () {
          return a;
        },
        scheduleImmediate: function () {
          return i;
        },
        scheduleOnNextTick: function () {
          return n;
        },
        waitAtLeastOneReactRenderTask: function () {
          return o;
        },
      }));
    let n = (e) => {
        Promise.resolve().then(() => {
          process.nextTick(e);
        });
      },
      i = (e) => {
        setImmediate(e);
      };
    function a() {
      return new Promise((e) => i(e));
    }
    function o() {
      return new Promise((e) => setImmediate(e));
    }
  },
  17011,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        BailoutToCSRError: function () {
          return i;
        },
        isBailoutToCSRError: function () {
          return a;
        },
      }));
    let n = 'BAILOUT_TO_CLIENT_SIDE_RENDERING';
    class i extends Error {
      constructor(e) {
        (super('Bail out to client-side rendering: ' + e), (this.reason = e), (this.digest = n));
      }
    }
    function a(e) {
      return 'object' == typeof e && null !== e && 'digest' in e && e.digest === n;
    }
  },
  45436,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'InvariantError', {
        enumerable: !0,
        get: function () {
          return n;
        },
      }));
    class n extends Error {
      constructor(e, t) {
        (super('Invariant: ' + (e.endsWith('.') ? e : e + '.') + ' This is a bug in Next.js.', t),
          (this.name = 'InvariantError'));
      }
    }
  },
  46583,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        Postpone: function () {
          return E;
        },
        PreludeState: function () {
          return q;
        },
        abortAndThrowOnSynchronousRequestDataAccess: function () {
          return w;
        },
        abortOnSynchronousPlatformIOAccess: function () {
          return x;
        },
        accessedDynamicData: function () {
          return A;
        },
        annotateDynamicAccess: function () {
          return Z;
        },
        consumeDynamicAccess: function () {
          return D;
        },
        createDynamicTrackingState: function () {
          return m;
        },
        createDynamicValidationState: function () {
          return g;
        },
        createHangingInputAbortSignal: function () {
          return C;
        },
        createRenderInBrowserAbortSignal: function () {
          return z;
        },
        delayUntilRuntimeStage: function () {
          return J;
        },
        formatDynamicAPIAccesses: function () {
          return U;
        },
        getFirstDynamicReason: function () {
          return h;
        },
        isDynamicPostpone: function () {
          return P;
        },
        isPrerenderInterruptedError: function () {
          return j;
        },
        logDisallowedDynamicError: function () {
          return W;
        },
        markCurrentScopeAsDynamic: function () {
          return v;
        },
        postponeWithTracking: function () {
          return k;
        },
        throwIfDisallowedDynamic: function () {
          return H;
        },
        throwToInterruptStaticGeneration: function () {
          return b;
        },
        trackAllowedDynamicAccess: function () {
          return X;
        },
        trackDynamicDataInDynamicRender: function () {
          return _;
        },
        trackSynchronousPlatformIOAccessInDev: function () {
          return $;
        },
        trackSynchronousRequestDataAccessInDev: function () {
          return O;
        },
        useDynamicRouteParams: function () {
          return L;
        },
        warnOnSyncDynamicError: function () {
          return S;
        },
      }));
    let n = (function (e) {
        return e && e.__esModule ? e : { default: e };
      })(e.r(91392)),
      i = e.r(80690),
      a = e.r(36359),
      o = e.r(32319),
      s = e.r(56704),
      u = e.r(77547),
      l = e.r(29366),
      c = e.r(47050),
      d = e.r(17011),
      f = e.r(45436),
      p = 'function' == typeof n.default.unstable_postpone;
    function m(e) {
      return { isDebugDynamicAccesses: e, dynamicAccesses: [], syncDynamicErrorWithStack: null };
    }
    function g() {
      return {
        hasSuspenseAboveBody: !1,
        hasDynamicMetadata: !1,
        hasDynamicViewport: !1,
        hasAllowedDynamic: !1,
        dynamicErrors: [],
      };
    }
    function h(e) {
      var t;
      return null == (t = e.dynamicAccesses[0]) ? void 0 : t.expression;
    }
    function v(e, t, r) {
      if (t)
        switch (t.type) {
          case 'cache':
          case 'unstable-cache':
          case 'private-cache':
            return;
        }
      if (!e.forceDynamic && !e.forceStatic) {
        if (e.dynamicShouldError)
          throw Object.defineProperty(
            new a.StaticGenBailoutError(
              `Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${r}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E553', enumerable: !1, configurable: !0 }
          );
        if (t)
          switch (t.type) {
            case 'prerender-ppr':
              return k(e.route, r, t.dynamicTracking);
            case 'prerender-legacy':
              t.revalidate = 0;
              let n = Object.defineProperty(
                new i.DynamicServerError(
                  `Route ${e.route} couldn't be rendered statically because it used ${r}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E550', enumerable: !1, configurable: !0 }
              );
              throw ((e.dynamicUsageDescription = r), (e.dynamicUsageStack = n.stack), n);
          }
      }
    }
    function b(e, t, r) {
      let n = Object.defineProperty(
        new i.DynamicServerError(
          `Route ${t.route} couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E558', enumerable: !1, configurable: !0 }
      );
      throw (
        (r.revalidate = 0),
        (t.dynamicUsageDescription = e),
        (t.dynamicUsageStack = n.stack),
        n
      );
    }
    function _(e) {
      switch (e.type) {
        case 'cache':
        case 'unstable-cache':
        case 'private-cache':
          return;
      }
    }
    function y(e, t, r) {
      let n = T(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`);
      r.controller.abort(n);
      let i = r.dynamicTracking;
      i &&
        i.dynamicAccesses.push({
          stack: i.isDebugDynamicAccesses ? Error().stack : void 0,
          expression: t,
        });
    }
    function x(e, t, r, n) {
      let i = n.dynamicTracking;
      (y(e, t, n), i && null === i.syncDynamicErrorWithStack && (i.syncDynamicErrorWithStack = r));
    }
    function $(e) {
      e.prerenderPhase = !1;
    }
    function w(e, t, r, n) {
      if (!1 === n.controller.signal.aborted) {
        y(e, t, n);
        let i = n.dynamicTracking;
        i && null === i.syncDynamicErrorWithStack && (i.syncDynamicErrorWithStack = r);
      }
      throw T(`Route ${e} needs to bail out of prerendering at this point because it used ${t}.`);
    }
    function S(e) {
      e.syncDynamicErrorWithStack && console.error(e.syncDynamicErrorWithStack);
    }
    let O = $;
    function E({ reason: e, route: t }) {
      let r = o.workUnitAsyncStorage.getStore();
      k(t, e, r && 'prerender-ppr' === r.type ? r.dynamicTracking : null);
    }
    function k(e, t, r) {
      ((function () {
        if (!p)
          throw Object.defineProperty(
            Error(
              'Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js'
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E224', enumerable: !1, configurable: !0 }
          );
      })(),
        r &&
          r.dynamicAccesses.push({
            stack: r.isDebugDynamicAccesses ? Error().stack : void 0,
            expression: t,
          }),
        n.default.unstable_postpone(I(e, t)));
    }
    function I(e, t) {
      return `Route ${e} needs to bail out of prerendering at this point because it used ${t}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    }
    function P(e) {
      return 'object' == typeof e && null !== e && 'string' == typeof e.message && N(e.message);
    }
    function N(e) {
      return (
        e.includes('needs to bail out of prerendering at this point because it used') &&
        e.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error')
      );
    }
    if (!1 === N(I('%%%', '^^^')))
      throw Object.defineProperty(
        Error(
          'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E296', enumerable: !1, configurable: !0 }
      );
    let R = 'NEXT_PRERENDER_INTERRUPTED';
    function T(e) {
      let t = Object.defineProperty(Error(e), '__NEXT_ERROR_CODE', {
        value: 'E394',
        enumerable: !1,
        configurable: !0,
      });
      return ((t.digest = R), t);
    }
    function j(e) {
      return (
        'object' == typeof e &&
        null !== e &&
        e.digest === R &&
        'name' in e &&
        'message' in e &&
        e instanceof Error
      );
    }
    function A(e) {
      return e.length > 0;
    }
    function D(e, t) {
      return (e.dynamicAccesses.push(...t.dynamicAccesses), e.dynamicAccesses);
    }
    function U(e) {
      return e
        .filter((e) => 'string' == typeof e.stack && e.stack.length > 0)
        .map(
          ({ expression: e, stack: t }) => (
            (t = t
              .split('\n')
              .slice(4)
              .filter(
                (e) =>
                  !(
                    e.includes('node_modules/next/') ||
                    e.includes(' (<anonymous>)') ||
                    e.includes(' (node:')
                  )
              )
              .join('\n')),
            `Dynamic API Usage Debug - ${e}:
${t}`
          )
        );
    }
    function z() {
      let e = new AbortController();
      return (
        e.abort(
          Object.defineProperty(new d.BailoutToCSRError('Render in Browser'), '__NEXT_ERROR_CODE', {
            value: 'E721',
            enumerable: !1,
            configurable: !0,
          })
        ),
        e.signal
      );
    }
    function C(e) {
      switch (e.type) {
        case 'prerender':
        case 'prerender-runtime':
          let t = new AbortController();
          if (e.cacheSignal)
            e.cacheSignal.inputReady().then(() => {
              t.abort();
            });
          else {
            let r = (0, o.getRuntimeStagePromise)(e);
            r
              ? r.then(() => (0, c.scheduleOnNextTick)(() => t.abort()))
              : (0, c.scheduleOnNextTick)(() => t.abort());
          }
          return t.signal;
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
        case 'request':
        case 'cache':
        case 'private-cache':
        case 'unstable-cache':
          return;
      }
    }
    function Z(e, t) {
      let r = t.dynamicTracking;
      r &&
        r.dynamicAccesses.push({
          stack: r.isDebugDynamicAccesses ? Error().stack : void 0,
          expression: e,
        });
    }
    function L(e) {
      let t = s.workAsyncStorage.getStore(),
        r = o.workUnitAsyncStorage.getStore();
      if (t && r)
        switch (r.type) {
          case 'prerender-client':
          case 'prerender': {
            let i = r.fallbackRouteParams;
            i && i.size > 0 && n.default.use((0, u.makeHangingPromise)(r.renderSignal, t.route, e));
            break;
          }
          case 'prerender-ppr': {
            let n = r.fallbackRouteParams;
            if (n && n.size > 0) return k(t.route, e, r.dynamicTracking);
            break;
          }
          case 'prerender-runtime':
            throw Object.defineProperty(
              new f.InvariantError(
                `\`${e}\` was called during a runtime prerender. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E771', enumerable: !1, configurable: !0 }
            );
          case 'cache':
          case 'private-cache':
            throw Object.defineProperty(
              new f.InvariantError(
                `\`${e}\` was called inside a cache scope. Next.js should be preventing ${e} from being included in server components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E745', enumerable: !1, configurable: !0 }
            );
        }
    }
    let M = /\n\s+at Suspense \(<anonymous>\)/,
      B = RegExp(
        `\\n\\s+at Suspense \\(<anonymous>\\)(?:(?!\\n\\s+at (?:body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6) \\(<anonymous>\\))[\\s\\S])*?\\n\\s+at ${l.ROOT_LAYOUT_BOUNDARY_NAME} \\([^\\n]*\\)`
      ),
      F = RegExp(`\\n\\s+at ${l.METADATA_BOUNDARY_NAME}[\\n\\s]`),
      G = RegExp(`\\n\\s+at ${l.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`),
      V = RegExp(`\\n\\s+at ${l.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
    function X(e, t, r, n) {
      if (!V.test(t)) {
        if (F.test(t)) {
          r.hasDynamicMetadata = !0;
          return;
        }
        if (G.test(t)) {
          r.hasDynamicViewport = !0;
          return;
        }
        if (B.test(t)) {
          ((r.hasAllowedDynamic = !0), (r.hasSuspenseAboveBody = !0));
          return;
        } else if (M.test(t)) {
          r.hasAllowedDynamic = !0;
          return;
        } else {
          if (n.syncDynamicErrorWithStack)
            return void r.dynamicErrors.push(n.syncDynamicErrorWithStack);
          let i = (function (e, t) {
            let r = Object.defineProperty(Error(e), '__NEXT_ERROR_CODE', {
              value: 'E394',
              enumerable: !1,
              configurable: !0,
            });
            return ((r.stack = r.name + ': ' + e + t), r);
          })(
            `Route "${e.route}": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a "use cache" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense`,
            t
          );
          return void r.dynamicErrors.push(i);
        }
      }
    }
    var q = (function (e) {
      return (
        (e[(e.Full = 0)] = 'Full'),
        (e[(e.Empty = 1)] = 'Empty'),
        (e[(e.Errored = 2)] = 'Errored'),
        e
      );
    })({});
    function W(e, t) {
      (console.error(t),
        e.dev ||
          (e.hasReadableErrorStacks
            ? console.error(
                `To get a more detailed stack trace and pinpoint the issue, start the app in development mode by running \`next dev\`, then open "${e.route}" in your browser to investigate the error.`
              )
            : console.error(`To get a more detailed stack trace and pinpoint the issue, try one of the following:
  - Start the app in development mode by running \`next dev\`, then open "${e.route}" in your browser to investigate the error.
  - Rerun the production build with \`next build --debug-prerender\` to generate better stack traces.`)));
    }
    function H(e, t, r, n) {
      if (0 !== t) {
        if (r.hasSuspenseAboveBody) return;
        if (n.syncDynamicErrorWithStack)
          throw (W(e, n.syncDynamicErrorWithStack), new a.StaticGenBailoutError());
        let i = r.dynamicErrors;
        if (i.length > 0) {
          for (let t = 0; t < i.length; t++) W(e, i[t]);
          throw new a.StaticGenBailoutError();
        }
        if (r.hasDynamicViewport)
          throw (
            console.error(
              `Route "${e.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`
            ),
            new a.StaticGenBailoutError()
          );
        if (1 === t)
          throw (
            console.error(
              `Route "${e.route}" did not produce a static shell and Next.js was unable to determine a reason. This is a bug in Next.js.`
            ),
            new a.StaticGenBailoutError()
          );
      } else if (!1 === r.hasAllowedDynamic && r.hasDynamicMetadata)
        throw (
          console.error(
            `Route "${e.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or uncached external data (\`fetch(...)\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`
          ),
          new a.StaticGenBailoutError()
        );
    }
    function J(e, t) {
      return e.runtimeStagePromise ? e.runtimeStagePromise.then(() => t) : t;
    }
  },
  39107,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        isRequestAPICallableInsideAfter: function () {
          return u;
        },
        throwForSearchParamsAccessInUseCache: function () {
          return s;
        },
        throwWithStaticGenerationBailoutError: function () {
          return a;
        },
        throwWithStaticGenerationBailoutErrorWithDynamicError: function () {
          return o;
        },
      }));
    let n = e.r(36359),
      i = e.r(24725);
    function a(e, t) {
      throw Object.defineProperty(
        new n.StaticGenBailoutError(
          `Route ${e} couldn't be rendered statically because it used ${t}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E576', enumerable: !1, configurable: !0 }
      );
    }
    function o(e, t) {
      throw Object.defineProperty(
        new n.StaticGenBailoutError(
          `Route ${e} with \`dynamic = "error"\` couldn't be rendered statically because it used ${t}. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E543', enumerable: !1, configurable: !0 }
      );
    }
    function s(e, t) {
      let r = Object.defineProperty(
        Error(
          `Route ${e.route} used "searchParams" inside "use cache". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await "searchParams" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E779', enumerable: !1, configurable: !0 }
      );
      throw (Error.captureStackTrace(r, t), (e.invalidDynamicUsageError ??= r), r);
    }
    function u() {
      let e = i.afterTaskAsyncStorage.getStore();
      return (null == e ? void 0 : e.rootTaskSpawnPhase) === 'action';
    }
  },
  21162,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'connection', {
        enumerable: !0,
        get: function () {
          return l;
        },
      }));
    let n = e.r(56704),
      i = e.r(32319),
      a = e.r(46583),
      o = e.r(36359),
      s = e.r(77547),
      u = e.r(39107);
    function l() {
      let e = n.workAsyncStorage.getStore(),
        t = i.workUnitAsyncStorage.getStore();
      if (e) {
        if (t && 'after' === t.phase && !(0, u.isRequestAPICallableInsideAfter)())
          throw Object.defineProperty(
            Error(
              `Route ${e.route} used "connection" inside "after(...)". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual Request, but "after(...)" executes after the request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E186', enumerable: !1, configurable: !0 }
          );
        if (e.forceStatic) return Promise.resolve(void 0);
        if (e.dynamicShouldError)
          throw Object.defineProperty(
            new o.StaticGenBailoutError(
              `Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`connection\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E562', enumerable: !1, configurable: !0 }
          );
        if (t)
          switch (t.type) {
            case 'cache': {
              let t = Object.defineProperty(
                Error(
                  `Route ${e.route} used "connection" inside "use cache". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual request, but caches must be able to be produced before a request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E752', enumerable: !1, configurable: !0 }
              );
              throw (Error.captureStackTrace(t, l), (e.invalidDynamicUsageError ??= t), t);
            }
            case 'private-cache': {
              let t = Object.defineProperty(
                Error(
                  `Route ${e.route} used "connection" inside "use cache: private". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual navigation request, but caches must be able to be produced before a navigation request, so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E753', enumerable: !1, configurable: !0 }
              );
              throw (Error.captureStackTrace(t, l), (e.invalidDynamicUsageError ??= t), t);
            }
            case 'unstable-cache':
              throw Object.defineProperty(
                Error(
                  `Route ${e.route} used "connection" inside a function cached with "unstable_cache(...)". The \`connection()\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E1', enumerable: !1, configurable: !0 }
              );
            case 'prerender':
            case 'prerender-client':
            case 'prerender-runtime':
              return (0, s.makeHangingPromise)(t.renderSignal, e.route, '`connection()`');
            case 'prerender-ppr':
              return (0, a.postponeWithTracking)(e.route, 'connection', t.dynamicTracking);
            case 'prerender-legacy':
              return (0, a.throwToInterruptStaticGeneration)('connection', e, t);
            case 'request':
              return ((0, a.trackDynamicDataInDynamicRender)(t), Promise.resolve(void 0));
          }
      }
      (0, i.throwForMissingRequestStore)('connection');
    }
  },
  21024,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        describeHasCheckingStringProperty: function () {
          return a;
        },
        describeStringPropertyAccess: function () {
          return i;
        },
        wellKnownProperties: function () {
          return o;
        },
      }));
    let n = /^[A-Za-z_$][A-Za-z0-9_$]*$/;
    function i(e, t) {
      return n.test(t) ? '`' + e + '.' + t + '`' : '`' + e + '[' + JSON.stringify(t) + ']`';
    }
    function a(e, t) {
      let r = JSON.stringify(t);
      return '`Reflect.has(' + e + ', ' + r + ')`, `' + r + ' in ' + e + '`, or similar';
    }
    let o = new Set([
      'hasOwnProperty',
      'isPrototypeOf',
      'propertyIsEnumerable',
      'toString',
      'valueOf',
      'toLocaleString',
      'then',
      'catch',
      'finally',
      'status',
      'displayName',
      '_debugInfo',
      'toJSON',
      '$$typeof',
      '__esModule',
    ]);
  },
  5795,
  (e, t, r) => {
    'use strict';
    var n;
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        bgBlack: function () {
          return k;
        },
        bgBlue: function () {
          return R;
        },
        bgCyan: function () {
          return j;
        },
        bgGreen: function () {
          return P;
        },
        bgMagenta: function () {
          return T;
        },
        bgRed: function () {
          return I;
        },
        bgWhite: function () {
          return A;
        },
        bgYellow: function () {
          return N;
        },
        black: function () {
          return v;
        },
        blue: function () {
          return x;
        },
        bold: function () {
          return c;
        },
        cyan: function () {
          return S;
        },
        dim: function () {
          return d;
        },
        gray: function () {
          return E;
        },
        green: function () {
          return _;
        },
        hidden: function () {
          return g;
        },
        inverse: function () {
          return m;
        },
        italic: function () {
          return f;
        },
        magenta: function () {
          return $;
        },
        purple: function () {
          return w;
        },
        red: function () {
          return b;
        },
        reset: function () {
          return l;
        },
        strikethrough: function () {
          return h;
        },
        underline: function () {
          return p;
        },
        white: function () {
          return O;
        },
        yellow: function () {
          return y;
        },
      }));
    let { env: i, stdout: a } = (null == (n = globalThis) ? void 0 : n.process) ?? {},
      o =
        i &&
        !i.NO_COLOR &&
        (i.FORCE_COLOR || ((null == a ? void 0 : a.isTTY) && !i.CI && 'dumb' !== i.TERM)),
      s = (e, t, r, n) => {
        let i = e.substring(0, n) + r,
          a = e.substring(n + t.length),
          o = a.indexOf(t);
        return ~o ? i + s(a, t, r, o) : i + a;
      },
      u = (e, t, r = e) =>
        o
          ? (n) => {
              let i = '' + n,
                a = i.indexOf(t, e.length);
              return ~a ? e + s(i, t, r, a) + t : e + i + t;
            }
          : String,
      l = o ? (e) => `\x1b[0m${e}\x1b[0m` : String,
      c = u('\x1b[1m', '\x1b[22m', '\x1b[22m\x1b[1m'),
      d = u('\x1b[2m', '\x1b[22m', '\x1b[22m\x1b[2m'),
      f = u('\x1b[3m', '\x1b[23m'),
      p = u('\x1b[4m', '\x1b[24m'),
      m = u('\x1b[7m', '\x1b[27m'),
      g = u('\x1b[8m', '\x1b[28m'),
      h = u('\x1b[9m', '\x1b[29m'),
      v = u('\x1b[30m', '\x1b[39m'),
      b = u('\x1b[31m', '\x1b[39m'),
      _ = u('\x1b[32m', '\x1b[39m'),
      y = u('\x1b[33m', '\x1b[39m'),
      x = u('\x1b[34m', '\x1b[39m'),
      $ = u('\x1b[35m', '\x1b[39m'),
      w = u('\x1b[38;2;173;127;168m', '\x1b[39m'),
      S = u('\x1b[36m', '\x1b[39m'),
      O = u('\x1b[37m', '\x1b[39m'),
      E = u('\x1b[90m', '\x1b[39m'),
      k = u('\x1b[40m', '\x1b[49m'),
      I = u('\x1b[41m', '\x1b[49m'),
      P = u('\x1b[42m', '\x1b[49m'),
      N = u('\x1b[43m', '\x1b[49m'),
      R = u('\x1b[44m', '\x1b[49m'),
      T = u('\x1b[45m', '\x1b[49m'),
      j = u('\x1b[46m', '\x1b[49m'),
      A = u('\x1b[47m', '\x1b[49m');
  },
  50336,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      Object.defineProperty(r, 'LRUCache', {
        enumerable: !0,
        get: function () {
          return a;
        },
      }));
    class n {
      constructor(e, t, r) {
        ((this.prev = null), (this.next = null), (this.key = e), (this.data = t), (this.size = r));
      }
    }
    class i {
      constructor() {
        ((this.prev = null), (this.next = null));
      }
    }
    class a {
      constructor(e, t) {
        ((this.cache = new Map()),
          (this.totalSize = 0),
          (this.maxSize = e),
          (this.calculateSize = t),
          (this.head = new i()),
          (this.tail = new i()),
          (this.head.next = this.tail),
          (this.tail.prev = this.head));
      }
      addToHead(e) {
        ((e.prev = this.head),
          (e.next = this.head.next),
          (this.head.next.prev = e),
          (this.head.next = e));
      }
      removeNode(e) {
        ((e.prev.next = e.next), (e.next.prev = e.prev));
      }
      moveToHead(e) {
        (this.removeNode(e), this.addToHead(e));
      }
      removeTail() {
        let e = this.tail.prev;
        return (this.removeNode(e), e);
      }
      set(e, t) {
        let r = (null == this.calculateSize ? void 0 : this.calculateSize.call(this, t)) ?? 1;
        if (r > this.maxSize) return void console.warn('Single item size exceeds maxSize');
        let i = this.cache.get(e);
        if (i)
          ((i.data = t),
            (this.totalSize = this.totalSize - i.size + r),
            (i.size = r),
            this.moveToHead(i));
        else {
          let i = new n(e, t, r);
          (this.cache.set(e, i), this.addToHead(i), (this.totalSize += r));
        }
        for (; this.totalSize > this.maxSize && this.cache.size > 0; ) {
          let e = this.removeTail();
          (this.cache.delete(e.key), (this.totalSize -= e.size));
        }
      }
      has(e) {
        return this.cache.has(e);
      }
      get(e) {
        let t = this.cache.get(e);
        if (t) return (this.moveToHead(t), t.data);
      }
      *[Symbol.iterator]() {
        let e = this.head.next;
        for (; e && e !== this.tail; ) {
          let t = e;
          (yield [t.key, t.data], (e = e.next));
        }
      }
      remove(e) {
        let t = this.cache.get(e);
        t && (this.removeNode(t), this.cache.delete(e), (this.totalSize -= t.size));
      }
      get size() {
        return this.cache.size;
      }
      get currentSize() {
        return this.totalSize;
      }
    }
  },
  72479,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        bootstrap: function () {
          return u;
        },
        error: function () {
          return c;
        },
        event: function () {
          return m;
        },
        info: function () {
          return p;
        },
        prefixes: function () {
          return a;
        },
        ready: function () {
          return f;
        },
        trace: function () {
          return g;
        },
        wait: function () {
          return l;
        },
        warn: function () {
          return d;
        },
        warnOnce: function () {
          return v;
        },
      }));
    let n = e.r(5795),
      i = e.r(50336),
      a = {
        wait: (0, n.white)((0, n.bold)('○')),
        error: (0, n.red)((0, n.bold)('⨯')),
        warn: (0, n.yellow)((0, n.bold)('⚠')),
        ready: '▲',
        info: (0, n.white)((0, n.bold)(' ')),
        event: (0, n.green)((0, n.bold)('✓')),
        trace: (0, n.magenta)((0, n.bold)('»')),
      },
      o = { log: 'log', warn: 'warn', error: 'error' };
    function s(e, ...t) {
      ('' === t[0] || void 0 === t[0]) && 1 === t.length && t.shift();
      let r = e in o ? o[e] : 'log',
        n = a[e];
      0 === t.length
        ? console[r]('')
        : 1 === t.length && 'string' == typeof t[0]
          ? console[r](' ' + n + ' ' + t[0])
          : console[r](' ' + n, ...t);
    }
    function u(...e) {
      console.log('   ' + e.join(' '));
    }
    function l(...e) {
      s('wait', ...e);
    }
    function c(...e) {
      s('error', ...e);
    }
    function d(...e) {
      s('warn', ...e);
    }
    function f(...e) {
      s('ready', ...e);
    }
    function p(...e) {
      s('info', ...e);
    }
    function m(...e) {
      s('event', ...e);
    }
    function g(...e) {
      s('trace', ...e);
    }
    let h = new i.LRUCache(1e4, (e) => e.length);
    function v(...e) {
      let t = e.join(' ');
      h.has(t) || (h.set(t, t), d(...e));
    }
  },
  72181,
  (e, t, r) => {
    'use strict';
    (Object.defineProperty(r, '__esModule', { value: !0 }),
      !(function (e, t) {
        for (var r in t) Object.defineProperty(e, r, { enumerable: !0, get: t[r] });
      })(r, {
        getRootParam: function () {
          return p;
        },
        unstable_rootParams: function () {
          return f;
        },
      }));
    let n = e.r(45436),
      i = e.r(46583),
      a = e.r(56704),
      o = e.r(32319),
      s = e.r(77547),
      u = e.r(21024),
      l = e.r(20635),
      c = e.r(72479),
      d = new WeakMap();
    async function f() {
      (0, c.warnOnce)(
        '`unstable_rootParams()` is deprecated and will be removed in an upcoming major release. Import specific root params from `next/root-params` instead.'
      );
      let e = a.workAsyncStorage.getStore();
      if (!e)
        throw Object.defineProperty(
          new n.InvariantError('Missing workStore in unstable_rootParams'),
          '__NEXT_ERROR_CODE',
          { value: 'E615', enumerable: !1, configurable: !0 }
        );
      let t = o.workUnitAsyncStorage.getStore();
      if (!t)
        throw Object.defineProperty(
          Error(
            `Route ${e.route} used \`unstable_rootParams()\` in Pages Router. This API is only available within App Router.`
          ),
          '__NEXT_ERROR_CODE',
          { value: 'E641', enumerable: !1, configurable: !0 }
        );
      switch (t.type) {
        case 'cache':
        case 'unstable-cache':
          throw Object.defineProperty(
            Error(
              `Route ${e.route} used \`unstable_rootParams()\` inside \`"use cache"\` or \`unstable_cache\`. Support for this API inside cache scopes is planned for a future version of Next.js.`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E642', enumerable: !1, configurable: !0 }
          );
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
          return (function (e, t, r) {
            switch (r.type) {
              case 'prerender-client': {
                let e = '`unstable_rootParams`';
                throw Object.defineProperty(
                  new n.InvariantError(
                    `${e} must not be used within a client component. Next.js should be preventing ${e} from being included in client components statically, but did not in this case.`
                  ),
                  '__NEXT_ERROR_CODE',
                  { value: 'E693', enumerable: !1, configurable: !0 }
                );
              }
              case 'prerender': {
                let n = r.fallbackRouteParams;
                if (n) {
                  for (let i in e)
                    if (n.has(i)) {
                      let n = d.get(e);
                      if (n) return n;
                      let i = (0, s.makeHangingPromise)(
                        r.renderSignal,
                        t.route,
                        '`unstable_rootParams`'
                      );
                      return (d.set(e, i), i);
                    }
                }
                break;
              }
              case 'prerender-ppr': {
                let n = r.fallbackRouteParams;
                if (n) {
                  for (let a in e)
                    if (n.has(a))
                      return (function (e, t, r, n) {
                        let a = d.get(e);
                        if (a) return a;
                        let o = { ...e },
                          s = Promise.resolve(o);
                        return (
                          d.set(e, s),
                          Object.keys(e).forEach((a) => {
                            u.wellKnownProperties.has(a) ||
                              (t.has(a)
                                ? Object.defineProperty(o, a, {
                                    get() {
                                      let e = (0, u.describeStringPropertyAccess)(
                                        'unstable_rootParams',
                                        a
                                      );
                                      'prerender-ppr' === n.type
                                        ? (0, i.postponeWithTracking)(r.route, e, n.dynamicTracking)
                                        : (0, i.throwToInterruptStaticGeneration)(e, r, n);
                                    },
                                    enumerable: !0,
                                  })
                                : (s[a] = e[a]));
                          }),
                          s
                        );
                      })(e, n, t, r);
                }
              }
            }
            return Promise.resolve(e);
          })(t.rootParams, e, t);
        case 'private-cache':
        case 'prerender-runtime':
        case 'request':
          return Promise.resolve(t.rootParams);
        default:
          return t;
      }
    }
    function p(e) {
      let t = `\`import('next/root-params').${e}()\``,
        r = a.workAsyncStorage.getStore();
      if (!r)
        throw Object.defineProperty(
          new n.InvariantError(`Missing workStore in ${t}`),
          '__NEXT_ERROR_CODE',
          { value: 'E764', enumerable: !1, configurable: !0 }
        );
      let i = o.workUnitAsyncStorage.getStore();
      if (!i)
        throw Object.defineProperty(
          Error(`Route ${r.route} used ${t} outside of a Server Component. This is not allowed.`),
          '__NEXT_ERROR_CODE',
          { value: 'E774', enumerable: !1, configurable: !0 }
        );
      let u = l.actionAsyncStorage.getStore();
      if (u) {
        if (u.isAppRoute)
          throw Object.defineProperty(
            Error(
              `Route ${r.route} used ${t} inside a Route Handler. Support for this API in Route Handlers is planned for a future version of Next.js.`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E765', enumerable: !1, configurable: !0 }
          );
        if (u.isAction && 'action' === i.phase)
          throw Object.defineProperty(
            Error(
              `${t} was used inside a Server Action. This is not supported. Functions from 'next/root-params' can only be called in the context of a route.`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E766', enumerable: !1, configurable: !0 }
          );
      }
      switch (i.type) {
        case 'unstable-cache':
        case 'cache':
          throw Object.defineProperty(
            Error(
              `Route ${r.route} used ${t} inside \`"use cache"\` or \`unstable_cache\`. Support for this API inside cache scopes is planned for a future version of Next.js.`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E760', enumerable: !1, configurable: !0 }
          );
        case 'prerender':
        case 'prerender-client':
        case 'prerender-ppr':
        case 'prerender-legacy':
          var c = e,
            d = r,
            f = i,
            p = t;
          if ('prerender-client' === f.type)
            throw Object.defineProperty(
              new n.InvariantError(
                `${p} must not be used within a client component. Next.js should be preventing ${p} from being included in client components statically, but did not in this case.`
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E693', enumerable: !1, configurable: !0 }
            );
          let g = f.rootParams;
          switch (f.type) {
            case 'prerender':
              if (f.fallbackRouteParams && f.fallbackRouteParams.has(c))
                return (0, s.makeHangingPromise)(f.renderSignal, d.route, p);
              break;
            case 'prerender-ppr':
              if (f.fallbackRouteParams && f.fallbackRouteParams.has(c)) return m(c, d, f, p);
          }
          return Promise.resolve(g[c]);
      }
      return Promise.resolve(i.rootParams[e]);
    }
    async function m(e, t, r, n) {
      let a = (0, u.describeStringPropertyAccess)(n, e);
      switch (r.type) {
        case 'prerender-ppr':
          return (0, i.postponeWithTracking)(t.route, a, r.dynamicTracking);
        case 'prerender-legacy':
          return (0, i.throwToInterruptStaticGeneration)(a, t, r);
      }
    }
  },
  75352,
  (e, t, r) => {
    let n = {
      NextRequest: e.r(56193).NextRequest,
      NextResponse: e.r(20147).NextResponse,
      ImageResponse: e.r(65190).ImageResponse,
      userAgentFromString: e.r(22822).userAgentFromString,
      userAgent: e.r(22822).userAgent,
      URLPattern: e.r(73161).URLPattern,
      after: e.r(74171).after,
      connection: e.r(21162).connection,
      unstable_rootParams: e.r(72181).unstable_rootParams,
    };
    ((t.exports = n),
      (r.NextRequest = n.NextRequest),
      (r.NextResponse = n.NextResponse),
      (r.ImageResponse = n.ImageResponse),
      (r.userAgentFromString = n.userAgentFromString),
      (r.userAgent = n.userAgent),
      (r.URLPattern = n.URLPattern),
      (r.after = n.after),
      (r.connection = n.connection),
      (r.unstable_rootParams = n.unstable_rootParams));
  },
  79627,
  (e) => {
    'use strict';
    let t, r;
    e.s(
      [
        'handler',
        () => c9,
        'patchFetch',
        () => c2,
        'routeModule',
        () => c0,
        'serverHooks',
        () => c6,
        'workAsyncStorage',
        () => c1,
        'workUnitAsyncStorage',
        () => c4,
      ],
      79627
    );
    var n,
      i,
      a = e.i(22522),
      o = (function (e) {
        return (
          (e.PAGES = 'PAGES'),
          (e.PAGES_API = 'PAGES_API'),
          (e.APP_PAGE = 'APP_PAGE'),
          (e.APP_ROUTE = 'APP_ROUTE'),
          (e.IMAGE = 'IMAGE'),
          e
        );
      })({}),
      s = (function (e) {
        return (
          (e.handleRequest = 'BaseServer.handleRequest'),
          (e.run = 'BaseServer.run'),
          (e.pipe = 'BaseServer.pipe'),
          (e.getStaticHTML = 'BaseServer.getStaticHTML'),
          (e.render = 'BaseServer.render'),
          (e.renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents'),
          (e.renderToResponse = 'BaseServer.renderToResponse'),
          (e.renderToHTML = 'BaseServer.renderToHTML'),
          (e.renderError = 'BaseServer.renderError'),
          (e.renderErrorToResponse = 'BaseServer.renderErrorToResponse'),
          (e.renderErrorToHTML = 'BaseServer.renderErrorToHTML'),
          (e.render404 = 'BaseServer.render404'),
          e
        );
      })(s || {}),
      u = (function (e) {
        return (
          (e.loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents'),
          (e.loadComponents = 'LoadComponents.loadComponents'),
          e
        );
      })(u || {}),
      l = (function (e) {
        return (
          (e.getRequestHandler = 'NextServer.getRequestHandler'),
          (e.getServer = 'NextServer.getServer'),
          (e.getServerRequestHandler = 'NextServer.getServerRequestHandler'),
          (e.createServer = 'createServer.createServer'),
          e
        );
      })(l || {}),
      c = (function (e) {
        return (
          (e.compression = 'NextNodeServer.compression'),
          (e.getBuildId = 'NextNodeServer.getBuildId'),
          (e.createComponentTree = 'NextNodeServer.createComponentTree'),
          (e.clientComponentLoading = 'NextNodeServer.clientComponentLoading'),
          (e.getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule'),
          (e.generateStaticRoutes = 'NextNodeServer.generateStaticRoutes'),
          (e.generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes'),
          (e.generatePublicRoutes = 'NextNodeServer.generatePublicRoutes'),
          (e.generateImageRoutes = 'NextNodeServer.generateImageRoutes.route'),
          (e.sendRenderResult = 'NextNodeServer.sendRenderResult'),
          (e.proxyRequest = 'NextNodeServer.proxyRequest'),
          (e.runApi = 'NextNodeServer.runApi'),
          (e.render = 'NextNodeServer.render'),
          (e.renderHTML = 'NextNodeServer.renderHTML'),
          (e.imageOptimizer = 'NextNodeServer.imageOptimizer'),
          (e.getPagePath = 'NextNodeServer.getPagePath'),
          (e.getRoutesManifest = 'NextNodeServer.getRoutesManifest'),
          (e.findPageComponents = 'NextNodeServer.findPageComponents'),
          (e.getFontManifest = 'NextNodeServer.getFontManifest'),
          (e.getServerComponentManifest = 'NextNodeServer.getServerComponentManifest'),
          (e.getRequestHandler = 'NextNodeServer.getRequestHandler'),
          (e.renderToHTML = 'NextNodeServer.renderToHTML'),
          (e.renderError = 'NextNodeServer.renderError'),
          (e.renderErrorToHTML = 'NextNodeServer.renderErrorToHTML'),
          (e.render404 = 'NextNodeServer.render404'),
          (e.startResponse = 'NextNodeServer.startResponse'),
          (e.route = 'route'),
          (e.onProxyReq = 'onProxyReq'),
          (e.apiResolver = 'apiResolver'),
          (e.internalFetch = 'internalFetch'),
          e
        );
      })(c || {}),
      d = (function (e) {
        return ((e.startServer = 'startServer.startServer'), e);
      })(d || {}),
      f = (function (e) {
        return (
          (e.getServerSideProps = 'Render.getServerSideProps'),
          (e.getStaticProps = 'Render.getStaticProps'),
          (e.renderToString = 'Render.renderToString'),
          (e.renderDocument = 'Render.renderDocument'),
          (e.createBodyResult = 'Render.createBodyResult'),
          e
        );
      })(f || {}),
      p = (function (e) {
        return (
          (e.renderToString = 'AppRender.renderToString'),
          (e.renderToReadableStream = 'AppRender.renderToReadableStream'),
          (e.getBodyResult = 'AppRender.getBodyResult'),
          (e.fetch = 'AppRender.fetch'),
          e
        );
      })(p || {}),
      m = (function (e) {
        return ((e.executeRoute = 'Router.executeRoute'), e);
      })(m || {}),
      g = (function (e) {
        return ((e.runHandler = 'Node.runHandler'), e);
      })(g || {}),
      h = (function (e) {
        return ((e.runHandler = 'AppRouteRouteHandlers.runHandler'), e);
      })(h || {}),
      v = (function (e) {
        return (
          (e.generateMetadata = 'ResolveMetadata.generateMetadata'),
          (e.generateViewport = 'ResolveMetadata.generateViewport'),
          e
        );
      })(v || {}),
      b = (function (e) {
        return ((e.execute = 'Middleware.execute'), e);
      })(b || {});
    let _ = [
        'Middleware.execute',
        'BaseServer.handleRequest',
        'Render.getServerSideProps',
        'Render.getStaticProps',
        'AppRender.fetch',
        'AppRender.getBodyResult',
        'Render.renderDocument',
        'Node.runHandler',
        'AppRouteRouteHandlers.runHandler',
        'ResolveMetadata.generateMetadata',
        'ResolveMetadata.generateViewport',
        'NextNodeServer.createComponentTree',
        'NextNodeServer.findPageComponents',
        'NextNodeServer.getLayoutOrPageModule',
        'NextNodeServer.startResponse',
        'NextNodeServer.clientComponentLoading',
      ],
      y = [
        'NextNodeServer.findPageComponents',
        'NextNodeServer.createComponentTree',
        'NextNodeServer.clientComponentLoading',
      ];
    try {
      t = e.r(67173);
    } catch (r) {
      t = e.r(24773);
    }
    let {
      context: x,
      propagation: $,
      trace: w,
      SpanStatusCode: S,
      SpanKind: O,
      ROOT_CONTEXT: E,
    } = t;
    class k extends Error {
      constructor(e, t) {
        (super(), (this.bubble = e), (this.result = t));
      }
    }
    let I = (e, t) => {
        ((function (e) {
          return 'object' == typeof e && null !== e && e instanceof k;
        })(t) && t.bubble
          ? e.setAttribute('next.bubble', !0)
          : (t && (e.recordException(t), e.setAttribute('error.type', t.name)),
            e.setStatus({ code: S.ERROR, message: null == t ? void 0 : t.message })),
          e.end());
      },
      P = new Map(),
      N = t.createContextKey('next.rootSpanId'),
      R = 0,
      T = {
        set(e, t, r) {
          e.push({ key: t, value: r });
        },
      };
    class j {
      getTracerInstance() {
        return w.getTracer('next.js', '0.0.1');
      }
      getContext() {
        return x;
      }
      getTracePropagationData() {
        let e = x.active(),
          t = [];
        return ($.inject(e, t, T), t);
      }
      getActiveScopeSpan() {
        return w.getSpan(null == x ? void 0 : x.active());
      }
      withPropagatedContext(e, t, r) {
        let n = x.active();
        if (w.getSpanContext(n)) return t();
        let i = $.extract(n, e, r);
        return x.with(i, t);
      }
      trace(...e) {
        var t;
        let [r, n, i] = e,
          { fn: a, options: o } =
            'function' == typeof n ? { fn: n, options: {} } : { fn: i, options: { ...n } },
          s = o.spanName ?? r;
        if ((!_.includes(r) && '1' !== process.env.NEXT_OTEL_VERBOSE) || o.hideSpan) return a();
        let u = this.getSpanContext(
            (null == o ? void 0 : o.parentSpan) ?? this.getActiveScopeSpan()
          ),
          l = !1;
        u
          ? (null == (t = w.getSpanContext(u)) ? void 0 : t.isRemote) && (l = !0)
          : ((u = (null == x ? void 0 : x.active()) ?? E), (l = !0));
        let c = R++;
        return (
          (o.attributes = { 'next.span_name': s, 'next.span_type': r, ...o.attributes }),
          x.with(u.setValue(N, c), () =>
            this.getTracerInstance().startActiveSpan(s, o, (e) => {
              let t =
                  'performance' in globalThis && 'measure' in performance
                    ? globalThis.performance.now()
                    : void 0,
                n = () => {
                  (P.delete(c),
                    t &&
                      process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&
                      y.includes(r || '') &&
                      performance.measure(
                        `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(r.split('.').pop() || '').replace(/[A-Z]/g, (e) => '-' + e.toLowerCase())}`,
                        { start: t, end: performance.now() }
                      ));
                };
              l && P.set(c, new Map(Object.entries(o.attributes ?? {})));
              try {
                if (a.length > 1) return a(e, (t) => I(e, t));
                let t = a(e);
                if (
                  null !== t &&
                  'object' == typeof t &&
                  'then' in t &&
                  'function' == typeof t.then
                )
                  return t
                    .then((t) => (e.end(), t))
                    .catch((t) => {
                      throw (I(e, t), t);
                    })
                    .finally(n);
                return (e.end(), n(), t);
              } catch (t) {
                throw (I(e, t), n(), t);
              }
            })
          )
        );
      }
      wrap(...e) {
        let t = this,
          [r, n, i] = 3 === e.length ? e : [e[0], {}, e[1]];
        return _.includes(r) || '1' === process.env.NEXT_OTEL_VERBOSE
          ? function () {
              let e = n;
              'function' == typeof e && 'function' == typeof i && (e = e.apply(this, arguments));
              let a = arguments.length - 1,
                o = arguments[a];
              if ('function' != typeof o) return t.trace(r, e, () => i.apply(this, arguments));
              {
                let n = t.getContext().bind(x.active(), o);
                return t.trace(
                  r,
                  e,
                  (e, t) => (
                    (arguments[a] = function (e) {
                      return (null == t || t(e), n.apply(this, arguments));
                    }),
                    i.apply(this, arguments)
                  )
                );
              }
            }
          : i;
      }
      startSpan(...e) {
        let [t, r] = e,
          n = this.getSpanContext((null == r ? void 0 : r.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(t, r, n);
      }
      getSpanContext(e) {
        return e ? w.setSpan(x.active(), e) : void 0;
      }
      getRootSpanAttributes() {
        let e = x.active().getValue(N);
        return P.get(e);
      }
      setRootSpanAttribute(e, t) {
        let r = x.active().getValue(N),
          n = P.get(r);
        n && n.set(e, t);
      }
    }
    let A = (() => {
        let e = new j();
        return () => e;
      })(),
      D = 'x-next-cache-tags',
      U = {
        shared: 'shared',
        reactServerComponents: 'rsc',
        serverSideRendering: 'ssr',
        actionBrowser: 'action-browser',
        apiNode: 'api-node',
        apiEdge: 'api-edge',
        middleware: 'middleware',
        instrument: 'instrument',
        edgeAsset: 'edge-asset',
        appPagesBrowser: 'app-pages-browser',
        pagesDirBrowser: 'pages-dir-browser',
        pagesDirEdge: 'pages-dir-edge',
        pagesDirNode: 'pages-dir-node',
      };
    ({
      ...U,
      GROUP: {
        builtinReact: [U.reactServerComponents, U.actionBrowser],
        serverOnly: [U.reactServerComponents, U.actionBrowser, U.instrument, U.middleware],
        neutralTarget: [U.apiNode, U.apiEdge],
        clientOnly: [U.serverSideRendering, U.appPagesBrowser],
        bundled: [
          U.reactServerComponents,
          U.actionBrowser,
          U.serverSideRendering,
          U.appPagesBrowser,
          U.shared,
          U.instrument,
          U.middleware,
        ],
        appPages: [
          U.reactServerComponents,
          U.serverSideRendering,
          U.appPagesBrowser,
          U.actionBrowser,
        ],
      },
    });
    var z = e.i(91392);
    class C extends Error {
      constructor(e) {
        (super('Dynamic server usage: ' + e),
          (this.description = e),
          (this.digest = 'DYNAMIC_SERVER_USAGE'));
      }
    }
    class Z extends Error {
      constructor(...e) {
        (super(...e), (this.code = 'NEXT_STATIC_GEN_BAILOUT'));
      }
    }
    var L = e.i(32319);
    e.i(56704);
    class M extends Error {
      constructor(e, t) {
        (super(
          `During prerendering, ${t} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${t} to a different context by using \`setTimeout\`, \`after\`, or similar functions you may observe this error and you should handle it in that context. This occurred at route "${e}".`
        ),
          (this.route = e),
          (this.expression = t),
          (this.digest = 'HANGING_PROMISE_REJECTION'));
      }
    }
    let B = new WeakMap();
    function F(e, t, r) {
      if (e.aborted) return Promise.reject(new M(t, r));
      {
        let n = new Promise((n, i) => {
          let a = i.bind(null, new M(t, r)),
            o = B.get(e);
          if (o) o.push(a);
          else {
            let t = [a];
            (B.set(e, t),
              e.addEventListener(
                'abort',
                () => {
                  for (let e = 0; e < t.length; e++) t[e]();
                },
                { once: !0 }
              ));
          }
        });
        return (n.catch(G), n);
      }
    }
    function G() {}
    class V extends Error {
      constructor(e, t) {
        (super('Invariant: ' + (e.endsWith('.') ? e : e + '.') + ' This is a bug in Next.js.', t),
          (this.name = 'InvariantError'));
      }
    }
    let X = 'function' == typeof z.default.unstable_postpone;
    function q(e, t, r) {
      if (t)
        switch (t.type) {
          case 'cache':
          case 'unstable-cache':
          case 'private-cache':
            return;
        }
      if (!e.forceDynamic && !e.forceStatic) {
        if (e.dynamicShouldError)
          throw Object.defineProperty(
            new Z(
              `Route ${e.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${r}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`
            ),
            '__NEXT_ERROR_CODE',
            { value: 'E553', enumerable: !1, configurable: !0 }
          );
        if (t)
          switch (t.type) {
            case 'prerender-ppr':
              var n, i, a;
              return (
                (n = e.route),
                (i = r),
                (a = t.dynamicTracking),
                void ((function () {
                  if (!X)
                    throw Object.defineProperty(
                      Error(
                        'Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js'
                      ),
                      '__NEXT_ERROR_CODE',
                      { value: 'E224', enumerable: !1, configurable: !0 }
                    );
                })(),
                a &&
                  a.dynamicAccesses.push({
                    stack: a.isDebugDynamicAccesses ? Error().stack : void 0,
                    expression: i,
                  }),
                z.default.unstable_postpone(W(n, i)))
              );
            case 'prerender-legacy':
              t.revalidate = 0;
              let o = Object.defineProperty(
                new C(
                  `Route ${e.route} couldn't be rendered statically because it used ${r}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E550', enumerable: !1, configurable: !0 }
              );
              throw ((e.dynamicUsageDescription = r), (e.dynamicUsageStack = o.stack), o);
          }
      }
    }
    function W(e, t) {
      return `Route ${e} needs to bail out of prerendering at this point because it used ${t}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    }
    if (
      !1 ===
      (function (e) {
        return (
          e.includes('needs to bail out of prerendering at this point because it used') &&
          e.includes('Learn more: https://nextjs.org/docs/messages/ppr-caught-error')
        );
      })(W('%%%', '^^^'))
    )
      throw Object.defineProperty(
        Error(
          'Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js'
        ),
        '__NEXT_ERROR_CODE',
        { value: 'E296', enumerable: !1, configurable: !0 }
      );
    (RegExp(
      `\\n\\s+at Suspense \\(<anonymous>\\)(?:(?!\\n\\s+at (?:body|div|main|section|article|aside|header|footer|nav|form|p|span|h1|h2|h3|h4|h5|h6) \\(<anonymous>\\))[\\s\\S])*?\\n\\s+at __next_root_layout_boundary__ \\([^\\n]*\\)`
    ),
      RegExp(`\\n\\s+at __next_metadata_boundary__[\\n\\s]`),
      RegExp(`\\n\\s+at __next_viewport_boundary__[\\n\\s]`),
      RegExp(`\\n\\s+at __next_outlet_boundary__[\\n\\s]`));
    let H = () => {};
    function J(e) {
      if (!e.body) return [e, e];
      let [t, n] = e.body.tee(),
        i = new Response(t, { status: e.status, statusText: e.statusText, headers: e.headers });
      (Object.defineProperty(i, 'url', {
        value: e.url,
        configurable: !0,
        enumerable: !0,
        writable: !1,
      }),
        r && i.body && r.register(i, new WeakRef(i.body)));
      let a = new Response(n, { status: e.status, statusText: e.statusText, headers: e.headers });
      return (
        Object.defineProperty(a, 'url', {
          value: e.url,
          configurable: !0,
          enumerable: !0,
          writable: !1,
        }),
        [i, a]
      );
    }
    globalThis.FinalizationRegistry &&
      (r = new FinalizationRegistry((e) => {
        let t = e.deref();
        t && !t.locked && t.cancel('Response object has been garbage collected').then(H);
      }));
    class K {
      constructor() {
        let e, t;
        ((this.promise = new Promise((r, n) => {
          ((e = r), (t = n));
        })),
          (this.resolve = e),
          (this.reject = t));
      }
    }
    var Y = (function (e) {
        return (
          (e.APP_PAGE = 'APP_PAGE'),
          (e.APP_ROUTE = 'APP_ROUTE'),
          (e.PAGES = 'PAGES'),
          (e.FETCH = 'FETCH'),
          (e.REDIRECT = 'REDIRECT'),
          (e.IMAGE = 'IMAGE'),
          e
        );
      })({}),
      Q = (function (e) {
        return (
          (e.APP_PAGE = 'APP_PAGE'),
          (e.APP_ROUTE = 'APP_ROUTE'),
          (e.PAGES = 'PAGES'),
          (e.FETCH = 'FETCH'),
          (e.IMAGE = 'IMAGE'),
          e
        );
      })({});
    function ee() {}
    (new Uint8Array([60, 104, 116, 109, 108]),
      new Uint8Array([60, 98, 111, 100, 121]),
      new Uint8Array([60, 47, 104, 101, 97, 100, 62]),
      new Uint8Array([60, 47, 98, 111, 100, 121, 62]),
      new Uint8Array([60, 47, 104, 116, 109, 108, 62]),
      new Uint8Array([60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62]),
      new Uint8Array([
        60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120, 116, 45, 105, 99,
        111, 110, 194, 187, 34,
      ]));
    let et = new TextEncoder();
    function er(e) {
      return new ReadableStream({
        start(t) {
          (t.enqueue(et.encode(e)), t.close());
        },
      });
    }
    function en(e) {
      return new ReadableStream({
        start(t) {
          (t.enqueue(e), t.close());
        },
      });
    }
    async function ei(e, t) {
      let r = new TextDecoder('utf-8', { fatal: !0 }),
        n = '';
      for await (let i of e) {
        if (null == t ? void 0 : t.aborted) return n;
        n += r.decode(i, { stream: !0 });
      }
      return n + r.decode();
    }
    let ea = Symbol.for('NextInternalRequestMeta');
    function eo(e, t) {
      let r = e[ea] || {};
      return 'string' == typeof t ? r[t] : r;
    }
    function es(e) {
      let t = new Headers();
      for (let [r, n] of Object.entries(e))
        for (let e of Array.isArray(n) ? n : [n])
          void 0 !== e && ('number' == typeof e && (e = e.toString()), t.append(r, e));
      return t;
    }
    function eu(e) {
      var t,
        r,
        n,
        i,
        a,
        o = [],
        s = 0;
      function u() {
        for (; s < e.length && /\s/.test(e.charAt(s)); ) s += 1;
        return s < e.length;
      }
      for (; s < e.length; ) {
        for (t = s, a = !1; u(); )
          if (',' === (r = e.charAt(s))) {
            for (
              n = s, s += 1, u(), i = s;
              s < e.length && '=' !== (r = e.charAt(s)) && ';' !== r && ',' !== r;

            )
              s += 1;
            s < e.length && '=' === e.charAt(s)
              ? ((a = !0), (s = i), o.push(e.substring(t, n)), (t = s))
              : (s = n + 1);
          } else s += 1;
        (!a || s >= e.length) && o.push(e.substring(t, e.length));
      }
      return o;
    }
    function el(e) {
      let t = {},
        r = [];
      if (e)
        for (let [n, i] of e.entries())
          'set-cookie' === n.toLowerCase()
            ? (r.push(...eu(i)), (t[n] = 1 === r.length ? r[0] : r))
            : (t[n] = i);
      return t;
    }
    function ec(e) {
      return e.replace(/\/$/, '') || '/';
    }
    function ed(e) {
      let t = e.indexOf('#'),
        r = e.indexOf('?'),
        n = r > -1 && (t < 0 || r < t);
      return n || t > -1
        ? {
            pathname: e.substring(0, n ? r : t),
            query: n ? e.substring(r, t > -1 ? t : void 0) : '',
            hash: t > -1 ? e.slice(t) : '',
          }
        : { pathname: e, query: '', hash: '' };
    }
    function ef(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: n, hash: i } = ed(e);
      return '' + t + r + n + i;
    }
    function ep(e, t) {
      if (!e.startsWith('/') || !t) return e;
      let { pathname: r, query: n, hash: i } = ed(e);
      return '' + r + t + n + i;
    }
    function em(e, t) {
      if ('string' != typeof e) return !1;
      let { pathname: r } = ed(e);
      return r === t || r.startsWith(t + '/');
    }
    let eg = new WeakMap();
    function eh(e, t) {
      let r;
      if (!t) return { pathname: e };
      let n = eg.get(t);
      n || ((n = t.map((e) => e.toLowerCase())), eg.set(t, n));
      let i = e.split('/', 2);
      if (!i[1]) return { pathname: e };
      let a = i[1].toLowerCase(),
        o = n.indexOf(a);
      return o < 0
        ? { pathname: e }
        : ((r = t[o]), { pathname: (e = e.slice(r.length + 1) || '/'), detectedLocale: r });
    }
    let ev =
      /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function eb(e, t) {
      return new URL(String(e).replace(ev, 'localhost'), t && String(t).replace(ev, 'localhost'));
    }
    let e_ = Symbol('NextURLInternal');
    class ey {
      constructor(e, t, r) {
        let n, i;
        (('object' == typeof t && 'pathname' in t) || 'string' == typeof t
          ? ((n = t), (i = r || {}))
          : (i = r || t || {}),
          (this[e_] = { url: eb(e, n ?? i.base), options: i, basePath: '' }),
          this.analyze());
      }
      analyze() {
        var e, t, r, n, i;
        let a = (function (e, t) {
            var r, n;
            let { basePath: i, i18n: a, trailingSlash: o } = null != (r = t.nextConfig) ? r : {},
              s = { pathname: e, trailingSlash: '/' !== e ? e.endsWith('/') : o };
            i &&
              em(s.pathname, i) &&
              ((s.pathname = (function (e, t) {
                if (!em(e, t)) return e;
                let r = e.slice(t.length);
                return r.startsWith('/') ? r : '/' + r;
              })(s.pathname, i)),
              (s.basePath = i));
            let u = s.pathname;
            if (s.pathname.startsWith('/_next/data/') && s.pathname.endsWith('.json')) {
              let e = s.pathname
                .replace(/^\/_next\/data\//, '')
                .replace(/\.json$/, '')
                .split('/');
              ((s.buildId = e[0]),
                (u = 'index' !== e[1] ? '/' + e.slice(1).join('/') : '/'),
                !0 === t.parseData && (s.pathname = u));
            }
            if (a) {
              let e = t.i18nProvider
                ? t.i18nProvider.analyze(s.pathname)
                : eh(s.pathname, a.locales);
              ((s.locale = e.detectedLocale),
                (s.pathname = null != (n = e.pathname) ? n : s.pathname),
                !e.detectedLocale &&
                  s.buildId &&
                  (e = t.i18nProvider ? t.i18nProvider.analyze(u) : eh(u, a.locales))
                    .detectedLocale &&
                  (s.locale = e.detectedLocale));
            }
            return s;
          })(this[e_].url.pathname, {
            nextConfig: this[e_].options.nextConfig,
            parseData: !0,
            i18nProvider: this[e_].options.i18nProvider,
          }),
          o = (function (e, t) {
            let r;
            if ((null == t ? void 0 : t.host) && !Array.isArray(t.host))
              r = t.host.toString().split(':', 1)[0];
            else {
              if (!e.hostname) return;
              r = e.hostname;
            }
            return r.toLowerCase();
          })(this[e_].url, this[e_].options.headers);
        this[e_].domainLocale = this[e_].options.i18nProvider
          ? this[e_].options.i18nProvider.detectDomainLocale(o)
          : (function (e, t, r) {
              if (e)
                for (let a of (r && (r = r.toLowerCase()), e)) {
                  var n, i;
                  if (
                    t === (null == (n = a.domain) ? void 0 : n.split(':', 1)[0].toLowerCase()) ||
                    r === a.defaultLocale.toLowerCase() ||
                    (null == (i = a.locales) ? void 0 : i.some((e) => e.toLowerCase() === r))
                  )
                    return a;
                }
            })(
              null == (t = this[e_].options.nextConfig) || null == (e = t.i18n)
                ? void 0
                : e.domains,
              o
            );
        let s =
          (null == (r = this[e_].domainLocale) ? void 0 : r.defaultLocale) ||
          (null == (i = this[e_].options.nextConfig) || null == (n = i.i18n)
            ? void 0
            : n.defaultLocale);
        ((this[e_].url.pathname = a.pathname),
          (this[e_].defaultLocale = s),
          (this[e_].basePath = a.basePath ?? ''),
          (this[e_].buildId = a.buildId),
          (this[e_].locale = a.locale ?? s),
          (this[e_].trailingSlash = a.trailingSlash));
      }
      formatPathname() {
        var e;
        let t;
        return (
          (t = (function (e, t, r, n) {
            if (!t || t === r) return e;
            let i = e.toLowerCase();
            return !n && (em(i, '/api') || em(i, '/' + t.toLowerCase())) ? e : ef(e, '/' + t);
          })(
            (e = {
              basePath: this[e_].basePath,
              buildId: this[e_].buildId,
              defaultLocale: this[e_].options.forceLocale ? void 0 : this[e_].defaultLocale,
              locale: this[e_].locale,
              pathname: this[e_].url.pathname,
              trailingSlash: this[e_].trailingSlash,
            }).pathname,
            e.locale,
            e.buildId ? void 0 : e.defaultLocale,
            e.ignorePrefix
          )),
          (e.buildId || !e.trailingSlash) && (t = ec(t)),
          e.buildId &&
            (t = ep(
              ef(t, '/_next/data/' + e.buildId),
              '/' === e.pathname ? 'index.json' : '.json'
            )),
          (t = ef(t, e.basePath)),
          !e.buildId && e.trailingSlash ? (t.endsWith('/') ? t : ep(t, '/')) : ec(t)
        );
      }
      formatSearch() {
        return this[e_].url.search;
      }
      get buildId() {
        return this[e_].buildId;
      }
      set buildId(e) {
        this[e_].buildId = e;
      }
      get locale() {
        return this[e_].locale ?? '';
      }
      set locale(e) {
        var t, r;
        if (
          !this[e_].locale ||
          !(null == (r = this[e_].options.nextConfig) || null == (t = r.i18n)
            ? void 0
            : t.locales.includes(e))
        )
          throw Object.defineProperty(
            TypeError(`The NextURL configuration includes no locale "${e}"`),
            '__NEXT_ERROR_CODE',
            { value: 'E597', enumerable: !1, configurable: !0 }
          );
        this[e_].locale = e;
      }
      get defaultLocale() {
        return this[e_].defaultLocale;
      }
      get domainLocale() {
        return this[e_].domainLocale;
      }
      get searchParams() {
        return this[e_].url.searchParams;
      }
      get host() {
        return this[e_].url.host;
      }
      set host(e) {
        this[e_].url.host = e;
      }
      get hostname() {
        return this[e_].url.hostname;
      }
      set hostname(e) {
        this[e_].url.hostname = e;
      }
      get port() {
        return this[e_].url.port;
      }
      set port(e) {
        this[e_].url.port = e;
      }
      get protocol() {
        return this[e_].url.protocol;
      }
      set protocol(e) {
        this[e_].url.protocol = e;
      }
      get href() {
        let e = this.formatPathname(),
          t = this.formatSearch();
        return `${this.protocol}//${this.host}${e}${t}${this.hash}`;
      }
      set href(e) {
        ((this[e_].url = eb(e)), this.analyze());
      }
      get origin() {
        return this[e_].url.origin;
      }
      get pathname() {
        return this[e_].url.pathname;
      }
      set pathname(e) {
        this[e_].url.pathname = e;
      }
      get hash() {
        return this[e_].url.hash;
      }
      set hash(e) {
        this[e_].url.hash = e;
      }
      get search() {
        return this[e_].url.search;
      }
      set search(e) {
        this[e_].url.search = e;
      }
      get password() {
        return this[e_].url.password;
      }
      set password(e) {
        this[e_].url.password = e;
      }
      get username() {
        return this[e_].url.username;
      }
      set username(e) {
        this[e_].url.username = e;
      }
      get basePath() {
        return this[e_].basePath;
      }
      set basePath(e) {
        this[e_].basePath = e.startsWith('/') ? e : `/${e}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash,
        };
      }
      clone() {
        return new ey(String(this), this[e_].options);
      }
    }
    class ex extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    }
    class e$ extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    }
    var ew = e.i(82159);
    let eS = Symbol('internal request');
    class eO extends Request {
      constructor(e, t = {}) {
        let r = 'string' != typeof e && 'url' in e ? e.url : String(e);
        (!(function (e) {
          try {
            String(new URL(String(e)));
          } catch (t) {
            throw Object.defineProperty(
              Error(
                `URL is malformed "${String(e)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,
                { cause: t }
              ),
              '__NEXT_ERROR_CODE',
              { value: 'E61', enumerable: !1, configurable: !0 }
            );
          }
        })(r),
          t.body && 'half' !== t.duplex && (t.duplex = 'half'),
          e instanceof Request ? super(e, t) : super(r, t));
        let n = new ey(r, { headers: el(this.headers), nextConfig: t.nextConfig });
        this[eS] = { cookies: new ew.RequestCookies(this.headers), nextUrl: n, url: n.toString() };
      }
      [Symbol.for('edge-runtime.inspect.custom')]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal,
        };
      }
      get cookies() {
        return this[eS].cookies;
      }
      get nextUrl() {
        return this[eS].nextUrl;
      }
      get page() {
        throw new ex();
      }
      get ua() {
        throw new e$();
      }
      get url() {
        return this[eS].url;
      }
    }
    let eE = 'ResponseAborted';
    class ek extends Error {
      constructor(...e) {
        (super(...e), (this.name = eE));
      }
    }
    function eI(e) {
      let t = new AbortController();
      return (
        e.once('close', () => {
          e.writableFinished || t.abort(new ek());
        }),
        t
      );
    }
    class eP {
      static fromBaseNextRequest(e, t) {
        return eP.fromNodeNextRequest(e, t);
      }
      static fromNodeNextRequest(e, t) {
        let r,
          n = null;
        if (
          ('GET' !== e.method && 'HEAD' !== e.method && e.body && (n = e.body),
          e.url.startsWith('http'))
        )
          r = new URL(e.url);
        else {
          let t = eo(e, 'initURL');
          r = t && t.startsWith('http') ? new URL(e.url, t) : new URL(e.url, 'http://n');
        }
        return new eO(r, {
          method: e.method,
          headers: es(e.headers),
          duplex: 'half',
          signal: t,
          ...(t.aborted ? {} : { body: n }),
        });
      }
      static fromWebNextRequest(e) {
        let t = null;
        return (
          'GET' !== e.method && 'HEAD' !== e.method && (t = e.body),
          new eO(e.url, {
            method: e.method,
            headers: es(e.headers),
            duplex: 'half',
            signal: e.request.signal,
            ...(e.request.signal.aborted ? {} : { body: t }),
          })
        );
      }
    }
    let eN = 0,
      eR = 0,
      eT = 0;
    function ej(e) {
      return (null == e ? void 0 : e.name) === 'AbortError' || (null == e ? void 0 : e.name) === eE;
    }
    async function eA(e, t, r) {
      try {
        let { errored: n, destroyed: i } = t;
        if (n || i) return;
        let a = eI(t),
          o = (function (e, t) {
            let r = !1,
              n = new K();
            function i() {
              n.resolve();
            }
            (e.on('drain', i),
              e.once('close', () => {
                (e.off('drain', i), n.resolve());
              }));
            let a = new K();
            return (
              e.once('finish', () => {
                a.resolve();
              }),
              new WritableStream({
                write: async (t) => {
                  if (!r) {
                    if (
                      ((r = !0),
                      'performance' in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX)
                    ) {
                      let e = (function (e = {}) {
                        let t =
                          0 === eN
                            ? void 0
                            : {
                                clientComponentLoadStart: eN,
                                clientComponentLoadTimes: eR,
                                clientComponentLoadCount: eT,
                              };
                        return (e.reset && ((eN = 0), (eR = 0), (eT = 0)), t);
                      })();
                      e &&
                        performance.measure(
                          `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,
                          {
                            start: e.clientComponentLoadStart,
                            end: e.clientComponentLoadStart + e.clientComponentLoadTimes,
                          }
                        );
                    }
                    (e.flushHeaders(),
                      A().trace(c.startResponse, { spanName: 'start response' }, () => void 0));
                  }
                  try {
                    let r = e.write(t);
                    ('flush' in e && 'function' == typeof e.flush && e.flush(),
                      r || (await n.promise, (n = new K())));
                  } catch (t) {
                    throw (
                      e.end(),
                      Object.defineProperty(
                        Error('failed to write chunk to response', { cause: t }),
                        '__NEXT_ERROR_CODE',
                        { value: 'E321', enumerable: !1, configurable: !0 }
                      )
                    );
                  }
                },
                abort: (t) => {
                  e.writableFinished || e.destroy(t);
                },
                close: async () => {
                  if ((t && (await t), !e.writableFinished)) return (e.end(), a.promise);
                },
              })
            );
          })(t, r);
        await e.pipeTo(o, { signal: a.signal });
      } catch (e) {
        if (ej(e)) return;
        throw Object.defineProperty(
          Error('failed to pipe response', { cause: e }),
          '__NEXT_ERROR_CODE',
          { value: 'E180', enumerable: !1, configurable: !0 }
        );
      }
    }
    class eD {
      static #e = (this.EMPTY = new eD(null, { metadata: {}, contentType: null }));
      static fromStatic(e, t) {
        return new eD(e, { metadata: {}, contentType: t });
      }
      constructor(e, { contentType: t, waitUntil: r, metadata: n }) {
        ((this.response = e), (this.contentType = t), (this.metadata = n), (this.waitUntil = r));
      }
      assignMetadata(e) {
        Object.assign(this.metadata, e);
      }
      get isNull() {
        return null === this.response;
      }
      get isDynamic() {
        return 'string' != typeof this.response;
      }
      toUnchunkedString(e = !1) {
        if (null === this.response) return '';
        if ('string' != typeof this.response) {
          if (!e)
            throw Object.defineProperty(
              new V('dynamic responses cannot be unchunked. This is a bug in Next.js'),
              '__NEXT_ERROR_CODE',
              { value: 'E732', enumerable: !1, configurable: !0 }
            );
          return ei(this.readable);
        }
        return this.response;
      }
      get readable() {
        return null === this.response
          ? new ReadableStream({
              start(e) {
                e.close();
              },
            })
          : 'string' == typeof this.response
            ? er(this.response)
            : Buffer.isBuffer(this.response)
              ? en(this.response)
              : Array.isArray(this.response)
                ? (function (...e) {
                    if (0 === e.length)
                      return new ReadableStream({
                        start(e) {
                          e.close();
                        },
                      });
                    if (1 === e.length) return e[0];
                    let { readable: t, writable: r } = new TransformStream(),
                      n = e[0].pipeTo(r, { preventClose: !0 }),
                      i = 1;
                    for (; i < e.length - 1; i++) {
                      let t = e[i];
                      n = n.then(() => t.pipeTo(r, { preventClose: !0 }));
                    }
                    let a = e[i];
                    return ((n = n.then(() => a.pipeTo(r))).catch(ee), t);
                  })(...this.response)
                : this.response;
      }
      coerce() {
        return null === this.response
          ? []
          : 'string' == typeof this.response
            ? [er(this.response)]
            : Array.isArray(this.response)
              ? this.response
              : Buffer.isBuffer(this.response)
                ? [en(this.response)]
                : [this.response];
      }
      unshift(e) {
        ((this.response = this.coerce()), this.response.unshift(e));
      }
      push(e) {
        ((this.response = this.coerce()), this.response.push(e));
      }
      async pipeTo(e) {
        try {
          (await this.readable.pipeTo(e, { preventClose: !0 }),
            this.waitUntil && (await this.waitUntil),
            await e.close());
        } catch (t) {
          if (ej(t)) return void (await e.abort(t));
          throw t;
        }
      }
      async pipeToNodeResponse(e) {
        await eA(this.readable, e, this.waitUntil);
      }
    }
    let eU = Symbol.for('next-patch');
    function ez(e, t) {
      e.shouldTrackFetchMetrics &&
        ((e.fetchMetrics ??= []),
        e.fetchMetrics.push({
          ...t,
          end: performance.timeOrigin + performance.now(),
          idx: e.nextFetchId || 0,
        }));
    }
    async function eC(e, t, r, n, i, a) {
      let o = await e.arrayBuffer(),
        s = {
          headers: Object.fromEntries(e.headers.entries()),
          body: Buffer.from(o).toString('base64'),
          status: e.status,
          url: e.url,
        };
      return (
        r && (await n.set(t, { kind: Y.FETCH, data: s, revalidate: i }, r)),
        await a(),
        new Response(o, { headers: e.headers, status: e.status, statusText: e.statusText })
      );
    }
    async function eZ(e, t, r, n, i, a, o, s, u) {
      let [l, c] = J(t),
        d = l
          .arrayBuffer()
          .then(async (e) => {
            let t = Buffer.from(e),
              s = {
                headers: Object.fromEntries(l.headers.entries()),
                body: t.toString('base64'),
                status: l.status,
                url: l.url,
              };
            (null == a || a.set(r, s),
              n && (await i.set(r, { kind: Y.FETCH, data: s, revalidate: o }, n)));
          })
          .catch((e) => console.warn('Failed to set fetch cache', s, e))
          .finally(u),
        f = `cache-set-${r}`;
      return (
        (e.pendingRevalidates ??= {}),
        f in e.pendingRevalidates && (await e.pendingRevalidates[f]),
        (e.pendingRevalidates[f] = d.finally(() => {
          var t;
          (null == (t = e.pendingRevalidates) ? void 0 : t[f]) && delete e.pendingRevalidates[f];
        })),
        c
      );
    }
    class eL {
      static get(e, t, r) {
        let n = Reflect.get(e, t, r);
        return 'function' == typeof n ? n.bind(e) : n;
      }
      static set(e, t, r, n) {
        return Reflect.set(e, t, r, n);
      }
      static has(e, t) {
        return Reflect.has(e, t);
      }
      static deleteProperty(e, t) {
        return Reflect.deleteProperty(e, t);
      }
    }
    class eM extends Error {
      constructor() {
        super(
          'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'
        );
      }
      static callable() {
        throw new eM();
      }
    }
    class eB extends Headers {
      constructor(e) {
        (super(),
          (this.headers = new Proxy(e, {
            get(t, r, n) {
              if ('symbol' == typeof r) return eL.get(t, r, n);
              let i = r.toLowerCase(),
                a = Object.keys(e).find((e) => e.toLowerCase() === i);
              if (void 0 !== a) return eL.get(t, a, n);
            },
            set(t, r, n, i) {
              if ('symbol' == typeof r) return eL.set(t, r, n, i);
              let a = r.toLowerCase(),
                o = Object.keys(e).find((e) => e.toLowerCase() === a);
              return eL.set(t, o ?? r, n, i);
            },
            has(t, r) {
              if ('symbol' == typeof r) return eL.has(t, r);
              let n = r.toLowerCase(),
                i = Object.keys(e).find((e) => e.toLowerCase() === n);
              return void 0 !== i && eL.has(t, i);
            },
            deleteProperty(t, r) {
              if ('symbol' == typeof r) return eL.deleteProperty(t, r);
              let n = r.toLowerCase(),
                i = Object.keys(e).find((e) => e.toLowerCase() === n);
              return void 0 === i || eL.deleteProperty(t, i);
            },
          })));
      }
      static seal(e) {
        return new Proxy(e, {
          get(e, t, r) {
            switch (t) {
              case 'append':
              case 'delete':
              case 'set':
                return eM.callable;
              default:
                return eL.get(e, t, r);
            }
          },
        });
      }
      merge(e) {
        return Array.isArray(e) ? e.join(', ') : e;
      }
      static from(e) {
        return e instanceof Headers ? e : new eB(e);
      }
      append(e, t) {
        let r = this.headers[e];
        'string' == typeof r
          ? (this.headers[e] = [r, t])
          : Array.isArray(r)
            ? r.push(t)
            : (this.headers[e] = t);
      }
      delete(e) {
        delete this.headers[e];
      }
      get(e) {
        let t = this.headers[e];
        return void 0 !== t ? this.merge(t) : null;
      }
      has(e) {
        return void 0 !== this.headers[e];
      }
      set(e, t) {
        this.headers[e] = t;
      }
      forEach(e, t) {
        for (let [r, n] of this.entries()) e.call(t, n, r, this);
      }
      *entries() {
        for (let e of Object.keys(this.headers)) {
          let t = e.toLowerCase(),
            r = this.get(t);
          yield [t, r];
        }
      }
      *keys() {
        for (let e of Object.keys(this.headers)) {
          let t = e.toLowerCase();
          yield t;
        }
      }
      *values() {
        for (let e of Object.keys(this.headers)) {
          let t = this.get(e);
          yield t;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    }
    Symbol('__next_preview_data');
    let eF = Symbol('__prerender_bypass');
    var eG = (function (e) {
      return (
        (e[(e.SeeOther = 303)] = 'SeeOther'),
        (e[(e.TemporaryRedirect = 307)] = 'TemporaryRedirect'),
        (e[(e.PermanentRedirect = 308)] = 'PermanentRedirect'),
        e
      );
    })({});
    class eV {
      constructor(e, t, r) {
        ((this.method = e), (this.url = t), (this.body = r));
      }
      get cookies() {
        var t;
        return this._cookies
          ? this._cookies
          : (this._cookies = ((t = this.headers),
            function () {
              let { cookie: r } = t;
              if (!r) return {};
              let { parse: n } = e.r(40374);
              return n(Array.isArray(r) ? r.join('; ') : r);
            })());
      }
    }
    class eX {
      constructor(e) {
        this.destination = e;
      }
      redirect(e, t) {
        return (
          this.setHeader('Location', e),
          (this.statusCode = t),
          t === eG.PermanentRedirect && this.setHeader('Refresh', `0;url=${e}`),
          this
        );
      }
    }
    class eq extends eV {
      static #e = (n = ea);
      constructor(e) {
        var t;
        (super(e.method.toUpperCase(), e.url, e),
          (this._req = e),
          (this.headers = this._req.headers),
          (this.fetchMetrics = null == (t = this._req) ? void 0 : t.fetchMetrics),
          (this[n] = this._req[ea] || {}),
          (this.streaming = !1));
      }
      get originalRequest() {
        return (
          (this._req[ea] = this[ea]),
          (this._req.url = this.url),
          (this._req.cookies = this.cookies),
          this._req
        );
      }
      set originalRequest(e) {
        this._req = e;
      }
      stream() {
        if (this.streaming)
          throw Object.defineProperty(
            Error('Invariant: NodeNextRequest.stream() can only be called once'),
            '__NEXT_ERROR_CODE',
            { value: 'E467', enumerable: !1, configurable: !0 }
          );
        return (
          (this.streaming = !0),
          new ReadableStream({
            start: (e) => {
              (this._req.on('data', (t) => {
                e.enqueue(new Uint8Array(t));
              }),
                this._req.on('end', () => {
                  e.close();
                }),
                this._req.on('error', (t) => {
                  e.error(t);
                }));
            },
          })
        );
      }
    }
    class eW extends eX {
      get originalResponse() {
        return (eF in this && (this._res[eF] = this[eF]), this._res);
      }
      constructor(e) {
        (super(e), (this._res = e), (this.textBody = void 0));
      }
      get sent() {
        return this._res.finished || this._res.headersSent;
      }
      get statusCode() {
        return this._res.statusCode;
      }
      set statusCode(e) {
        this._res.statusCode = e;
      }
      get statusMessage() {
        return this._res.statusMessage;
      }
      set statusMessage(e) {
        this._res.statusMessage = e;
      }
      setHeader(e, t) {
        return (this._res.setHeader(e, t), this);
      }
      removeHeader(e) {
        return (this._res.removeHeader(e), this);
      }
      getHeaderValues(e) {
        let t = this._res.getHeader(e);
        if (void 0 !== t) return (Array.isArray(t) ? t : [t]).map((e) => e.toString());
      }
      hasHeader(e) {
        return this._res.hasHeader(e);
      }
      getHeader(e) {
        let t = this.getHeaderValues(e);
        return Array.isArray(t) ? t.join(',') : void 0;
      }
      getHeaders() {
        return this._res.getHeaders();
      }
      appendHeader(e, t) {
        let r = this.getHeaderValues(e) ?? [];
        return (r.includes(t) || this._res.setHeader(e, [...r, t]), this);
      }
      body(e) {
        return ((this.textBody = e), this);
      }
      send() {
        this._res.end(this.textBody);
      }
      onClose(e) {
        this.originalResponse.on('close', e);
      }
    }
    function eH(e) {
      return e.isOnDemandRevalidate ? 'on-demand' : e.isRevalidate ? 'stale' : void 0;
    }
    async function eJ(e, t, r, n) {
      {
        var i;
        ((t.statusCode = r.status), (t.statusMessage = r.statusText));
        let a = ['set-cookie', 'www-authenticate', 'proxy-authenticate', 'vary'];
        null == (i = r.headers) ||
          i.forEach((e, r) => {
            if ('x-middleware-set-cookie' !== r.toLowerCase())
              if ('set-cookie' === r.toLowerCase()) for (let n of eu(e)) t.appendHeader(r, n);
              else {
                let n = void 0 !== t.getHeader(r);
                (a.includes(r.toLowerCase()) || !n) && t.appendHeader(r, e);
              }
          });
        let { originalResponse: o } = t;
        r.body && 'HEAD' !== e.method ? await eA(r.body, o, n) : o.end();
      }
    }
    var eK = e.i(93695);
    e.s(['GET', () => cY, 'dynamic', () => cK], 49345);
    var eY = e.i(75352);
    function eQ(e, t) {
      if (e instanceof Promise) throw Error(t);
    }
    (e.s(
      [
        '$brand',
        () => e4,
        '$input',
        () => a7,
        '$output',
        () => a3,
        'NEVER',
        () => e0,
        'TimePrecision',
        () => oO,
        'ZodAny',
        () => lx,
        'ZodArray',
        () => lR,
        'ZodBase64',
        () => uK,
        'ZodBase64URL',
        () => uQ,
        'ZodBigInt',
        () => lc,
        'ZodBigIntFormat',
        () => lf,
        'ZodBoolean',
        () => lu,
        'ZodCIDRv4',
        () => uq,
        'ZodCIDRv6',
        () => uH,
        'ZodCUID',
        () => uj,
        'ZodCUID2',
        () => uD,
        'ZodCatch',
        () => cd,
        'ZodCodec',
        () => cv,
        'ZodCustom',
        () => cP,
        'ZodCustomStringFormat',
        () => u9,
        'ZodDate',
        () => lP,
        'ZodDefault',
        () => cn,
        'ZodDiscriminatedUnion',
        () => lL,
        'ZodE164',
        () => u1,
        'ZodEmail',
        () => uv,
        'ZodEmoji',
        () => uP,
        'ZodEnum',
        () => lQ,
        'ZodError',
        () => s5,
        'ZodFile',
        () => l2,
        'ZodFirstPartyTypeKind',
        () => i,
        'ZodFunction',
        () => ck,
        'ZodGUID',
        () => u_,
        'ZodIPv4',
        () => uF,
        'ZodIPv6',
        () => uV,
        'ZodISODate',
        () => s1,
        'ZodISODateTime',
        () => sQ,
        'ZodISODuration',
        () => s9,
        'ZodISOTime',
        () => s6,
        'ZodIntersection',
        () => lB,
        'ZodIssueCode',
        () => cC,
        'ZodJWT',
        () => u6,
        'ZodKSUID',
        () => uM,
        'ZodLazy',
        () => cw,
        'ZodLiteral',
        () => l4,
        'ZodMap',
        () => lH,
        'ZodNaN',
        () => cp,
        'ZodNanoID',
        () => uR,
        'ZodNever',
        () => lO,
        'ZodNonOptional',
        () => cs,
        'ZodNull',
        () => l_,
        'ZodNullable',
        () => ce,
        'ZodNumber',
        () => le,
        'ZodNumberFormat',
        () => lr,
        'ZodObject',
        () => lA,
        'ZodOptional',
        () => l5,
        'ZodPipe',
        () => cg,
        'ZodPrefault',
        () => ca,
        'ZodPromise',
        () => cO,
        'ZodReadonly',
        () => c_,
        'ZodRealError',
        () => s8,
        'ZodRecord',
        () => lX,
        'ZodSet',
        () => lK,
        'ZodString',
        () => um,
        'ZodStringFormat',
        () => uh,
        'ZodSuccess',
        () => cl,
        'ZodSymbol',
        () => lg,
        'ZodTemplateLiteral',
        () => cx,
        'ZodTransform',
        () => l3,
        'ZodTuple',
        () => lG,
        'ZodType',
        () => uf,
        'ZodULID',
        () => uz,
        'ZodURL',
        () => uE,
        'ZodUUID',
        () => ux,
        'ZodUndefined',
        () => lv,
        'ZodUnion',
        () => lC,
        'ZodUnknown',
        () => lw,
        'ZodVoid',
        () => lk,
        'ZodXID',
        () => uZ,
        '_ZodString',
        () => up,
        '_default',
        () => ci,
        '_function',
        () => cI,
        'any',
        () => l$,
        'array',
        () => lT,
        'base64',
        () => uY,
        'base64url',
        () => u0,
        'bigint',
        () => ld,
        'boolean',
        () => ll,
        'catch',
        () => cf,
        'check',
        () => cN,
        'cidrv4',
        () => uW,
        'cidrv6',
        () => uJ,
        'clone',
        () => tP,
        'codec',
        () => cb,
        'coerce',
        () => cW,
        'config',
        () => e3,
        'core',
        () => sJ,
        'cuid',
        () => uA,
        'cuid2',
        () => uU,
        'custom',
        () => cR,
        'date',
        () => lN,
        'decode',
        () => ua,
        'decodeAsync',
        () => us,
        'discriminatedUnion',
        () => lM,
        'e164',
        () => u4,
        'email',
        () => ub,
        'emoji',
        () => uN,
        'encode',
        () => ui,
        'encodeAsync',
        () => uo,
        'endsWith',
        () => sl,
        'enum',
        () => l0,
        'file',
        () => l9,
        'flattenError',
        () => t5,
        'float32',
        () => li,
        'float64',
        () => la,
        'formatError',
        () => t8,
        'function',
        () => cI,
        'getErrorMap',
        () => cL,
        'globalRegistry',
        () => oe,
        'gt',
        () => o1,
        'gte',
        () => o4,
        'guid',
        () => uy,
        'hash',
        () => u8,
        'hex',
        () => u5,
        'hostname',
        () => u7,
        'httpUrl',
        () => uI,
        'includes',
        () => ss,
        'instanceof',
        () => cA,
        'int',
        () => ln,
        'int32',
        () => lo,
        'int64',
        () => lp,
        'intersection',
        () => lF,
        'ipv4',
        () => uG,
        'ipv6',
        () => uX,
        'iso',
        () => cB,
        'json',
        () => cU,
        'jwt',
        () => u2,
        'keyof',
        () => lj,
        'ksuid',
        () => uB,
        'lazy',
        () => cS,
        'length',
        () => sn,
        'literal',
        () => l6,
        'locales',
        () => cM,
        'looseObject',
        () => lz,
        'lowercase',
        () => sa,
        'lt',
        () => oQ,
        'lte',
        () => o0,
        'map',
        () => lJ,
        'maxLength',
        () => st,
        'maxSize',
        () => o5,
        'mime',
        () => sd,
        'minLength',
        () => sr,
        'minSize',
        () => o8,
        'multipleOf',
        () => o7,
        'nan',
        () => cm,
        'nanoid',
        () => uT,
        'nativeEnum',
        () => l1,
        'negative',
        () => o2,
        'never',
        () => lE,
        'nonnegative',
        () => o3,
        'nonoptional',
        () => cu,
        'nonpositive',
        () => o9,
        'normalize',
        () => sp,
        'null',
        () => ly,
        'nullable',
        () => ct,
        'nullish',
        () => cr,
        'number',
        () => lt,
        'object',
        () => lD,
        'optional',
        () => l8,
        'overwrite',
        () => sf,
        'parse',
        () => ue,
        'parseAsync',
        () => ut,
        'partialRecord',
        () => lW,
        'pipe',
        () => ch,
        'positive',
        () => o6,
        'prefault',
        () => co,
        'preprocess',
        () => cz,
        'prettifyError',
        () => rr,
        'promise',
        () => cE,
        'property',
        () => sc,
        'readonly',
        () => cy,
        'record',
        () => lq,
        'refine',
        () => cT,
        'regex',
        () => si,
        'regexes',
        () => sK,
        'registry',
        () => a8,
        'safeDecode',
        () => ul,
        'safeDecodeAsync',
        () => ud,
        'safeEncode',
        () => uu,
        'safeEncodeAsync',
        () => uc,
        'safeParse',
        () => ur,
        'safeParseAsync',
        () => un,
        'set',
        () => lY,
        'setErrorMap',
        () => cZ,
        'size',
        () => se,
        'startsWith',
        () => su,
        'strictObject',
        () => lU,
        'string',
        () => ug,
        'stringFormat',
        () => u3,
        'stringbool',
        () => cD,
        'success',
        () => cc,
        'superRefine',
        () => cj,
        'symbol',
        () => lh,
        'templateLiteral',
        () => c$,
        'toJSONSchema',
        () => sW,
        'toLowerCase',
        () => sg,
        'toUpperCase',
        () => sh,
        'transform',
        () => l7,
        'treeifyError',
        () => re,
        'trim',
        () => sm,
        'tuple',
        () => lV,
        'uint32',
        () => ls,
        'uint64',
        () => lm,
        'ulid',
        () => uC,
        'undefined',
        () => lb,
        'union',
        () => lZ,
        'unknown',
        () => lS,
        'uppercase',
        () => so,
        'url',
        () => uk,
        'util',
        () => sY,
        'uuid',
        () => u$,
        'uuidv4',
        () => uw,
        'uuidv6',
        () => uS,
        'uuidv7',
        () => uO,
        'void',
        () => lI,
        'xid',
        () => uL,
      ],
      23629
    ),
      e.s([], 48609),
      e.s(
        [
          '$ZodAsyncError',
          () => e6,
          '$ZodEncodeError',
          () => e2,
          '$brand',
          () => e4,
          '$constructor',
          () => e1,
          'NEVER',
          () => e0,
          'config',
          () => e3,
          'globalConfig',
          () => e9,
        ],
        77256
      ));
    let e0 = Object.freeze({ status: 'aborted' });
    function e1(e, t, r) {
      function n(r, n) {
        var i;
        for (let a in (Object.defineProperty(r, '_zod', { value: r._zod ?? {}, enumerable: !1 }),
        (i = r._zod).traits ?? (i.traits = new Set()),
        r._zod.traits.add(e),
        t(r, n),
        o.prototype))
          a in r || Object.defineProperty(r, a, { value: o.prototype[a].bind(r) });
        ((r._zod.constr = o), (r._zod.def = n));
      }
      let i = r?.Parent ?? Object;
      class a extends i {}
      function o(e) {
        var t;
        let i = r?.Parent ? new a() : this;
        for (let r of (n(i, e), (t = i._zod).deferred ?? (t.deferred = []), i._zod.deferred)) r();
        return i;
      }
      return (
        Object.defineProperty(a, 'name', { value: e }),
        Object.defineProperty(o, 'init', { value: n }),
        Object.defineProperty(o, Symbol.hasInstance, {
          value: (t) => (!!r?.Parent && t instanceof r.Parent) || t?._zod?.traits?.has(e),
        }),
        Object.defineProperty(o, 'name', { value: e }),
        o
      );
    }
    let e4 = Symbol('zod_brand');
    class e6 extends Error {
      constructor() {
        super('Encountered Promise during synchronous parse. Use .parseAsync() instead.');
      }
    }
    class e2 extends Error {
      constructor(e) {
        (super(`Encountered unidirectional transform during encode: ${e}`),
          (this.name = 'ZodEncodeError'));
      }
    }
    let e9 = {};
    function e3(e) {
      return (e && Object.assign(e9, e), e9);
    }
    function e7(e) {
      return e;
    }
    function e5(e) {
      return e;
    }
    function e8(e) {}
    function te(e) {
      throw Error();
    }
    function tt(e) {}
    function tr(e) {
      let t = Object.values(e).filter((e) => 'number' == typeof e);
      return Object.entries(e)
        .filter(([e, r]) => -1 === t.indexOf(+e))
        .map(([e, t]) => t);
    }
    function tn(e, t = '|') {
      return e.map((e) => tT(e)).join(t);
    }
    function ti(e, t) {
      return 'bigint' == typeof t ? t.toString() : t;
    }
    function ta(e) {
      return {
        get value() {
          {
            let t = e();
            return (Object.defineProperty(this, 'value', { value: t }), t);
          }
        },
      };
    }
    function to(e) {
      return null == e;
    }
    function ts(e) {
      let t = +!!e.startsWith('^'),
        r = e.endsWith('$') ? e.length - 1 : e.length;
      return e.slice(t, r);
    }
    function tu(e, t) {
      let r = (e.toString().split('.')[1] || '').length,
        n = t.toString(),
        i = (n.split('.')[1] || '').length;
      if (0 === i && /\d?e-\d?/.test(n)) {
        let e = n.match(/\d?e-(\d?)/);
        e?.[1] && (i = Number.parseInt(e[1]));
      }
      let a = r > i ? r : i;
      return (
        (Number.parseInt(e.toFixed(a).replace('.', '')) %
          Number.parseInt(t.toFixed(a).replace('.', ''))) /
        10 ** a
      );
    }
    e.s(
      [
        'BIGINT_FORMAT_RANGES',
        () => tD,
        'Class',
        () => t6,
        'NUMBER_FORMAT_RANGES',
        () => tA,
        'aborted',
        () => tF,
        'allowsEval',
        () => tx,
        'assert',
        () => tt,
        'assertEqual',
        () => e7,
        'assertIs',
        () => e8,
        'assertNever',
        () => te,
        'assertNotEqual',
        () => e5,
        'assignProp',
        () => tf,
        'base64ToUint8Array',
        () => tK,
        'base64urlToUint8Array',
        () => tQ,
        'cached',
        () => ta,
        'captureStackTrace',
        () => t_,
        'cleanEnum',
        () => tJ,
        'cleanRegex',
        () => ts,
        'clone',
        () => tP,
        'cloneDef',
        () => tm,
        'createTransparentProxy',
        () => tR,
        'defineLazy',
        () => tc,
        'esc',
        () => tb,
        'escapeRegex',
        () => tI,
        'extend',
        () => tC,
        'finalizeIssue',
        () => tX,
        'floatSafeRemainder',
        () => tu,
        'getElementAtPath',
        () => tg,
        'getEnumValues',
        () => tr,
        'getLengthableOrigin',
        () => tW,
        'getParsedType',
        () => tO,
        'getSizableOrigin',
        () => tq,
        'hexToUint8Array',
        () => t1,
        'isObject',
        () => ty,
        'isPlainObject',
        () => t$,
        'issue',
        () => tH,
        'joinValues',
        () => tn,
        'jsonStringifyReplacer',
        () => ti,
        'merge',
        () => tL,
        'mergeDefs',
        () => tp,
        'normalizeParams',
        () => tN,
        'nullish',
        () => to,
        'numKeys',
        () => tS,
        'objectClone',
        () => td,
        'omit',
        () => tz,
        'optionalKeys',
        () => tj,
        'partial',
        () => tM,
        'pick',
        () => tU,
        'prefixIssues',
        () => tG,
        'primitiveTypes',
        () => tk,
        'promiseAllObject',
        () => th,
        'propertyKeyTypes',
        () => tE,
        'randomString',
        () => tv,
        'required',
        () => tB,
        'safeExtend',
        () => tZ,
        'shallowClone',
        () => tw,
        'stringifyPrimitive',
        () => tT,
        'uint8ArrayToBase64',
        () => tY,
        'uint8ArrayToBase64url',
        () => t0,
        'uint8ArrayToHex',
        () => t4,
        'unwrapMessage',
        () => tV,
      ],
      83254
    );
    let tl = Symbol('evaluating');
    function tc(e, t, r) {
      let n;
      Object.defineProperty(e, t, {
        get() {
          if (n !== tl) return (void 0 === n && ((n = tl), (n = r())), n);
        },
        set(r) {
          Object.defineProperty(e, t, { value: r });
        },
        configurable: !0,
      });
    }
    function td(e) {
      return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
    }
    function tf(e, t, r) {
      Object.defineProperty(e, t, { value: r, writable: !0, enumerable: !0, configurable: !0 });
    }
    function tp(...e) {
      let t = {};
      for (let r of e) Object.assign(t, Object.getOwnPropertyDescriptors(r));
      return Object.defineProperties({}, t);
    }
    function tm(e) {
      return tp(e._zod.def);
    }
    function tg(e, t) {
      return t ? t.reduce((e, t) => e?.[t], e) : e;
    }
    function th(e) {
      let t = Object.keys(e);
      return Promise.all(t.map((t) => e[t])).then((e) => {
        let r = {};
        for (let n = 0; n < t.length; n++) r[t[n]] = e[n];
        return r;
      });
    }
    function tv(e = 10) {
      let t = 'abcdefghijklmnopqrstuvwxyz',
        r = '';
      for (let n = 0; n < e; n++) r += t[Math.floor(Math.random() * t.length)];
      return r;
    }
    function tb(e) {
      return JSON.stringify(e);
    }
    let t_ = 'captureStackTrace' in Error ? Error.captureStackTrace : (...e) => {};
    function ty(e) {
      return 'object' == typeof e && null !== e && !Array.isArray(e);
    }
    let tx = ta(() => {
      if ('undefined' != typeof navigator && navigator?.userAgent?.includes('Cloudflare'))
        return !1;
      try {
        return (Function(''), !0);
      } catch (e) {
        return !1;
      }
    });
    function t$(e) {
      if (!1 === ty(e)) return !1;
      let t = e.constructor;
      if (void 0 === t) return !0;
      let r = t.prototype;
      return !1 !== ty(r) && !1 !== Object.prototype.hasOwnProperty.call(r, 'isPrototypeOf');
    }
    function tw(e) {
      return t$(e) ? { ...e } : e;
    }
    function tS(e) {
      let t = 0;
      for (let r in e) Object.prototype.hasOwnProperty.call(e, r) && t++;
      return t;
    }
    let tO = (e) => {
        let t = typeof e;
        switch (t) {
          case 'undefined':
            return 'undefined';
          case 'string':
            return 'string';
          case 'number':
            return Number.isNaN(e) ? 'nan' : 'number';
          case 'boolean':
            return 'boolean';
          case 'function':
            return 'function';
          case 'bigint':
            return 'bigint';
          case 'symbol':
            return 'symbol';
          case 'object':
            if (Array.isArray(e)) return 'array';
            if (null === e) return 'null';
            if (e.then && 'function' == typeof e.then && e.catch && 'function' == typeof e.catch)
              return 'promise';
            if ('undefined' != typeof Map && e instanceof Map) return 'map';
            if ('undefined' != typeof Set && e instanceof Set) return 'set';
            if ('undefined' != typeof Date && e instanceof Date) return 'date';
            if ('undefined' != typeof File && e instanceof File) return 'file';
            return 'object';
          default:
            throw Error(`Unknown data type: ${t}`);
        }
      },
      tE = new Set(['string', 'number', 'symbol']),
      tk = new Set(['string', 'number', 'bigint', 'boolean', 'symbol', 'undefined']);
    function tI(e) {
      return e.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    function tP(e, t, r) {
      let n = new e._zod.constr(t ?? e._zod.def);
      return ((!t || r?.parent) && (n._zod.parent = e), n);
    }
    function tN(e) {
      if (!e) return {};
      if ('string' == typeof e) return { error: () => e };
      if (e?.message !== void 0) {
        if (e?.error !== void 0) throw Error('Cannot specify both `message` and `error` params');
        e.error = e.message;
      }
      return (delete e.message, 'string' == typeof e.error) ? { ...e, error: () => e.error } : e;
    }
    function tR(e) {
      let t;
      return new Proxy(
        {},
        {
          get: (r, n, i) => (t ?? (t = e()), Reflect.get(t, n, i)),
          set: (r, n, i, a) => (t ?? (t = e()), Reflect.set(t, n, i, a)),
          has: (r, n) => (t ?? (t = e()), Reflect.has(t, n)),
          deleteProperty: (r, n) => (t ?? (t = e()), Reflect.deleteProperty(t, n)),
          ownKeys: (r) => (t ?? (t = e()), Reflect.ownKeys(t)),
          getOwnPropertyDescriptor: (r, n) => (
            t ?? (t = e()),
            Reflect.getOwnPropertyDescriptor(t, n)
          ),
          defineProperty: (r, n, i) => (t ?? (t = e()), Reflect.defineProperty(t, n, i)),
        }
      );
    }
    function tT(e) {
      return 'bigint' == typeof e ? e.toString() + 'n' : 'string' == typeof e ? `"${e}"` : `${e}`;
    }
    function tj(e) {
      return Object.keys(e).filter(
        (t) => 'optional' === e[t]._zod.optin && 'optional' === e[t]._zod.optout
      );
    }
    let tA = {
        safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
        int32: [-0x80000000, 0x7fffffff],
        uint32: [0, 0xffffffff],
        float32: [-34028234663852886e22, 34028234663852886e22],
        float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
      },
      tD = {
        int64: [BigInt('-9223372036854775808'), BigInt('9223372036854775807')],
        uint64: [BigInt(0), BigInt('18446744073709551615')],
      };
    function tU(e, t) {
      let r = e._zod.def,
        n = tp(e._zod.def, {
          get shape() {
            let e = {};
            for (let n in t) {
              if (!(n in r.shape)) throw Error(`Unrecognized key: "${n}"`);
              t[n] && (e[n] = r.shape[n]);
            }
            return (tf(this, 'shape', e), e);
          },
          checks: [],
        });
      return tP(e, n);
    }
    function tz(e, t) {
      let r = e._zod.def,
        n = tp(e._zod.def, {
          get shape() {
            let n = { ...e._zod.def.shape };
            for (let e in t) {
              if (!(e in r.shape)) throw Error(`Unrecognized key: "${e}"`);
              t[e] && delete n[e];
            }
            return (tf(this, 'shape', n), n);
          },
          checks: [],
        });
      return tP(e, n);
    }
    function tC(e, t) {
      if (!t$(t)) throw Error('Invalid input to extend: expected a plain object');
      let r = e._zod.def.checks;
      if (r && r.length > 0)
        throw Error(
          'Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.'
        );
      let n = tp(e._zod.def, {
        get shape() {
          let r = { ...e._zod.def.shape, ...t };
          return (tf(this, 'shape', r), r);
        },
        checks: [],
      });
      return tP(e, n);
    }
    function tZ(e, t) {
      if (!t$(t)) throw Error('Invalid input to safeExtend: expected a plain object');
      let r = {
        ...e._zod.def,
        get shape() {
          let r = { ...e._zod.def.shape, ...t };
          return (tf(this, 'shape', r), r);
        },
        checks: e._zod.def.checks,
      };
      return tP(e, r);
    }
    function tL(e, t) {
      let r = tp(e._zod.def, {
        get shape() {
          let r = { ...e._zod.def.shape, ...t._zod.def.shape };
          return (tf(this, 'shape', r), r);
        },
        get catchall() {
          return t._zod.def.catchall;
        },
        checks: [],
      });
      return tP(e, r);
    }
    function tM(e, t, r) {
      let n = tp(t._zod.def, {
        get shape() {
          let n = t._zod.def.shape,
            i = { ...n };
          if (r)
            for (let t in r) {
              if (!(t in n)) throw Error(`Unrecognized key: "${t}"`);
              r[t] && (i[t] = e ? new e({ type: 'optional', innerType: n[t] }) : n[t]);
            }
          else for (let t in n) i[t] = e ? new e({ type: 'optional', innerType: n[t] }) : n[t];
          return (tf(this, 'shape', i), i);
        },
        checks: [],
      });
      return tP(t, n);
    }
    function tB(e, t, r) {
      let n = tp(t._zod.def, {
        get shape() {
          let n = t._zod.def.shape,
            i = { ...n };
          if (r)
            for (let t in r) {
              if (!(t in i)) throw Error(`Unrecognized key: "${t}"`);
              r[t] && (i[t] = new e({ type: 'nonoptional', innerType: n[t] }));
            }
          else for (let t in n) i[t] = new e({ type: 'nonoptional', innerType: n[t] });
          return (tf(this, 'shape', i), i);
        },
        checks: [],
      });
      return tP(t, n);
    }
    function tF(e, t = 0) {
      if (!0 === e.aborted) return !0;
      for (let r = t; r < e.issues.length; r++) if (e.issues[r]?.continue !== !0) return !0;
      return !1;
    }
    function tG(e, t) {
      return t.map((t) => (t.path ?? (t.path = []), t.path.unshift(e), t));
    }
    function tV(e) {
      return 'string' == typeof e ? e : e?.message;
    }
    function tX(e, t, r) {
      let n = { ...e, path: e.path ?? [] };
      return (
        e.message ||
          (n.message =
            tV(e.inst?._zod.def?.error?.(e)) ??
            tV(t?.error?.(e)) ??
            tV(r.customError?.(e)) ??
            tV(r.localeError?.(e)) ??
            'Invalid input'),
        delete n.inst,
        delete n.continue,
        t?.reportInput || delete n.input,
        n
      );
    }
    function tq(e) {
      return e instanceof Set
        ? 'set'
        : e instanceof Map
          ? 'map'
          : e instanceof File
            ? 'file'
            : 'unknown';
    }
    function tW(e) {
      return Array.isArray(e) ? 'array' : 'string' == typeof e ? 'string' : 'unknown';
    }
    function tH(...e) {
      let [t, r, n] = e;
      return 'string' == typeof t ? { message: t, code: 'custom', input: r, inst: n } : { ...t };
    }
    function tJ(e) {
      return Object.entries(e)
        .filter(([e, t]) => Number.isNaN(Number.parseInt(e, 10)))
        .map((e) => e[1]);
    }
    function tK(e) {
      let t = atob(e),
        r = new Uint8Array(t.length);
      for (let e = 0; e < t.length; e++) r[e] = t.charCodeAt(e);
      return r;
    }
    function tY(e) {
      let t = '';
      for (let r = 0; r < e.length; r++) t += String.fromCharCode(e[r]);
      return btoa(t);
    }
    function tQ(e) {
      let t = e.replace(/-/g, '+').replace(/_/g, '/'),
        r = '='.repeat((4 - (t.length % 4)) % 4);
      return tK(t + r);
    }
    function t0(e) {
      return tY(e).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    function t1(e) {
      let t = e.replace(/^0x/, '');
      if (t.length % 2 != 0) throw Error('Invalid hex string length');
      let r = new Uint8Array(t.length / 2);
      for (let e = 0; e < t.length; e += 2) r[e / 2] = Number.parseInt(t.slice(e, e + 2), 16);
      return r;
    }
    function t4(e) {
      return Array.from(e)
        .map((e) => e.toString(16).padStart(2, '0'))
        .join('');
    }
    class t6 {
      constructor(...e) {}
    }
    function t2() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'characters', verb: 'to have' },
              file: { unit: 'bytes', verb: 'to have' },
              array: { unit: 'items', verb: 'to have' },
              set: { unit: 'items', verb: 'to have' },
            },
            t = {
              regex: 'input',
              email: 'email address',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datetime',
              date: 'ISO date',
              time: 'ISO time',
              duration: 'ISO duration',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded string',
              base64url: 'base64url-encoded string',
              json_string: 'JSON string',
              e164: 'E.164 number',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Invalid input: expected ${r.expected}, received ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Invalid input: expected ${tT(r.values[0])}`;
                return `Invalid option: expected one of ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Too big: expected ${r.origin ?? 'value'} to have ${t}${r.maximum.toString()} ${n.unit ?? 'elements'}`;
                return `Too big: expected ${r.origin ?? 'value'} to be ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Too small: expected ${r.origin} to have ${t}${r.minimum.toString()} ${n.unit}`;
                return `Too small: expected ${r.origin} to be ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Invalid string: must start with "${r.prefix}"`;
                if ('ends_with' === r.format) return `Invalid string: must end with "${r.suffix}"`;
                if ('includes' === r.format) return `Invalid string: must include "${r.includes}"`;
                if ('regex' === r.format) return `Invalid string: must match pattern ${r.pattern}`;
                return `Invalid ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Invalid number: must be a multiple of ${r.divisor}`;
              case 'unrecognized_keys':
                return `Unrecognized key${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Invalid key in ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Invalid input';
              case 'invalid_element':
                return `Invalid value in ${r.origin}`;
            }
          };
        })(),
      };
    }
    (e3(t2()),
      e.i(48609),
      e.s(
        [
          '$ZodAny',
          () => iE,
          '$ZodArray',
          () => iT,
          '$ZodAsyncError',
          () => e6,
          '$ZodBase64',
          () => ic,
          '$ZodBase64URL',
          () => ip,
          '$ZodBigInt',
          () => ix,
          '$ZodBigIntFormat',
          () => i$,
          '$ZodBoolean',
          () => iy,
          '$ZodCIDRv4',
          () => is,
          '$ZodCIDRv6',
          () => iu,
          '$ZodCUID',
          () => n9,
          '$ZodCUID2',
          () => n3,
          '$ZodCatch',
          () => i8,
          '$ZodCheck',
          () => nS,
          '$ZodCheckBigIntFormat',
          () => nN,
          '$ZodCheckEndsWith',
          () => nF,
          '$ZodCheckGreaterThan',
          () => nk,
          '$ZodCheckIncludes',
          () => nM,
          '$ZodCheckLengthEquals',
          () => nU,
          '$ZodCheckLessThan',
          () => nE,
          '$ZodCheckLowerCase',
          () => nZ,
          '$ZodCheckMaxLength',
          () => nA,
          '$ZodCheckMaxSize',
          () => nR,
          '$ZodCheckMimeType',
          () => nX,
          '$ZodCheckMinLength',
          () => nD,
          '$ZodCheckMinSize',
          () => nT,
          '$ZodCheckMultipleOf',
          () => nI,
          '$ZodCheckNumberFormat',
          () => nP,
          '$ZodCheckOverwrite',
          () => nq,
          '$ZodCheckProperty',
          () => nV,
          '$ZodCheckRegex',
          () => nC,
          '$ZodCheckSizeEquals',
          () => nj,
          '$ZodCheckStartsWith',
          () => nB,
          '$ZodCheckStringFormat',
          () => nz,
          '$ZodCheckUpperCase',
          () => nL,
          '$ZodCodec',
          () => an,
          '$ZodCustom',
          () => af,
          '$ZodCustomStringFormat',
          () => iv,
          '$ZodDate',
          () => iN,
          '$ZodDefault',
          () => i6,
          '$ZodDiscriminatedUnion',
          () => iL,
          '$ZodE164',
          () => im,
          '$ZodEmail',
          () => n1,
          '$ZodEmoji',
          () => n6,
          '$ZodEncodeError',
          () => e2,
          '$ZodEnum',
          () => iJ,
          '$ZodError',
          () => t3,
          '$ZodFile',
          () => iY,
          '$ZodFunction',
          () => al,
          '$ZodGUID',
          () => nQ,
          '$ZodIPv4',
          () => ia,
          '$ZodIPv6',
          () => io,
          '$ZodISODate',
          () => it,
          '$ZodISODateTime',
          () => ie,
          '$ZodISODuration',
          () => ii,
          '$ZodISOTime',
          () => ir,
          '$ZodIntersection',
          () => iM,
          '$ZodJWT',
          () => ih,
          '$ZodKSUID',
          () => n8,
          '$ZodLazy',
          () => ad,
          '$ZodLiteral',
          () => iK,
          '$ZodMap',
          () => iX,
          '$ZodNaN',
          () => ae,
          '$ZodNanoID',
          () => n2,
          '$ZodNever',
          () => iI,
          '$ZodNonOptional',
          () => i3,
          '$ZodNull',
          () => iO,
          '$ZodNullable',
          () => i4,
          '$ZodNumber',
          () => ib,
          '$ZodNumberFormat',
          () => i_,
          '$ZodObject',
          () => iU,
          '$ZodObjectJIT',
          () => iz,
          '$ZodOptional',
          () => i1,
          '$ZodPipe',
          () => at,
          '$ZodPrefault',
          () => i9,
          '$ZodPromise',
          () => ac,
          '$ZodReadonly',
          () => ao,
          '$ZodRealError',
          () => t7,
          '$ZodRecord',
          () => iV,
          '$ZodRegistry',
          () => a5,
          '$ZodSet',
          () => iW,
          '$ZodString',
          () => nK,
          '$ZodStringFormat',
          () => nY,
          '$ZodSuccess',
          () => i5,
          '$ZodSymbol',
          () => iw,
          '$ZodTemplateLiteral',
          () => au,
          '$ZodTransform',
          () => iQ,
          '$ZodTuple',
          () => iF,
          '$ZodType',
          () => nJ,
          '$ZodULID',
          () => n7,
          '$ZodURL',
          () => n4,
          '$ZodUUID',
          () => n0,
          '$ZodUndefined',
          () => iS,
          '$ZodUnion',
          () => iZ,
          '$ZodUnknown',
          () => ik,
          '$ZodVoid',
          () => iP,
          '$ZodXID',
          () => n5,
          '$brand',
          () => e4,
          '$constructor',
          () => e1,
          '$input',
          () => a7,
          '$output',
          () => a3,
          'Doc',
          () => nW,
          'JSONSchema',
          () => sH,
          'JSONSchemaGenerator',
          () => sq,
          'NEVER',
          () => e0,
          'TimePrecision',
          () => oO,
          '_any',
          () => oX,
          '_array',
          () => sv,
          '_base64',
          () => ox,
          '_base64url',
          () => o$,
          '_bigint',
          () => oZ,
          '_boolean',
          () => oz,
          '_catch',
          () => sD,
          '_check',
          () => sG,
          '_cidrv4',
          () => o_,
          '_cidrv6',
          () => oy,
          '_coercedBigint',
          () => oL,
          '_coercedBoolean',
          () => oC,
          '_coercedDate',
          () => oK,
          '_coercedNumber',
          () => oR,
          '_coercedString',
          () => or,
          '_cuid',
          () => of,
          '_cuid2',
          () => op,
          '_custom',
          () => sM,
          '_date',
          () => oJ,
          '_decode',
          () => rp,
          '_decodeAsync',
          () => rv,
          '_default',
          () => sT,
          '_discriminatedUnion',
          () => s_,
          '_e164',
          () => ow,
          '_email',
          () => on,
          '_emoji',
          () => oc,
          '_encode',
          () => rd,
          '_encodeAsync',
          () => rg,
          '_endsWith',
          () => sl,
          '_enum',
          () => sO,
          '_file',
          () => sI,
          '_float32',
          () => oj,
          '_float64',
          () => oA,
          '_gt',
          () => o1,
          '_gte',
          () => o4,
          '_guid',
          () => oi,
          '_includes',
          () => ss,
          '_int',
          () => oT,
          '_int32',
          () => oD,
          '_int64',
          () => oM,
          '_intersection',
          () => sy,
          '_ipv4',
          () => ov,
          '_ipv6',
          () => ob,
          '_isoDate',
          () => ok,
          '_isoDateTime',
          () => oE,
          '_isoDuration',
          () => oP,
          '_isoTime',
          () => oI,
          '_jwt',
          () => oS,
          '_ksuid',
          () => oh,
          '_lazy',
          () => sZ,
          '_length',
          () => sn,
          '_literal',
          () => sk,
          '_lowercase',
          () => sa,
          '_lt',
          () => oQ,
          '_lte',
          () => o0,
          '_map',
          () => sw,
          '_max',
          () => o0,
          '_maxLength',
          () => st,
          '_maxSize',
          () => o5,
          '_mime',
          () => sd,
          '_min',
          () => o4,
          '_minLength',
          () => sr,
          '_minSize',
          () => o8,
          '_multipleOf',
          () => o7,
          '_nan',
          () => oY,
          '_nanoid',
          () => od,
          '_nativeEnum',
          () => sE,
          '_negative',
          () => o2,
          '_never',
          () => oW,
          '_nonnegative',
          () => o3,
          '_nonoptional',
          () => sj,
          '_nonpositive',
          () => o9,
          '_normalize',
          () => sp,
          '_null',
          () => oV,
          '_nullable',
          () => sR,
          '_number',
          () => oN,
          '_optional',
          () => sN,
          '_overwrite',
          () => sf,
          '_parse',
          () => rn,
          '_parseAsync',
          () => ra,
          '_pipe',
          () => sU,
          '_positive',
          () => o6,
          '_promise',
          () => sL,
          '_property',
          () => sc,
          '_readonly',
          () => sz,
          '_record',
          () => s$,
          '_refine',
          () => sB,
          '_regex',
          () => si,
          '_safeDecode',
          () => rx,
          '_safeDecodeAsync',
          () => rO,
          '_safeEncode',
          () => r_,
          '_safeEncodeAsync',
          () => rw,
          '_safeParse',
          () => rs,
          '_safeParseAsync',
          () => rl,
          '_set',
          () => sS,
          '_size',
          () => se,
          '_startsWith',
          () => su,
          '_string',
          () => ot,
          '_stringFormat',
          () => sX,
          '_stringbool',
          () => sV,
          '_success',
          () => sA,
          '_superRefine',
          () => sF,
          '_symbol',
          () => oF,
          '_templateLiteral',
          () => sC,
          '_toLowerCase',
          () => sg,
          '_toUpperCase',
          () => sh,
          '_transform',
          () => sP,
          '_trim',
          () => sm,
          '_tuple',
          () => sx,
          '_uint32',
          () => oU,
          '_uint64',
          () => oB,
          '_ulid',
          () => om,
          '_undefined',
          () => oG,
          '_union',
          () => sb,
          '_unknown',
          () => oq,
          '_uppercase',
          () => so,
          '_url',
          () => ol,
          '_uuid',
          () => oa,
          '_uuidv4',
          () => oo,
          '_uuidv6',
          () => os,
          '_uuidv7',
          () => ou,
          '_void',
          () => oH,
          '_xid',
          () => og,
          'clone',
          () => tP,
          'config',
          () => e3,
          'decode',
          () => rm,
          'decodeAsync',
          () => rb,
          'encode',
          () => rf,
          'encodeAsync',
          () => rh,
          'flattenError',
          () => t5,
          'formatError',
          () => t8,
          'globalConfig',
          () => e9,
          'globalRegistry',
          () => oe,
          'isValidBase64',
          () => il,
          'isValidBase64URL',
          () => id,
          'isValidJWT',
          () => ig,
          'locales',
          () => a9,
          'parse',
          () => ri,
          'parseAsync',
          () => ro,
          'prettifyError',
          () => rr,
          'regexes',
          () => ag,
          'registry',
          () => a8,
          'safeDecode',
          () => r$,
          'safeDecodeAsync',
          () => rE,
          'safeEncode',
          () => ry,
          'safeEncodeAsync',
          () => rS,
          'safeParse',
          () => ru,
          'safeParseAsync',
          () => rc,
          'toDotPath',
          () => rt,
          'toJSONSchema',
          () => sW,
          'treeifyError',
          () => re,
          'util',
          () => am,
          'version',
          () => nH,
        ],
        38916
      ),
      e.s([], 38384),
      e.i(38384),
      e.i(77256),
      e.s(
        [
          '_decode',
          () => rp,
          '_decodeAsync',
          () => rv,
          '_encode',
          () => rd,
          '_encodeAsync',
          () => rg,
          '_parse',
          () => rn,
          '_parseAsync',
          () => ra,
          '_safeDecode',
          () => rx,
          '_safeDecodeAsync',
          () => rO,
          '_safeEncode',
          () => r_,
          '_safeEncodeAsync',
          () => rw,
          '_safeParse',
          () => rs,
          '_safeParseAsync',
          () => rl,
          'decode',
          () => rm,
          'decodeAsync',
          () => rb,
          'encode',
          () => rf,
          'encodeAsync',
          () => rh,
          'parse',
          () => ri,
          'parseAsync',
          () => ro,
          'safeDecode',
          () => r$,
          'safeDecodeAsync',
          () => rE,
          'safeEncode',
          () => ry,
          'safeEncodeAsync',
          () => rS,
          'safeParse',
          () => ru,
          'safeParseAsync',
          () => rc,
        ],
        86028
      ),
      e.s(
        [
          '$ZodError',
          () => t3,
          '$ZodRealError',
          () => t7,
          'flattenError',
          () => t5,
          'formatError',
          () => t8,
          'prettifyError',
          () => rr,
          'toDotPath',
          () => rt,
          'treeifyError',
          () => re,
        ],
        11588
      ));
    let t9 = (e, t) => {
        ((e.name = '$ZodError'),
          Object.defineProperty(e, '_zod', { value: e._zod, enumerable: !1 }),
          Object.defineProperty(e, 'issues', { value: t, enumerable: !1 }),
          (e.message = JSON.stringify(t, ti, 2)),
          Object.defineProperty(e, 'toString', { value: () => e.message, enumerable: !1 }));
      },
      t3 = e1('$ZodError', t9),
      t7 = e1('$ZodError', t9, { Parent: Error });
    function t5(e, t = (e) => e.message) {
      let r = {},
        n = [];
      for (let i of e.issues)
        i.path.length > 0
          ? ((r[i.path[0]] = r[i.path[0]] || []), r[i.path[0]].push(t(i)))
          : n.push(t(i));
      return { formErrors: n, fieldErrors: r };
    }
    function t8(e, t) {
      let r =
          t ||
          function (e) {
            return e.message;
          },
        n = { _errors: [] },
        i = (e) => {
          for (let t of e.issues)
            if ('invalid_union' === t.code && t.errors.length)
              t.errors.map((e) => i({ issues: e }));
            else if ('invalid_key' === t.code) i({ issues: t.issues });
            else if ('invalid_element' === t.code) i({ issues: t.issues });
            else if (0 === t.path.length) n._errors.push(r(t));
            else {
              let e = n,
                i = 0;
              for (; i < t.path.length; ) {
                let n = t.path[i];
                (i === t.path.length - 1
                  ? ((e[n] = e[n] || { _errors: [] }), e[n]._errors.push(r(t)))
                  : (e[n] = e[n] || { _errors: [] }),
                  (e = e[n]),
                  i++);
              }
            }
        };
      return (i(e), n);
    }
    function re(e, t) {
      let r =
          t ||
          function (e) {
            return e.message;
          },
        n = { errors: [] },
        i = (e, t = []) => {
          var a, o;
          for (let s of e.issues)
            if ('invalid_union' === s.code && s.errors.length)
              s.errors.map((e) => i({ issues: e }, s.path));
            else if ('invalid_key' === s.code) i({ issues: s.issues }, s.path);
            else if ('invalid_element' === s.code) i({ issues: s.issues }, s.path);
            else {
              let e = [...t, ...s.path];
              if (0 === e.length) {
                n.errors.push(r(s));
                continue;
              }
              let i = n,
                u = 0;
              for (; u < e.length; ) {
                let t = e[u],
                  n = u === e.length - 1;
                ('string' == typeof t
                  ? (i.properties ?? (i.properties = {}),
                    (a = i.properties)[t] ?? (a[t] = { errors: [] }),
                    (i = i.properties[t]))
                  : (i.items ?? (i.items = []),
                    (o = i.items)[t] ?? (o[t] = { errors: [] }),
                    (i = i.items[t])),
                  n && i.errors.push(r(s)),
                  u++);
              }
            }
        };
      return (i(e), n);
    }
    function rt(e) {
      let t = [];
      for (let r of e.map((e) => ('object' == typeof e ? e.key : e)))
        'number' == typeof r
          ? t.push(`[${r}]`)
          : 'symbol' == typeof r
            ? t.push(`[${JSON.stringify(String(r))}]`)
            : /[^\w$]/.test(r)
              ? t.push(`[${JSON.stringify(r)}]`)
              : (t.length && t.push('.'), t.push(r));
      return t.join('');
    }
    function rr(e) {
      let t = [];
      for (let r of [...e.issues].sort((e, t) => (e.path ?? []).length - (t.path ?? []).length))
        (t.push(`✖ ${r.message}`), r.path?.length && t.push(`  → at ${rt(r.path)}`));
      return t.join('\n');
    }
    let rn = (e) => (t, r, n, i) => {
        let a = n ? Object.assign(n, { async: !1 }) : { async: !1 },
          o = t._zod.run({ value: r, issues: [] }, a);
        if (o instanceof Promise) throw new e6();
        if (o.issues.length) {
          let t = new (i?.Err ?? e)(o.issues.map((e) => tX(e, a, e3())));
          throw (t_(t, i?.callee), t);
        }
        return o.value;
      },
      ri = rn(t7),
      ra = (e) => async (t, r, n, i) => {
        let a = n ? Object.assign(n, { async: !0 }) : { async: !0 },
          o = t._zod.run({ value: r, issues: [] }, a);
        if ((o instanceof Promise && (o = await o), o.issues.length)) {
          let t = new (i?.Err ?? e)(o.issues.map((e) => tX(e, a, e3())));
          throw (t_(t, i?.callee), t);
        }
        return o.value;
      },
      ro = ra(t7),
      rs = (e) => (t, r, n) => {
        let i = n ? { ...n, async: !1 } : { async: !1 },
          a = t._zod.run({ value: r, issues: [] }, i);
        if (a instanceof Promise) throw new e6();
        return a.issues.length
          ? { success: !1, error: new (e ?? t3)(a.issues.map((e) => tX(e, i, e3()))) }
          : { success: !0, data: a.value };
      },
      ru = rs(t7),
      rl = (e) => async (t, r, n) => {
        let i = n ? Object.assign(n, { async: !0 }) : { async: !0 },
          a = t._zod.run({ value: r, issues: [] }, i);
        return (
          a instanceof Promise && (a = await a),
          a.issues.length
            ? { success: !1, error: new e(a.issues.map((e) => tX(e, i, e3()))) }
            : { success: !0, data: a.value }
        );
      },
      rc = rl(t7),
      rd = (e) => (t, r, n) => {
        let i = n ? Object.assign(n, { direction: 'backward' }) : { direction: 'backward' };
        return rn(e)(t, r, i);
      },
      rf = rd(t7),
      rp = (e) => (t, r, n) => rn(e)(t, r, n),
      rm = rp(t7),
      rg = (e) => async (t, r, n) => {
        let i = n ? Object.assign(n, { direction: 'backward' }) : { direction: 'backward' };
        return ra(e)(t, r, i);
      },
      rh = rg(t7),
      rv = (e) => async (t, r, n) => ra(e)(t, r, n),
      rb = rv(t7),
      r_ = (e) => (t, r, n) => {
        let i = n ? Object.assign(n, { direction: 'backward' }) : { direction: 'backward' };
        return rs(e)(t, r, i);
      },
      ry = r_(t7),
      rx = (e) => (t, r, n) => rs(e)(t, r, n),
      r$ = rx(t7),
      rw = (e) => async (t, r, n) => {
        let i = n ? Object.assign(n, { direction: 'backward' }) : { direction: 'backward' };
        return rl(e)(t, r, i);
      },
      rS = rw(t7),
      rO = (e) => async (t, r, n) => rl(e)(t, r, n),
      rE = rO(t7);
    (e.i(86028),
      e.i(11588),
      e.s(
        [
          '$ZodAny',
          () => iE,
          '$ZodArray',
          () => iT,
          '$ZodBase64',
          () => ic,
          '$ZodBase64URL',
          () => ip,
          '$ZodBigInt',
          () => ix,
          '$ZodBigIntFormat',
          () => i$,
          '$ZodBoolean',
          () => iy,
          '$ZodCIDRv4',
          () => is,
          '$ZodCIDRv6',
          () => iu,
          '$ZodCUID',
          () => n9,
          '$ZodCUID2',
          () => n3,
          '$ZodCatch',
          () => i8,
          '$ZodCodec',
          () => an,
          '$ZodCustom',
          () => af,
          '$ZodCustomStringFormat',
          () => iv,
          '$ZodDate',
          () => iN,
          '$ZodDefault',
          () => i6,
          '$ZodDiscriminatedUnion',
          () => iL,
          '$ZodE164',
          () => im,
          '$ZodEmail',
          () => n1,
          '$ZodEmoji',
          () => n6,
          '$ZodEnum',
          () => iJ,
          '$ZodFile',
          () => iY,
          '$ZodFunction',
          () => al,
          '$ZodGUID',
          () => nQ,
          '$ZodIPv4',
          () => ia,
          '$ZodIPv6',
          () => io,
          '$ZodISODate',
          () => it,
          '$ZodISODateTime',
          () => ie,
          '$ZodISODuration',
          () => ii,
          '$ZodISOTime',
          () => ir,
          '$ZodIntersection',
          () => iM,
          '$ZodJWT',
          () => ih,
          '$ZodKSUID',
          () => n8,
          '$ZodLazy',
          () => ad,
          '$ZodLiteral',
          () => iK,
          '$ZodMap',
          () => iX,
          '$ZodNaN',
          () => ae,
          '$ZodNanoID',
          () => n2,
          '$ZodNever',
          () => iI,
          '$ZodNonOptional',
          () => i3,
          '$ZodNull',
          () => iO,
          '$ZodNullable',
          () => i4,
          '$ZodNumber',
          () => ib,
          '$ZodNumberFormat',
          () => i_,
          '$ZodObject',
          () => iU,
          '$ZodObjectJIT',
          () => iz,
          '$ZodOptional',
          () => i1,
          '$ZodPipe',
          () => at,
          '$ZodPrefault',
          () => i9,
          '$ZodPromise',
          () => ac,
          '$ZodReadonly',
          () => ao,
          '$ZodRecord',
          () => iV,
          '$ZodSet',
          () => iW,
          '$ZodString',
          () => nK,
          '$ZodStringFormat',
          () => nY,
          '$ZodSuccess',
          () => i5,
          '$ZodSymbol',
          () => iw,
          '$ZodTemplateLiteral',
          () => au,
          '$ZodTransform',
          () => iQ,
          '$ZodTuple',
          () => iF,
          '$ZodType',
          () => nJ,
          '$ZodULID',
          () => n7,
          '$ZodURL',
          () => n4,
          '$ZodUUID',
          () => n0,
          '$ZodUndefined',
          () => iS,
          '$ZodUnion',
          () => iZ,
          '$ZodUnknown',
          () => ik,
          '$ZodVoid',
          () => iP,
          '$ZodXID',
          () => n5,
          'clone',
          () => tP,
          'isValidBase64',
          () => il,
          'isValidBase64URL',
          () => id,
          'isValidJWT',
          () => ig,
        ],
        27962
      ),
      e.s(
        [
          '$ZodAny',
          () => iE,
          '$ZodArray',
          () => iT,
          '$ZodBase64',
          () => ic,
          '$ZodBase64URL',
          () => ip,
          '$ZodBigInt',
          () => ix,
          '$ZodBigIntFormat',
          () => i$,
          '$ZodBoolean',
          () => iy,
          '$ZodCIDRv4',
          () => is,
          '$ZodCIDRv6',
          () => iu,
          '$ZodCUID',
          () => n9,
          '$ZodCUID2',
          () => n3,
          '$ZodCatch',
          () => i8,
          '$ZodCodec',
          () => an,
          '$ZodCustom',
          () => af,
          '$ZodCustomStringFormat',
          () => iv,
          '$ZodDate',
          () => iN,
          '$ZodDefault',
          () => i6,
          '$ZodDiscriminatedUnion',
          () => iL,
          '$ZodE164',
          () => im,
          '$ZodEmail',
          () => n1,
          '$ZodEmoji',
          () => n6,
          '$ZodEnum',
          () => iJ,
          '$ZodFile',
          () => iY,
          '$ZodFunction',
          () => al,
          '$ZodGUID',
          () => nQ,
          '$ZodIPv4',
          () => ia,
          '$ZodIPv6',
          () => io,
          '$ZodISODate',
          () => it,
          '$ZodISODateTime',
          () => ie,
          '$ZodISODuration',
          () => ii,
          '$ZodISOTime',
          () => ir,
          '$ZodIntersection',
          () => iM,
          '$ZodJWT',
          () => ih,
          '$ZodKSUID',
          () => n8,
          '$ZodLazy',
          () => ad,
          '$ZodLiteral',
          () => iK,
          '$ZodMap',
          () => iX,
          '$ZodNaN',
          () => ae,
          '$ZodNanoID',
          () => n2,
          '$ZodNever',
          () => iI,
          '$ZodNonOptional',
          () => i3,
          '$ZodNull',
          () => iO,
          '$ZodNullable',
          () => i4,
          '$ZodNumber',
          () => ib,
          '$ZodNumberFormat',
          () => i_,
          '$ZodObject',
          () => iU,
          '$ZodObjectJIT',
          () => iz,
          '$ZodOptional',
          () => i1,
          '$ZodPipe',
          () => at,
          '$ZodPrefault',
          () => i9,
          '$ZodPromise',
          () => ac,
          '$ZodReadonly',
          () => ao,
          '$ZodRecord',
          () => iV,
          '$ZodSet',
          () => iW,
          '$ZodString',
          () => nK,
          '$ZodStringFormat',
          () => nY,
          '$ZodSuccess',
          () => i5,
          '$ZodSymbol',
          () => iw,
          '$ZodTemplateLiteral',
          () => au,
          '$ZodTransform',
          () => iQ,
          '$ZodTuple',
          () => iF,
          '$ZodType',
          () => nJ,
          '$ZodULID',
          () => n7,
          '$ZodURL',
          () => n4,
          '$ZodUUID',
          () => n0,
          '$ZodUndefined',
          () => iS,
          '$ZodUnion',
          () => iZ,
          '$ZodUnknown',
          () => ik,
          '$ZodVoid',
          () => iP,
          '$ZodXID',
          () => n5,
          'isValidBase64',
          () => il,
          'isValidBase64URL',
          () => id,
          'isValidJWT',
          () => ig,
        ],
        42793
      ),
      e.s(
        [
          '$ZodCheck',
          () => nS,
          '$ZodCheckBigIntFormat',
          () => nN,
          '$ZodCheckEndsWith',
          () => nF,
          '$ZodCheckGreaterThan',
          () => nk,
          '$ZodCheckIncludes',
          () => nM,
          '$ZodCheckLengthEquals',
          () => nU,
          '$ZodCheckLessThan',
          () => nE,
          '$ZodCheckLowerCase',
          () => nZ,
          '$ZodCheckMaxLength',
          () => nA,
          '$ZodCheckMaxSize',
          () => nR,
          '$ZodCheckMimeType',
          () => nX,
          '$ZodCheckMinLength',
          () => nD,
          '$ZodCheckMinSize',
          () => nT,
          '$ZodCheckMultipleOf',
          () => nI,
          '$ZodCheckNumberFormat',
          () => nP,
          '$ZodCheckOverwrite',
          () => nq,
          '$ZodCheckProperty',
          () => nV,
          '$ZodCheckRegex',
          () => nC,
          '$ZodCheckSizeEquals',
          () => nj,
          '$ZodCheckStartsWith',
          () => nB,
          '$ZodCheckStringFormat',
          () => nz,
          '$ZodCheckUpperCase',
          () => nL,
        ],
        88958
      ),
      e.s(
        [
          'base64',
          () => rK,
          'base64url',
          () => rY,
          'bigint',
          () => r5,
          'boolean',
          () => nt,
          'browserEmail',
          () => rV,
          'cidrv4',
          () => rH,
          'cidrv6',
          () => rJ,
          'cuid',
          () => rk,
          'cuid2',
          () => rI,
          'date',
          () => r6,
          'datetime',
          () => r3,
          'domain',
          () => r0,
          'duration',
          () => rj,
          'e164',
          () => r1,
          'email',
          () => rL,
          'emoji',
          () => rX,
          'extendedDuration',
          () => rA,
          'guid',
          () => rD,
          'hex',
          () => no,
          'hostname',
          () => rQ,
          'html5Email',
          () => rM,
          'idnEmail',
          () => rG,
          'integer',
          () => r8,
          'ipv4',
          () => rq,
          'ipv6',
          () => rW,
          'ksuid',
          () => rR,
          'lowercase',
          () => ni,
          'md5_base64',
          () => nc,
          'md5_base64url',
          () => nd,
          'md5_hex',
          () => nl,
          'nanoid',
          () => rT,
          'null',
          () => nr,
          'number',
          () => ne,
          'rfc5322Email',
          () => rB,
          'sha1_base64',
          () => np,
          'sha1_base64url',
          () => nm,
          'sha1_hex',
          () => nf,
          'sha256_base64',
          () => nh,
          'sha256_base64url',
          () => nv,
          'sha256_hex',
          () => ng,
          'sha384_base64',
          () => n_,
          'sha384_base64url',
          () => ny,
          'sha384_hex',
          () => nb,
          'sha512_base64',
          () => n$,
          'sha512_base64url',
          () => nw,
          'sha512_hex',
          () => nx,
          'string',
          () => r7,
          'time',
          () => r9,
          'ulid',
          () => rP,
          'undefined',
          () => nn,
          'unicodeEmail',
          () => rF,
          'uppercase',
          () => na,
          'uuid',
          () => rU,
          'uuid4',
          () => rz,
          'uuid6',
          () => rC,
          'uuid7',
          () => rZ,
          'xid',
          () => rN,
        ],
        34571
      ));
    let rk = /^[cC][^\s-]{8,}$/,
      rI = /^[0-9a-z]+$/,
      rP = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
      rN = /^[0-9a-vA-V]{20}$/,
      rR = /^[A-Za-z0-9]{27}$/,
      rT = /^[a-zA-Z0-9_-]{21}$/,
      rj =
        /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
      rA =
        /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
      rD = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
      rU = (e) =>
        e
          ? RegExp(
              `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`
            )
          : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      rz = rU(4),
      rC = rU(6),
      rZ = rU(7),
      rL =
        /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
      rM =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
      rB =
        /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
      rF = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
      rG = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
      rV =
        /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    function rX() {
      return RegExp('^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$', 'u');
    }
    let rq =
        /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      rW =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
      rH =
        /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
      rJ =
        /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      rK = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
      rY = /^[A-Za-z0-9_-]*$/,
      rQ =
        /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/,
      r0 = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
      r1 = /^\+(?:[0-9]){6,14}[0-9]$/,
      r4 =
        '(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))',
      r6 = RegExp(`^${r4}$`);
    function r2(e) {
      let t = '(?:[01]\\d|2[0-3]):[0-5]\\d';
      return 'number' == typeof e.precision
        ? -1 === e.precision
          ? `${t}`
          : 0 === e.precision
            ? `${t}:[0-5]\\d`
            : `${t}:[0-5]\\d\\.\\d{${e.precision}}`
        : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    }
    function r9(e) {
      return RegExp(`^${r2(e)}$`);
    }
    function r3(e) {
      let t = r2({ precision: e.precision }),
        r = ['Z'];
      (e.local && r.push(''), e.offset && r.push('([+-](?:[01]\\d|2[0-3]):[0-5]\\d)'));
      let n = `${t}(?:${r.join('|')})`;
      return RegExp(`^${r4}T(?:${n})$`);
    }
    let r7 = (e) => {
        let t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ''}}` : '[\\s\\S]*';
        return RegExp(`^${t}$`);
      },
      r5 = /^\d+n?$/,
      r8 = /^\d+$/,
      ne = /^-?\d+(?:\.\d+)?/i,
      nt = /true|false/i,
      nr = /null/i,
      nn = /undefined/i,
      ni = /^[^A-Z]*$/,
      na = /^[^a-z]*$/,
      no = /^[0-9a-fA-F]*$/;
    function ns(e, t) {
      return RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
    }
    function nu(e) {
      return RegExp(`^[A-Za-z0-9-_]{${e}}$`);
    }
    let nl = /^[0-9a-fA-F]{32}$/,
      nc = ns(22, '=='),
      nd = nu(22),
      nf = /^[0-9a-fA-F]{40}$/,
      np = ns(27, '='),
      nm = nu(27),
      ng = /^[0-9a-fA-F]{64}$/,
      nh = ns(43, '='),
      nv = nu(43),
      nb = /^[0-9a-fA-F]{96}$/,
      n_ = ns(64, ''),
      ny = nu(64),
      nx = /^[0-9a-fA-F]{128}$/,
      n$ = ns(86, '=='),
      nw = nu(86),
      nS = e1('$ZodCheck', (e, t) => {
        var r;
        (e._zod ?? (e._zod = {}), (e._zod.def = t), (r = e._zod).onattach ?? (r.onattach = []));
      }),
      nO = { number: 'number', bigint: 'bigint', object: 'date' },
      nE = e1('$ZodCheckLessThan', (e, t) => {
        nS.init(e, t);
        let r = nO[typeof t.value];
        (e._zod.onattach.push((e) => {
          let r = e._zod.bag,
            n = (t.inclusive ? r.maximum : r.exclusiveMaximum) ?? 1 / 0;
          t.value < n && (t.inclusive ? (r.maximum = t.value) : (r.exclusiveMaximum = t.value));
        }),
          (e._zod.check = (n) => {
            (t.inclusive ? n.value <= t.value : n.value < t.value) ||
              n.issues.push({
                origin: r,
                code: 'too_big',
                maximum: t.value,
                input: n.value,
                inclusive: t.inclusive,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nk = e1('$ZodCheckGreaterThan', (e, t) => {
        nS.init(e, t);
        let r = nO[typeof t.value];
        (e._zod.onattach.push((e) => {
          let r = e._zod.bag,
            n = (t.inclusive ? r.minimum : r.exclusiveMinimum) ?? -1 / 0;
          t.value > n && (t.inclusive ? (r.minimum = t.value) : (r.exclusiveMinimum = t.value));
        }),
          (e._zod.check = (n) => {
            (t.inclusive ? n.value >= t.value : n.value > t.value) ||
              n.issues.push({
                origin: r,
                code: 'too_small',
                minimum: t.value,
                input: n.value,
                inclusive: t.inclusive,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nI = e1('$ZodCheckMultipleOf', (e, t) => {
        (nS.init(e, t),
          e._zod.onattach.push((e) => {
            var r;
            (r = e._zod.bag).multipleOf ?? (r.multipleOf = t.value);
          }),
          (e._zod.check = (r) => {
            if (typeof r.value != typeof t.value)
              throw Error('Cannot mix number and bigint in multiple_of check.');
            ('bigint' == typeof r.value
              ? r.value % t.value === BigInt(0)
              : 0 === tu(r.value, t.value)) ||
              r.issues.push({
                origin: typeof r.value,
                code: 'not_multiple_of',
                divisor: t.value,
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nP = e1('$ZodCheckNumberFormat', (e, t) => {
        (nS.init(e, t), (t.format = t.format || 'float64'));
        let r = t.format?.includes('int'),
          n = r ? 'int' : 'number',
          [i, a] = tA[t.format];
        (e._zod.onattach.push((e) => {
          let n = e._zod.bag;
          ((n.format = t.format), (n.minimum = i), (n.maximum = a), r && (n.pattern = r8));
        }),
          (e._zod.check = (o) => {
            let s = o.value;
            if (r) {
              if (!Number.isInteger(s))
                return void o.issues.push({
                  expected: n,
                  format: t.format,
                  code: 'invalid_type',
                  continue: !1,
                  input: s,
                  inst: e,
                });
              if (!Number.isSafeInteger(s))
                return void (s > 0
                  ? o.issues.push({
                      input: s,
                      code: 'too_big',
                      maximum: Number.MAX_SAFE_INTEGER,
                      note: 'Integers must be within the safe integer range.',
                      inst: e,
                      origin: n,
                      continue: !t.abort,
                    })
                  : o.issues.push({
                      input: s,
                      code: 'too_small',
                      minimum: Number.MIN_SAFE_INTEGER,
                      note: 'Integers must be within the safe integer range.',
                      inst: e,
                      origin: n,
                      continue: !t.abort,
                    }));
            }
            (s < i &&
              o.issues.push({
                origin: 'number',
                input: s,
                code: 'too_small',
                minimum: i,
                inclusive: !0,
                inst: e,
                continue: !t.abort,
              }),
              s > a &&
                o.issues.push({
                  origin: 'number',
                  input: s,
                  code: 'too_big',
                  maximum: a,
                  inst: e,
                }));
          }));
      }),
      nN = e1('$ZodCheckBigIntFormat', (e, t) => {
        nS.init(e, t);
        let [r, n] = tD[t.format];
        (e._zod.onattach.push((e) => {
          let i = e._zod.bag;
          ((i.format = t.format), (i.minimum = r), (i.maximum = n));
        }),
          (e._zod.check = (i) => {
            let a = i.value;
            (a < r &&
              i.issues.push({
                origin: 'bigint',
                input: a,
                code: 'too_small',
                minimum: r,
                inclusive: !0,
                inst: e,
                continue: !t.abort,
              }),
              a > n &&
                i.issues.push({
                  origin: 'bigint',
                  input: a,
                  code: 'too_big',
                  maximum: n,
                  inst: e,
                }));
          }));
      }),
      nR = e1('$ZodCheckMaxSize', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag.maximum ?? 1 / 0;
            t.maximum < r && (e._zod.bag.maximum = t.maximum);
          }),
          (e._zod.check = (r) => {
            let n = r.value;
            n.size <= t.maximum ||
              r.issues.push({
                origin: tq(n),
                code: 'too_big',
                maximum: t.maximum,
                inclusive: !0,
                input: n,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nT = e1('$ZodCheckMinSize', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag.minimum ?? -1 / 0;
            t.minimum > r && (e._zod.bag.minimum = t.minimum);
          }),
          (e._zod.check = (r) => {
            let n = r.value;
            n.size >= t.minimum ||
              r.issues.push({
                origin: tq(n),
                code: 'too_small',
                minimum: t.minimum,
                inclusive: !0,
                input: n,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nj = e1('$ZodCheckSizeEquals', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.size;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag;
            ((r.minimum = t.size), (r.maximum = t.size), (r.size = t.size));
          }),
          (e._zod.check = (r) => {
            let n = r.value,
              i = n.size;
            if (i === t.size) return;
            let a = i > t.size;
            r.issues.push({
              origin: tq(n),
              ...(a
                ? { code: 'too_big', maximum: t.size }
                : { code: 'too_small', minimum: t.size }),
              inclusive: !0,
              exact: !0,
              input: r.value,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      nA = e1('$ZodCheckMaxLength', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag.maximum ?? 1 / 0;
            t.maximum < r && (e._zod.bag.maximum = t.maximum);
          }),
          (e._zod.check = (r) => {
            let n = r.value;
            if (n.length <= t.maximum) return;
            let i = tW(n);
            r.issues.push({
              origin: i,
              code: 'too_big',
              maximum: t.maximum,
              inclusive: !0,
              input: n,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      nD = e1('$ZodCheckMinLength', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag.minimum ?? -1 / 0;
            t.minimum > r && (e._zod.bag.minimum = t.minimum);
          }),
          (e._zod.check = (r) => {
            let n = r.value;
            if (n.length >= t.minimum) return;
            let i = tW(n);
            r.issues.push({
              origin: i,
              code: 'too_small',
              minimum: t.minimum,
              inclusive: !0,
              input: n,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      nU = e1('$ZodCheckLengthEquals', (e, t) => {
        var r;
        (nS.init(e, t),
          (r = e._zod.def).when ??
            (r.when = (e) => {
              let t = e.value;
              return !to(t) && void 0 !== t.length;
            }),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag;
            ((r.minimum = t.length), (r.maximum = t.length), (r.length = t.length));
          }),
          (e._zod.check = (r) => {
            let n = r.value,
              i = n.length;
            if (i === t.length) return;
            let a = tW(n),
              o = i > t.length;
            r.issues.push({
              origin: a,
              ...(o
                ? { code: 'too_big', maximum: t.length }
                : { code: 'too_small', minimum: t.length }),
              inclusive: !0,
              exact: !0,
              input: r.value,
              inst: e,
              continue: !t.abort,
            });
          }));
      }),
      nz = e1('$ZodCheckStringFormat', (e, t) => {
        var r, n;
        (nS.init(e, t),
          e._zod.onattach.push((e) => {
            let r = e._zod.bag;
            ((r.format = t.format),
              t.pattern && (r.patterns ?? (r.patterns = new Set()), r.patterns.add(t.pattern)));
          }),
          t.pattern
            ? ((r = e._zod).check ??
              (r.check = (r) => {
                ((t.pattern.lastIndex = 0),
                  t.pattern.test(r.value) ||
                    r.issues.push({
                      origin: 'string',
                      code: 'invalid_format',
                      format: t.format,
                      input: r.value,
                      ...(t.pattern ? { pattern: t.pattern.toString() } : {}),
                      inst: e,
                      continue: !t.abort,
                    }));
              }))
            : ((n = e._zod).check ?? (n.check = () => {})));
      }),
      nC = e1('$ZodCheckRegex', (e, t) => {
        (nz.init(e, t),
          (e._zod.check = (r) => {
            ((t.pattern.lastIndex = 0),
              t.pattern.test(r.value) ||
                r.issues.push({
                  origin: 'string',
                  code: 'invalid_format',
                  format: 'regex',
                  input: r.value,
                  pattern: t.pattern.toString(),
                  inst: e,
                  continue: !t.abort,
                }));
          }));
      }),
      nZ = e1('$ZodCheckLowerCase', (e, t) => {
        (t.pattern ?? (t.pattern = ni), nz.init(e, t));
      }),
      nL = e1('$ZodCheckUpperCase', (e, t) => {
        (t.pattern ?? (t.pattern = na), nz.init(e, t));
      }),
      nM = e1('$ZodCheckIncludes', (e, t) => {
        nS.init(e, t);
        let r = tI(t.includes),
          n = new RegExp('number' == typeof t.position ? `^.{${t.position}}${r}` : r);
        ((t.pattern = n),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(n));
          }),
          (e._zod.check = (r) => {
            r.value.includes(t.includes, t.position) ||
              r.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'includes',
                includes: t.includes,
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nB = e1('$ZodCheckStartsWith', (e, t) => {
        nS.init(e, t);
        let r = RegExp(`^${tI(t.prefix)}.*`);
        (t.pattern ?? (t.pattern = r),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(r));
          }),
          (e._zod.check = (r) => {
            r.value.startsWith(t.prefix) ||
              r.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'starts_with',
                prefix: t.prefix,
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nF = e1('$ZodCheckEndsWith', (e, t) => {
        nS.init(e, t);
        let r = RegExp(`.*${tI(t.suffix)}$`);
        (t.pattern ?? (t.pattern = r),
          e._zod.onattach.push((e) => {
            let t = e._zod.bag;
            (t.patterns ?? (t.patterns = new Set()), t.patterns.add(r));
          }),
          (e._zod.check = (r) => {
            r.value.endsWith(t.suffix) ||
              r.issues.push({
                origin: 'string',
                code: 'invalid_format',
                format: 'ends_with',
                suffix: t.suffix,
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      });
    function nG(e, t, r) {
      e.issues.length && t.issues.push(...tG(r, e.issues));
    }
    let nV = e1('$ZodCheckProperty', (e, t) => {
        (nS.init(e, t),
          (e._zod.check = (e) => {
            let r = t.schema._zod.run({ value: e.value[t.property], issues: [] }, {});
            if (r instanceof Promise) return r.then((r) => nG(r, e, t.property));
            nG(r, e, t.property);
          }));
      }),
      nX = e1('$ZodCheckMimeType', (e, t) => {
        nS.init(e, t);
        let r = new Set(t.mime);
        (e._zod.onattach.push((e) => {
          e._zod.bag.mime = t.mime;
        }),
          (e._zod.check = (n) => {
            r.has(n.value.type) ||
              n.issues.push({
                code: 'invalid_value',
                values: t.mime,
                input: n.value.type,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      nq = e1('$ZodCheckOverwrite', (e, t) => {
        (nS.init(e, t),
          (e._zod.check = (e) => {
            e.value = t.tx(e.value);
          }));
      });
    e.s(['Doc', () => nW], 42030);
    class nW {
      constructor(e = []) {
        ((this.content = []), (this.indent = 0), this && (this.args = e));
      }
      indented(e) {
        ((this.indent += 1), e(this), (this.indent -= 1));
      }
      write(e) {
        if ('function' == typeof e) {
          (e(this, { execution: 'sync' }), e(this, { execution: 'async' }));
          return;
        }
        let t = e.split('\n').filter((e) => e),
          r = Math.min(...t.map((e) => e.length - e.trimStart().length));
        for (let e of t.map((e) => e.slice(r)).map((e) => ' '.repeat(2 * this.indent) + e))
          this.content.push(e);
      }
      compile() {
        return Function(
          ...this?.args,
          [...(this?.content ?? ['']).map((e) => `  ${e}`)].join('\n')
        );
      }
    }
    e.s(['version', () => nH], 32878);
    let nH = { major: 4, minor: 1, patch: 5 },
      nJ = e1('$ZodType', (e, t) => {
        var r;
        (e ?? (e = {}), (e._zod.def = t), (e._zod.bag = e._zod.bag || {}), (e._zod.version = nH));
        let n = [...(e._zod.def.checks ?? [])];
        for (let t of (e._zod.traits.has('$ZodCheck') && n.unshift(e), n))
          for (let r of t._zod.onattach) r(e);
        if (0 === n.length)
          ((r = e._zod).deferred ?? (r.deferred = []),
            e._zod.deferred?.push(() => {
              e._zod.run = e._zod.parse;
            }));
        else {
          let t = (e, t, r) => {
              let n,
                i = tF(e);
              for (let a of t) {
                if (a._zod.def.when) {
                  if (!a._zod.def.when(e)) continue;
                } else if (i) continue;
                let t = e.issues.length,
                  o = a._zod.check(e);
                if (o instanceof Promise && r?.async === !1) throw new e6();
                if (n || o instanceof Promise)
                  n = (n ?? Promise.resolve()).then(async () => {
                    (await o, e.issues.length !== t && (i || (i = tF(e, t))));
                  });
                else {
                  if (e.issues.length === t) continue;
                  i || (i = tF(e, t));
                }
              }
              return n ? n.then(() => e) : e;
            },
            r = (r, i, a) => {
              if (tF(r)) return ((r.aborted = !0), r);
              let o = t(i, n, a);
              if (o instanceof Promise) {
                if (!1 === a.async) throw new e6();
                return o.then((t) => e._zod.parse(t, a));
              }
              return e._zod.parse(o, a);
            };
          e._zod.run = (i, a) => {
            if (a.skipChecks) return e._zod.parse(i, a);
            if ('backward' === a.direction) {
              let t = e._zod.parse({ value: i.value, issues: [] }, { ...a, skipChecks: !0 });
              return t instanceof Promise ? t.then((e) => r(e, i, a)) : r(t, i, a);
            }
            let o = e._zod.parse(i, a);
            if (o instanceof Promise) {
              if (!1 === a.async) throw new e6();
              return o.then((e) => t(e, n, a));
            }
            return t(o, n, a);
          };
        }
        e['~standard'] = {
          validate: (t) => {
            try {
              let r = ru(e, t);
              return r.success ? { value: r.data } : { issues: r.error?.issues };
            } catch (r) {
              return rc(e, t).then((e) =>
                e.success ? { value: e.data } : { issues: e.error?.issues }
              );
            }
          },
          vendor: 'zod',
          version: 1,
        };
      }),
      nK = e1('$ZodString', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = [...(e?._zod.bag?.patterns ?? [])].pop() ?? r7(e._zod.bag)),
          (e._zod.parse = (r, n) => {
            if (t.coerce)
              try {
                r.value = String(r.value);
              } catch (e) {}
            return (
              'string' == typeof r.value ||
                r.issues.push({
                  expected: 'string',
                  code: 'invalid_type',
                  input: r.value,
                  inst: e,
                }),
              r
            );
          }));
      }),
      nY = e1('$ZodStringFormat', (e, t) => {
        (nz.init(e, t), nK.init(e, t));
      }),
      nQ = e1('$ZodGUID', (e, t) => {
        (t.pattern ?? (t.pattern = rD), nY.init(e, t));
      }),
      n0 = e1('$ZodUUID', (e, t) => {
        if (t.version) {
          let e = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[t.version];
          if (void 0 === e) throw Error(`Invalid UUID version: "${t.version}"`);
          t.pattern ?? (t.pattern = rU(e));
        } else t.pattern ?? (t.pattern = rU());
        nY.init(e, t);
      }),
      n1 = e1('$ZodEmail', (e, t) => {
        (t.pattern ?? (t.pattern = rL), nY.init(e, t));
      }),
      n4 = e1('$ZodURL', (e, t) => {
        (nY.init(e, t),
          (e._zod.check = (r) => {
            try {
              let n = r.value.trim(),
                i = new URL(n);
              (t.hostname &&
                ((t.hostname.lastIndex = 0),
                t.hostname.test(i.hostname) ||
                  r.issues.push({
                    code: 'invalid_format',
                    format: 'url',
                    note: 'Invalid hostname',
                    pattern: rQ.source,
                    input: r.value,
                    inst: e,
                    continue: !t.abort,
                  })),
                t.protocol &&
                  ((t.protocol.lastIndex = 0),
                  t.protocol.test(
                    i.protocol.endsWith(':') ? i.protocol.slice(0, -1) : i.protocol
                  ) ||
                    r.issues.push({
                      code: 'invalid_format',
                      format: 'url',
                      note: 'Invalid protocol',
                      pattern: t.protocol.source,
                      input: r.value,
                      inst: e,
                      continue: !t.abort,
                    })),
                t.normalize ? (r.value = i.href) : (r.value = n));
              return;
            } catch (n) {
              r.issues.push({
                code: 'invalid_format',
                format: 'url',
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      }),
      n6 = e1('$ZodEmoji', (e, t) => {
        (t.pattern ?? (t.pattern = rX()), nY.init(e, t));
      }),
      n2 = e1('$ZodNanoID', (e, t) => {
        (t.pattern ?? (t.pattern = rT), nY.init(e, t));
      }),
      n9 = e1('$ZodCUID', (e, t) => {
        (t.pattern ?? (t.pattern = rk), nY.init(e, t));
      }),
      n3 = e1('$ZodCUID2', (e, t) => {
        (t.pattern ?? (t.pattern = rI), nY.init(e, t));
      }),
      n7 = e1('$ZodULID', (e, t) => {
        (t.pattern ?? (t.pattern = rP), nY.init(e, t));
      }),
      n5 = e1('$ZodXID', (e, t) => {
        (t.pattern ?? (t.pattern = rN), nY.init(e, t));
      }),
      n8 = e1('$ZodKSUID', (e, t) => {
        (t.pattern ?? (t.pattern = rR), nY.init(e, t));
      }),
      ie = e1('$ZodISODateTime', (e, t) => {
        (t.pattern ?? (t.pattern = r3(t)), nY.init(e, t));
      }),
      it = e1('$ZodISODate', (e, t) => {
        (t.pattern ?? (t.pattern = r6), nY.init(e, t));
      }),
      ir = e1('$ZodISOTime', (e, t) => {
        (t.pattern ?? (t.pattern = r9(t)), nY.init(e, t));
      }),
      ii = e1('$ZodISODuration', (e, t) => {
        (t.pattern ?? (t.pattern = rj), nY.init(e, t));
      }),
      ia = e1('$ZodIPv4', (e, t) => {
        (t.pattern ?? (t.pattern = rq),
          nY.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.format = 'ipv4';
          }));
      }),
      io = e1('$ZodIPv6', (e, t) => {
        (t.pattern ?? (t.pattern = rW),
          nY.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.format = 'ipv6';
          }),
          (e._zod.check = (r) => {
            try {
              new URL(`http://[${r.value}]`);
            } catch {
              r.issues.push({
                code: 'invalid_format',
                format: 'ipv6',
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      }),
      is = e1('$ZodCIDRv4', (e, t) => {
        (t.pattern ?? (t.pattern = rH), nY.init(e, t));
      }),
      iu = e1('$ZodCIDRv6', (e, t) => {
        (t.pattern ?? (t.pattern = rJ),
          nY.init(e, t),
          (e._zod.check = (r) => {
            let [n, i] = r.value.split('/');
            try {
              if (!i) throw Error();
              let e = Number(i);
              if (`${e}` !== i || e < 0 || e > 128) throw Error();
              new URL(`http://[${n}]`);
            } catch {
              r.issues.push({
                code: 'invalid_format',
                format: 'cidrv6',
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
            }
          }));
      });
    function il(e) {
      if ('' === e) return !0;
      if (e.length % 4 != 0) return !1;
      try {
        return (atob(e), !0);
      } catch {
        return !1;
      }
    }
    let ic = e1('$ZodBase64', (e, t) => {
      (t.pattern ?? (t.pattern = rK),
        nY.init(e, t),
        e._zod.onattach.push((e) => {
          e._zod.bag.contentEncoding = 'base64';
        }),
        (e._zod.check = (r) => {
          il(r.value) ||
            r.issues.push({
              code: 'invalid_format',
              format: 'base64',
              input: r.value,
              inst: e,
              continue: !t.abort,
            });
        }));
    });
    function id(e) {
      if (!rY.test(e)) return !1;
      let t = e.replace(/[-_]/g, (e) => ('-' === e ? '+' : '/'));
      return il(t.padEnd(4 * Math.ceil(t.length / 4), '='));
    }
    let ip = e1('$ZodBase64URL', (e, t) => {
        (t.pattern ?? (t.pattern = rY),
          nY.init(e, t),
          e._zod.onattach.push((e) => {
            e._zod.bag.contentEncoding = 'base64url';
          }),
          (e._zod.check = (r) => {
            id(r.value) ||
              r.issues.push({
                code: 'invalid_format',
                format: 'base64url',
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      im = e1('$ZodE164', (e, t) => {
        (t.pattern ?? (t.pattern = r1), nY.init(e, t));
      });
    function ig(e, t = null) {
      try {
        let r = e.split('.');
        if (3 !== r.length) return !1;
        let [n] = r;
        if (!n) return !1;
        let i = JSON.parse(atob(n));
        if (('typ' in i && i?.typ !== 'JWT') || !i.alg || (t && (!('alg' in i) || i.alg !== t)))
          return !1;
        return !0;
      } catch {
        return !1;
      }
    }
    let ih = e1('$ZodJWT', (e, t) => {
        (nY.init(e, t),
          (e._zod.check = (r) => {
            ig(r.value, t.alg) ||
              r.issues.push({
                code: 'invalid_format',
                format: 'jwt',
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      iv = e1('$ZodCustomStringFormat', (e, t) => {
        (nY.init(e, t),
          (e._zod.check = (r) => {
            t.fn(r.value) ||
              r.issues.push({
                code: 'invalid_format',
                format: t.format,
                input: r.value,
                inst: e,
                continue: !t.abort,
              });
          }));
      }),
      ib = e1('$ZodNumber', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = e._zod.bag.pattern ?? ne),
          (e._zod.parse = (r, n) => {
            if (t.coerce)
              try {
                r.value = Number(r.value);
              } catch (e) {}
            let i = r.value;
            if ('number' == typeof i && !Number.isNaN(i) && Number.isFinite(i)) return r;
            let a =
              'number' == typeof i
                ? Number.isNaN(i)
                  ? 'NaN'
                  : Number.isFinite(i)
                    ? void 0
                    : 'Infinity'
                : void 0;
            return (
              r.issues.push({
                expected: 'number',
                code: 'invalid_type',
                input: i,
                inst: e,
                ...(a ? { received: a } : {}),
              }),
              r
            );
          }));
      }),
      i_ = e1('$ZodNumber', (e, t) => {
        (nP.init(e, t), ib.init(e, t));
      }),
      iy = e1('$ZodBoolean', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = nt),
          (e._zod.parse = (r, n) => {
            if (t.coerce)
              try {
                r.value = !!r.value;
              } catch (e) {}
            let i = r.value;
            return (
              'boolean' == typeof i ||
                r.issues.push({ expected: 'boolean', code: 'invalid_type', input: i, inst: e }),
              r
            );
          }));
      }),
      ix = e1('$ZodBigInt', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = r5),
          (e._zod.parse = (r, n) => {
            if (t.coerce)
              try {
                r.value = BigInt(r.value);
              } catch (e) {}
            return (
              'bigint' == typeof r.value ||
                r.issues.push({
                  expected: 'bigint',
                  code: 'invalid_type',
                  input: r.value,
                  inst: e,
                }),
              r
            );
          }));
      }),
      i$ = e1('$ZodBigInt', (e, t) => {
        (nN.init(e, t), ix.init(e, t));
      }),
      iw = e1('$ZodSymbol', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (t, r) => {
            let n = t.value;
            return (
              'symbol' == typeof n ||
                t.issues.push({ expected: 'symbol', code: 'invalid_type', input: n, inst: e }),
              t
            );
          }));
      }),
      iS = e1('$ZodUndefined', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = nn),
          (e._zod.values = new Set([void 0])),
          (e._zod.optin = 'optional'),
          (e._zod.optout = 'optional'),
          (e._zod.parse = (t, r) => {
            let n = t.value;
            return (
              void 0 === n ||
                t.issues.push({ expected: 'undefined', code: 'invalid_type', input: n, inst: e }),
              t
            );
          }));
      }),
      iO = e1('$ZodNull', (e, t) => {
        (nJ.init(e, t),
          (e._zod.pattern = nr),
          (e._zod.values = new Set([null])),
          (e._zod.parse = (t, r) => {
            let n = t.value;
            return (
              null === n ||
                t.issues.push({ expected: 'null', code: 'invalid_type', input: n, inst: e }),
              t
            );
          }));
      }),
      iE = e1('$ZodAny', (e, t) => {
        (nJ.init(e, t), (e._zod.parse = (e) => e));
      }),
      ik = e1('$ZodUnknown', (e, t) => {
        (nJ.init(e, t), (e._zod.parse = (e) => e));
      }),
      iI = e1('$ZodNever', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (t, r) => (
            t.issues.push({ expected: 'never', code: 'invalid_type', input: t.value, inst: e }),
            t
          )));
      }),
      iP = e1('$ZodVoid', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (t, r) => {
            let n = t.value;
            return (
              void 0 === n ||
                t.issues.push({ expected: 'void', code: 'invalid_type', input: n, inst: e }),
              t
            );
          }));
      }),
      iN = e1('$ZodDate', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (r, n) => {
            if (t.coerce)
              try {
                r.value = new Date(r.value);
              } catch (e) {}
            let i = r.value,
              a = i instanceof Date;
            return (
              (a && !Number.isNaN(i.getTime())) ||
                r.issues.push({
                  expected: 'date',
                  code: 'invalid_type',
                  input: i,
                  ...(a ? { received: 'Invalid Date' } : {}),
                  inst: e,
                }),
              r
            );
          }));
      });
    function iR(e, t, r) {
      (e.issues.length && t.issues.push(...tG(r, e.issues)), (t.value[r] = e.value));
    }
    let iT = e1('$ZodArray', (e, t) => {
      (nJ.init(e, t),
        (e._zod.parse = (r, n) => {
          let i = r.value;
          if (!Array.isArray(i))
            return (
              r.issues.push({ expected: 'array', code: 'invalid_type', input: i, inst: e }),
              r
            );
          r.value = Array(i.length);
          let a = [];
          for (let e = 0; e < i.length; e++) {
            let o = i[e],
              s = t.element._zod.run({ value: o, issues: [] }, n);
            s instanceof Promise ? a.push(s.then((t) => iR(t, r, e))) : iR(s, r, e);
          }
          return a.length ? Promise.all(a).then(() => r) : r;
        }));
    });
    function ij(e, t, r, n) {
      (e.issues.length && t.issues.push(...tG(r, e.issues)),
        void 0 === e.value ? r in n && (t.value[r] = void 0) : (t.value[r] = e.value));
    }
    function iA(e) {
      let t = Object.keys(e.shape);
      for (let r of t)
        if (!e.shape[r]._zod.traits.has('$ZodType'))
          throw Error(`Invalid element at key "${r}": expected a Zod schema`);
      let r = tj(e.shape);
      return { ...e, keys: t, keySet: new Set(t), numKeys: t.length, optionalKeys: new Set(r) };
    }
    function iD(e, t, r, n, i, a) {
      let o = [],
        s = i.keySet,
        u = i.catchall._zod,
        l = u.def.type;
      for (let i of Object.keys(t)) {
        if (s.has(i)) continue;
        if ('never' === l) {
          o.push(i);
          continue;
        }
        let a = u.run({ value: t[i], issues: [] }, n);
        a instanceof Promise ? e.push(a.then((e) => ij(e, r, i, t))) : ij(a, r, i, t);
      }
      return (o.length && r.issues.push({ code: 'unrecognized_keys', keys: o, input: t, inst: a }),
      e.length)
        ? Promise.all(e).then(() => r)
        : r;
    }
    let iU = e1('$ZodObject', (e, t) => {
        let r;
        nJ.init(e, t);
        let n = ta(() => iA(t));
        tc(e._zod, 'propValues', () => {
          let e = t.shape,
            r = {};
          for (let t in e) {
            let n = e[t]._zod;
            if (n.values) for (let e of (r[t] ?? (r[t] = new Set()), n.values)) r[t].add(e);
          }
          return r;
        });
        let i = t.catchall;
        e._zod.parse = (t, a) => {
          r ?? (r = n.value);
          let o = t.value;
          if (!ty(o))
            return (
              t.issues.push({ expected: 'object', code: 'invalid_type', input: o, inst: e }),
              t
            );
          t.value = {};
          let s = [],
            u = r.shape;
          for (let e of r.keys) {
            let r = u[e]._zod.run({ value: o[e], issues: [] }, a);
            r instanceof Promise ? s.push(r.then((r) => ij(r, t, e, o))) : ij(r, t, e, o);
          }
          return i ? iD(s, o, t, a, n.value, e) : s.length ? Promise.all(s).then(() => t) : t;
        };
      }),
      iz = e1('$ZodObjectJIT', (e, t) => {
        let r, n;
        iU.init(e, t);
        let i = e._zod.parse,
          a = ta(() => iA(t)),
          o = !e9.jitless,
          s = o && tx.value,
          u = t.catchall;
        e._zod.parse = (l, c) => {
          n ?? (n = a.value);
          let d = l.value;
          return ty(d)
            ? o && s && c?.async === !1 && !0 !== c.jitless
              ? (r ||
                  (r = ((e) => {
                    let t = new nW(['shape', 'payload', 'ctx']),
                      r = a.value,
                      n = (e) => {
                        let t = tb(e);
                        return `shape[${t}]._zod.run({ value: input[${t}], issues: [] }, ctx)`;
                      };
                    t.write('const input = payload.value;');
                    let i = Object.create(null),
                      o = 0;
                    for (let e of r.keys) i[e] = `key_${o++}`;
                    for (let e of (t.write('const newResult = {}'), r.keys)) {
                      let r = i[e],
                        a = tb(e);
                      (t.write(`const ${r} = ${n(e)};`),
                        t.write(`
        if (${r}.issues.length) {
          payload.issues = payload.issues.concat(${r}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${a}, ...iss.path] : [${a}]
          })));
        }
        
        if (${r}.value === undefined) {
          if (${a} in input) {
            newResult[${a}] = undefined;
          }
        } else {
          newResult[${a}] = ${r}.value;
        }
      `));
                    }
                    (t.write('payload.value = newResult;'), t.write('return payload;'));
                    let s = t.compile();
                    return (t, r) => s(e, t, r);
                  })(t.shape)),
                (l = r(l, c)),
                u)
                ? iD([], d, l, c, n, e)
                : l
              : i(l, c)
            : (l.issues.push({ expected: 'object', code: 'invalid_type', input: d, inst: e }), l);
        };
      });
    function iC(e, t, r, n) {
      for (let r of e) if (0 === r.issues.length) return ((t.value = r.value), t);
      let i = e.filter((e) => !tF(e));
      return 1 === i.length
        ? ((t.value = i[0].value), i[0])
        : (t.issues.push({
            code: 'invalid_union',
            input: t.value,
            inst: r,
            errors: e.map((e) => e.issues.map((e) => tX(e, n, e3()))),
          }),
          t);
    }
    let iZ = e1('$ZodUnion', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'optin', () =>
            t.options.some((e) => 'optional' === e._zod.optin) ? 'optional' : void 0
          ),
          tc(e._zod, 'optout', () =>
            t.options.some((e) => 'optional' === e._zod.optout) ? 'optional' : void 0
          ),
          tc(e._zod, 'values', () => {
            if (t.options.every((e) => e._zod.values))
              return new Set(t.options.flatMap((e) => Array.from(e._zod.values)));
          }),
          tc(e._zod, 'pattern', () => {
            if (t.options.every((e) => e._zod.pattern)) {
              let e = t.options.map((e) => e._zod.pattern);
              return RegExp(`^(${e.map((e) => ts(e.source)).join('|')})$`);
            }
          }));
        let r = 1 === t.options.length,
          n = t.options[0]._zod.run;
        e._zod.parse = (i, a) => {
          if (r) return n(i, a);
          let o = !1,
            s = [];
          for (let e of t.options) {
            let t = e._zod.run({ value: i.value, issues: [] }, a);
            if (t instanceof Promise) (s.push(t), (o = !0));
            else {
              if (0 === t.issues.length) return t;
              s.push(t);
            }
          }
          return o ? Promise.all(s).then((t) => iC(t, i, e, a)) : iC(s, i, e, a);
        };
      }),
      iL = e1('$ZodDiscriminatedUnion', (e, t) => {
        iZ.init(e, t);
        let r = e._zod.parse;
        tc(e._zod, 'propValues', () => {
          let e = {};
          for (let r of t.options) {
            let n = r._zod.propValues;
            if (!n || 0 === Object.keys(n).length)
              throw Error(`Invalid discriminated union option at index "${t.options.indexOf(r)}"`);
            for (let [t, r] of Object.entries(n))
              for (let n of (e[t] || (e[t] = new Set()), r)) e[t].add(n);
          }
          return e;
        });
        let n = ta(() => {
          let e = t.options,
            r = new Map();
          for (let n of e) {
            let e = n._zod.propValues?.[t.discriminator];
            if (!e || 0 === e.size)
              throw Error(`Invalid discriminated union option at index "${t.options.indexOf(n)}"`);
            for (let t of e) {
              if (r.has(t)) throw Error(`Duplicate discriminator value "${String(t)}"`);
              r.set(t, n);
            }
          }
          return r;
        });
        e._zod.parse = (i, a) => {
          let o = i.value;
          if (!ty(o))
            return (
              i.issues.push({ code: 'invalid_type', expected: 'object', input: o, inst: e }),
              i
            );
          let s = n.value.get(o?.[t.discriminator]);
          return s
            ? s._zod.run(i, a)
            : t.unionFallback
              ? r(i, a)
              : (i.issues.push({
                  code: 'invalid_union',
                  errors: [],
                  note: 'No matching discriminator',
                  discriminator: t.discriminator,
                  input: o,
                  path: [t.discriminator],
                  inst: e,
                }),
                i);
        };
      }),
      iM = e1('$ZodIntersection', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (e, r) => {
            let n = e.value,
              i = t.left._zod.run({ value: n, issues: [] }, r),
              a = t.right._zod.run({ value: n, issues: [] }, r);
            return i instanceof Promise || a instanceof Promise
              ? Promise.all([i, a]).then(([t, r]) => iB(e, t, r))
              : iB(e, i, a);
          }));
      });
    function iB(e, t, r) {
      if (
        (t.issues.length && e.issues.push(...t.issues),
        r.issues.length && e.issues.push(...r.issues),
        tF(e))
      )
        return e;
      let n = (function e(t, r) {
        if (t === r || (t instanceof Date && r instanceof Date && +t == +r))
          return { valid: !0, data: t };
        if (t$(t) && t$(r)) {
          let n = Object.keys(r),
            i = Object.keys(t).filter((e) => -1 !== n.indexOf(e)),
            a = { ...t, ...r };
          for (let n of i) {
            let i = e(t[n], r[n]);
            if (!i.valid) return { valid: !1, mergeErrorPath: [n, ...i.mergeErrorPath] };
            a[n] = i.data;
          }
          return { valid: !0, data: a };
        }
        if (Array.isArray(t) && Array.isArray(r)) {
          if (t.length !== r.length) return { valid: !1, mergeErrorPath: [] };
          let n = [];
          for (let i = 0; i < t.length; i++) {
            let a = e(t[i], r[i]);
            if (!a.valid) return { valid: !1, mergeErrorPath: [i, ...a.mergeErrorPath] };
            n.push(a.data);
          }
          return { valid: !0, data: n };
        }
        return { valid: !1, mergeErrorPath: [] };
      })(t.value, r.value);
      if (!n.valid)
        throw Error(`Unmergable intersection. Error path: ${JSON.stringify(n.mergeErrorPath)}`);
      return ((e.value = n.data), e);
    }
    let iF = e1('$ZodTuple', (e, t) => {
      nJ.init(e, t);
      let r = t.items,
        n = r.length - [...r].reverse().findIndex((e) => 'optional' !== e._zod.optin);
      e._zod.parse = (i, a) => {
        let o = i.value;
        if (!Array.isArray(o))
          return (i.issues.push({ input: o, inst: e, expected: 'tuple', code: 'invalid_type' }), i);
        i.value = [];
        let s = [];
        if (!t.rest) {
          let t = o.length > r.length,
            a = o.length < n - 1;
          if (t || a)
            return (
              i.issues.push({
                ...(t
                  ? { code: 'too_big', maximum: r.length }
                  : { code: 'too_small', minimum: r.length }),
                input: o,
                inst: e,
                origin: 'array',
              }),
              i
            );
        }
        let u = -1;
        for (let e of r) {
          if (++u >= o.length && u >= n) continue;
          let t = e._zod.run({ value: o[u], issues: [] }, a);
          t instanceof Promise ? s.push(t.then((e) => iG(e, i, u))) : iG(t, i, u);
        }
        if (t.rest)
          for (let e of o.slice(r.length)) {
            u++;
            let r = t.rest._zod.run({ value: e, issues: [] }, a);
            r instanceof Promise ? s.push(r.then((e) => iG(e, i, u))) : iG(r, i, u);
          }
        return s.length ? Promise.all(s).then(() => i) : i;
      };
    });
    function iG(e, t, r) {
      (e.issues.length && t.issues.push(...tG(r, e.issues)), (t.value[r] = e.value));
    }
    let iV = e1('$ZodRecord', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (r, n) => {
            let i = r.value;
            if (!t$(i))
              return (
                r.issues.push({ expected: 'record', code: 'invalid_type', input: i, inst: e }),
                r
              );
            let a = [];
            if (t.keyType._zod.values) {
              let o,
                s = t.keyType._zod.values;
              for (let e of ((r.value = {}), s))
                if ('string' == typeof e || 'number' == typeof e || 'symbol' == typeof e) {
                  let o = t.valueType._zod.run({ value: i[e], issues: [] }, n);
                  o instanceof Promise
                    ? a.push(
                        o.then((t) => {
                          (t.issues.length && r.issues.push(...tG(e, t.issues)),
                            (r.value[e] = t.value));
                        })
                      )
                    : (o.issues.length && r.issues.push(...tG(e, o.issues)),
                      (r.value[e] = o.value));
                }
              for (let e in i) s.has(e) || (o = o ?? []).push(e);
              o &&
                o.length > 0 &&
                r.issues.push({ code: 'unrecognized_keys', input: i, inst: e, keys: o });
            } else
              for (let o of ((r.value = {}), Reflect.ownKeys(i))) {
                if ('__proto__' === o) continue;
                let s = t.keyType._zod.run({ value: o, issues: [] }, n);
                if (s instanceof Promise)
                  throw Error('Async schemas not supported in object keys currently');
                if (s.issues.length) {
                  (r.issues.push({
                    code: 'invalid_key',
                    origin: 'record',
                    issues: s.issues.map((e) => tX(e, n, e3())),
                    input: o,
                    path: [o],
                    inst: e,
                  }),
                    (r.value[s.value] = s.value));
                  continue;
                }
                let u = t.valueType._zod.run({ value: i[o], issues: [] }, n);
                u instanceof Promise
                  ? a.push(
                      u.then((e) => {
                        (e.issues.length && r.issues.push(...tG(o, e.issues)),
                          (r.value[s.value] = e.value));
                      })
                    )
                  : (u.issues.length && r.issues.push(...tG(o, u.issues)),
                    (r.value[s.value] = u.value));
              }
            return a.length ? Promise.all(a).then(() => r) : r;
          }));
      }),
      iX = e1('$ZodMap', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (r, n) => {
            let i = r.value;
            if (!(i instanceof Map))
              return (
                r.issues.push({ expected: 'map', code: 'invalid_type', input: i, inst: e }),
                r
              );
            let a = [];
            for (let [o, s] of ((r.value = new Map()), i)) {
              let u = t.keyType._zod.run({ value: o, issues: [] }, n),
                l = t.valueType._zod.run({ value: s, issues: [] }, n);
              u instanceof Promise || l instanceof Promise
                ? a.push(
                    Promise.all([u, l]).then(([t, a]) => {
                      iq(t, a, r, o, i, e, n);
                    })
                  )
                : iq(u, l, r, o, i, e, n);
            }
            return a.length ? Promise.all(a).then(() => r) : r;
          }));
      });
    function iq(e, t, r, n, i, a, o) {
      (e.issues.length &&
        (tE.has(typeof n)
          ? r.issues.push(...tG(n, e.issues))
          : r.issues.push({
              code: 'invalid_key',
              origin: 'map',
              input: i,
              inst: a,
              issues: e.issues.map((e) => tX(e, o, e3())),
            })),
        t.issues.length &&
          (tE.has(typeof n)
            ? r.issues.push(...tG(n, t.issues))
            : r.issues.push({
                origin: 'map',
                code: 'invalid_element',
                input: i,
                inst: a,
                key: n,
                issues: t.issues.map((e) => tX(e, o, e3())),
              })),
        r.value.set(e.value, t.value));
    }
    let iW = e1('$ZodSet', (e, t) => {
      (nJ.init(e, t),
        (e._zod.parse = (r, n) => {
          let i = r.value;
          if (!(i instanceof Set))
            return (r.issues.push({ input: i, inst: e, expected: 'set', code: 'invalid_type' }), r);
          let a = [];
          for (let e of ((r.value = new Set()), i)) {
            let i = t.valueType._zod.run({ value: e, issues: [] }, n);
            i instanceof Promise ? a.push(i.then((e) => iH(e, r))) : iH(i, r);
          }
          return a.length ? Promise.all(a).then(() => r) : r;
        }));
    });
    function iH(e, t) {
      (e.issues.length && t.issues.push(...e.issues), t.value.add(e.value));
    }
    let iJ = e1('$ZodEnum', (e, t) => {
        nJ.init(e, t);
        let r = tr(t.entries),
          n = new Set(r);
        ((e._zod.values = n),
          (e._zod.pattern = RegExp(
            `^(${r
              .filter((e) => tE.has(typeof e))
              .map((e) => ('string' == typeof e ? tI(e) : e.toString()))
              .join('|')})$`
          )),
          (e._zod.parse = (t, i) => {
            let a = t.value;
            return (
              n.has(a) || t.issues.push({ code: 'invalid_value', values: r, input: a, inst: e }),
              t
            );
          }));
      }),
      iK = e1('$ZodLiteral', (e, t) => {
        if ((nJ.init(e, t), 0 === t.values.length))
          throw Error('Cannot create literal schema with no valid values');
        ((e._zod.values = new Set(t.values)),
          (e._zod.pattern = RegExp(
            `^(${t.values.map((e) => ('string' == typeof e ? tI(e) : e ? tI(e.toString()) : String(e))).join('|')})$`
          )),
          (e._zod.parse = (r, n) => {
            let i = r.value;
            return (
              e._zod.values.has(i) ||
                r.issues.push({ code: 'invalid_value', values: t.values, input: i, inst: e }),
              r
            );
          }));
      }),
      iY = e1('$ZodFile', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (t, r) => {
            let n = t.value;
            return (
              n instanceof File ||
                t.issues.push({ expected: 'file', code: 'invalid_type', input: n, inst: e }),
              t
            );
          }));
      }),
      iQ = e1('$ZodTransform', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (r, n) => {
            if ('backward' === n.direction) throw new e2(e.constructor.name);
            let i = t.transform(r.value, r);
            if (n.async)
              return (i instanceof Promise ? i : Promise.resolve(i)).then(
                (e) => ((r.value = e), r)
              );
            if (i instanceof Promise) throw new e6();
            return ((r.value = i), r);
          }));
      });
    function i0(e, t) {
      return e.issues.length && void 0 === t ? { issues: [], value: void 0 } : e;
    }
    let i1 = e1('$ZodOptional', (e, t) => {
        (nJ.init(e, t),
          (e._zod.optin = 'optional'),
          (e._zod.optout = 'optional'),
          tc(e._zod, 'values', () =>
            t.innerType._zod.values ? new Set([...t.innerType._zod.values, void 0]) : void 0
          ),
          tc(e._zod, 'pattern', () => {
            let e = t.innerType._zod.pattern;
            return e ? RegExp(`^(${ts(e.source)})?$`) : void 0;
          }),
          (e._zod.parse = (e, r) => {
            if ('optional' === t.innerType._zod.optin) {
              let n = t.innerType._zod.run(e, r);
              return n instanceof Promise ? n.then((t) => i0(t, e.value)) : i0(n, e.value);
            }
            return void 0 === e.value ? e : t.innerType._zod.run(e, r);
          }));
      }),
      i4 = e1('$ZodNullable', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'optin', () => t.innerType._zod.optin),
          tc(e._zod, 'optout', () => t.innerType._zod.optout),
          tc(e._zod, 'pattern', () => {
            let e = t.innerType._zod.pattern;
            return e ? RegExp(`^(${ts(e.source)}|null)$`) : void 0;
          }),
          tc(e._zod, 'values', () =>
            t.innerType._zod.values ? new Set([...t.innerType._zod.values, null]) : void 0
          ),
          (e._zod.parse = (e, r) => (null === e.value ? e : t.innerType._zod.run(e, r))));
      }),
      i6 = e1('$ZodDefault', (e, t) => {
        (nJ.init(e, t),
          (e._zod.optin = 'optional'),
          tc(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, r) => {
            if ('backward' === r.direction) return t.innerType._zod.run(e, r);
            if (void 0 === e.value) return ((e.value = t.defaultValue), e);
            let n = t.innerType._zod.run(e, r);
            return n instanceof Promise ? n.then((e) => i2(e, t)) : i2(n, t);
          }));
      });
    function i2(e, t) {
      return (void 0 === e.value && (e.value = t.defaultValue), e);
    }
    let i9 = e1('$ZodPrefault', (e, t) => {
        (nJ.init(e, t),
          (e._zod.optin = 'optional'),
          tc(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, r) => (
            'backward' === r.direction || (void 0 === e.value && (e.value = t.defaultValue)),
            t.innerType._zod.run(e, r)
          )));
      }),
      i3 = e1('$ZodNonOptional', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'values', () => {
            let e = t.innerType._zod.values;
            return e ? new Set([...e].filter((e) => void 0 !== e)) : void 0;
          }),
          (e._zod.parse = (r, n) => {
            let i = t.innerType._zod.run(r, n);
            return i instanceof Promise ? i.then((t) => i7(t, e)) : i7(i, e);
          }));
      });
    function i7(e, t) {
      return (
        e.issues.length ||
          void 0 !== e.value ||
          e.issues.push({ code: 'invalid_type', expected: 'nonoptional', input: e.value, inst: t }),
        e
      );
    }
    let i5 = e1('$ZodSuccess', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (e, r) => {
            if ('backward' === r.direction) throw new e2('ZodSuccess');
            let n = t.innerType._zod.run(e, r);
            return n instanceof Promise
              ? n.then((t) => ((e.value = 0 === t.issues.length), e))
              : ((e.value = 0 === n.issues.length), e);
          }));
      }),
      i8 = e1('$ZodCatch', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'optin', () => t.innerType._zod.optin),
          tc(e._zod, 'optout', () => t.innerType._zod.optout),
          tc(e._zod, 'values', () => t.innerType._zod.values),
          (e._zod.parse = (e, r) => {
            if ('backward' === r.direction) return t.innerType._zod.run(e, r);
            let n = t.innerType._zod.run(e, r);
            return n instanceof Promise
              ? n.then(
                  (n) => (
                    (e.value = n.value),
                    n.issues.length &&
                      ((e.value = t.catchValue({
                        ...e,
                        error: { issues: n.issues.map((e) => tX(e, r, e3())) },
                        input: e.value,
                      })),
                      (e.issues = [])),
                    e
                  )
                )
              : ((e.value = n.value),
                n.issues.length &&
                  ((e.value = t.catchValue({
                    ...e,
                    error: { issues: n.issues.map((e) => tX(e, r, e3())) },
                    input: e.value,
                  })),
                  (e.issues = [])),
                e);
          }));
      }),
      ae = e1('$ZodNaN', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (t, r) => (
            ('number' == typeof t.value && Number.isNaN(t.value)) ||
              t.issues.push({ input: t.value, inst: e, expected: 'nan', code: 'invalid_type' }),
            t
          )));
      }),
      at = e1('$ZodPipe', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'values', () => t.in._zod.values),
          tc(e._zod, 'optin', () => t.in._zod.optin),
          tc(e._zod, 'optout', () => t.out._zod.optout),
          tc(e._zod, 'propValues', () => t.in._zod.propValues),
          (e._zod.parse = (e, r) => {
            if ('backward' === r.direction) {
              let n = t.out._zod.run(e, r);
              return n instanceof Promise ? n.then((e) => ar(e, t.in, r)) : ar(n, t.in, r);
            }
            let n = t.in._zod.run(e, r);
            return n instanceof Promise ? n.then((e) => ar(e, t.out, r)) : ar(n, t.out, r);
          }));
      });
    function ar(e, t, r) {
      return e.issues.length
        ? ((e.aborted = !0), e)
        : t._zod.run({ value: e.value, issues: e.issues }, r);
    }
    let an = e1('$ZodCodec', (e, t) => {
      (nJ.init(e, t),
        tc(e._zod, 'values', () => t.in._zod.values),
        tc(e._zod, 'optin', () => t.in._zod.optin),
        tc(e._zod, 'optout', () => t.out._zod.optout),
        tc(e._zod, 'propValues', () => t.in._zod.propValues),
        (e._zod.parse = (e, r) => {
          if ('forward' === (r.direction || 'forward')) {
            let n = t.in._zod.run(e, r);
            return n instanceof Promise ? n.then((e) => ai(e, t, r)) : ai(n, t, r);
          }
          {
            let n = t.out._zod.run(e, r);
            return n instanceof Promise ? n.then((e) => ai(e, t, r)) : ai(n, t, r);
          }
        }));
    });
    function ai(e, t, r) {
      if (e.issues.length) return ((e.aborted = !0), e);
      if ('forward' === (r.direction || 'forward')) {
        let n = t.transform(e.value, e);
        return n instanceof Promise ? n.then((n) => aa(e, n, t.out, r)) : aa(e, n, t.out, r);
      }
      {
        let n = t.reverseTransform(e.value, e);
        return n instanceof Promise ? n.then((n) => aa(e, n, t.in, r)) : aa(e, n, t.in, r);
      }
    }
    function aa(e, t, r, n) {
      return e.issues.length
        ? ((e.aborted = !0), e)
        : r._zod.run({ value: t, issues: e.issues }, n);
    }
    let ao = e1('$ZodReadonly', (e, t) => {
      (nJ.init(e, t),
        tc(e._zod, 'propValues', () => t.innerType._zod.propValues),
        tc(e._zod, 'values', () => t.innerType._zod.values),
        tc(e._zod, 'optin', () => t.innerType._zod.optin),
        tc(e._zod, 'optout', () => t.innerType._zod.optout),
        (e._zod.parse = (e, r) => {
          if ('backward' === r.direction) return t.innerType._zod.run(e, r);
          let n = t.innerType._zod.run(e, r);
          return n instanceof Promise ? n.then(as) : as(n);
        }));
    });
    function as(e) {
      return ((e.value = Object.freeze(e.value)), e);
    }
    let au = e1('$ZodTemplateLiteral', (e, t) => {
        nJ.init(e, t);
        let r = [];
        for (let e of t.parts)
          if ('object' == typeof e && null !== e) {
            if (!e._zod.pattern)
              throw Error(
                `Invalid template literal part, no pattern found: ${[...e._zod.traits].shift()}`
              );
            let t = e._zod.pattern instanceof RegExp ? e._zod.pattern.source : e._zod.pattern;
            if (!t) throw Error(`Invalid template literal part: ${e._zod.traits}`);
            let n = +!!t.startsWith('^'),
              i = t.endsWith('$') ? t.length - 1 : t.length;
            r.push(t.slice(n, i));
          } else if (null === e || tk.has(typeof e)) r.push(tI(`${e}`));
          else throw Error(`Invalid template literal part: ${e}`);
        ((e._zod.pattern = RegExp(`^${r.join('')}$`)),
          (e._zod.parse = (r, n) => (
            'string' != typeof r.value
              ? r.issues.push({
                  input: r.value,
                  inst: e,
                  expected: 'template_literal',
                  code: 'invalid_type',
                })
              : ((e._zod.pattern.lastIndex = 0),
                e._zod.pattern.test(r.value) ||
                  r.issues.push({
                    input: r.value,
                    inst: e,
                    code: 'invalid_format',
                    format: t.format ?? 'template_literal',
                    pattern: e._zod.pattern.source,
                  })),
            r
          )));
      }),
      al = e1(
        '$ZodFunction',
        (e, t) => (
          nJ.init(e, t),
          (e._def = t),
          (e._zod.def = t),
          (e.implement = (t) => {
            if ('function' != typeof t) throw Error('implement() must be called with a function');
            return function (...r) {
              let n = Reflect.apply(t, this, e._def.input ? ri(e._def.input, r) : r);
              return e._def.output ? ri(e._def.output, n) : n;
            };
          }),
          (e.implementAsync = (t) => {
            if ('function' != typeof t)
              throw Error('implementAsync() must be called with a function');
            return async function (...r) {
              let n = e._def.input ? await ro(e._def.input, r) : r,
                i = await Reflect.apply(t, this, n);
              return e._def.output ? await ro(e._def.output, i) : i;
            };
          }),
          (e._zod.parse = (t, r) => (
            'function' != typeof t.value
              ? t.issues.push({
                  code: 'invalid_type',
                  expected: 'function',
                  input: t.value,
                  inst: e,
                })
              : e._def.output && 'promise' === e._def.output._zod.def.type
                ? (t.value = e.implementAsync(t.value))
                : (t.value = e.implement(t.value)),
            t
          )),
          (e.input = (...t) => {
            let r = e.constructor;
            return new r(
              Array.isArray(t[0])
                ? {
                    type: 'function',
                    input: new iF({ type: 'tuple', items: t[0], rest: t[1] }),
                    output: e._def.output,
                  }
                : { type: 'function', input: t[0], output: e._def.output }
            );
          }),
          (e.output = (t) =>
            new e.constructor({ type: 'function', input: e._def.input, output: t })),
          e
        )
      ),
      ac = e1('$ZodPromise', (e, t) => {
        (nJ.init(e, t),
          (e._zod.parse = (e, r) =>
            Promise.resolve(e.value).then((e) =>
              t.innerType._zod.run({ value: e, issues: [] }, r)
            )));
      }),
      ad = e1('$ZodLazy', (e, t) => {
        (nJ.init(e, t),
          tc(e._zod, 'innerType', () => t.getter()),
          tc(e._zod, 'pattern', () => e._zod.innerType._zod.pattern),
          tc(e._zod, 'propValues', () => e._zod.innerType._zod.propValues),
          tc(e._zod, 'optin', () => e._zod.innerType._zod.optin ?? void 0),
          tc(e._zod, 'optout', () => e._zod.innerType._zod.optout ?? void 0),
          (e._zod.parse = (t, r) => e._zod.innerType._zod.run(t, r)));
      }),
      af = e1('$ZodCustom', (e, t) => {
        (nS.init(e, t),
          nJ.init(e, t),
          (e._zod.parse = (e, t) => e),
          (e._zod.check = (r) => {
            let n = r.value,
              i = t.fn(n);
            if (i instanceof Promise) return i.then((t) => ap(t, r, n, e));
            ap(i, r, n, e);
          }));
      });
    function ap(e, t, r, n) {
      if (!e) {
        let e = {
          code: 'custom',
          input: r,
          inst: n,
          path: [...(n._zod.def.path ?? [])],
          continue: !n._zod.def.abort,
        };
        (n._zod.def.params && (e.params = n._zod.def.params), t.issues.push(tH(e)));
      }
    }
    (e.i(42793), e.i(27962), e.i(88958), e.i(32878));
    var am = e.i(83254),
      ag = e.i(34571);
    function ah() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'حرف', verb: 'أن يحوي' },
              file: { unit: 'بايت', verb: 'أن يحوي' },
              array: { unit: 'عنصر', verb: 'أن يحوي' },
              set: { unit: 'عنصر', verb: 'أن يحوي' },
            },
            t = {
              regex: 'مدخل',
              email: 'بريد إلكتروني',
              url: 'رابط',
              emoji: 'إيموجي',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'تاريخ ووقت بمعيار ISO',
              date: 'تاريخ بمعيار ISO',
              time: 'وقت بمعيار ISO',
              duration: 'مدة بمعيار ISO',
              ipv4: 'عنوان IPv4',
              ipv6: 'عنوان IPv6',
              cidrv4: 'مدى عناوين بصيغة IPv4',
              cidrv6: 'مدى عناوين بصيغة IPv6',
              base64: 'نَص بترميز base64-encoded',
              base64url: 'نَص بترميز base64url-encoded',
              json_string: 'نَص على هيئة JSON',
              e164: 'رقم هاتف بمعيار E.164',
              jwt: 'JWT',
              template_literal: 'مدخل',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `مدخلات غير مقبولة: يفترض إدخال ${r.expected}، ولكن تم إدخال ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `مدخلات غير مقبولة: يفترض إدخال ${tT(r.values[0])}`;
                return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return ` أكبر من اللازم: يفترض أن تكون ${r.origin ?? 'القيمة'} ${t} ${r.maximum.toString()} ${n.unit ?? 'عنصر'}`;
                return `أكبر من اللازم: يفترض أن تكون ${r.origin ?? 'القيمة'} ${t} ${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `أصغر من اللازم: يفترض لـ ${r.origin} أن يكون ${t} ${r.minimum.toString()} ${n.unit}`;
                return `أصغر من اللازم: يفترض لـ ${r.origin} أن يكون ${t} ${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `نَص غير مقبول: يجب أن يبدأ بـ "${r.prefix}"`;
                if ('ends_with' === r.format) return `نَص غير مقبول: يجب أن ينتهي بـ "${r.suffix}"`;
                if ('includes' === r.format) return `نَص غير مقبول: يجب أن يتضمَّن "${r.includes}"`;
                if ('regex' === r.format) return `نَص غير مقبول: يجب أن يطابق النمط ${r.pattern}`;
                return `${t[r.format] ?? r.format} غير مقبول`;
              case 'not_multiple_of':
                return `رقم غير مقبول: يجب أن يكون من مضاعفات ${r.divisor}`;
              case 'unrecognized_keys':
                return `معرف${r.keys.length > 1 ? 'ات' : ''} غريب${r.keys.length > 1 ? 'ة' : ''}: ${tn(r.keys, '، ')}`;
              case 'invalid_key':
                return `معرف غير مقبول في ${r.origin}`;
              case 'invalid_union':
              default:
                return 'مدخل غير مقبول';
              case 'invalid_element':
                return `مدخل غير مقبول في ${r.origin}`;
            }
          };
        })(),
      };
    }
    function av() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'simvol', verb: 'olmalıdır' },
              file: { unit: 'bayt', verb: 'olmalıdır' },
              array: { unit: 'element', verb: 'olmalıdır' },
              set: { unit: 'element', verb: 'olmalıdır' },
            },
            t = {
              regex: 'input',
              email: 'email address',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datetime',
              date: 'ISO date',
              time: 'ISO time',
              duration: 'ISO duration',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded string',
              base64url: 'base64url-encoded string',
              json_string: 'JSON string',
              e164: 'E.164 number',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Yanlış dəyər: g\xf6zlənilən ${r.expected}, daxil olan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Yanlış dəyər: g\xf6zlənilən ${tT(r.values[0])}`;
                return `Yanlış se\xe7im: aşağıdakılardan biri olmalıdır: ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `\xc7ox b\xf6y\xfck: g\xf6zlənilən ${r.origin ?? 'dəyər'} ${t}${r.maximum.toString()} ${n.unit ?? 'element'}`;
                return `\xc7ox b\xf6y\xfck: g\xf6zlənilən ${r.origin ?? 'dəyər'} ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `\xc7ox ki\xe7ik: g\xf6zlənilən ${r.origin} ${t}${r.minimum.toString()} ${n.unit}`;
                return `\xc7ox ki\xe7ik: g\xf6zlənilən ${r.origin} ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Yanlış mətn: "${r.prefix}" ilə başlamalıdır`;
                if ('ends_with' === r.format) return `Yanlış mətn: "${r.suffix}" ilə bitməlidir`;
                if ('includes' === r.format) return `Yanlış mətn: "${r.includes}" daxil olmalıdır`;
                if ('regex' === r.format)
                  return `Yanlış mətn: ${r.pattern} şablonuna uyğun olmalıdır`;
                return `Yanlış ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Yanlış ədəd: ${r.divisor} ilə b\xf6l\xfcnə bilən olmalıdır`;
              case 'unrecognized_keys':
                return `Tanınmayan a\xe7ar${r.keys.length > 1 ? 'lar' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `${r.origin} daxilində yanlış a\xe7ar`;
              case 'invalid_union':
                return 'Yanlış dəyər';
              case 'invalid_element':
                return `${r.origin} daxilində yanlış dəyər`;
              default:
                return `Yanlış dəyər`;
            }
          };
        })(),
      };
    }
    function ab(e, t, r, n) {
      let i = Math.abs(e),
        a = i % 10,
        o = i % 100;
      return o >= 11 && o <= 19 ? n : 1 === a ? t : a >= 2 && a <= 4 ? r : n;
    }
    function a_() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: { one: 'сімвал', few: 'сімвалы', many: 'сімвалаў' }, verb: 'мець' },
              array: { unit: { one: 'элемент', few: 'элементы', many: 'элементаў' }, verb: 'мець' },
              set: { unit: { one: 'элемент', few: 'элементы', many: 'элементаў' }, verb: 'мець' },
              file: { unit: { one: 'байт', few: 'байты', many: 'байтаў' }, verb: 'мець' },
            },
            t = {
              regex: 'увод',
              email: 'email адрас',
              url: 'URL',
              emoji: 'эмодзі',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO дата і час',
              date: 'ISO дата',
              time: 'ISO час',
              duration: 'ISO працягласць',
              ipv4: 'IPv4 адрас',
              ipv6: 'IPv6 адрас',
              cidrv4: 'IPv4 дыяпазон',
              cidrv6: 'IPv6 дыяпазон',
              base64: 'радок у фармаце base64',
              base64url: 'радок у фармаце base64url',
              json_string: 'JSON радок',
              e164: 'нумар E.164',
              jwt: 'JWT',
              template_literal: 'увод',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Няправільны ўвод: чакаўся ${r.expected}, атрымана ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'лік';
                    case 'object':
                      if (Array.isArray(e)) return 'масіў';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Няправільны ўвод: чакалася ${tT(r.values[0])}`;
                return `Няправільны варыянт: чакаўся адзін з ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n) {
                  let e = ab(Number(r.maximum), n.unit.one, n.unit.few, n.unit.many);
                  return `Занадта вялікі: чакалася, што ${r.origin ?? 'значэнне'} павінна ${n.verb} ${t}${r.maximum.toString()} ${e}`;
                }
                return `Занадта вялікі: чакалася, што ${r.origin ?? 'значэнне'} павінна быць ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n) {
                  let e = ab(Number(r.minimum), n.unit.one, n.unit.few, n.unit.many);
                  return `Занадта малы: чакалася, што ${r.origin} павінна ${n.verb} ${t}${r.minimum.toString()} ${e}`;
                }
                return `Занадта малы: чакалася, што ${r.origin} павінна быць ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Няправільны радок: павінен пачынацца з "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Няправільны радок: павінен заканчвацца на "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Няправільны радок: павінен змяшчаць "${r.includes}"`;
                if ('regex' === r.format)
                  return `Няправільны радок: павінен адпавядаць шаблону ${r.pattern}`;
                return `Няправільны ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Няправільны лік: павінен быць кратным ${r.divisor}`;
              case 'unrecognized_keys':
                return `Нераспазнаны ${r.keys.length > 1 ? 'ключы' : 'ключ'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Няправільны ключ у ${r.origin}`;
              case 'invalid_union':
                return 'Няправільны ўвод';
              case 'invalid_element':
                return `Няправільнае значэнне ў ${r.origin}`;
              default:
                return `Няправільны ўвод`;
            }
          };
        })(),
      };
    }
    function ay() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caràcters', verb: 'contenir' },
              file: { unit: 'bytes', verb: 'contenir' },
              array: { unit: 'elements', verb: 'contenir' },
              set: { unit: 'elements', verb: 'contenir' },
            },
            t = {
              regex: 'entrada',
              email: 'adreça electrònica',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data i hora ISO',
              date: 'data ISO',
              time: 'hora ISO',
              duration: 'durada ISO',
              ipv4: 'adreça IPv4',
              ipv6: 'adreça IPv6',
              cidrv4: 'rang IPv4',
              cidrv6: 'rang IPv6',
              base64: 'cadena codificada en base64',
              base64url: 'cadena codificada en base64url',
              json_string: 'cadena JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Tipus inv\xe0lid: s'esperava ${r.expected}, s'ha rebut ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Valor inv\xe0lid: s'esperava ${tT(r.values[0])}`;
                return `Opci\xf3 inv\xe0lida: s'esperava una de ${tn(r.values, ' o ')}`;
              case 'too_big': {
                let t = r.inclusive ? 'com a màxim' : 'menys de',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Massa gran: s'esperava que ${r.origin ?? 'el valor'} contingu\xe9s ${t} ${r.maximum.toString()} ${n.unit ?? 'elements'}`;
                return `Massa gran: s'esperava que ${r.origin ?? 'el valor'} fos ${t} ${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? 'com a mínim' : 'més de',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Massa petit: s'esperava que ${r.origin} contingu\xe9s ${t} ${r.minimum.toString()} ${n.unit}`;
                return `Massa petit: s'esperava que ${r.origin} fos ${t} ${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Format inv\xe0lid: ha de comen\xe7ar amb "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Format inv\xe0lid: ha d'acabar amb "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Format inv\xe0lid: ha d'incloure "${r.includes}"`;
                if ('regex' === r.format)
                  return `Format inv\xe0lid: ha de coincidir amb el patr\xf3 ${r.pattern}`;
                return `Format inv\xe0lid per a ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe0lid: ha de ser m\xfaltiple de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Clau${r.keys.length > 1 ? 's' : ''} no reconeguda${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Clau inv\xe0lida a ${r.origin}`;
              case 'invalid_union':
                return 'Entrada invàlida';
              case 'invalid_element':
                return `Element inv\xe0lid a ${r.origin}`;
              default:
                return `Entrada inv\xe0lida`;
            }
          };
        })(),
      };
    }
    function ax() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znaků', verb: 'mít' },
              file: { unit: 'bajtů', verb: 'mít' },
              array: { unit: 'prvků', verb: 'mít' },
              set: { unit: 'prvků', verb: 'mít' },
            },
            t = {
              regex: 'regulární výraz',
              email: 'e-mailová adresa',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'datum a čas ve formátu ISO',
              date: 'datum ve formátu ISO',
              time: 'čas ve formátu ISO',
              duration: 'doba trvání ISO',
              ipv4: 'IPv4 adresa',
              ipv6: 'IPv6 adresa',
              cidrv4: 'rozsah IPv4',
              cidrv6: 'rozsah IPv6',
              base64: 'řetězec zakódovaný ve formátu base64',
              base64url: 'řetězec zakódovaný ve formátu base64url',
              json_string: 'řetězec ve formátu JSON',
              e164: 'číslo E.164',
              jwt: 'JWT',
              template_literal: 'vstup',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Neplatn\xfd vstup: oček\xe1v\xe1no ${r.expected}, obdrženo ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'číslo';
                    case 'string':
                      return 'řetězec';
                    case 'boolean':
                      return 'boolean';
                    case 'bigint':
                      return 'bigint';
                    case 'function':
                      return 'funkce';
                    case 'symbol':
                      return 'symbol';
                    case 'undefined':
                      return 'undefined';
                    case 'object':
                      if (Array.isArray(e)) return 'pole';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Neplatn\xfd vstup: oček\xe1v\xe1no ${tT(r.values[0])}`;
                return `Neplatn\xe1 možnost: oček\xe1v\xe1na jedna z hodnot ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Hodnota je př\xedliš velk\xe1: ${r.origin ?? 'hodnota'} mus\xed m\xedt ${t}${r.maximum.toString()} ${n.unit ?? 'prvků'}`;
                return `Hodnota je př\xedliš velk\xe1: ${r.origin ?? 'hodnota'} mus\xed b\xfdt ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Hodnota je př\xedliš mal\xe1: ${r.origin ?? 'hodnota'} mus\xed m\xedt ${t}${r.minimum.toString()} ${n.unit ?? 'prvků'}`;
                return `Hodnota je př\xedliš mal\xe1: ${r.origin ?? 'hodnota'} mus\xed b\xfdt ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Neplatn\xfd řetězec: mus\xed zač\xednat na "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Neplatn\xfd řetězec: mus\xed končit na "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Neplatn\xfd řetězec: mus\xed obsahovat "${r.includes}"`;
                if ('regex' === r.format)
                  return `Neplatn\xfd řetězec: mus\xed odpov\xeddat vzoru ${r.pattern}`;
                return `Neplatn\xfd form\xe1t ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Neplatn\xe9 č\xedslo: mus\xed b\xfdt n\xe1sobkem ${r.divisor}`;
              case 'unrecognized_keys':
                return `Nezn\xe1m\xe9 kl\xedče: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Neplatn\xfd kl\xedč v ${r.origin}`;
              case 'invalid_union':
                return 'Neplatný vstup';
              case 'invalid_element':
                return `Neplatn\xe1 hodnota v ${r.origin}`;
              default:
                return `Neplatn\xfd vstup`;
            }
          };
        })(),
      };
    }
    function a$() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tegn', verb: 'havde' },
              file: { unit: 'bytes', verb: 'havde' },
              array: { unit: 'elementer', verb: 'indeholdt' },
              set: { unit: 'elementer', verb: 'indeholdt' },
            },
            t = {
              string: 'streng',
              number: 'tal',
              boolean: 'boolean',
              array: 'liste',
              object: 'objekt',
              set: 'sæt',
              file: 'fil',
            },
            r = {
              regex: 'input',
              email: 'e-mailadresse',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dato- og klokkeslæt',
              date: 'ISO-dato',
              time: 'ISO-klokkeslæt',
              duration: 'ISO-varighed',
              ipv4: 'IPv4-område',
              ipv6: 'IPv6-område',
              cidrv4: 'IPv4-spektrum',
              cidrv6: 'IPv6-spektrum',
              base64: 'base64-kodet streng',
              base64url: 'base64url-kodet streng',
              json_string: 'JSON-streng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (n) => {
            var i, a, o, s;
            switch (n.code) {
              case 'invalid_type':
                return `Ugyldigt input: forventede ${t[(i = n.expected)] ?? i}, fik ${
                  t[
                    (a = ((e) => {
                      let t = typeof e;
                      switch (t) {
                        case 'number':
                          return Number.isNaN(e) ? 'NaN' : 'tal';
                        case 'object':
                          if (Array.isArray(e)) return 'liste';
                          if (null === e) return 'null';
                          if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                            return e.constructor.name;
                          return 'objekt';
                      }
                      return t;
                    })(n.input))
                  ] ?? a
                }`;
              case 'invalid_value':
                if (1 === n.values.length) return `Ugyldig v\xe6rdi: forventede ${tT(n.values[0])}`;
                return `Ugyldigt valg: forventede en af f\xf8lgende ${tn(n.values, '|')}`;
              case 'too_big': {
                let r = n.inclusive ? '<=' : '<',
                  i = e[n.origin] ?? null,
                  a = t[(o = n.origin)] ?? o;
                if (i)
                  return `For stor: forventede ${a ?? 'value'} ${i.verb} ${r} ${n.maximum.toString()} ${i.unit ?? 'elementer'}`;
                return `For stor: forventede ${a ?? 'value'} havde ${r} ${n.maximum.toString()}`;
              }
              case 'too_small': {
                let r = n.inclusive ? '>=' : '>',
                  i = e[n.origin] ?? null,
                  a = t[(s = n.origin)] ?? s;
                if (i)
                  return `For lille: forventede ${a} ${i.verb} ${r} ${n.minimum.toString()} ${i.unit}`;
                return `For lille: forventede ${a} havde ${r} ${n.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === n.format)
                  return `Ugyldig streng: skal starte med "${n.prefix}"`;
                if ('ends_with' === n.format) return `Ugyldig streng: skal ende med "${n.suffix}"`;
                if ('includes' === n.format)
                  return `Ugyldig streng: skal indeholde "${n.includes}"`;
                if ('regex' === n.format)
                  return `Ugyldig streng: skal matche m\xf8nsteret ${n.pattern}`;
                return `Ugyldig ${r[n.format] ?? n.format}`;
              case 'not_multiple_of':
                return `Ugyldigt tal: skal v\xe6re deleligt med ${n.divisor}`;
              case 'unrecognized_keys':
                return `${n.keys.length > 1 ? 'Ukendte nøgler' : 'Ukendt nøgle'}: ${tn(n.keys, ', ')}`;
              case 'invalid_key':
                return `Ugyldig n\xf8gle i ${n.origin}`;
              case 'invalid_union':
                return 'Ugyldigt input: matcher ingen af de tilladte typer';
              case 'invalid_element':
                return `Ugyldig v\xe6rdi i ${n.origin}`;
              default:
                return 'Ugyldigt input';
            }
          };
        })(),
      };
    }
    function aw() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'Zeichen', verb: 'zu haben' },
              file: { unit: 'Bytes', verb: 'zu haben' },
              array: { unit: 'Elemente', verb: 'zu haben' },
              set: { unit: 'Elemente', verb: 'zu haben' },
            },
            t = {
              regex: 'Eingabe',
              email: 'E-Mail-Adresse',
              url: 'URL',
              emoji: 'Emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-Datum und -Uhrzeit',
              date: 'ISO-Datum',
              time: 'ISO-Uhrzeit',
              duration: 'ISO-Dauer',
              ipv4: 'IPv4-Adresse',
              ipv6: 'IPv6-Adresse',
              cidrv4: 'IPv4-Bereich',
              cidrv6: 'IPv6-Bereich',
              base64: 'Base64-codierter String',
              base64url: 'Base64-URL-codierter String',
              json_string: 'JSON-String',
              e164: 'E.164-Nummer',
              jwt: 'JWT',
              template_literal: 'Eingabe',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Ung\xfcltige Eingabe: erwartet ${r.expected}, erhalten ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'Zahl';
                    case 'object':
                      if (Array.isArray(e)) return 'Array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Ung\xfcltige Eingabe: erwartet ${tT(r.values[0])}`;
                return `Ung\xfcltige Option: erwartet eine von ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Zu gro\xdf: erwartet, dass ${r.origin ?? 'Wert'} ${t}${r.maximum.toString()} ${n.unit ?? 'Elemente'} hat`;
                return `Zu gro\xdf: erwartet, dass ${r.origin ?? 'Wert'} ${t}${r.maximum.toString()} ist`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Zu klein: erwartet, dass ${r.origin} ${t}${r.minimum.toString()} ${n.unit} hat`;
                return `Zu klein: erwartet, dass ${r.origin} ${t}${r.minimum.toString()} ist`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ung\xfcltiger String: muss mit "${r.prefix}" beginnen`;
                if ('ends_with' === r.format)
                  return `Ung\xfcltiger String: muss mit "${r.suffix}" enden`;
                if ('includes' === r.format)
                  return `Ung\xfcltiger String: muss "${r.includes}" enthalten`;
                if ('regex' === r.format)
                  return `Ung\xfcltiger String: muss dem Muster ${r.pattern} entsprechen`;
                return `Ung\xfcltig: ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ung\xfcltige Zahl: muss ein Vielfaches von ${r.divisor} sein`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Unbekannte Schlüssel' : 'Unbekannter Schlüssel'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Ung\xfcltiger Schl\xfcssel in ${r.origin}`;
              case 'invalid_union':
                return 'Ungültige Eingabe';
              case 'invalid_element':
                return `Ung\xfcltiger Wert in ${r.origin}`;
              default:
                return `Ung\xfcltige Eingabe`;
            }
          };
        })(),
      };
    }
    function aS() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karaktrojn', verb: 'havi' },
              file: { unit: 'bajtojn', verb: 'havi' },
              array: { unit: 'elementojn', verb: 'havi' },
              set: { unit: 'elementojn', verb: 'havi' },
            },
            t = {
              regex: 'enigo',
              email: 'retadreso',
              url: 'URL',
              emoji: 'emoĝio',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-datotempo',
              date: 'ISO-dato',
              time: 'ISO-tempo',
              duration: 'ISO-daŭro',
              ipv4: 'IPv4-adreso',
              ipv6: 'IPv6-adreso',
              cidrv4: 'IPv4-rango',
              cidrv6: 'IPv6-rango',
              base64: '64-ume kodita karaktraro',
              base64url: 'URL-64-ume kodita karaktraro',
              json_string: 'JSON-karaktraro',
              e164: 'E.164-nombro',
              jwt: 'JWT',
              template_literal: 'enigo',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Nevalida enigo: atendiĝis ${r.expected}, riceviĝis ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombro';
                    case 'object':
                      if (Array.isArray(e)) return 'tabelo';
                      if (null === e) return 'senvalora';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Nevalida enigo: atendiĝis ${tT(r.values[0])}`;
                return `Nevalida opcio: atendiĝis unu el ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Tro granda: atendiĝis ke ${r.origin ?? 'valoro'} havu ${t}${r.maximum.toString()} ${n.unit ?? 'elementojn'}`;
                return `Tro granda: atendiĝis ke ${r.origin ?? 'valoro'} havu ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Tro malgranda: atendiĝis ke ${r.origin} havu ${t}${r.minimum.toString()} ${n.unit}`;
                return `Tro malgranda: atendiĝis ke ${r.origin} estu ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Nevalida karaktraro: devas komenciĝi per "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Nevalida karaktraro: devas finiĝi per "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Nevalida karaktraro: devas inkluzivi "${r.includes}"`;
                if ('regex' === r.format)
                  return `Nevalida karaktraro: devas kongrui kun la modelo ${r.pattern}`;
                return `Nevalida ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Nevalida nombro: devas esti oblo de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Nekonata${r.keys.length > 1 ? 'j' : ''} ŝlosilo${r.keys.length > 1 ? 'j' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Nevalida ŝlosilo en ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Nevalida enigo';
              case 'invalid_element':
                return `Nevalida valoro en ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aO() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caracteres', verb: 'tener' },
              file: { unit: 'bytes', verb: 'tener' },
              array: { unit: 'elementos', verb: 'tener' },
              set: { unit: 'elementos', verb: 'tener' },
            },
            t = {
              regex: 'entrada',
              email: 'dirección de correo electrónico',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'fecha y hora ISO',
              date: 'fecha ISO',
              time: 'hora ISO',
              duration: 'duración ISO',
              ipv4: 'dirección IPv4',
              ipv6: 'dirección IPv6',
              cidrv4: 'rango IPv4',
              cidrv6: 'rango IPv6',
              base64: 'cadena codificada en base64',
              base64url: 'URL codificada en base64',
              json_string: 'cadena JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Entrada inv\xe1lida: se esperaba ${r.expected}, recibido ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'número';
                    case 'object':
                      if (Array.isArray(e)) return 'arreglo';
                      if (null === e) return 'nulo';
                      if (Object.getPrototypeOf(e) !== Object.prototype) return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Entrada inv\xe1lida: se esperaba ${tT(r.values[0])}`;
                return `Opci\xf3n inv\xe1lida: se esperaba una de ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Demasiado grande: se esperaba que ${r.origin ?? 'valor'} tuviera ${t}${r.maximum.toString()} ${n.unit ?? 'elementos'}`;
                return `Demasiado grande: se esperaba que ${r.origin ?? 'valor'} fuera ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Demasiado peque\xf1o: se esperaba que ${r.origin} tuviera ${t}${r.minimum.toString()} ${n.unit}`;
                return `Demasiado peque\xf1o: se esperaba que ${r.origin} fuera ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Cadena inv\xe1lida: debe comenzar con "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Cadena inv\xe1lida: debe terminar en "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Cadena inv\xe1lida: debe incluir "${r.includes}"`;
                if ('regex' === r.format)
                  return `Cadena inv\xe1lida: debe coincidir con el patr\xf3n ${r.pattern}`;
                return `Inv\xe1lido ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe1lido: debe ser m\xfaltiplo de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Llave${r.keys.length > 1 ? 's' : ''} desconocida${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Llave inv\xe1lida en ${r.origin}`;
              case 'invalid_union':
                return 'Entrada inválida';
              case 'invalid_element':
                return `Valor inv\xe1lido en ${r.origin}`;
              default:
                return `Entrada inv\xe1lida`;
            }
          };
        })(),
      };
    }
    function aE() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'کاراکتر', verb: 'داشته باشد' },
              file: { unit: 'بایت', verb: 'داشته باشد' },
              array: { unit: 'آیتم', verb: 'داشته باشد' },
              set: { unit: 'آیتم', verb: 'داشته باشد' },
            },
            t = {
              regex: 'ورودی',
              email: 'آدرس ایمیل',
              url: 'URL',
              emoji: 'ایموجی',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'تاریخ و زمان ایزو',
              date: 'تاریخ ایزو',
              time: 'زمان ایزو',
              duration: 'مدت زمان ایزو',
              ipv4: 'IPv4 آدرس',
              ipv6: 'IPv6 آدرس',
              cidrv4: 'IPv4 دامنه',
              cidrv6: 'IPv6 دامنه',
              base64: 'base64-encoded رشته',
              base64url: 'base64url-encoded رشته',
              json_string: 'JSON رشته',
              e164: 'E.164 عدد',
              jwt: 'JWT',
              template_literal: 'ورودی',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `ورودی نامعتبر: می‌بایست ${r.expected} می‌بود، ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'عدد';
                    case 'object':
                      if (Array.isArray(e)) return 'آرایه';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)} دریافت شد`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `ورودی نامعتبر: می‌بایست ${tT(r.values[0])} می‌بود`;
                return `گزینه نامعتبر: می‌بایست یکی از ${tn(r.values, '|')} می‌بود`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `خیلی بزرگ: ${r.origin ?? 'مقدار'} باید ${t}${r.maximum.toString()} ${n.unit ?? 'عنصر'} باشد`;
                return `خیلی بزرگ: ${r.origin ?? 'مقدار'} باید ${t}${r.maximum.toString()} باشد`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `خیلی کوچک: ${r.origin} باید ${t}${r.minimum.toString()} ${n.unit} باشد`;
                return `خیلی کوچک: ${r.origin} باید ${t}${r.minimum.toString()} باشد`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `رشته نامعتبر: باید با "${r.prefix}" شروع شود`;
                if ('ends_with' === r.format) return `رشته نامعتبر: باید با "${r.suffix}" تمام شود`;
                if ('includes' === r.format) return `رشته نامعتبر: باید شامل "${r.includes}" باشد`;
                if ('regex' === r.format)
                  return `رشته نامعتبر: باید با الگوی ${r.pattern} مطابقت داشته باشد`;
                return `${t[r.format] ?? r.format} نامعتبر`;
              case 'not_multiple_of':
                return `عدد نامعتبر: باید مضرب ${r.divisor} باشد`;
              case 'unrecognized_keys':
                return `کلید${r.keys.length > 1 ? 'های' : ''} ناشناس: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `کلید ناشناس در ${r.origin}`;
              case 'invalid_union':
              default:
                return `ورودی نامعتبر`;
              case 'invalid_element':
                return `مقدار نامعتبر در ${r.origin}`;
            }
          };
        })(),
      };
    }
    function ak() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'merkkiä', subject: 'merkkijonon' },
              file: { unit: 'tavua', subject: 'tiedoston' },
              array: { unit: 'alkiota', subject: 'listan' },
              set: { unit: 'alkiota', subject: 'joukon' },
              number: { unit: '', subject: 'luvun' },
              bigint: { unit: '', subject: 'suuren kokonaisluvun' },
              int: { unit: '', subject: 'kokonaisluvun' },
              date: { unit: '', subject: 'päivämäärän' },
            },
            t = {
              regex: 'säännöllinen lauseke',
              email: 'sähköpostiosoite',
              url: 'URL-osoite',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-aikaleima',
              date: 'ISO-päivämäärä',
              time: 'ISO-aika',
              duration: 'ISO-kesto',
              ipv4: 'IPv4-osoite',
              ipv6: 'IPv6-osoite',
              cidrv4: 'IPv4-alue',
              cidrv6: 'IPv6-alue',
              base64: 'base64-koodattu merkkijono',
              base64url: 'base64url-koodattu merkkijono',
              json_string: 'JSON-merkkijono',
              e164: 'E.164-luku',
              jwt: 'JWT',
              template_literal: 'templaattimerkkijono',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Virheellinen tyyppi: odotettiin ${r.expected}, oli ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Virheellinen sy\xf6te: t\xe4ytyy olla ${tT(r.values[0])}`;
                return `Virheellinen valinta: t\xe4ytyy olla yksi seuraavista: ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Liian suuri: ${n.subject} t\xe4ytyy olla ${t}${r.maximum.toString()} ${n.unit}`.trim();
                return `Liian suuri: arvon t\xe4ytyy olla ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Liian pieni: ${n.subject} t\xe4ytyy olla ${t}${r.minimum.toString()} ${n.unit}`.trim();
                return `Liian pieni: arvon t\xe4ytyy olla ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy alkaa "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy loppua "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy sis\xe4lt\xe4\xe4 "${r.includes}"`;
                if ('regex' === r.format)
                  return `Virheellinen sy\xf6te: t\xe4ytyy vastata s\xe4\xe4nn\xf6llist\xe4 lauseketta ${r.pattern}`;
                return `Virheellinen ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Virheellinen luku: t\xe4ytyy olla luvun ${r.divisor} monikerta`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Tuntemattomat avaimet' : 'Tuntematon avain'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return 'Virheellinen avain tietueessa';
              case 'invalid_union':
                return 'Virheellinen unioni';
              case 'invalid_element':
                return 'Virheellinen arvo joukossa';
              default:
                return `Virheellinen sy\xf6te`;
            }
          };
        })(),
      };
    }
    function aI() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caractères', verb: 'avoir' },
              file: { unit: 'octets', verb: 'avoir' },
              array: { unit: 'éléments', verb: 'avoir' },
              set: { unit: 'éléments', verb: 'avoir' },
            },
            t = {
              regex: 'entrée',
              email: 'adresse e-mail',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'date et heure ISO',
              date: 'date ISO',
              time: 'heure ISO',
              duration: 'durée ISO',
              ipv4: 'adresse IPv4',
              ipv6: 'adresse IPv6',
              cidrv4: 'plage IPv4',
              cidrv6: 'plage IPv6',
              base64: 'chaîne encodée en base64',
              base64url: 'chaîne encodée en base64url',
              json_string: 'chaîne JSON',
              e164: 'numéro E.164',
              jwt: 'JWT',
              template_literal: 'entrée',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Entr\xe9e invalide : ${r.expected} attendu, ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombre';
                    case 'object':
                      if (Array.isArray(e)) return 'tableau';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)} re\xe7u`;
              case 'invalid_value':
                if (1 === r.values.length) return `Entr\xe9e invalide : ${tT(r.values[0])} attendu`;
                return `Option invalide : une valeur parmi ${tn(r.values, '|')} attendue`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Trop grand : ${r.origin ?? 'valeur'} doit ${n.verb} ${t}${r.maximum.toString()} ${n.unit ?? 'élément(s)'}`;
                return `Trop grand : ${r.origin ?? 'valeur'} doit \xeatre ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Trop petit : ${r.origin} doit ${n.verb} ${t}${r.minimum.toString()} ${n.unit}`;
                return `Trop petit : ${r.origin} doit \xeatre ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Cha\xeene invalide : doit commencer par "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Cha\xeene invalide : doit se terminer par "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Cha\xeene invalide : doit inclure "${r.includes}"`;
                if ('regex' === r.format)
                  return `Cha\xeene invalide : doit correspondre au mod\xe8le ${r.pattern}`;
                return `${t[r.format] ?? r.format} invalide`;
              case 'not_multiple_of':
                return `Nombre invalide : doit \xeatre un multiple de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Cl\xe9${r.keys.length > 1 ? 's' : ''} non reconnue${r.keys.length > 1 ? 's' : ''} : ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Cl\xe9 invalide dans ${r.origin}`;
              case 'invalid_union':
                return 'Entrée invalide';
              case 'invalid_element':
                return `Valeur invalide dans ${r.origin}`;
              default:
                return `Entr\xe9e invalide`;
            }
          };
        })(),
      };
    }
    function aP() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caractères', verb: 'avoir' },
              file: { unit: 'octets', verb: 'avoir' },
              array: { unit: 'éléments', verb: 'avoir' },
              set: { unit: 'éléments', verb: 'avoir' },
            },
            t = {
              regex: 'entrée',
              email: 'adresse courriel',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'date-heure ISO',
              date: 'date ISO',
              time: 'heure ISO',
              duration: 'durée ISO',
              ipv4: 'adresse IPv4',
              ipv6: 'adresse IPv6',
              cidrv4: 'plage IPv4',
              cidrv6: 'plage IPv6',
              base64: 'chaîne encodée en base64',
              base64url: 'chaîne encodée en base64url',
              json_string: 'chaîne JSON',
              e164: 'numéro E.164',
              jwt: 'JWT',
              template_literal: 'entrée',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Entr\xe9e invalide : attendu ${r.expected}, re\xe7u ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Entr\xe9e invalide : attendu ${tT(r.values[0])}`;
                return `Option invalide : attendu l'une des valeurs suivantes ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '≤' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Trop grand : attendu que ${r.origin ?? 'la valeur'} ait ${t}${r.maximum.toString()} ${n.unit}`;
                return `Trop grand : attendu que ${r.origin ?? 'la valeur'} soit ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '≥' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Trop petit : attendu que ${r.origin} ait ${t}${r.minimum.toString()} ${n.unit}`;
                return `Trop petit : attendu que ${r.origin} soit ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Cha\xeene invalide : doit commencer par "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Cha\xeene invalide : doit se terminer par "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Cha\xeene invalide : doit inclure "${r.includes}"`;
                if ('regex' === r.format)
                  return `Cha\xeene invalide : doit correspondre au motif ${r.pattern}`;
                return `${t[r.format] ?? r.format} invalide`;
              case 'not_multiple_of':
                return `Nombre invalide : doit \xeatre un multiple de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Cl\xe9${r.keys.length > 1 ? 's' : ''} non reconnue${r.keys.length > 1 ? 's' : ''} : ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Cl\xe9 invalide dans ${r.origin}`;
              case 'invalid_union':
                return 'Entrée invalide';
              case 'invalid_element':
                return `Valeur invalide dans ${r.origin}`;
              default:
                return `Entr\xe9e invalide`;
            }
          };
        })(),
      };
    }
    function aN() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'אותיות', verb: 'לכלול' },
              file: { unit: 'בייטים', verb: 'לכלול' },
              array: { unit: 'פריטים', verb: 'לכלול' },
              set: { unit: 'פריטים', verb: 'לכלול' },
            },
            t = {
              regex: 'קלט',
              email: 'כתובת אימייל',
              url: 'כתובת רשת',
              emoji: "אימוג'י",
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'תאריך וזמן ISO',
              date: 'תאריך ISO',
              time: 'זמן ISO',
              duration: 'משך זמן ISO',
              ipv4: 'כתובת IPv4',
              ipv6: 'כתובת IPv6',
              cidrv4: 'טווח IPv4',
              cidrv6: 'טווח IPv6',
              base64: 'מחרוזת בבסיס 64',
              base64url: 'מחרוזת בבסיס 64 לכתובות רשת',
              json_string: 'מחרוזת JSON',
              e164: 'מספר E.164',
              jwt: 'JWT',
              template_literal: 'קלט',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `קלט לא תקין: צריך ${r.expected}, התקבל ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `קלט לא תקין: צריך ${tT(r.values[0])}`;
                return `קלט לא תקין: צריך אחת מהאפשרויות  ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `גדול מדי: ${r.origin ?? 'value'} צריך להיות ${t}${r.maximum.toString()} ${n.unit ?? 'elements'}`;
                return `גדול מדי: ${r.origin ?? 'value'} צריך להיות ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `קטן מדי: ${r.origin} צריך להיות ${t}${r.minimum.toString()} ${n.unit}`;
                return `קטן מדי: ${r.origin} צריך להיות ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `מחרוזת לא תקינה: חייבת להתחיל ב"${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `מחרוזת לא תקינה: חייבת להסתיים ב "${r.suffix}"`;
                if ('includes' === r.format) return `מחרוזת לא תקינה: חייבת לכלול "${r.includes}"`;
                if ('regex' === r.format)
                  return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${r.pattern}`;
                return `${t[r.format] ?? r.format} לא תקין`;
              case 'not_multiple_of':
                return `מספר לא תקין: חייב להיות מכפלה של ${r.divisor}`;
              case 'unrecognized_keys':
                return `מפתח${r.keys.length > 1 ? 'ות' : ''} לא מזוה${r.keys.length > 1 ? 'ים' : 'ה'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `מפתח לא תקין ב${r.origin}`;
              case 'invalid_union':
                return 'קלט לא תקין';
              case 'invalid_element':
                return `ערך לא תקין ב${r.origin}`;
              default:
                return `קלט לא תקין`;
            }
          };
        })(),
      };
    }
    function aR() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'legyen' },
              file: { unit: 'byte', verb: 'legyen' },
              array: { unit: 'elem', verb: 'legyen' },
              set: { unit: 'elem', verb: 'legyen' },
            },
            t = {
              regex: 'bemenet',
              email: 'email cím',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO időbélyeg',
              date: 'ISO dátum',
              time: 'ISO idő',
              duration: 'ISO időintervallum',
              ipv4: 'IPv4 cím',
              ipv6: 'IPv6 cím',
              cidrv4: 'IPv4 tartomány',
              cidrv6: 'IPv6 tartomány',
              base64: 'base64-kódolt string',
              base64url: 'base64url-kódolt string',
              json_string: 'JSON string',
              e164: 'E.164 szám',
              jwt: 'JWT',
              template_literal: 'bemenet',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `\xc9rv\xe9nytelen bemenet: a v\xe1rt \xe9rt\xe9k ${r.expected}, a kapott \xe9rt\xe9k ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'szám';
                    case 'object':
                      if (Array.isArray(e)) return 'tömb';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `\xc9rv\xe9nytelen bemenet: a v\xe1rt \xe9rt\xe9k ${tT(r.values[0])}`;
                return `\xc9rv\xe9nytelen opci\xf3: valamelyik \xe9rt\xe9k v\xe1rt ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `T\xfal nagy: ${r.origin ?? 'érték'} m\xe9rete t\xfal nagy ${t}${r.maximum.toString()} ${n.unit ?? 'elem'}`;
                return `T\xfal nagy: a bemeneti \xe9rt\xe9k ${r.origin ?? 'érték'} t\xfal nagy: ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `T\xfal kicsi: a bemeneti \xe9rt\xe9k ${r.origin} m\xe9rete t\xfal kicsi ${t}${r.minimum.toString()} ${n.unit}`;
                return `T\xfal kicsi: a bemeneti \xe9rt\xe9k ${r.origin} t\xfal kicsi ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `\xc9rv\xe9nytelen string: "${r.prefix}" \xe9rt\xe9kkel kell kezdődnie`;
                if ('ends_with' === r.format)
                  return `\xc9rv\xe9nytelen string: "${r.suffix}" \xe9rt\xe9kkel kell v\xe9gződnie`;
                if ('includes' === r.format)
                  return `\xc9rv\xe9nytelen string: "${r.includes}" \xe9rt\xe9ket kell tartalmaznia`;
                if ('regex' === r.format)
                  return `\xc9rv\xe9nytelen string: ${r.pattern} mint\xe1nak kell megfelelnie`;
                return `\xc9rv\xe9nytelen ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `\xc9rv\xe9nytelen sz\xe1m: ${r.divisor} t\xf6bbsz\xf6r\xf6s\xe9nek kell lennie`;
              case 'unrecognized_keys':
                return `Ismeretlen kulcs${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `\xc9rv\xe9nytelen kulcs ${r.origin}`;
              case 'invalid_union':
                return 'Érvénytelen bemenet';
              case 'invalid_element':
                return `\xc9rv\xe9nytelen \xe9rt\xe9k: ${r.origin}`;
              default:
                return `\xc9rv\xe9nytelen bemenet`;
            }
          };
        })(),
      };
    }
    function aT() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'memiliki' },
              file: { unit: 'byte', verb: 'memiliki' },
              array: { unit: 'item', verb: 'memiliki' },
              set: { unit: 'item', verb: 'memiliki' },
            },
            t = {
              regex: 'input',
              email: 'alamat email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'tanggal dan waktu format ISO',
              date: 'tanggal format ISO',
              time: 'jam format ISO',
              duration: 'durasi format ISO',
              ipv4: 'alamat IPv4',
              ipv6: 'alamat IPv6',
              cidrv4: 'rentang alamat IPv4',
              cidrv6: 'rentang alamat IPv6',
              base64: 'string dengan enkode base64',
              base64url: 'string dengan enkode base64url',
              json_string: 'string JSON',
              e164: 'angka E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Input tidak valid: diharapkan ${r.expected}, diterima ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Input tidak valid: diharapkan ${tT(r.values[0])}`;
                return `Pilihan tidak valid: diharapkan salah satu dari ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Terlalu besar: diharapkan ${r.origin ?? 'value'} memiliki ${t}${r.maximum.toString()} ${n.unit ?? 'elemen'}`;
                return `Terlalu besar: diharapkan ${r.origin ?? 'value'} menjadi ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Terlalu kecil: diharapkan ${r.origin} memiliki ${t}${r.minimum.toString()} ${n.unit}`;
                return `Terlalu kecil: diharapkan ${r.origin} menjadi ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `String tidak valid: harus dimulai dengan "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `String tidak valid: harus berakhir dengan "${r.suffix}"`;
                if ('includes' === r.format)
                  return `String tidak valid: harus menyertakan "${r.includes}"`;
                if ('regex' === r.format)
                  return `String tidak valid: harus sesuai pola ${r.pattern}`;
                return `${t[r.format] ?? r.format} tidak valid`;
              case 'not_multiple_of':
                return `Angka tidak valid: harus kelipatan dari ${r.divisor}`;
              case 'unrecognized_keys':
                return `Kunci tidak dikenali ${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Kunci tidak valid di ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Input tidak valid';
              case 'invalid_element':
                return `Nilai tidak valid di ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aj() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'stafi', verb: 'að hafa' },
              file: { unit: 'bæti', verb: 'að hafa' },
              array: { unit: 'hluti', verb: 'að hafa' },
              set: { unit: 'hluti', verb: 'að hafa' },
            },
            t = {
              regex: 'gildi',
              email: 'netfang',
              url: 'vefslóð',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dagsetning og tími',
              date: 'ISO dagsetning',
              time: 'ISO tími',
              duration: 'ISO tímalengd',
              ipv4: 'IPv4 address',
              ipv6: 'IPv6 address',
              cidrv4: 'IPv4 range',
              cidrv6: 'IPv6 range',
              base64: 'base64-encoded strengur',
              base64url: 'base64url-encoded strengur',
              json_string: 'JSON strengur',
              e164: 'E.164 tölugildi',
              jwt: 'JWT',
              template_literal: 'gildi',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Rangt gildi: \xde\xfa sl\xf3st inn ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'númer';
                    case 'object':
                      if (Array.isArray(e)) return 'fylki';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)} \xfear sem \xe1 a\xf0 vera ${r.expected}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Rangt gildi: gert r\xe1\xf0 fyrir ${tT(r.values[0])}`;
                return `\xd3gilt val: m\xe1 vera eitt af eftirfarandi ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Of st\xf3rt: gert er r\xe1\xf0 fyrir a\xf0 ${r.origin ?? 'gildi'} hafi ${t}${r.maximum.toString()} ${n.unit ?? 'hluti'}`;
                return `Of st\xf3rt: gert er r\xe1\xf0 fyrir a\xf0 ${r.origin ?? 'gildi'} s\xe9 ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Of l\xedti\xf0: gert er r\xe1\xf0 fyrir a\xf0 ${r.origin} hafi ${t}${r.minimum.toString()} ${n.unit}`;
                return `Of l\xedti\xf0: gert er r\xe1\xf0 fyrir a\xf0 ${r.origin} s\xe9 ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 byrja \xe1 "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 enda \xe1 "${r.suffix}"`;
                if ('includes' === r.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 innihalda "${r.includes}"`;
                if ('regex' === r.format)
                  return `\xd3gildur strengur: ver\xf0ur a\xf0 fylgja mynstri ${r.pattern}`;
                return `Rangt ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `R\xf6ng tala: ver\xf0ur a\xf0 vera margfeldi af ${r.divisor}`;
              case 'unrecognized_keys':
                return `\xd3\xfeekkt ${r.keys.length > 1 ? 'ir lyklar' : 'ur lykill'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Rangur lykill \xed ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Rangt gildi';
              case 'invalid_element':
                return `Rangt gildi \xed ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aA() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caratteri', verb: 'avere' },
              file: { unit: 'byte', verb: 'avere' },
              array: { unit: 'elementi', verb: 'avere' },
              set: { unit: 'elementi', verb: 'avere' },
            },
            t = {
              regex: 'input',
              email: 'indirizzo email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data e ora ISO',
              date: 'data ISO',
              time: 'ora ISO',
              duration: 'durata ISO',
              ipv4: 'indirizzo IPv4',
              ipv6: 'indirizzo IPv6',
              cidrv4: 'intervallo IPv4',
              cidrv6: 'intervallo IPv6',
              base64: 'stringa codificata in base64',
              base64url: 'URL codificata in base64',
              json_string: 'stringa JSON',
              e164: 'numero E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Input non valido: atteso ${r.expected}, ricevuto ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'numero';
                    case 'object':
                      if (Array.isArray(e)) return 'vettore';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Input non valido: atteso ${tT(r.values[0])}`;
                return `Opzione non valida: atteso uno tra ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Troppo grande: ${r.origin ?? 'valore'} deve avere ${t}${r.maximum.toString()} ${n.unit ?? 'elementi'}`;
                return `Troppo grande: ${r.origin ?? 'valore'} deve essere ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Troppo piccolo: ${r.origin} deve avere ${t}${r.minimum.toString()} ${n.unit}`;
                return `Troppo piccolo: ${r.origin} deve essere ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Stringa non valida: deve iniziare con "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Stringa non valida: deve terminare con "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Stringa non valida: deve includere "${r.includes}"`;
                if ('regex' === r.format)
                  return `Stringa non valida: deve corrispondere al pattern ${r.pattern}`;
                return `Invalid ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Numero non valido: deve essere un multiplo di ${r.divisor}`;
              case 'unrecognized_keys':
                return `Chiav${r.keys.length > 1 ? 'i' : 'e'} non riconosciut${r.keys.length > 1 ? 'e' : 'a'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Chiave non valida in ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Input non valido';
              case 'invalid_element':
                return `Valore non valido in ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aD() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '文字', verb: 'である' },
              file: { unit: 'バイト', verb: 'である' },
              array: { unit: '要素', verb: 'である' },
              set: { unit: '要素', verb: 'である' },
            },
            t = {
              regex: '入力値',
              email: 'メールアドレス',
              url: 'URL',
              emoji: '絵文字',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO日時',
              date: 'ISO日付',
              time: 'ISO時刻',
              duration: 'ISO期間',
              ipv4: 'IPv4アドレス',
              ipv6: 'IPv6アドレス',
              cidrv4: 'IPv4範囲',
              cidrv6: 'IPv6範囲',
              base64: 'base64エンコード文字列',
              base64url: 'base64urlエンコード文字列',
              json_string: 'JSON文字列',
              e164: 'E.164番号',
              jwt: 'JWT',
              template_literal: '入力値',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `無効な入力: ${r.expected}が期待されましたが、${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : '数値';
                    case 'object':
                      if (Array.isArray(e)) return '配列';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}が入力されました`;
              case 'invalid_value':
                if (1 === r.values.length) return `無効な入力: ${tT(r.values[0])}が期待されました`;
                return `無効な選択: ${tn(r.values, '、')}のいずれかである必要があります`;
              case 'too_big': {
                let t = r.inclusive ? '以下である' : 'より小さい',
                  n = e[r.origin] ?? null;
                if (n)
                  return `大きすぎる値: ${r.origin ?? '値'}は${r.maximum.toString()}${n.unit ?? '要素'}${t}必要があります`;
                return `大きすぎる値: ${r.origin ?? '値'}は${r.maximum.toString()}${t}必要があります`;
              }
              case 'too_small': {
                let t = r.inclusive ? '以上である' : 'より大きい',
                  n = e[r.origin] ?? null;
                if (n)
                  return `小さすぎる値: ${r.origin}は${r.minimum.toString()}${n.unit}${t}必要があります`;
                return `小さすぎる値: ${r.origin}は${r.minimum.toString()}${t}必要があります`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `無効な文字列: "${r.prefix}"で始まる必要があります`;
                if ('ends_with' === r.format)
                  return `無効な文字列: "${r.suffix}"で終わる必要があります`;
                if ('includes' === r.format)
                  return `無効な文字列: "${r.includes}"を含む必要があります`;
                if ('regex' === r.format)
                  return `無効な文字列: パターン${r.pattern}に一致する必要があります`;
                return `無効な${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `無効な数値: ${r.divisor}の倍数である必要があります`;
              case 'unrecognized_keys':
                return `認識されていないキー${r.keys.length > 1 ? '群' : ''}: ${tn(r.keys, '、')}`;
              case 'invalid_key':
                return `${r.origin}内の無効なキー`;
              case 'invalid_union':
                return '無効な入力';
              case 'invalid_element':
                return `${r.origin}内の無効な値`;
              default:
                return `無効な入力`;
            }
          };
        })(),
      };
    }
    function aU() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'តួអក្សរ', verb: 'គួរមាន' },
              file: { unit: 'បៃ', verb: 'គួរមាន' },
              array: { unit: 'ធាតុ', verb: 'គួរមាន' },
              set: { unit: 'ធាតុ', verb: 'គួរមាន' },
            },
            t = {
              regex: 'ទិន្នន័យបញ្ចូល',
              email: 'អាសយដ្ឋានអ៊ីមែល',
              url: 'URL',
              emoji: 'សញ្ញាអារម្មណ៍',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'កាលបរិច្ឆេទ និងម៉ោង ISO',
              date: 'កាលបរិច្ឆេទ ISO',
              time: 'ម៉ោង ISO',
              duration: 'រយៈពេល ISO',
              ipv4: 'អាសយដ្ឋាន IPv4',
              ipv6: 'អាសយដ្ឋាន IPv6',
              cidrv4: 'ដែនអាសយដ្ឋាន IPv4',
              cidrv6: 'ដែនអាសយដ្ឋាន IPv6',
              base64: 'ខ្សែអក្សរអ៊ិកូដ base64',
              base64url: 'ខ្សែអក្សរអ៊ិកូដ base64url',
              json_string: 'ខ្សែអក្សរ JSON',
              e164: 'លេខ E.164',
              jwt: 'JWT',
              template_literal: 'ទិន្នន័យបញ្ចូល',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${r.expected} ប៉ុន្តែទទួលបាន ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'មិនមែនជាលេខ (NaN)' : 'លេខ';
                    case 'object':
                      if (Array.isArray(e)) return 'អារេ (Array)';
                      if (null === e) return 'គ្មានតម្លៃ (null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${tT(r.values[0])}`;
                return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `ធំពេក៖ ត្រូវការ ${r.origin ?? 'តម្លៃ'} ${t} ${r.maximum.toString()} ${n.unit ?? 'ធាតុ'}`;
                return `ធំពេក៖ ត្រូវការ ${r.origin ?? 'តម្លៃ'} ${t} ${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n) return `តូចពេក៖ ត្រូវការ ${r.origin} ${t} ${r.minimum.toString()} ${n.unit}`;
                return `តូចពេក៖ ត្រូវការ ${r.origin} ${t} ${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${r.suffix}"`;
                if ('includes' === r.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${r.includes}"`;
                if ('regex' === r.format)
                  return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${r.pattern}`;
                return `មិនត្រឹមត្រូវ៖ ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${r.divisor}`;
              case 'unrecognized_keys':
                return `រកឃើញសោមិនស្គាល់៖ ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `សោមិនត្រឹមត្រូវនៅក្នុង ${r.origin}`;
              case 'invalid_union':
              default:
                return `ទិន្នន័យមិនត្រឹមត្រូវ`;
              case 'invalid_element':
                return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${r.origin}`;
            }
          };
        })(),
      };
    }
    function az() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '문자', verb: 'to have' },
              file: { unit: '바이트', verb: 'to have' },
              array: { unit: '개', verb: 'to have' },
              set: { unit: '개', verb: 'to have' },
            },
            t = {
              regex: '입력',
              email: '이메일 주소',
              url: 'URL',
              emoji: '이모지',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO 날짜시간',
              date: 'ISO 날짜',
              time: 'ISO 시간',
              duration: 'ISO 기간',
              ipv4: 'IPv4 주소',
              ipv6: 'IPv6 주소',
              cidrv4: 'IPv4 범위',
              cidrv6: 'IPv6 범위',
              base64: 'base64 인코딩 문자열',
              base64url: 'base64url 인코딩 문자열',
              json_string: 'JSON 문자열',
              e164: 'E.164 번호',
              jwt: 'JWT',
              template_literal: '입력',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `잘못된 입력: 예상 타입은 ${r.expected}, 받은 타입은 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}입니다`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `잘못된 입력: 값은 ${tT(r.values[0])} 이어야 합니다`;
                return `잘못된 옵션: ${tn(r.values, '또는 ')} 중 하나여야 합니다`;
              case 'too_big': {
                let t = r.inclusive ? '이하' : '미만',
                  n = '미만' === t ? '이어야 합니다' : '여야 합니다',
                  i = e[r.origin] ?? null,
                  a = i?.unit ?? '요소';
                if (i)
                  return `${r.origin ?? '값'}이 너무 큽니다: ${r.maximum.toString()}${a} ${t}${n}`;
                return `${r.origin ?? '값'}이 너무 큽니다: ${r.maximum.toString()} ${t}${n}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '이상' : '초과',
                  n = '이상' === t ? '이어야 합니다' : '여야 합니다',
                  i = e[r.origin] ?? null,
                  a = i?.unit ?? '요소';
                if (i)
                  return `${r.origin ?? '값'}이 너무 작습니다: ${r.minimum.toString()}${a} ${t}${n}`;
                return `${r.origin ?? '값'}이 너무 작습니다: ${r.minimum.toString()} ${t}${n}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `잘못된 문자열: "${r.prefix}"(으)로 시작해야 합니다`;
                if ('ends_with' === r.format)
                  return `잘못된 문자열: "${r.suffix}"(으)로 끝나야 합니다`;
                if ('includes' === r.format)
                  return `잘못된 문자열: "${r.includes}"을(를) 포함해야 합니다`;
                if ('regex' === r.format)
                  return `잘못된 문자열: 정규식 ${r.pattern} 패턴과 일치해야 합니다`;
                return `잘못된 ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `잘못된 숫자: ${r.divisor}의 배수여야 합니다`;
              case 'unrecognized_keys':
                return `인식할 수 없는 키: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `잘못된 키: ${r.origin}`;
              case 'invalid_union':
              default:
                return `잘못된 입력`;
              case 'invalid_element':
                return `잘못된 값: ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aC() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'знаци', verb: 'да имаат' },
              file: { unit: 'бајти', verb: 'да имаат' },
              array: { unit: 'ставки', verb: 'да имаат' },
              set: { unit: 'ставки', verb: 'да имаат' },
            },
            t = {
              regex: 'внес',
              email: 'адреса на е-пошта',
              url: 'URL',
              emoji: 'емоџи',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO датум и време',
              date: 'ISO датум',
              time: 'ISO време',
              duration: 'ISO времетраење',
              ipv4: 'IPv4 адреса',
              ipv6: 'IPv6 адреса',
              cidrv4: 'IPv4 опсег',
              cidrv6: 'IPv6 опсег',
              base64: 'base64-енкодирана низа',
              base64url: 'base64url-енкодирана низа',
              json_string: 'JSON низа',
              e164: 'E.164 број',
              jwt: 'JWT',
              template_literal: 'внес',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Грешен внес: се очекува ${r.expected}, примено ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'број';
                    case 'object':
                      if (Array.isArray(e)) return 'низа';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Invalid input: expected ${tT(r.values[0])}`;
                return `Грешана опција: се очекува една ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Премногу голем: се очекува ${r.origin ?? 'вредноста'} да има ${t}${r.maximum.toString()} ${n.unit ?? 'елементи'}`;
                return `Премногу голем: се очекува ${r.origin ?? 'вредноста'} да биде ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Премногу мал: се очекува ${r.origin} да има ${t}${r.minimum.toString()} ${n.unit}`;
                return `Премногу мал: се очекува ${r.origin} да биде ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Неважечка низа: мора да започнува со "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Неважечка низа: мора да завршува со "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Неважечка низа: мора да вклучува "${r.includes}"`;
                if ('regex' === r.format)
                  return `Неважечка низа: мора да одгоара на патернот ${r.pattern}`;
                return `Invalid ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Грешен број: мора да биде делив со ${r.divisor}`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Непрепознаени клучеви' : 'Непрепознаен клуч'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Грешен клуч во ${r.origin}`;
              case 'invalid_union':
                return 'Грешен внес';
              case 'invalid_element':
                return `Грешна вредност во ${r.origin}`;
              default:
                return `Грешен внес`;
            }
          };
        })(),
      };
    }
    function aZ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'aksara', verb: 'mempunyai' },
              file: { unit: 'bait', verb: 'mempunyai' },
              array: { unit: 'elemen', verb: 'mempunyai' },
              set: { unit: 'elemen', verb: 'mempunyai' },
            },
            t = {
              regex: 'input',
              email: 'alamat e-mel',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'tarikh masa ISO',
              date: 'tarikh ISO',
              time: 'masa ISO',
              duration: 'tempoh ISO',
              ipv4: 'alamat IPv4',
              ipv6: 'alamat IPv6',
              cidrv4: 'julat IPv4',
              cidrv6: 'julat IPv6',
              base64: 'string dikodkan base64',
              base64url: 'string dikodkan base64url',
              json_string: 'string JSON',
              e164: 'nombor E.164',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Input tidak sah: dijangka ${r.expected}, diterima ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nombor';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Input tidak sah: dijangka ${tT(r.values[0])}`;
                return `Pilihan tidak sah: dijangka salah satu daripada ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Terlalu besar: dijangka ${r.origin ?? 'nilai'} ${n.verb} ${t}${r.maximum.toString()} ${n.unit ?? 'elemen'}`;
                return `Terlalu besar: dijangka ${r.origin ?? 'nilai'} adalah ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Terlalu kecil: dijangka ${r.origin} ${n.verb} ${t}${r.minimum.toString()} ${n.unit}`;
                return `Terlalu kecil: dijangka ${r.origin} adalah ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `String tidak sah: mesti bermula dengan "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `String tidak sah: mesti berakhir dengan "${r.suffix}"`;
                if ('includes' === r.format)
                  return `String tidak sah: mesti mengandungi "${r.includes}"`;
                if ('regex' === r.format)
                  return `String tidak sah: mesti sepadan dengan corak ${r.pattern}`;
                return `${t[r.format] ?? r.format} tidak sah`;
              case 'not_multiple_of':
                return `Nombor tidak sah: perlu gandaan ${r.divisor}`;
              case 'unrecognized_keys':
                return `Kunci tidak dikenali: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Kunci tidak sah dalam ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Input tidak sah';
              case 'invalid_element':
                return `Nilai tidak sah dalam ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aL() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tekens' },
              file: { unit: 'bytes' },
              array: { unit: 'elementen' },
              set: { unit: 'elementen' },
            },
            t = {
              regex: 'invoer',
              email: 'emailadres',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datum en tijd',
              date: 'ISO datum',
              time: 'ISO tijd',
              duration: 'ISO duur',
              ipv4: 'IPv4-adres',
              ipv6: 'IPv6-adres',
              cidrv4: 'IPv4-bereik',
              cidrv6: 'IPv6-bereik',
              base64: 'base64-gecodeerde tekst',
              base64url: 'base64 URL-gecodeerde tekst',
              json_string: 'JSON string',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'invoer',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Ongeldige invoer: verwacht ${r.expected}, ontving ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'getal';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Ongeldige invoer: verwacht ${tT(r.values[0])}`;
                return `Ongeldige optie: verwacht \xe9\xe9n van ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Te lang: verwacht dat ${r.origin ?? 'waarde'} ${t}${r.maximum.toString()} ${n.unit ?? 'elementen'} bevat`;
                return `Te lang: verwacht dat ${r.origin ?? 'waarde'} ${t}${r.maximum.toString()} is`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Te kort: verwacht dat ${r.origin} ${t}${r.minimum.toString()} ${n.unit} bevat`;
                return `Te kort: verwacht dat ${r.origin} ${t}${r.minimum.toString()} is`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ongeldige tekst: moet met "${r.prefix}" beginnen`;
                if ('ends_with' === r.format)
                  return `Ongeldige tekst: moet op "${r.suffix}" eindigen`;
                if ('includes' === r.format)
                  return `Ongeldige tekst: moet "${r.includes}" bevatten`;
                if ('regex' === r.format)
                  return `Ongeldige tekst: moet overeenkomen met patroon ${r.pattern}`;
                return `Ongeldig: ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ongeldig getal: moet een veelvoud van ${r.divisor} zijn`;
              case 'unrecognized_keys':
                return `Onbekende key${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Ongeldige key in ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Ongeldige invoer';
              case 'invalid_element':
                return `Ongeldige waarde in ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aM() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tegn', verb: 'å ha' },
              file: { unit: 'bytes', verb: 'å ha' },
              array: { unit: 'elementer', verb: 'å inneholde' },
              set: { unit: 'elementer', verb: 'å inneholde' },
            },
            t = {
              regex: 'input',
              email: 'e-postadresse',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO dato- og klokkeslett',
              date: 'ISO-dato',
              time: 'ISO-klokkeslett',
              duration: 'ISO-varighet',
              ipv4: 'IPv4-område',
              ipv6: 'IPv6-område',
              cidrv4: 'IPv4-spekter',
              cidrv6: 'IPv6-spekter',
              base64: 'base64-enkodet streng',
              base64url: 'base64url-enkodet streng',
              json_string: 'JSON-streng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Ugyldig input: forventet ${r.expected}, fikk ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'tall';
                    case 'object':
                      if (Array.isArray(e)) return 'liste';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Ugyldig verdi: forventet ${tT(r.values[0])}`;
                return `Ugyldig valg: forventet en av ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `For stor(t): forventet ${r.origin ?? 'value'} til \xe5 ha ${t}${r.maximum.toString()} ${n.unit ?? 'elementer'}`;
                return `For stor(t): forventet ${r.origin ?? 'value'} til \xe5 ha ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `For lite(n): forventet ${r.origin} til \xe5 ha ${t}${r.minimum.toString()} ${n.unit}`;
                return `For lite(n): forventet ${r.origin} til \xe5 ha ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ugyldig streng: m\xe5 starte med "${r.prefix}"`;
                if ('ends_with' === r.format) return `Ugyldig streng: m\xe5 ende med "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Ugyldig streng: m\xe5 inneholde "${r.includes}"`;
                if ('regex' === r.format)
                  return `Ugyldig streng: m\xe5 matche m\xf8nsteret ${r.pattern}`;
                return `Ugyldig ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ugyldig tall: m\xe5 v\xe6re et multiplum av ${r.divisor}`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Ukjente nøkler' : 'Ukjent nøkkel'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Ugyldig n\xf8kkel i ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Ugyldig input';
              case 'invalid_element':
                return `Ugyldig verdi i ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aB() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'harf', verb: 'olmalıdır' },
              file: { unit: 'bayt', verb: 'olmalıdır' },
              array: { unit: 'unsur', verb: 'olmalıdır' },
              set: { unit: 'unsur', verb: 'olmalıdır' },
            },
            t = {
              regex: 'giren',
              email: 'epostagâh',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO hengâmı',
              date: 'ISO tarihi',
              time: 'ISO zamanı',
              duration: 'ISO müddeti',
              ipv4: 'IPv4 nişânı',
              ipv6: 'IPv6 nişânı',
              cidrv4: 'IPv4 menzili',
              cidrv6: 'IPv6 menzili',
              base64: 'base64-şifreli metin',
              base64url: 'base64url-şifreli metin',
              json_string: 'JSON metin',
              e164: 'E.164 sayısı',
              jwt: 'JWT',
              template_literal: 'giren',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `F\xe2sit giren: umulan ${r.expected}, alınan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'numara';
                    case 'object':
                      if (Array.isArray(e)) return 'saf';
                      if (null === e) return 'gayb';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `F\xe2sit giren: umulan ${tT(r.values[0])}`;
                return `F\xe2sit tercih: m\xfbteberler ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Fazla b\xfcy\xfck: ${r.origin ?? 'value'}, ${t}${r.maximum.toString()} ${n.unit ?? 'elements'} sahip olmalıydı.`;
                return `Fazla b\xfcy\xfck: ${r.origin ?? 'value'}, ${t}${r.maximum.toString()} olmalıydı.`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Fazla k\xfc\xe7\xfck: ${r.origin}, ${t}${r.minimum.toString()} ${n.unit} sahip olmalıydı.`;
                return `Fazla k\xfc\xe7\xfck: ${r.origin}, ${t}${r.minimum.toString()} olmalıydı.`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `F\xe2sit metin: "${r.prefix}" ile başlamalı.`;
                if ('ends_with' === r.format) return `F\xe2sit metin: "${r.suffix}" ile bitmeli.`;
                if ('includes' === r.format)
                  return `F\xe2sit metin: "${r.includes}" ihtiv\xe2 etmeli.`;
                if ('regex' === r.format) return `F\xe2sit metin: ${r.pattern} nakşına uymalı.`;
                return `F\xe2sit ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `F\xe2sit sayı: ${r.divisor} katı olmalıydı.`;
              case 'unrecognized_keys':
                return `Tanınmayan anahtar ${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `${r.origin} i\xe7in tanınmayan anahtar var.`;
              case 'invalid_union':
                return 'Giren tanınamadı.';
              case 'invalid_element':
                return `${r.origin} i\xe7in tanınmayan kıymet var.`;
              default:
                return `Kıymet tanınamadı.`;
            }
          };
        })(),
      };
    }
    function aF() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'توکي', verb: 'ولري' },
              file: { unit: 'بایټس', verb: 'ولري' },
              array: { unit: 'توکي', verb: 'ولري' },
              set: { unit: 'توکي', verb: 'ولري' },
            },
            t = {
              regex: 'ورودي',
              email: 'بریښنالیک',
              url: 'یو آر ال',
              emoji: 'ایموجي',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'نیټه او وخت',
              date: 'نېټه',
              time: 'وخت',
              duration: 'موده',
              ipv4: 'د IPv4 پته',
              ipv6: 'د IPv6 پته',
              cidrv4: 'د IPv4 ساحه',
              cidrv6: 'د IPv6 ساحه',
              base64: 'base64-encoded متن',
              base64url: 'base64url-encoded متن',
              json_string: 'JSON متن',
              e164: 'د E.164 شمېره',
              jwt: 'JWT',
              template_literal: 'ورودي',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `ناسم ورودي: باید ${r.expected} وای, مګر ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'عدد';
                    case 'object':
                      if (Array.isArray(e)) return 'ارې';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)} ترلاسه شو`;
              case 'invalid_value':
                if (1 === r.values.length) return `ناسم ورودي: باید ${tT(r.values[0])} وای`;
                return `ناسم انتخاب: باید یو له ${tn(r.values, '|')} څخه وای`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `ډیر لوی: ${r.origin ?? 'ارزښت'} باید ${t}${r.maximum.toString()} ${n.unit ?? 'عنصرونه'} ولري`;
                return `ډیر لوی: ${r.origin ?? 'ارزښت'} باید ${t}${r.maximum.toString()} وي`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `ډیر کوچنی: ${r.origin} باید ${t}${r.minimum.toString()} ${n.unit} ولري`;
                return `ډیر کوچنی: ${r.origin} باید ${t}${r.minimum.toString()} وي`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format) return `ناسم متن: باید د "${r.prefix}" سره پیل شي`;
                if ('ends_with' === r.format)
                  return `ناسم متن: باید د "${r.suffix}" سره پای ته ورسيږي`;
                if ('includes' === r.format) return `ناسم متن: باید "${r.includes}" ولري`;
                if ('regex' === r.format) return `ناسم متن: باید د ${r.pattern} سره مطابقت ولري`;
                return `${t[r.format] ?? r.format} ناسم دی`;
              case 'not_multiple_of':
                return `ناسم عدد: باید د ${r.divisor} مضرب وي`;
              case 'unrecognized_keys':
                return `ناسم ${r.keys.length > 1 ? 'کلیډونه' : 'کلیډ'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `ناسم کلیډ په ${r.origin} کې`;
              case 'invalid_union':
              default:
                return `ناسمه ورودي`;
              case 'invalid_element':
                return `ناسم عنصر په ${r.origin} کې`;
            }
          };
        })(),
      };
    }
    function aG() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znaków', verb: 'mieć' },
              file: { unit: 'bajtów', verb: 'mieć' },
              array: { unit: 'elementów', verb: 'mieć' },
              set: { unit: 'elementów', verb: 'mieć' },
            },
            t = {
              regex: 'wyrażenie',
              email: 'adres email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data i godzina w formacie ISO',
              date: 'data w formacie ISO',
              time: 'godzina w formacie ISO',
              duration: 'czas trwania ISO',
              ipv4: 'adres IPv4',
              ipv6: 'adres IPv6',
              cidrv4: 'zakres IPv4',
              cidrv6: 'zakres IPv6',
              base64: 'ciąg znaków zakodowany w formacie base64',
              base64url: 'ciąg znaków zakodowany w formacie base64url',
              json_string: 'ciąg znaków w formacie JSON',
              e164: 'liczba E.164',
              jwt: 'JWT',
              template_literal: 'wejście',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Nieprawidłowe dane wejściowe: oczekiwano ${r.expected}, otrzymano ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'liczba';
                    case 'object':
                      if (Array.isArray(e)) return 'tablica';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Nieprawidłowe dane wejściowe: oczekiwano ${tT(r.values[0])}`;
                return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Za duża wartość: oczekiwano, że ${r.origin ?? 'wartość'} będzie mieć ${t}${r.maximum.toString()} ${n.unit ?? 'elementów'}`;
                return `Zbyt duż(y/a/e): oczekiwano, że ${r.origin ?? 'wartość'} będzie wynosić ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Za mała wartość: oczekiwano, że ${r.origin ?? 'wartość'} będzie mieć ${t}${r.minimum.toString()} ${n.unit ?? 'elementów'}`;
                return `Zbyt mał(y/a/e): oczekiwano, że ${r.origin ?? 'wartość'} będzie wynosić ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi zaczynać się od "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi kończyć się na "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi zawierać "${r.includes}"`;
                if ('regex' === r.format)
                  return `Nieprawidłowy ciąg znak\xf3w: musi odpowiadać wzorcowi ${r.pattern}`;
                return `Nieprawidłow(y/a/e) ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Nieprawidłowa liczba: musi być wielokrotnością ${r.divisor}`;
              case 'unrecognized_keys':
                return `Nierozpoznane klucze${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Nieprawidłowy klucz w ${r.origin}`;
              case 'invalid_union':
                return 'Nieprawidłowe dane wejściowe';
              case 'invalid_element':
                return `Nieprawidłowa wartość w ${r.origin}`;
              default:
                return `Nieprawidłowe dane wejściowe`;
            }
          };
        })(),
      };
    }
    function aV() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'caracteres', verb: 'ter' },
              file: { unit: 'bytes', verb: 'ter' },
              array: { unit: 'itens', verb: 'ter' },
              set: { unit: 'itens', verb: 'ter' },
            },
            t = {
              regex: 'padrão',
              email: 'endereço de e-mail',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'data e hora ISO',
              date: 'data ISO',
              time: 'hora ISO',
              duration: 'duração ISO',
              ipv4: 'endereço IPv4',
              ipv6: 'endereço IPv6',
              cidrv4: 'faixa de IPv4',
              cidrv6: 'faixa de IPv6',
              base64: 'texto codificado em base64',
              base64url: 'URL codificada em base64',
              json_string: 'texto JSON',
              e164: 'número E.164',
              jwt: 'JWT',
              template_literal: 'entrada',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Tipo inv\xe1lido: esperado ${r.expected}, recebido ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'número';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'nulo';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Entrada inv\xe1lida: esperado ${tT(r.values[0])}`;
                return `Op\xe7\xe3o inv\xe1lida: esperada uma das ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Muito grande: esperado que ${r.origin ?? 'valor'} tivesse ${t}${r.maximum.toString()} ${n.unit ?? 'elementos'}`;
                return `Muito grande: esperado que ${r.origin ?? 'valor'} fosse ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Muito pequeno: esperado que ${r.origin} tivesse ${t}${r.minimum.toString()} ${n.unit}`;
                return `Muito pequeno: esperado que ${r.origin} fosse ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Texto inv\xe1lido: deve come\xe7ar com "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Texto inv\xe1lido: deve terminar com "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Texto inv\xe1lido: deve incluir "${r.includes}"`;
                if ('regex' === r.format)
                  return `Texto inv\xe1lido: deve corresponder ao padr\xe3o ${r.pattern}`;
                return `${t[r.format] ?? r.format} inv\xe1lido`;
              case 'not_multiple_of':
                return `N\xfamero inv\xe1lido: deve ser m\xfaltiplo de ${r.divisor}`;
              case 'unrecognized_keys':
                return `Chave${r.keys.length > 1 ? 's' : ''} desconhecida${r.keys.length > 1 ? 's' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Chave inv\xe1lida em ${r.origin}`;
              case 'invalid_union':
                return 'Entrada inválida';
              case 'invalid_element':
                return `Valor inv\xe1lido em ${r.origin}`;
              default:
                return `Campo inv\xe1lido`;
            }
          };
        })(),
      };
    }
    function aX(e, t, r, n) {
      let i = Math.abs(e),
        a = i % 10,
        o = i % 100;
      return o >= 11 && o <= 19 ? n : 1 === a ? t : a >= 2 && a <= 4 ? r : n;
    }
    function aq() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: { one: 'символ', few: 'символа', many: 'символов' }, verb: 'иметь' },
              file: { unit: { one: 'байт', few: 'байта', many: 'байт' }, verb: 'иметь' },
              array: {
                unit: { one: 'элемент', few: 'элемента', many: 'элементов' },
                verb: 'иметь',
              },
              set: { unit: { one: 'элемент', few: 'элемента', many: 'элементов' }, verb: 'иметь' },
            },
            t = {
              regex: 'ввод',
              email: 'email адрес',
              url: 'URL',
              emoji: 'эмодзи',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO дата и время',
              date: 'ISO дата',
              time: 'ISO время',
              duration: 'ISO длительность',
              ipv4: 'IPv4 адрес',
              ipv6: 'IPv6 адрес',
              cidrv4: 'IPv4 диапазон',
              cidrv6: 'IPv6 диапазон',
              base64: 'строка в формате base64',
              base64url: 'строка в формате base64url',
              json_string: 'JSON строка',
              e164: 'номер E.164',
              jwt: 'JWT',
              template_literal: 'ввод',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Неверный ввод: ожидалось ${r.expected}, получено ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'число';
                    case 'object':
                      if (Array.isArray(e)) return 'массив';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Неверный ввод: ожидалось ${tT(r.values[0])}`;
                return `Неверный вариант: ожидалось одно из ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n) {
                  let e = aX(Number(r.maximum), n.unit.one, n.unit.few, n.unit.many);
                  return `Слишком большое значение: ожидалось, что ${r.origin ?? 'значение'} будет иметь ${t}${r.maximum.toString()} ${e}`;
                }
                return `Слишком большое значение: ожидалось, что ${r.origin ?? 'значение'} будет ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n) {
                  let e = aX(Number(r.minimum), n.unit.one, n.unit.few, n.unit.many);
                  return `Слишком маленькое значение: ожидалось, что ${r.origin} будет иметь ${t}${r.minimum.toString()} ${e}`;
                }
                return `Слишком маленькое значение: ожидалось, что ${r.origin} будет ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Неверная строка: должна начинаться с "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Неверная строка: должна заканчиваться на "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Неверная строка: должна содержать "${r.includes}"`;
                if ('regex' === r.format)
                  return `Неверная строка: должна соответствовать шаблону ${r.pattern}`;
                return `Неверный ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Неверное число: должно быть кратным ${r.divisor}`;
              case 'unrecognized_keys':
                return `Нераспознанн${r.keys.length > 1 ? 'ые' : 'ый'} ключ${r.keys.length > 1 ? 'и' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Неверный ключ в ${r.origin}`;
              case 'invalid_union':
                return 'Неверные входные данные';
              case 'invalid_element':
                return `Неверное значение в ${r.origin}`;
              default:
                return `Неверные входные данные`;
            }
          };
        })(),
      };
    }
    function aW() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'znakov', verb: 'imeti' },
              file: { unit: 'bajtov', verb: 'imeti' },
              array: { unit: 'elementov', verb: 'imeti' },
              set: { unit: 'elementov', verb: 'imeti' },
            },
            t = {
              regex: 'vnos',
              email: 'e-poštni naslov',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO datum in čas',
              date: 'ISO datum',
              time: 'ISO čas',
              duration: 'ISO trajanje',
              ipv4: 'IPv4 naslov',
              ipv6: 'IPv6 naslov',
              cidrv4: 'obseg IPv4',
              cidrv6: 'obseg IPv6',
              base64: 'base64 kodiran niz',
              base64url: 'base64url kodiran niz',
              json_string: 'JSON niz',
              e164: 'E.164 številka',
              jwt: 'JWT',
              template_literal: 'vnos',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Neveljaven vnos: pričakovano ${r.expected}, prejeto ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'število';
                    case 'object':
                      if (Array.isArray(e)) return 'tabela';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Neveljaven vnos: pričakovano ${tT(r.values[0])}`;
                return `Neveljavna možnost: pričakovano eno izmed ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Preveliko: pričakovano, da bo ${r.origin ?? 'vrednost'} imelo ${t}${r.maximum.toString()} ${n.unit ?? 'elementov'}`;
                return `Preveliko: pričakovano, da bo ${r.origin ?? 'vrednost'} ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Premajhno: pričakovano, da bo ${r.origin} imelo ${t}${r.minimum.toString()} ${n.unit}`;
                return `Premajhno: pričakovano, da bo ${r.origin} ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Neveljaven niz: mora se začeti z "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Neveljaven niz: mora se končati z "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Neveljaven niz: mora vsebovati "${r.includes}"`;
                if ('regex' === r.format)
                  return `Neveljaven niz: mora ustrezati vzorcu ${r.pattern}`;
                return `Neveljaven ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Neveljavno število: mora biti večkratnik ${r.divisor}`;
              case 'unrecognized_keys':
                return `Neprepoznan${r.keys.length > 1 ? 'i ključi' : ' ključ'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Neveljaven ključ v ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Neveljaven vnos';
              case 'invalid_element':
                return `Neveljavna vrednost v ${r.origin}`;
            }
          };
        })(),
      };
    }
    function aH() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'tecken', verb: 'att ha' },
              file: { unit: 'bytes', verb: 'att ha' },
              array: { unit: 'objekt', verb: 'att innehålla' },
              set: { unit: 'objekt', verb: 'att innehålla' },
            },
            t = {
              regex: 'reguljärt uttryck',
              email: 'e-postadress',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO-datum och tid',
              date: 'ISO-datum',
              time: 'ISO-tid',
              duration: 'ISO-varaktighet',
              ipv4: 'IPv4-intervall',
              ipv6: 'IPv6-intervall',
              cidrv4: 'IPv4-spektrum',
              cidrv6: 'IPv6-spektrum',
              base64: 'base64-kodad sträng',
              base64url: 'base64url-kodad sträng',
              json_string: 'JSON-sträng',
              e164: 'E.164-nummer',
              jwt: 'JWT',
              template_literal: 'mall-literal',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Ogiltig inmatning: f\xf6rv\xe4ntat ${r.expected}, fick ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'antal';
                    case 'object':
                      if (Array.isArray(e)) return 'lista';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Ogiltig inmatning: f\xf6rv\xe4ntat ${tT(r.values[0])}`;
                return `Ogiltigt val: f\xf6rv\xe4ntade en av ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `F\xf6r stor(t): f\xf6rv\xe4ntade ${r.origin ?? 'värdet'} att ha ${t}${r.maximum.toString()} ${n.unit ?? 'element'}`;
                return `F\xf6r stor(t): f\xf6rv\xe4ntat ${r.origin ?? 'värdet'} att ha ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `F\xf6r lite(t): f\xf6rv\xe4ntade ${r.origin ?? 'värdet'} att ha ${t}${r.minimum.toString()} ${n.unit}`;
                return `F\xf6r lite(t): f\xf6rv\xe4ntade ${r.origin ?? 'värdet'} att ha ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ogiltig str\xe4ng: m\xe5ste b\xf6rja med "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Ogiltig str\xe4ng: m\xe5ste sluta med "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Ogiltig str\xe4ng: m\xe5ste inneh\xe5lla "${r.includes}"`;
                if ('regex' === r.format)
                  return `Ogiltig str\xe4ng: m\xe5ste matcha m\xf6nstret "${r.pattern}"`;
                return `Ogiltig(t) ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ogiltigt tal: m\xe5ste vara en multipel av ${r.divisor}`;
              case 'unrecognized_keys':
                return `${r.keys.length > 1 ? 'Okända nycklar' : 'Okänd nyckel'}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Ogiltig nyckel i ${r.origin ?? 'värdet'}`;
              case 'invalid_union':
              default:
                return 'Ogiltig input';
              case 'invalid_element':
                return `Ogiltigt v\xe4rde i ${r.origin ?? 'värdet'}`;
            }
          };
        })(),
      };
    }
    function aJ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'எழுத்துக்கள்', verb: 'கொண்டிருக்க வேண்டும்' },
              file: { unit: 'பைட்டுகள்', verb: 'கொண்டிருக்க வேண்டும்' },
              array: { unit: 'உறுப்புகள்', verb: 'கொண்டிருக்க வேண்டும்' },
              set: { unit: 'உறுப்புகள்', verb: 'கொண்டிருக்க வேண்டும்' },
            },
            t = {
              regex: 'உள்ளீடு',
              email: 'மின்னஞ்சல் முகவரி',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO தேதி நேரம்',
              date: 'ISO தேதி',
              time: 'ISO நேரம்',
              duration: 'ISO கால அளவு',
              ipv4: 'IPv4 முகவரி',
              ipv6: 'IPv6 முகவரி',
              cidrv4: 'IPv4 வரம்பு',
              cidrv6: 'IPv6 வரம்பு',
              base64: 'base64-encoded சரம்',
              base64url: 'base64url-encoded சரம்',
              json_string: 'JSON சரம்',
              e164: 'E.164 எண்',
              jwt: 'JWT',
              template_literal: 'input',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${r.expected}, பெறப்பட்டது ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'எண் அல்லாதது' : 'எண்';
                    case 'object':
                      if (Array.isArray(e)) return 'அணி';
                      if (null === e) return 'வெறுமை';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${tT(r.values[0])}`;
                return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${tn(r.values, '|')} இல் ஒன்று`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${r.origin ?? 'மதிப்பு'} ${t}${r.maximum.toString()} ${n.unit ?? 'உறுப்புகள்'} ஆக இருக்க வேண்டும்`;
                return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${r.origin ?? 'மதிப்பு'} ${t}${r.maximum.toString()} ஆக இருக்க வேண்டும்`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${r.origin} ${t}${r.minimum.toString()} ${n.unit} ஆக இருக்க வேண்டும்`;
                return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${r.origin} ${t}${r.minimum.toString()} ஆக இருக்க வேண்டும்`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `தவறான சரம்: "${r.prefix}" இல் தொடங்க வேண்டும்`;
                if ('ends_with' === r.format)
                  return `தவறான சரம்: "${r.suffix}" இல் முடிவடைய வேண்டும்`;
                if ('includes' === r.format)
                  return `தவறான சரம்: "${r.includes}" ஐ உள்ளடக்க வேண்டும்`;
                if ('regex' === r.format)
                  return `தவறான சரம்: ${r.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
                return `தவறான ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `தவறான எண்: ${r.divisor} இன் பலமாக இருக்க வேண்டும்`;
              case 'unrecognized_keys':
                return `அடையாளம் தெரியாத விசை${r.keys.length > 1 ? 'கள்' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `${r.origin} இல் தவறான விசை`;
              case 'invalid_union':
                return 'தவறான உள்ளீடு';
              case 'invalid_element':
                return `${r.origin} இல் தவறான மதிப்பு`;
              default:
                return `தவறான உள்ளீடு`;
            }
          };
        })(),
      };
    }
    function aK() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'ตัวอักษร', verb: 'ควรมี' },
              file: { unit: 'ไบต์', verb: 'ควรมี' },
              array: { unit: 'รายการ', verb: 'ควรมี' },
              set: { unit: 'รายการ', verb: 'ควรมี' },
            },
            t = {
              regex: 'ข้อมูลที่ป้อน',
              email: 'ที่อยู่อีเมล',
              url: 'URL',
              emoji: 'อิโมจิ',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'วันที่เวลาแบบ ISO',
              date: 'วันที่แบบ ISO',
              time: 'เวลาแบบ ISO',
              duration: 'ช่วงเวลาแบบ ISO',
              ipv4: 'ที่อยู่ IPv4',
              ipv6: 'ที่อยู่ IPv6',
              cidrv4: 'ช่วง IP แบบ IPv4',
              cidrv6: 'ช่วง IP แบบ IPv6',
              base64: 'ข้อความแบบ Base64',
              base64url: 'ข้อความแบบ Base64 สำหรับ URL',
              json_string: 'ข้อความแบบ JSON',
              e164: 'เบอร์โทรศัพท์ระหว่างประเทศ (E.164)',
              jwt: 'โทเคน JWT',
              template_literal: 'ข้อมูลที่ป้อน',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${r.expected} แต่ได้รับ ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'ไม่ใช่ตัวเลข (NaN)' : 'ตัวเลข';
                    case 'object':
                      if (Array.isArray(e)) return 'อาร์เรย์ (Array)';
                      if (null === e) return 'ไม่มีค่า (null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `ค่าไม่ถูกต้อง: ควรเป็น ${tT(r.values[0])}`;
                return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? 'ไม่เกิน' : 'น้อยกว่า',
                  n = e[r.origin] ?? null;
                if (n)
                  return `เกินกำหนด: ${r.origin ?? 'ค่า'} ควรมี${t} ${r.maximum.toString()} ${n.unit ?? 'รายการ'}`;
                return `เกินกำหนด: ${r.origin ?? 'ค่า'} ควรมี${t} ${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? 'อย่างน้อย' : 'มากกว่า',
                  n = e[r.origin] ?? null;
                if (n)
                  return `น้อยกว่ากำหนด: ${r.origin} ควรมี${t} ${r.minimum.toString()} ${n.unit}`;
                return `น้อยกว่ากำหนด: ${r.origin} ควรมี${t} ${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${r.suffix}"`;
                if ('includes' === r.format)
                  return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${r.includes}" อยู่ในข้อความ`;
                if ('regex' === r.format)
                  return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${r.pattern}`;
                return `รูปแบบไม่ถูกต้อง: ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${r.divisor} ได้ลงตัว`;
              case 'unrecognized_keys':
                return `พบคีย์ที่ไม่รู้จัก: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `คีย์ไม่ถูกต้องใน ${r.origin}`;
              case 'invalid_union':
                return 'ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้';
              case 'invalid_element':
                return `ข้อมูลไม่ถูกต้องใน ${r.origin}`;
              default:
                return `ข้อมูลไม่ถูกต้อง`;
            }
          };
        })(),
      };
    }
    function aY() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'karakter', verb: 'olmalı' },
              file: { unit: 'bayt', verb: 'olmalı' },
              array: { unit: 'öğe', verb: 'olmalı' },
              set: { unit: 'öğe', verb: 'olmalı' },
            },
            t = {
              regex: 'girdi',
              email: 'e-posta adresi',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO tarih ve saat',
              date: 'ISO tarih',
              time: 'ISO saat',
              duration: 'ISO süre',
              ipv4: 'IPv4 adresi',
              ipv6: 'IPv6 adresi',
              cidrv4: 'IPv4 aralığı',
              cidrv6: 'IPv6 aralığı',
              base64: 'base64 ile şifrelenmiş metin',
              base64url: 'base64url ile şifrelenmiş metin',
              json_string: 'JSON dizesi',
              e164: 'E.164 sayısı',
              jwt: 'JWT',
              template_literal: 'Şablon dizesi',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Ge\xe7ersiz değer: beklenen ${r.expected}, alınan ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `Ge\xe7ersiz değer: beklenen ${tT(r.values[0])}`;
                return `Ge\xe7ersiz se\xe7enek: aşağıdakilerden biri olmalı: ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `\xc7ok b\xfcy\xfck: beklenen ${r.origin ?? 'değer'} ${t}${r.maximum.toString()} ${n.unit ?? 'öğe'}`;
                return `\xc7ok b\xfcy\xfck: beklenen ${r.origin ?? 'değer'} ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `\xc7ok k\xfc\xe7\xfck: beklenen ${r.origin} ${t}${r.minimum.toString()} ${n.unit}`;
                return `\xc7ok k\xfc\xe7\xfck: beklenen ${r.origin} ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ge\xe7ersiz metin: "${r.prefix}" ile başlamalı`;
                if ('ends_with' === r.format) return `Ge\xe7ersiz metin: "${r.suffix}" ile bitmeli`;
                if ('includes' === r.format)
                  return `Ge\xe7ersiz metin: "${r.includes}" i\xe7ermeli`;
                if ('regex' === r.format) return `Ge\xe7ersiz metin: ${r.pattern} desenine uymalı`;
                return `Ge\xe7ersiz ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Ge\xe7ersiz sayı: ${r.divisor} ile tam b\xf6l\xfcnebilmeli`;
              case 'unrecognized_keys':
                return `Tanınmayan anahtar${r.keys.length > 1 ? 'lar' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `${r.origin} i\xe7inde ge\xe7ersiz anahtar`;
              case 'invalid_union':
                return 'Geçersiz değer';
              case 'invalid_element':
                return `${r.origin} i\xe7inde ge\xe7ersiz değer`;
              default:
                return `Ge\xe7ersiz değer`;
            }
          };
        })(),
      };
    }
    function aQ() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'символів', verb: 'матиме' },
              file: { unit: 'байтів', verb: 'матиме' },
              array: { unit: 'елементів', verb: 'матиме' },
              set: { unit: 'елементів', verb: 'матиме' },
            },
            t = {
              regex: 'вхідні дані',
              email: 'адреса електронної пошти',
              url: 'URL',
              emoji: 'емодзі',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'дата та час ISO',
              date: 'дата ISO',
              time: 'час ISO',
              duration: 'тривалість ISO',
              ipv4: 'адреса IPv4',
              ipv6: 'адреса IPv6',
              cidrv4: 'діапазон IPv4',
              cidrv6: 'діапазон IPv6',
              base64: 'рядок у кодуванні base64',
              base64url: 'рядок у кодуванні base64url',
              json_string: 'рядок JSON',
              e164: 'номер E.164',
              jwt: 'JWT',
              template_literal: 'вхідні дані',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Неправильні вхідні дані: очікується ${r.expected}, отримано ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'число';
                    case 'object':
                      if (Array.isArray(e)) return 'масив';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Неправильні вхідні дані: очікується ${tT(r.values[0])}`;
                return `Неправильна опція: очікується одне з ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Занадто велике: очікується, що ${r.origin ?? 'значення'} ${n.verb} ${t}${r.maximum.toString()} ${n.unit ?? 'елементів'}`;
                return `Занадто велике: очікується, що ${r.origin ?? 'значення'} буде ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Занадто мале: очікується, що ${r.origin} ${n.verb} ${t}${r.minimum.toString()} ${n.unit}`;
                return `Занадто мале: очікується, що ${r.origin} буде ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Неправильний рядок: повинен починатися з "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Неправильний рядок: повинен закінчуватися на "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Неправильний рядок: повинен містити "${r.includes}"`;
                if ('regex' === r.format)
                  return `Неправильний рядок: повинен відповідати шаблону ${r.pattern}`;
                return `Неправильний ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Неправильне число: повинно бути кратним ${r.divisor}`;
              case 'unrecognized_keys':
                return `Нерозпізнаний ключ${r.keys.length > 1 ? 'і' : ''}: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Неправильний ключ у ${r.origin}`;
              case 'invalid_union':
                return 'Неправильні вхідні дані';
              case 'invalid_element':
                return `Неправильне значення у ${r.origin}`;
              default:
                return `Неправильні вхідні дані`;
            }
          };
        })(),
      };
    }
    function a0() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'حروف', verb: 'ہونا' },
              file: { unit: 'بائٹس', verb: 'ہونا' },
              array: { unit: 'آئٹمز', verb: 'ہونا' },
              set: { unit: 'آئٹمز', verb: 'ہونا' },
            },
            t = {
              regex: 'ان پٹ',
              email: 'ای میل ایڈریس',
              url: 'یو آر ایل',
              emoji: 'ایموجی',
              uuid: 'یو یو آئی ڈی',
              uuidv4: 'یو یو آئی ڈی وی 4',
              uuidv6: 'یو یو آئی ڈی وی 6',
              nanoid: 'نینو آئی ڈی',
              guid: 'جی یو آئی ڈی',
              cuid: 'سی یو آئی ڈی',
              cuid2: 'سی یو آئی ڈی 2',
              ulid: 'یو ایل آئی ڈی',
              xid: 'ایکس آئی ڈی',
              ksuid: 'کے ایس یو آئی ڈی',
              datetime: 'آئی ایس او ڈیٹ ٹائم',
              date: 'آئی ایس او تاریخ',
              time: 'آئی ایس او وقت',
              duration: 'آئی ایس او مدت',
              ipv4: 'آئی پی وی 4 ایڈریس',
              ipv6: 'آئی پی وی 6 ایڈریس',
              cidrv4: 'آئی پی وی 4 رینج',
              cidrv6: 'آئی پی وی 6 رینج',
              base64: 'بیس 64 ان کوڈڈ سٹرنگ',
              base64url: 'بیس 64 یو آر ایل ان کوڈڈ سٹرنگ',
              json_string: 'جے ایس او این سٹرنگ',
              e164: 'ای 164 نمبر',
              jwt: 'جے ڈبلیو ٹی',
              template_literal: 'ان پٹ',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `غلط ان پٹ: ${r.expected} متوقع تھا، ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'نمبر';
                    case 'object':
                      if (Array.isArray(e)) return 'آرے';
                      if (null === e) return 'نل';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)} موصول ہوا`;
              case 'invalid_value':
                if (1 === r.values.length) return `غلط ان پٹ: ${tT(r.values[0])} متوقع تھا`;
                return `غلط آپشن: ${tn(r.values, '|')} میں سے ایک متوقع تھا`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `بہت بڑا: ${r.origin ?? 'ویلیو'} کے ${t}${r.maximum.toString()} ${n.unit ?? 'عناصر'} ہونے متوقع تھے`;
                return `بہت بڑا: ${r.origin ?? 'ویلیو'} کا ${t}${r.maximum.toString()} ہونا متوقع تھا`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `بہت چھوٹا: ${r.origin} کے ${t}${r.minimum.toString()} ${n.unit} ہونے متوقع تھے`;
                return `بہت چھوٹا: ${r.origin} کا ${t}${r.minimum.toString()} ہونا متوقع تھا`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `غلط سٹرنگ: "${r.prefix}" سے شروع ہونا چاہیے`;
                if ('ends_with' === r.format) return `غلط سٹرنگ: "${r.suffix}" پر ختم ہونا چاہیے`;
                if ('includes' === r.format) return `غلط سٹرنگ: "${r.includes}" شامل ہونا چاہیے`;
                if ('regex' === r.format) return `غلط سٹرنگ: پیٹرن ${r.pattern} سے میچ ہونا چاہیے`;
                return `غلط ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `غلط نمبر: ${r.divisor} کا مضاعف ہونا چاہیے`;
              case 'unrecognized_keys':
                return `غیر تسلیم شدہ کی${r.keys.length > 1 ? 'ز' : ''}: ${tn(r.keys, '، ')}`;
              case 'invalid_key':
                return `${r.origin} میں غلط کی`;
              case 'invalid_union':
                return 'غلط ان پٹ';
              case 'invalid_element':
                return `${r.origin} میں غلط ویلیو`;
              default:
                return `غلط ان پٹ`;
            }
          };
        })(),
      };
    }
    function a1() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'ký tự', verb: 'có' },
              file: { unit: 'byte', verb: 'có' },
              array: { unit: 'phần tử', verb: 'có' },
              set: { unit: 'phần tử', verb: 'có' },
            },
            t = {
              regex: 'đầu vào',
              email: 'địa chỉ email',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ngày giờ ISO',
              date: 'ngày ISO',
              time: 'giờ ISO',
              duration: 'khoảng thời gian ISO',
              ipv4: 'địa chỉ IPv4',
              ipv6: 'địa chỉ IPv6',
              cidrv4: 'dải IPv4',
              cidrv6: 'dải IPv6',
              base64: 'chuỗi mã hóa base64',
              base64url: 'chuỗi mã hóa base64url',
              json_string: 'chuỗi JSON',
              e164: 'số E.164',
              jwt: 'JWT',
              template_literal: 'đầu vào',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `Đầu v\xe0o kh\xf4ng hợp lệ: mong đợi ${r.expected}, nhận được ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'số';
                    case 'object':
                      if (Array.isArray(e)) return 'mảng';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `Đầu v\xe0o kh\xf4ng hợp lệ: mong đợi ${tT(r.values[0])}`;
                return `T\xf9y chọn kh\xf4ng hợp lệ: mong đợi một trong c\xe1c gi\xe1 trị ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Qu\xe1 lớn: mong đợi ${r.origin ?? 'giá trị'} ${n.verb} ${t}${r.maximum.toString()} ${n.unit ?? 'phần tử'}`;
                return `Qu\xe1 lớn: mong đợi ${r.origin ?? 'giá trị'} ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `Qu\xe1 nhỏ: mong đợi ${r.origin} ${n.verb} ${t}${r.minimum.toString()} ${n.unit}`;
                return `Qu\xe1 nhỏ: mong đợi ${r.origin} ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải bắt đầu bằng "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải kết th\xfac bằng "${r.suffix}"`;
                if ('includes' === r.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải bao gồm "${r.includes}"`;
                if ('regex' === r.format)
                  return `Chuỗi kh\xf4ng hợp lệ: phải khớp với mẫu ${r.pattern}`;
                return `${t[r.format] ?? r.format} kh\xf4ng hợp lệ`;
              case 'not_multiple_of':
                return `Số kh\xf4ng hợp lệ: phải l\xe0 bội số của ${r.divisor}`;
              case 'unrecognized_keys':
                return `Kh\xf3a kh\xf4ng được nhận dạng: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Kh\xf3a kh\xf4ng hợp lệ trong ${r.origin}`;
              case 'invalid_union':
                return 'Đầu vào không hợp lệ';
              case 'invalid_element':
                return `Gi\xe1 trị kh\xf4ng hợp lệ trong ${r.origin}`;
              default:
                return `Đầu v\xe0o kh\xf4ng hợp lệ`;
            }
          };
        })(),
      };
    }
    function a4() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '字符', verb: '包含' },
              file: { unit: '字节', verb: '包含' },
              array: { unit: '项', verb: '包含' },
              set: { unit: '项', verb: '包含' },
            },
            t = {
              regex: '输入',
              email: '电子邮件',
              url: 'URL',
              emoji: '表情符号',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO日期时间',
              date: 'ISO日期',
              time: 'ISO时间',
              duration: 'ISO时长',
              ipv4: 'IPv4地址',
              ipv6: 'IPv6地址',
              cidrv4: 'IPv4网段',
              cidrv6: 'IPv6网段',
              base64: 'base64编码字符串',
              base64url: 'base64url编码字符串',
              json_string: 'JSON字符串',
              e164: 'E.164号码',
              jwt: 'JWT',
              template_literal: '输入',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `无效输入：期望 ${r.expected}，实际接收 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? '非数字(NaN)' : '数字';
                    case 'object':
                      if (Array.isArray(e)) return '数组';
                      if (null === e) return '空值(null)';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `无效输入：期望 ${tT(r.values[0])}`;
                return `无效选项：期望以下之一 ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `数值过大：期望 ${r.origin ?? '值'} ${t}${r.maximum.toString()} ${n.unit ?? '个元素'}`;
                return `数值过大：期望 ${r.origin ?? '值'} ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n) return `数值过小：期望 ${r.origin} ${t}${r.minimum.toString()} ${n.unit}`;
                return `数值过小：期望 ${r.origin} ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format) return `无效字符串：必须以 "${r.prefix}" 开头`;
                if ('ends_with' === r.format) return `无效字符串：必须以 "${r.suffix}" 结尾`;
                if ('includes' === r.format) return `无效字符串：必须包含 "${r.includes}"`;
                if ('regex' === r.format) return `无效字符串：必须满足正则表达式 ${r.pattern}`;
                return `无效${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `无效数字：必须是 ${r.divisor} 的倍数`;
              case 'unrecognized_keys':
                return `出现未知的键(key): ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `${r.origin} 中的键(key)无效`;
              case 'invalid_union':
                return '无效输入';
              case 'invalid_element':
                return `${r.origin} 中包含无效值(value)`;
              default:
                return `无效输入`;
            }
          };
        })(),
      };
    }
    function a6() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: '字元', verb: '擁有' },
              file: { unit: '位元組', verb: '擁有' },
              array: { unit: '項目', verb: '擁有' },
              set: { unit: '項目', verb: '擁有' },
            },
            t = {
              regex: '輸入',
              email: '郵件地址',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'ISO 日期時間',
              date: 'ISO 日期',
              time: 'ISO 時間',
              duration: 'ISO 期間',
              ipv4: 'IPv4 位址',
              ipv6: 'IPv6 位址',
              cidrv4: 'IPv4 範圍',
              cidrv6: 'IPv6 範圍',
              base64: 'base64 編碼字串',
              base64url: 'base64url 編碼字串',
              json_string: 'JSON 字串',
              e164: 'E.164 數值',
              jwt: 'JWT',
              template_literal: '輸入',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `無效的輸入值：預期為 ${r.expected}，但收到 ${((e) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'number';
                    case 'object':
                      if (Array.isArray(e)) return 'array';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length) return `無效的輸入值：預期為 ${tT(r.values[0])}`;
                return `無效的選項：預期為以下其中之一 ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `數值過大：預期 ${r.origin ?? '值'} 應為 ${t}${r.maximum.toString()} ${n.unit ?? '個元素'}`;
                return `數值過大：預期 ${r.origin ?? '值'} 應為 ${t}${r.maximum.toString()}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `數值過小：預期 ${r.origin} 應為 ${t}${r.minimum.toString()} ${n.unit}`;
                return `數值過小：預期 ${r.origin} 應為 ${t}${r.minimum.toString()}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format) return `無效的字串：必須以 "${r.prefix}" 開頭`;
                if ('ends_with' === r.format) return `無效的字串：必須以 "${r.suffix}" 結尾`;
                if ('includes' === r.format) return `無效的字串：必須包含 "${r.includes}"`;
                if ('regex' === r.format) return `無效的字串：必須符合格式 ${r.pattern}`;
                return `無效的 ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `無效的數字：必須為 ${r.divisor} 的倍數`;
              case 'unrecognized_keys':
                return `無法識別的鍵值${r.keys.length > 1 ? '們' : ''}：${tn(r.keys, '、')}`;
              case 'invalid_key':
                return `${r.origin} 中有無效的鍵值`;
              case 'invalid_union':
                return '無效的輸入值';
              case 'invalid_element':
                return `${r.origin} 中有無效的值`;
              default:
                return `無效的輸入值`;
            }
          };
        })(),
      };
    }
    function a2() {
      return {
        localeError: (() => {
          let e = {
              string: { unit: 'àmi', verb: 'ní' },
              file: { unit: 'bytes', verb: 'ní' },
              array: { unit: 'nkan', verb: 'ní' },
              set: { unit: 'nkan', verb: 'ní' },
            },
            t = {
              regex: 'ẹ̀rọ ìbáwọlé',
              email: 'àdírẹ́sì ìmẹ́lì',
              url: 'URL',
              emoji: 'emoji',
              uuid: 'UUID',
              uuidv4: 'UUIDv4',
              uuidv6: 'UUIDv6',
              nanoid: 'nanoid',
              guid: 'GUID',
              cuid: 'cuid',
              cuid2: 'cuid2',
              ulid: 'ULID',
              xid: 'XID',
              ksuid: 'KSUID',
              datetime: 'àkókò ISO',
              date: 'ọjọ́ ISO',
              time: 'àkókò ISO',
              duration: 'àkókò tó pé ISO',
              ipv4: 'àdírẹ́sì IPv4',
              ipv6: 'àdírẹ́sì IPv6',
              cidrv4: 'àgbègbè IPv4',
              cidrv6: 'àgbègbè IPv6',
              base64: 'ọ̀rọ̀ tí a kọ́ ní base64',
              base64url: 'ọ̀rọ̀ base64url',
              json_string: 'ọ̀rọ̀ JSON',
              e164: 'nọ́mbà E.164',
              jwt: 'JWT',
              template_literal: 'ẹ̀rọ ìbáwọlé',
            };
          return (r) => {
            switch (r.code) {
              case 'invalid_type':
                return `\xccb\xe1wọl\xe9 aṣ\xecṣe: a n\xed l\xe1ti fi ${r.expected}, \xe0mọ̀ a r\xed ${((
                  e
                ) => {
                  let t = typeof e;
                  switch (t) {
                    case 'number':
                      return Number.isNaN(e) ? 'NaN' : 'nọ́mbà';
                    case 'object':
                      if (Array.isArray(e)) return 'akopọ';
                      if (null === e) return 'null';
                      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
                        return e.constructor.name;
                  }
                  return t;
                })(r.input)}`;
              case 'invalid_value':
                if (1 === r.values.length)
                  return `\xccb\xe1wọl\xe9 aṣ\xecṣe: a n\xed l\xe1ti fi ${tT(r.values[0])}`;
                return `\xc0ṣ\xe0y\xe0n aṣ\xecṣe: yan ọ̀kan l\xe1ra ${tn(r.values, '|')}`;
              case 'too_big': {
                let t = r.inclusive ? '<=' : '<',
                  n = e[r.origin] ?? null;
                if (n)
                  return `T\xf3 pọ̀ j\xf9: a n\xed l\xe1ti jẹ́ p\xe9 ${r.origin ?? 'iye'} ${n.verb} ${t}${r.maximum} ${n.unit}`;
                return `T\xf3 pọ̀ j\xf9: a n\xed l\xe1ti jẹ́ ${t}${r.maximum}`;
              }
              case 'too_small': {
                let t = r.inclusive ? '>=' : '>',
                  n = e[r.origin] ?? null;
                if (n)
                  return `K\xe9r\xe9 ju: a n\xed l\xe1ti jẹ́ p\xe9 ${r.origin} ${n.verb} ${t}${r.minimum} ${n.unit}`;
                return `K\xe9r\xe9 ju: a n\xed l\xe1ti jẹ́ ${t}${r.minimum}`;
              }
              case 'invalid_format':
                if ('starts_with' === r.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀l\xfa "${r.prefix}"`;
                if ('ends_with' === r.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ par\xed pẹ̀l\xfa "${r.suffix}"`;
                if ('includes' === r.format) return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ n\xed "${r.includes}"`;
                if ('regex' === r.format)
                  return `Ọ̀rọ̀ aṣ\xecṣe: gbọ́dọ̀ b\xe1 \xe0pẹẹrẹ mu ${r.pattern}`;
                return `Aṣ\xecṣe: ${t[r.format] ?? r.format}`;
              case 'not_multiple_of':
                return `Nọ́mb\xe0 aṣ\xecṣe: gbọ́dọ̀ jẹ́ \xe8y\xe0 p\xedp\xedn ti ${r.divisor}`;
              case 'unrecognized_keys':
                return `Bọt\xecn\xec \xe0\xecmọ̀: ${tn(r.keys, ', ')}`;
              case 'invalid_key':
                return `Bọt\xecn\xec aṣ\xecṣe n\xedn\xfa ${r.origin}`;
              case 'invalid_union':
              default:
                return 'Ìbáwọlé aṣìṣe';
              case 'invalid_element':
                return `Iye aṣ\xecṣe n\xedn\xfa ${r.origin}`;
            }
          };
        })(),
      };
    }
    (e.s(
      [
        'ar',
        () => ah,
        'az',
        () => av,
        'be',
        () => a_,
        'ca',
        () => ay,
        'cs',
        () => ax,
        'da',
        () => a$,
        'de',
        () => aw,
        'en',
        () => t2,
        'eo',
        () => aS,
        'es',
        () => aO,
        'fa',
        () => aE,
        'fi',
        () => ak,
        'fr',
        () => aI,
        'frCA',
        () => aP,
        'he',
        () => aN,
        'hu',
        () => aR,
        'id',
        () => aT,
        'is',
        () => aj,
        'it',
        () => aA,
        'ja',
        () => aD,
        'kh',
        () => aU,
        'ko',
        () => az,
        'mk',
        () => aC,
        'ms',
        () => aZ,
        'nl',
        () => aL,
        'no',
        () => aM,
        'ota',
        () => aB,
        'pl',
        () => aG,
        'ps',
        () => aF,
        'pt',
        () => aV,
        'ru',
        () => aq,
        'sl',
        () => aW,
        'sv',
        () => aH,
        'ta',
        () => aJ,
        'th',
        () => aK,
        'tr',
        () => aY,
        'ua',
        () => aQ,
        'ur',
        () => a0,
        'vi',
        () => a1,
        'yo',
        () => a2,
        'zhCN',
        () => a4,
        'zhTW',
        () => a6,
      ],
      53584
    ),
      e.s([], 55241),
      e.i(55241));
    var a9 = e.i(53584);
    e.s(
      [
        '$ZodRegistry',
        () => a5,
        '$input',
        () => a7,
        '$output',
        () => a3,
        'globalRegistry',
        () => oe,
        'registry',
        () => a8,
      ],
      39479
    );
    let a3 = Symbol('ZodOutput'),
      a7 = Symbol('ZodInput');
    class a5 {
      constructor() {
        ((this._map = new Map()), (this._idmap = new Map()));
      }
      add(e, ...t) {
        let r = t[0];
        if ((this._map.set(e, r), r && 'object' == typeof r && 'id' in r)) {
          if (this._idmap.has(r.id)) throw Error(`ID ${r.id} already exists in the registry`);
          this._idmap.set(r.id, e);
        }
        return this;
      }
      clear() {
        return ((this._map = new Map()), (this._idmap = new Map()), this);
      }
      remove(e) {
        let t = this._map.get(e);
        return (
          t && 'object' == typeof t && 'id' in t && this._idmap.delete(t.id),
          this._map.delete(e),
          this
        );
      }
      get(e) {
        let t = e._zod.parent;
        if (t) {
          let r = { ...(this.get(t) ?? {}) };
          delete r.id;
          let n = { ...r, ...this._map.get(e) };
          return Object.keys(n).length ? n : void 0;
        }
        return this._map.get(e);
      }
      has(e) {
        return this._map.has(e);
      }
    }
    function a8() {
      return new a5();
    }
    let oe = a8();
    function ot(e, t) {
      return new e({ type: 'string', ...tN(t) });
    }
    function or(e, t) {
      return new e({ type: 'string', coerce: !0, ...tN(t) });
    }
    function on(e, t) {
      return new e({
        type: 'string',
        format: 'email',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function oi(e, t) {
      return new e({ type: 'string', format: 'guid', check: 'string_format', abort: !1, ...tN(t) });
    }
    function oa(e, t) {
      return new e({ type: 'string', format: 'uuid', check: 'string_format', abort: !1, ...tN(t) });
    }
    function oo(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v4',
        ...tN(t),
      });
    }
    function os(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v6',
        ...tN(t),
      });
    }
    function ou(e, t) {
      return new e({
        type: 'string',
        format: 'uuid',
        check: 'string_format',
        abort: !1,
        version: 'v7',
        ...tN(t),
      });
    }
    function ol(e, t) {
      return new e({ type: 'string', format: 'url', check: 'string_format', abort: !1, ...tN(t) });
    }
    function oc(e, t) {
      return new e({
        type: 'string',
        format: 'emoji',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function od(e, t) {
      return new e({
        type: 'string',
        format: 'nanoid',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function of(e, t) {
      return new e({ type: 'string', format: 'cuid', check: 'string_format', abort: !1, ...tN(t) });
    }
    function op(e, t) {
      return new e({
        type: 'string',
        format: 'cuid2',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function om(e, t) {
      return new e({ type: 'string', format: 'ulid', check: 'string_format', abort: !1, ...tN(t) });
    }
    function og(e, t) {
      return new e({ type: 'string', format: 'xid', check: 'string_format', abort: !1, ...tN(t) });
    }
    function oh(e, t) {
      return new e({
        type: 'string',
        format: 'ksuid',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function ov(e, t) {
      return new e({ type: 'string', format: 'ipv4', check: 'string_format', abort: !1, ...tN(t) });
    }
    function ob(e, t) {
      return new e({ type: 'string', format: 'ipv6', check: 'string_format', abort: !1, ...tN(t) });
    }
    function o_(e, t) {
      return new e({
        type: 'string',
        format: 'cidrv4',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function oy(e, t) {
      return new e({
        type: 'string',
        format: 'cidrv6',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function ox(e, t) {
      return new e({
        type: 'string',
        format: 'base64',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function o$(e, t) {
      return new e({
        type: 'string',
        format: 'base64url',
        check: 'string_format',
        abort: !1,
        ...tN(t),
      });
    }
    function ow(e, t) {
      return new e({ type: 'string', format: 'e164', check: 'string_format', abort: !1, ...tN(t) });
    }
    function oS(e, t) {
      return new e({ type: 'string', format: 'jwt', check: 'string_format', abort: !1, ...tN(t) });
    }
    (e.i(39479),
      e.i(42030),
      e.s(
        [
          'TimePrecision',
          () => oO,
          '_any',
          () => oX,
          '_array',
          () => sv,
          '_base64',
          () => ox,
          '_base64url',
          () => o$,
          '_bigint',
          () => oZ,
          '_boolean',
          () => oz,
          '_catch',
          () => sD,
          '_check',
          () => sG,
          '_cidrv4',
          () => o_,
          '_cidrv6',
          () => oy,
          '_coercedBigint',
          () => oL,
          '_coercedBoolean',
          () => oC,
          '_coercedDate',
          () => oK,
          '_coercedNumber',
          () => oR,
          '_coercedString',
          () => or,
          '_cuid',
          () => of,
          '_cuid2',
          () => op,
          '_custom',
          () => sM,
          '_date',
          () => oJ,
          '_default',
          () => sT,
          '_discriminatedUnion',
          () => s_,
          '_e164',
          () => ow,
          '_email',
          () => on,
          '_emoji',
          () => oc,
          '_endsWith',
          () => sl,
          '_enum',
          () => sO,
          '_file',
          () => sI,
          '_float32',
          () => oj,
          '_float64',
          () => oA,
          '_gt',
          () => o1,
          '_gte',
          () => o4,
          '_guid',
          () => oi,
          '_includes',
          () => ss,
          '_int',
          () => oT,
          '_int32',
          () => oD,
          '_int64',
          () => oM,
          '_intersection',
          () => sy,
          '_ipv4',
          () => ov,
          '_ipv6',
          () => ob,
          '_isoDate',
          () => ok,
          '_isoDateTime',
          () => oE,
          '_isoDuration',
          () => oP,
          '_isoTime',
          () => oI,
          '_jwt',
          () => oS,
          '_ksuid',
          () => oh,
          '_lazy',
          () => sZ,
          '_length',
          () => sn,
          '_literal',
          () => sk,
          '_lowercase',
          () => sa,
          '_lt',
          () => oQ,
          '_lte',
          () => o0,
          '_map',
          () => sw,
          '_max',
          () => o0,
          '_maxLength',
          () => st,
          '_maxSize',
          () => o5,
          '_mime',
          () => sd,
          '_min',
          () => o4,
          '_minLength',
          () => sr,
          '_minSize',
          () => o8,
          '_multipleOf',
          () => o7,
          '_nan',
          () => oY,
          '_nanoid',
          () => od,
          '_nativeEnum',
          () => sE,
          '_negative',
          () => o2,
          '_never',
          () => oW,
          '_nonnegative',
          () => o3,
          '_nonoptional',
          () => sj,
          '_nonpositive',
          () => o9,
          '_normalize',
          () => sp,
          '_null',
          () => oV,
          '_nullable',
          () => sR,
          '_number',
          () => oN,
          '_optional',
          () => sN,
          '_overwrite',
          () => sf,
          '_pipe',
          () => sU,
          '_positive',
          () => o6,
          '_promise',
          () => sL,
          '_property',
          () => sc,
          '_readonly',
          () => sz,
          '_record',
          () => s$,
          '_refine',
          () => sB,
          '_regex',
          () => si,
          '_set',
          () => sS,
          '_size',
          () => se,
          '_startsWith',
          () => su,
          '_string',
          () => ot,
          '_stringFormat',
          () => sX,
          '_stringbool',
          () => sV,
          '_success',
          () => sA,
          '_superRefine',
          () => sF,
          '_symbol',
          () => oF,
          '_templateLiteral',
          () => sC,
          '_toLowerCase',
          () => sg,
          '_toUpperCase',
          () => sh,
          '_transform',
          () => sP,
          '_trim',
          () => sm,
          '_tuple',
          () => sx,
          '_uint32',
          () => oU,
          '_uint64',
          () => oB,
          '_ulid',
          () => om,
          '_undefined',
          () => oG,
          '_union',
          () => sb,
          '_unknown',
          () => oq,
          '_uppercase',
          () => so,
          '_url',
          () => ol,
          '_uuid',
          () => oa,
          '_uuidv4',
          () => oo,
          '_uuidv6',
          () => os,
          '_uuidv7',
          () => ou,
          '_void',
          () => oH,
          '_xid',
          () => og,
        ],
        68455
      ));
    let oO = { Any: null, Minute: -1, Second: 0, Millisecond: 3, Microsecond: 6 };
    function oE(e, t) {
      return new e({
        type: 'string',
        format: 'datetime',
        check: 'string_format',
        offset: !1,
        local: !1,
        precision: null,
        ...tN(t),
      });
    }
    function ok(e, t) {
      return new e({ type: 'string', format: 'date', check: 'string_format', ...tN(t) });
    }
    function oI(e, t) {
      return new e({
        type: 'string',
        format: 'time',
        check: 'string_format',
        precision: null,
        ...tN(t),
      });
    }
    function oP(e, t) {
      return new e({ type: 'string', format: 'duration', check: 'string_format', ...tN(t) });
    }
    function oN(e, t) {
      return new e({ type: 'number', checks: [], ...tN(t) });
    }
    function oR(e, t) {
      return new e({ type: 'number', coerce: !0, checks: [], ...tN(t) });
    }
    function oT(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'safeint',
        ...tN(t),
      });
    }
    function oj(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float32',
        ...tN(t),
      });
    }
    function oA(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'float64',
        ...tN(t),
      });
    }
    function oD(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'int32',
        ...tN(t),
      });
    }
    function oU(e, t) {
      return new e({
        type: 'number',
        check: 'number_format',
        abort: !1,
        format: 'uint32',
        ...tN(t),
      });
    }
    function oz(e, t) {
      return new e({ type: 'boolean', ...tN(t) });
    }
    function oC(e, t) {
      return new e({ type: 'boolean', coerce: !0, ...tN(t) });
    }
    function oZ(e, t) {
      return new e({ type: 'bigint', ...tN(t) });
    }
    function oL(e, t) {
      return new e({ type: 'bigint', coerce: !0, ...tN(t) });
    }
    function oM(e, t) {
      return new e({
        type: 'bigint',
        check: 'bigint_format',
        abort: !1,
        format: 'int64',
        ...tN(t),
      });
    }
    function oB(e, t) {
      return new e({
        type: 'bigint',
        check: 'bigint_format',
        abort: !1,
        format: 'uint64',
        ...tN(t),
      });
    }
    function oF(e, t) {
      return new e({ type: 'symbol', ...tN(t) });
    }
    function oG(e, t) {
      return new e({ type: 'undefined', ...tN(t) });
    }
    function oV(e, t) {
      return new e({ type: 'null', ...tN(t) });
    }
    function oX(e) {
      return new e({ type: 'any' });
    }
    function oq(e) {
      return new e({ type: 'unknown' });
    }
    function oW(e, t) {
      return new e({ type: 'never', ...tN(t) });
    }
    function oH(e, t) {
      return new e({ type: 'void', ...tN(t) });
    }
    function oJ(e, t) {
      return new e({ type: 'date', ...tN(t) });
    }
    function oK(e, t) {
      return new e({ type: 'date', coerce: !0, ...tN(t) });
    }
    function oY(e, t) {
      return new e({ type: 'nan', ...tN(t) });
    }
    function oQ(e, t) {
      return new nE({ check: 'less_than', ...tN(t), value: e, inclusive: !1 });
    }
    function o0(e, t) {
      return new nE({ check: 'less_than', ...tN(t), value: e, inclusive: !0 });
    }
    function o1(e, t) {
      return new nk({ check: 'greater_than', ...tN(t), value: e, inclusive: !1 });
    }
    function o4(e, t) {
      return new nk({ check: 'greater_than', ...tN(t), value: e, inclusive: !0 });
    }
    function o6(e) {
      return o1(0, e);
    }
    function o2(e) {
      return oQ(0, e);
    }
    function o9(e) {
      return o0(0, e);
    }
    function o3(e) {
      return o4(0, e);
    }
    function o7(e, t) {
      return new nI({ check: 'multiple_of', ...tN(t), value: e });
    }
    function o5(e, t) {
      return new nR({ check: 'max_size', ...tN(t), maximum: e });
    }
    function o8(e, t) {
      return new nT({ check: 'min_size', ...tN(t), minimum: e });
    }
    function se(e, t) {
      return new nj({ check: 'size_equals', ...tN(t), size: e });
    }
    function st(e, t) {
      return new nA({ check: 'max_length', ...tN(t), maximum: e });
    }
    function sr(e, t) {
      return new nD({ check: 'min_length', ...tN(t), minimum: e });
    }
    function sn(e, t) {
      return new nU({ check: 'length_equals', ...tN(t), length: e });
    }
    function si(e, t) {
      return new nC({ check: 'string_format', format: 'regex', ...tN(t), pattern: e });
    }
    function sa(e) {
      return new nZ({ check: 'string_format', format: 'lowercase', ...tN(e) });
    }
    function so(e) {
      return new nL({ check: 'string_format', format: 'uppercase', ...tN(e) });
    }
    function ss(e, t) {
      return new nM({ check: 'string_format', format: 'includes', ...tN(t), includes: e });
    }
    function su(e, t) {
      return new nB({ check: 'string_format', format: 'starts_with', ...tN(t), prefix: e });
    }
    function sl(e, t) {
      return new nF({ check: 'string_format', format: 'ends_with', ...tN(t), suffix: e });
    }
    function sc(e, t, r) {
      return new nV({ check: 'property', property: e, schema: t, ...tN(r) });
    }
    function sd(e, t) {
      return new nX({ check: 'mime_type', mime: e, ...tN(t) });
    }
    function sf(e) {
      return new nq({ check: 'overwrite', tx: e });
    }
    function sp(e) {
      return sf((t) => t.normalize(e));
    }
    function sm() {
      return sf((e) => e.trim());
    }
    function sg() {
      return sf((e) => e.toLowerCase());
    }
    function sh() {
      return sf((e) => e.toUpperCase());
    }
    function sv(e, t, r) {
      return new e({ type: 'array', element: t, ...tN(r) });
    }
    function sb(e, t, r) {
      return new e({ type: 'union', options: t, ...tN(r) });
    }
    function s_(e, t, r, n) {
      return new e({ type: 'union', options: r, discriminator: t, ...tN(n) });
    }
    function sy(e, t, r) {
      return new e({ type: 'intersection', left: t, right: r });
    }
    function sx(e, t, r, n) {
      let i = r instanceof nJ,
        a = i ? n : r;
      return new e({ type: 'tuple', items: t, rest: i ? r : null, ...tN(a) });
    }
    function s$(e, t, r, n) {
      return new e({ type: 'record', keyType: t, valueType: r, ...tN(n) });
    }
    function sw(e, t, r, n) {
      return new e({ type: 'map', keyType: t, valueType: r, ...tN(n) });
    }
    function sS(e, t, r) {
      return new e({ type: 'set', valueType: t, ...tN(r) });
    }
    function sO(e, t, r) {
      return new e({
        type: 'enum',
        entries: Array.isArray(t) ? Object.fromEntries(t.map((e) => [e, e])) : t,
        ...tN(r),
      });
    }
    function sE(e, t, r) {
      return new e({ type: 'enum', entries: t, ...tN(r) });
    }
    function sk(e, t, r) {
      return new e({ type: 'literal', values: Array.isArray(t) ? t : [t], ...tN(r) });
    }
    function sI(e, t) {
      return new e({ type: 'file', ...tN(t) });
    }
    function sP(e, t) {
      return new e({ type: 'transform', transform: t });
    }
    function sN(e, t) {
      return new e({ type: 'optional', innerType: t });
    }
    function sR(e, t) {
      return new e({ type: 'nullable', innerType: t });
    }
    function sT(e, t, r) {
      return new e({
        type: 'default',
        innerType: t,
        get defaultValue() {
          return 'function' == typeof r ? r() : tw(r);
        },
      });
    }
    function sj(e, t, r) {
      return new e({ type: 'nonoptional', innerType: t, ...tN(r) });
    }
    function sA(e, t) {
      return new e({ type: 'success', innerType: t });
    }
    function sD(e, t, r) {
      return new e({
        type: 'catch',
        innerType: t,
        catchValue: 'function' == typeof r ? r : () => r,
      });
    }
    function sU(e, t, r) {
      return new e({ type: 'pipe', in: t, out: r });
    }
    function sz(e, t) {
      return new e({ type: 'readonly', innerType: t });
    }
    function sC(e, t, r) {
      return new e({ type: 'template_literal', parts: t, ...tN(r) });
    }
    function sZ(e, t) {
      return new e({ type: 'lazy', getter: t });
    }
    function sL(e, t) {
      return new e({ type: 'promise', innerType: t });
    }
    function sM(e, t, r) {
      let n = tN(r);
      return (n.abort ?? (n.abort = !0), new e({ type: 'custom', check: 'custom', fn: t, ...n }));
    }
    function sB(e, t, r) {
      return new e({ type: 'custom', check: 'custom', fn: t, ...tN(r) });
    }
    function sF(e) {
      let t = sG(
        (r) => (
          (r.addIssue = (e) => {
            'string' == typeof e
              ? r.issues.push(tH(e, r.value, t._zod.def))
              : (e.fatal && (e.continue = !1),
                e.code ?? (e.code = 'custom'),
                e.input ?? (e.input = r.value),
                e.inst ?? (e.inst = t),
                e.continue ?? (e.continue = !t._zod.def.abort),
                r.issues.push(tH(e)));
          }),
          e(r.value, r)
        )
      );
      return t;
    }
    function sG(e, t) {
      let r = new nS({ check: 'custom', ...tN(t) });
      return ((r._zod.check = e), r);
    }
    function sV(e, t) {
      let r = tN(t),
        n = r.truthy ?? ['true', '1', 'yes', 'on', 'y', 'enabled'],
        i = r.falsy ?? ['false', '0', 'no', 'off', 'n', 'disabled'];
      'sensitive' !== r.case &&
        ((n = n.map((e) => ('string' == typeof e ? e.toLowerCase() : e))),
        (i = i.map((e) => ('string' == typeof e ? e.toLowerCase() : e))));
      let a = new Set(n),
        o = new Set(i),
        s = e.Codec ?? an,
        u = e.Boolean ?? iy,
        l = new s({
          type: 'pipe',
          in: new (e.String ?? nK)({ type: 'string', error: r.error }),
          out: new u({ type: 'boolean', error: r.error }),
          transform: (e, t) => {
            let n = e;
            return (
              'sensitive' !== r.case && (n = n.toLowerCase()),
              !!a.has(n) ||
                (!o.has(n) &&
                  (t.issues.push({
                    code: 'invalid_value',
                    expected: 'stringbool',
                    values: [...a, ...o],
                    input: t.value,
                    inst: l,
                    continue: !1,
                  }),
                  {}))
            );
          },
          reverseTransform: (e, t) => (!0 === e ? n[0] || 'true' : i[0] || 'false'),
          error: r.error,
        });
      return l;
    }
    function sX(e, t, r, n = {}) {
      let i = tN(n),
        a = {
          ...tN(n),
          check: 'string_format',
          type: 'string',
          format: t,
          fn: 'function' == typeof r ? r : (e) => r.test(e),
          ...i,
        };
      return (r instanceof RegExp && (a.pattern = r), new e(a));
    }
    (e.i(68455), e.s(['JSONSchemaGenerator', () => sq, 'toJSONSchema', () => sW], 38371));
    class sq {
      constructor(e) {
        ((this.counter = 0),
          (this.metadataRegistry = e?.metadata ?? oe),
          (this.target = e?.target ?? 'draft-2020-12'),
          (this.unrepresentable = e?.unrepresentable ?? 'throw'),
          (this.override = e?.override ?? (() => {})),
          (this.io = e?.io ?? 'output'),
          (this.seen = new Map()));
      }
      process(e, t = { path: [], schemaPath: [] }) {
        var r;
        let n = e._zod.def,
          i = this.seen.get(e);
        if (i) return (i.count++, t.schemaPath.includes(e) && (i.cycle = t.path), i.schema);
        let a = { schema: {}, count: 1, cycle: void 0, path: t.path };
        this.seen.set(e, a);
        let o = e._zod.toJSONSchema?.();
        if (o) a.schema = o;
        else {
          let r = { ...t, schemaPath: [...t.schemaPath, e], path: t.path },
            i = e._zod.parent;
          if (i) ((a.ref = i), this.process(i, r), (this.seen.get(i).isParent = !0));
          else {
            let t = a.schema;
            switch (n.type) {
              case 'string': {
                t.type = 'string';
                let {
                  minimum: r,
                  maximum: n,
                  format: i,
                  patterns: o,
                  contentEncoding: s,
                } = e._zod.bag;
                if (
                  ('number' == typeof r && (t.minLength = r),
                  'number' == typeof n && (t.maxLength = n),
                  i &&
                    ((t.format =
                      {
                        guid: 'uuid',
                        url: 'uri',
                        datetime: 'date-time',
                        json_string: 'json-string',
                        regex: '',
                      }[i] ?? i),
                    '' === t.format && delete t.format),
                  s && (t.contentEncoding = s),
                  o && o.size > 0)
                ) {
                  let e = [...o];
                  1 === e.length
                    ? (t.pattern = e[0].source)
                    : e.length > 1 &&
                      (a.schema.allOf = [
                        ...e.map((e) => ({
                          ...('draft-7' === this.target ||
                          'draft-4' === this.target ||
                          'openapi-3.0' === this.target
                            ? { type: 'string' }
                            : {}),
                          pattern: e.source,
                        })),
                      ]);
                }
                break;
              }
              case 'number': {
                let {
                  minimum: r,
                  maximum: n,
                  format: i,
                  multipleOf: a,
                  exclusiveMaximum: o,
                  exclusiveMinimum: s,
                } = e._zod.bag;
                ('string' == typeof i && i.includes('int')
                  ? (t.type = 'integer')
                  : (t.type = 'number'),
                  'number' == typeof s &&
                    ('draft-4' === this.target || 'openapi-3.0' === this.target
                      ? ((t.minimum = s), (t.exclusiveMinimum = !0))
                      : (t.exclusiveMinimum = s)),
                  'number' == typeof r &&
                    ((t.minimum = r),
                    'number' == typeof s &&
                      'draft-4' !== this.target &&
                      (s >= r ? delete t.minimum : delete t.exclusiveMinimum)),
                  'number' == typeof o &&
                    ('draft-4' === this.target || 'openapi-3.0' === this.target
                      ? ((t.maximum = o), (t.exclusiveMaximum = !0))
                      : (t.exclusiveMaximum = o)),
                  'number' == typeof n &&
                    ((t.maximum = n),
                    'number' == typeof o &&
                      'draft-4' !== this.target &&
                      (o <= n ? delete t.maximum : delete t.exclusiveMaximum)),
                  'number' == typeof a && (t.multipleOf = a));
                break;
              }
              case 'boolean':
              case 'success':
                t.type = 'boolean';
                break;
              case 'bigint':
                if ('throw' === this.unrepresentable)
                  throw Error('BigInt cannot be represented in JSON Schema');
                break;
              case 'symbol':
                if ('throw' === this.unrepresentable)
                  throw Error('Symbols cannot be represented in JSON Schema');
                break;
              case 'null':
                'openapi-3.0' === this.target
                  ? ((t.type = 'string'), (t.nullable = !0), (t.enum = [null]))
                  : (t.type = 'null');
                break;
              case 'any':
              case 'unknown':
                break;
              case 'undefined':
                if ('throw' === this.unrepresentable)
                  throw Error('Undefined cannot be represented in JSON Schema');
                break;
              case 'void':
                if ('throw' === this.unrepresentable)
                  throw Error('Void cannot be represented in JSON Schema');
                break;
              case 'never':
                t.not = {};
                break;
              case 'date':
                if ('throw' === this.unrepresentable)
                  throw Error('Date cannot be represented in JSON Schema');
                break;
              case 'array': {
                let { minimum: i, maximum: a } = e._zod.bag;
                ('number' == typeof i && (t.minItems = i),
                  'number' == typeof a && (t.maxItems = a),
                  (t.type = 'array'),
                  (t.items = this.process(n.element, { ...r, path: [...r.path, 'items'] })));
                break;
              }
              case 'object': {
                ((t.type = 'object'), (t.properties = {}));
                let e = n.shape;
                for (let n in e)
                  t.properties[n] = this.process(e[n], {
                    ...r,
                    path: [...r.path, 'properties', n],
                  });
                let i = new Set(
                  [...new Set(Object.keys(e))].filter((e) => {
                    let t = n.shape[e]._zod;
                    return 'input' === this.io ? void 0 === t.optin : void 0 === t.optout;
                  })
                );
                (i.size > 0 && (t.required = Array.from(i)),
                  n.catchall?._zod.def.type === 'never'
                    ? (t.additionalProperties = !1)
                    : n.catchall
                      ? n.catchall &&
                        (t.additionalProperties = this.process(n.catchall, {
                          ...r,
                          path: [...r.path, 'additionalProperties'],
                        }))
                      : 'output' === this.io && (t.additionalProperties = !1));
                break;
              }
              case 'union':
                t.anyOf = n.options.map((e, t) =>
                  this.process(e, { ...r, path: [...r.path, 'anyOf', t] })
                );
                break;
              case 'intersection': {
                let e = this.process(n.left, { ...r, path: [...r.path, 'allOf', 0] }),
                  i = this.process(n.right, { ...r, path: [...r.path, 'allOf', 1] }),
                  a = (e) => 'allOf' in e && 1 === Object.keys(e).length;
                t.allOf = [...(a(e) ? e.allOf : [e]), ...(a(i) ? i.allOf : [i])];
                break;
              }
              case 'tuple': {
                t.type = 'array';
                let i = 'draft-2020-12' === this.target ? 'prefixItems' : 'items',
                  a =
                    'draft-2020-12' === this.target || 'openapi-3.0' === this.target
                      ? 'items'
                      : 'additionalItems',
                  o = n.items.map((e, t) => this.process(e, { ...r, path: [...r.path, i, t] })),
                  s = n.rest
                    ? this.process(n.rest, {
                        ...r,
                        path: [
                          ...r.path,
                          a,
                          ...('openapi-3.0' === this.target ? [n.items.length] : []),
                        ],
                      })
                    : null;
                'draft-2020-12' === this.target
                  ? ((t.prefixItems = o), s && (t.items = s))
                  : 'openapi-3.0' === this.target
                    ? ((t.items = { anyOf: o }),
                      s && t.items.anyOf.push(s),
                      (t.minItems = o.length),
                      s || (t.maxItems = o.length))
                    : ((t.items = o), s && (t.additionalItems = s));
                let { minimum: u, maximum: l } = e._zod.bag;
                ('number' == typeof u && (t.minItems = u),
                  'number' == typeof l && (t.maxItems = l));
                break;
              }
              case 'record':
                ((t.type = 'object'),
                  ('draft-7' === this.target || 'draft-2020-12' === this.target) &&
                    (t.propertyNames = this.process(n.keyType, {
                      ...r,
                      path: [...r.path, 'propertyNames'],
                    })),
                  (t.additionalProperties = this.process(n.valueType, {
                    ...r,
                    path: [...r.path, 'additionalProperties'],
                  })));
                break;
              case 'map':
                if ('throw' === this.unrepresentable)
                  throw Error('Map cannot be represented in JSON Schema');
                break;
              case 'set':
                if ('throw' === this.unrepresentable)
                  throw Error('Set cannot be represented in JSON Schema');
                break;
              case 'enum': {
                let e = tr(n.entries);
                (e.every((e) => 'number' == typeof e) && (t.type = 'number'),
                  e.every((e) => 'string' == typeof e) && (t.type = 'string'),
                  (t.enum = e));
                break;
              }
              case 'literal': {
                let e = [];
                for (let t of n.values)
                  if (void 0 === t) {
                    if ('throw' === this.unrepresentable)
                      throw Error('Literal `undefined` cannot be represented in JSON Schema');
                  } else if ('bigint' == typeof t)
                    if ('throw' === this.unrepresentable)
                      throw Error('BigInt literals cannot be represented in JSON Schema');
                    else e.push(Number(t));
                  else e.push(t);
                if (0 === e.length);
                else if (1 === e.length) {
                  let r = e[0];
                  ((t.type = null === r ? 'null' : typeof r),
                    'draft-4' === this.target || 'openapi-3.0' === this.target
                      ? (t.enum = [r])
                      : (t.const = r));
                } else
                  (e.every((e) => 'number' == typeof e) && (t.type = 'number'),
                    e.every((e) => 'string' == typeof e) && (t.type = 'string'),
                    e.every((e) => 'boolean' == typeof e) && (t.type = 'string'),
                    e.every((e) => null === e) && (t.type = 'null'),
                    (t.enum = e));
                break;
              }
              case 'file': {
                let r = { type: 'string', format: 'binary', contentEncoding: 'binary' },
                  { minimum: n, maximum: i, mime: a } = e._zod.bag;
                (void 0 !== n && (r.minLength = n),
                  void 0 !== i && (r.maxLength = i),
                  a
                    ? 1 === a.length
                      ? ((r.contentMediaType = a[0]), Object.assign(t, r))
                      : (t.anyOf = a.map((e) => ({ ...r, contentMediaType: e })))
                    : Object.assign(t, r));
                break;
              }
              case 'transform':
                if ('throw' === this.unrepresentable)
                  throw Error('Transforms cannot be represented in JSON Schema');
                break;
              case 'nullable': {
                let e = this.process(n.innerType, r);
                'openapi-3.0' === this.target
                  ? ((a.ref = n.innerType), (t.nullable = !0))
                  : (t.anyOf = [e, { type: 'null' }]);
                break;
              }
              case 'nonoptional':
              case 'promise':
              case 'optional':
                (this.process(n.innerType, r), (a.ref = n.innerType));
                break;
              case 'default':
                (this.process(n.innerType, r),
                  (a.ref = n.innerType),
                  (t.default = JSON.parse(JSON.stringify(n.defaultValue))));
                break;
              case 'prefault':
                (this.process(n.innerType, r),
                  (a.ref = n.innerType),
                  'input' === this.io &&
                    (t._prefault = JSON.parse(JSON.stringify(n.defaultValue))));
                break;
              case 'catch': {
                let e;
                (this.process(n.innerType, r), (a.ref = n.innerType));
                try {
                  e = n.catchValue(void 0);
                } catch {
                  throw Error('Dynamic catch values are not supported in JSON Schema');
                }
                t.default = e;
                break;
              }
              case 'nan':
                if ('throw' === this.unrepresentable)
                  throw Error('NaN cannot be represented in JSON Schema');
                break;
              case 'template_literal': {
                let r = e._zod.pattern;
                if (!r) throw Error('Pattern not found in template literal');
                ((t.type = 'string'), (t.pattern = r.source));
                break;
              }
              case 'pipe': {
                let e =
                  'input' === this.io ? ('transform' === n.in._zod.def.type ? n.out : n.in) : n.out;
                (this.process(e, r), (a.ref = e));
                break;
              }
              case 'readonly':
                (this.process(n.innerType, r), (a.ref = n.innerType), (t.readOnly = !0));
                break;
              case 'lazy': {
                let t = e._zod.innerType;
                (this.process(t, r), (a.ref = t));
                break;
              }
              case 'custom':
                if ('throw' === this.unrepresentable)
                  throw Error('Custom types cannot be represented in JSON Schema');
                break;
              case 'function':
                if ('throw' === this.unrepresentable)
                  throw Error('Function types cannot be represented in JSON Schema');
            }
          }
        }
        let s = this.metadataRegistry.get(e);
        return (
          s && Object.assign(a.schema, s),
          'input' === this.io &&
            (function e(t, r) {
              let n = r ?? { seen: new Set() };
              if (n.seen.has(t)) return !1;
              n.seen.add(t);
              let i = t._zod.def;
              switch (i.type) {
                case 'string':
                case 'number':
                case 'bigint':
                case 'boolean':
                case 'date':
                case 'symbol':
                case 'undefined':
                case 'null':
                case 'any':
                case 'unknown':
                case 'never':
                case 'void':
                case 'literal':
                case 'enum':
                case 'nan':
                case 'file':
                case 'template_literal':
                case 'custom':
                case 'success':
                case 'catch':
                case 'function':
                  return !1;
                case 'array':
                  return e(i.element, n);
                case 'object':
                  for (let t in i.shape) if (e(i.shape[t], n)) return !0;
                  return !1;
                case 'union':
                  for (let t of i.options) if (e(t, n)) return !0;
                  return !1;
                case 'intersection':
                  return e(i.left, n) || e(i.right, n);
                case 'tuple':
                  for (let t of i.items) if (e(t, n)) return !0;
                  if (i.rest && e(i.rest, n)) return !0;
                  return !1;
                case 'record':
                case 'map':
                  return e(i.keyType, n) || e(i.valueType, n);
                case 'set':
                  return e(i.valueType, n);
                case 'promise':
                case 'optional':
                case 'nonoptional':
                case 'nullable':
                case 'readonly':
                case 'default':
                case 'prefault':
                  return e(i.innerType, n);
                case 'lazy':
                  return e(i.getter(), n);
                case 'transform':
                  return !0;
                case 'pipe':
                  return e(i.in, n) || e(i.out, n);
              }
              throw Error(`Unknown schema type: ${i.type}`);
            })(e) &&
            (delete a.schema.examples, delete a.schema.default),
          'input' === this.io &&
            a.schema._prefault &&
            ((r = a.schema).default ?? (r.default = a.schema._prefault)),
          delete a.schema._prefault,
          this.seen.get(e).schema
        );
      }
      emit(e, t) {
        let r = {
            cycles: t?.cycles ?? 'ref',
            reused: t?.reused ?? 'inline',
            external: t?.external ?? void 0,
          },
          n = this.seen.get(e);
        if (!n) throw Error('Unprocessed schema. This is a bug in Zod.');
        let i = (e) => {
            let t = 'draft-2020-12' === this.target ? '$defs' : 'definitions';
            if (r.external) {
              let n = r.external.registry.get(e[0])?.id,
                i = r.external.uri ?? ((e) => e);
              if (n) return { ref: i(n) };
              let a = e[1].defId ?? e[1].schema.id ?? `schema${this.counter++}`;
              return ((e[1].defId = a), { defId: a, ref: `${i('__shared')}#/${t}/${a}` });
            }
            if (e[1] === n) return { ref: '#' };
            let i = `#/${t}/`,
              a = e[1].schema.id ?? `__schema${this.counter++}`;
            return { defId: a, ref: i + a };
          },
          a = (e) => {
            if (e[1].schema.$ref) return;
            let t = e[1],
              { ref: r, defId: n } = i(e);
            ((t.def = { ...t.schema }), n && (t.defId = n));
            let a = t.schema;
            for (let e in a) delete a[e];
            a.$ref = r;
          };
        if ('throw' === r.cycles)
          for (let e of this.seen.entries()) {
            let t = e[1];
            if (t.cycle)
              throw Error(`Cycle detected: #/${t.cycle?.join('/')}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
          }
        for (let t of this.seen.entries()) {
          let n = t[1];
          if (e === t[0]) {
            a(t);
            continue;
          }
          if (r.external) {
            let n = r.external.registry.get(t[0])?.id;
            if (e !== t[0] && n) {
              a(t);
              continue;
            }
          }
          if (
            this.metadataRegistry.get(t[0])?.id ||
            n.cycle ||
            (n.count > 1 && 'ref' === r.reused)
          ) {
            a(t);
            continue;
          }
        }
        let o = (e, t) => {
          let r = this.seen.get(e),
            n = r.def ?? r.schema,
            i = { ...n };
          if (null === r.ref) return;
          let a = r.ref;
          if (((r.ref = null), a)) {
            o(a, t);
            let e = this.seen.get(a).schema;
            e.$ref &&
            ('draft-7' === t.target || 'draft-4' === t.target || 'openapi-3.0' === t.target)
              ? ((n.allOf = n.allOf ?? []), n.allOf.push(e))
              : (Object.assign(n, e), Object.assign(n, i));
          }
          r.isParent || this.override({ zodSchema: e, jsonSchema: n, path: r.path ?? [] });
        };
        for (let e of [...this.seen.entries()].reverse()) o(e[0], { target: this.target });
        let s = {};
        if (
          ('draft-2020-12' === this.target
            ? (s.$schema = 'https://json-schema.org/draft/2020-12/schema')
            : 'draft-7' === this.target
              ? (s.$schema = 'http://json-schema.org/draft-07/schema#')
              : 'draft-4' === this.target
                ? (s.$schema = 'http://json-schema.org/draft-04/schema#')
                : 'openapi-3.0' === this.target || console.warn(`Invalid target: ${this.target}`),
          r.external?.uri)
        ) {
          let t = r.external.registry.get(e)?.id;
          if (!t) throw Error('Schema is missing an `id` property');
          s.$id = r.external.uri(t);
        }
        Object.assign(s, n.def);
        let u = r.external?.defs ?? {};
        for (let e of this.seen.entries()) {
          let t = e[1];
          t.def && t.defId && (u[t.defId] = t.def);
        }
        r.external ||
          (Object.keys(u).length > 0 &&
            ('draft-2020-12' === this.target ? (s.$defs = u) : (s.definitions = u)));
        try {
          return JSON.parse(JSON.stringify(s));
        } catch (e) {
          throw Error('Error converting schema to JSON.');
        }
      }
    }
    function sW(e, t) {
      if (e instanceof a5) {
        let r = new sq(t),
          n = {};
        for (let t of e._idmap.entries()) {
          let [e, n] = t;
          r.process(n);
        }
        let i = {},
          a = { registry: e, uri: t?.uri, defs: n };
        for (let n of e._idmap.entries()) {
          let [e, o] = n;
          i[e] = r.emit(o, { ...t, external: a });
        }
        return (
          Object.keys(n).length > 0 &&
            (i.__shared = { ['draft-2020-12' === r.target ? '$defs' : 'definitions']: n }),
          { schemas: i }
        );
      }
      let r = new sq(t);
      return (r.process(e), r.emit(e, t));
    }
    (e.i(38371), e.s([], 11618));
    var sH = e.i(11618),
      sJ = e.i(38916);
    e.s(
      [
        'ZodAny',
        () => lx,
        'ZodArray',
        () => lR,
        'ZodBase64',
        () => uK,
        'ZodBase64URL',
        () => uQ,
        'ZodBigInt',
        () => lc,
        'ZodBigIntFormat',
        () => lf,
        'ZodBoolean',
        () => lu,
        'ZodCIDRv4',
        () => uq,
        'ZodCIDRv6',
        () => uH,
        'ZodCUID',
        () => uj,
        'ZodCUID2',
        () => uD,
        'ZodCatch',
        () => cd,
        'ZodCodec',
        () => cv,
        'ZodCustom',
        () => cP,
        'ZodCustomStringFormat',
        () => u9,
        'ZodDate',
        () => lP,
        'ZodDefault',
        () => cn,
        'ZodDiscriminatedUnion',
        () => lL,
        'ZodE164',
        () => u1,
        'ZodEmail',
        () => uv,
        'ZodEmoji',
        () => uP,
        'ZodEnum',
        () => lQ,
        'ZodFile',
        () => l2,
        'ZodFunction',
        () => ck,
        'ZodGUID',
        () => u_,
        'ZodIPv4',
        () => uF,
        'ZodIPv6',
        () => uV,
        'ZodIntersection',
        () => lB,
        'ZodJWT',
        () => u6,
        'ZodKSUID',
        () => uM,
        'ZodLazy',
        () => cw,
        'ZodLiteral',
        () => l4,
        'ZodMap',
        () => lH,
        'ZodNaN',
        () => cp,
        'ZodNanoID',
        () => uR,
        'ZodNever',
        () => lO,
        'ZodNonOptional',
        () => cs,
        'ZodNull',
        () => l_,
        'ZodNullable',
        () => ce,
        'ZodNumber',
        () => le,
        'ZodNumberFormat',
        () => lr,
        'ZodObject',
        () => lA,
        'ZodOptional',
        () => l5,
        'ZodPipe',
        () => cg,
        'ZodPrefault',
        () => ca,
        'ZodPromise',
        () => cO,
        'ZodReadonly',
        () => c_,
        'ZodRecord',
        () => lX,
        'ZodSet',
        () => lK,
        'ZodString',
        () => um,
        'ZodStringFormat',
        () => uh,
        'ZodSuccess',
        () => cl,
        'ZodSymbol',
        () => lg,
        'ZodTemplateLiteral',
        () => cx,
        'ZodTransform',
        () => l3,
        'ZodTuple',
        () => lG,
        'ZodType',
        () => uf,
        'ZodULID',
        () => uz,
        'ZodURL',
        () => uE,
        'ZodUUID',
        () => ux,
        'ZodUndefined',
        () => lv,
        'ZodUnion',
        () => lC,
        'ZodUnknown',
        () => lw,
        'ZodVoid',
        () => lk,
        'ZodXID',
        () => uZ,
        '_ZodString',
        () => up,
        '_default',
        () => ci,
        '_function',
        () => cI,
        'any',
        () => l$,
        'array',
        () => lT,
        'base64',
        () => uY,
        'base64url',
        () => u0,
        'bigint',
        () => ld,
        'boolean',
        () => ll,
        'catch',
        () => cf,
        'check',
        () => cN,
        'cidrv4',
        () => uW,
        'cidrv6',
        () => uJ,
        'codec',
        () => cb,
        'cuid',
        () => uA,
        'cuid2',
        () => uU,
        'custom',
        () => cR,
        'date',
        () => lN,
        'discriminatedUnion',
        () => lM,
        'e164',
        () => u4,
        'email',
        () => ub,
        'emoji',
        () => uN,
        'enum',
        () => l0,
        'file',
        () => l9,
        'float32',
        () => li,
        'float64',
        () => la,
        'function',
        () => cI,
        'guid',
        () => uy,
        'hash',
        () => u8,
        'hex',
        () => u5,
        'hostname',
        () => u7,
        'httpUrl',
        () => uI,
        'instanceof',
        () => cA,
        'int',
        () => ln,
        'int32',
        () => lo,
        'int64',
        () => lp,
        'intersection',
        () => lF,
        'ipv4',
        () => uG,
        'ipv6',
        () => uX,
        'json',
        () => cU,
        'jwt',
        () => u2,
        'keyof',
        () => lj,
        'ksuid',
        () => uB,
        'lazy',
        () => cS,
        'literal',
        () => l6,
        'looseObject',
        () => lz,
        'map',
        () => lJ,
        'nan',
        () => cm,
        'nanoid',
        () => uT,
        'nativeEnum',
        () => l1,
        'never',
        () => lE,
        'nonoptional',
        () => cu,
        'null',
        () => ly,
        'nullable',
        () => ct,
        'nullish',
        () => cr,
        'number',
        () => lt,
        'object',
        () => lD,
        'optional',
        () => l8,
        'partialRecord',
        () => lW,
        'pipe',
        () => ch,
        'prefault',
        () => co,
        'preprocess',
        () => cz,
        'promise',
        () => cE,
        'readonly',
        () => cy,
        'record',
        () => lq,
        'refine',
        () => cT,
        'set',
        () => lY,
        'strictObject',
        () => lU,
        'string',
        () => ug,
        'stringFormat',
        () => u3,
        'stringbool',
        () => cD,
        'success',
        () => cc,
        'superRefine',
        () => cj,
        'symbol',
        () => lh,
        'templateLiteral',
        () => c$,
        'transform',
        () => l7,
        'tuple',
        () => lV,
        'uint32',
        () => ls,
        'uint64',
        () => lm,
        'ulid',
        () => uC,
        'undefined',
        () => lb,
        'union',
        () => lZ,
        'unknown',
        () => lS,
        'url',
        () => uk,
        'uuid',
        () => u$,
        'uuidv4',
        () => uw,
        'uuidv6',
        () => uS,
        'uuidv7',
        () => uO,
        'void',
        () => lI,
        'xid',
        () => uL,
      ],
      91871
    );
    var sK = ag,
      sY = am;
    e.s(
      [
        'ZodISODate',
        () => s1,
        'ZodISODateTime',
        () => sQ,
        'ZodISODuration',
        () => s9,
        'ZodISOTime',
        () => s6,
        'date',
        () => s4,
        'datetime',
        () => s0,
        'duration',
        () => s3,
        'time',
        () => s2,
      ],
      73673
    );
    let sQ = e1('ZodISODateTime', (e, t) => {
      (ie.init(e, t), uh.init(e, t));
    });
    function s0(e) {
      return oE(sQ, e);
    }
    let s1 = e1('ZodISODate', (e, t) => {
      (it.init(e, t), uh.init(e, t));
    });
    function s4(e) {
      return ok(s1, e);
    }
    let s6 = e1('ZodISOTime', (e, t) => {
      (ir.init(e, t), uh.init(e, t));
    });
    function s2(e) {
      return oI(s6, e);
    }
    let s9 = e1('ZodISODuration', (e, t) => {
      (ii.init(e, t), uh.init(e, t));
    });
    function s3(e) {
      return oP(s9, e);
    }
    (e.s(
      [
        'decode',
        () => ua,
        'decodeAsync',
        () => us,
        'encode',
        () => ui,
        'encodeAsync',
        () => uo,
        'parse',
        () => ue,
        'parseAsync',
        () => ut,
        'safeDecode',
        () => ul,
        'safeDecodeAsync',
        () => ud,
        'safeEncode',
        () => uu,
        'safeEncodeAsync',
        () => uc,
        'safeParse',
        () => ur,
        'safeParseAsync',
        () => un,
      ],
      52083
    ),
      e.s(['ZodError', () => s5, 'ZodRealError', () => s8], 64911));
    let s7 = (e, t) => {
        (t3.init(e, t),
          (e.name = 'ZodError'),
          Object.defineProperties(e, {
            format: { value: (t) => t8(e, t) },
            flatten: { value: (t) => t5(e, t) },
            addIssue: {
              value: (t) => {
                (e.issues.push(t), (e.message = JSON.stringify(e.issues, ti, 2)));
              },
            },
            addIssues: {
              value: (t) => {
                (e.issues.push(...t), (e.message = JSON.stringify(e.issues, ti, 2)));
              },
            },
            isEmpty: { get: () => 0 === e.issues.length },
          }));
      },
      s5 = e1('ZodError', s7),
      s8 = e1('ZodError', s7, { Parent: Error }),
      ue = rn(s8),
      ut = ra(s8),
      ur = rs(s8),
      un = rl(s8),
      ui = rd(s8),
      ua = rp(s8),
      uo = rg(s8),
      us = rv(s8),
      uu = r_(s8),
      ul = rx(s8),
      uc = rw(s8),
      ud = rO(s8),
      uf = e1(
        'ZodType',
        (e, t) => (
          nJ.init(e, t),
          (e.def = t),
          (e.type = t.type),
          Object.defineProperty(e, '_def', { value: t }),
          (e.check = (...r) =>
            e.clone({
              ...t,
              checks: [
                ...(t.checks ?? []),
                ...r.map((e) =>
                  'function' == typeof e
                    ? { _zod: { check: e, def: { check: 'custom' }, onattach: [] } }
                    : e
                ),
              ],
            })),
          (e.clone = (t, r) => tP(e, t, r)),
          (e.brand = () => e),
          (e.register = (t, r) => (t.add(e, r), e)),
          (e.parse = (t, r) => ue(e, t, r, { callee: e.parse })),
          (e.safeParse = (t, r) => ur(e, t, r)),
          (e.parseAsync = async (t, r) => ut(e, t, r, { callee: e.parseAsync })),
          (e.safeParseAsync = async (t, r) => un(e, t, r)),
          (e.spa = e.safeParseAsync),
          (e.encode = (t, r) => ui(e, t, r)),
          (e.decode = (t, r) => ua(e, t, r)),
          (e.encodeAsync = async (t, r) => uo(e, t, r)),
          (e.decodeAsync = async (t, r) => us(e, t, r)),
          (e.safeEncode = (t, r) => uu(e, t, r)),
          (e.safeDecode = (t, r) => ul(e, t, r)),
          (e.safeEncodeAsync = async (t, r) => uc(e, t, r)),
          (e.safeDecodeAsync = async (t, r) => ud(e, t, r)),
          (e.refine = (t, r) => e.check(cT(t, r))),
          (e.superRefine = (t) => e.check(sF(t))),
          (e.overwrite = (t) => e.check(sf(t))),
          (e.optional = () => l8(e)),
          (e.nullable = () => ct(e)),
          (e.nullish = () => l8(ct(e))),
          (e.nonoptional = (t) => cu(e, t)),
          (e.array = () => lT(e)),
          (e.or = (t) => lZ([e, t])),
          (e.and = (t) => lF(e, t)),
          (e.transform = (t) => ch(e, l7(t))),
          (e.default = (t) => ci(e, t)),
          (e.prefault = (t) => co(e, t)),
          (e.catch = (t) => cf(e, t)),
          (e.pipe = (t) => ch(e, t)),
          (e.readonly = () => cy(e)),
          (e.describe = (t) => {
            let r = e.clone();
            return (oe.add(r, { description: t }), r);
          }),
          Object.defineProperty(e, 'description', {
            get: () => oe.get(e)?.description,
            configurable: !0,
          }),
          (e.meta = (...t) => {
            if (0 === t.length) return oe.get(e);
            let r = e.clone();
            return (oe.add(r, t[0]), r);
          }),
          (e.isOptional = () => e.safeParse(void 0).success),
          (e.isNullable = () => e.safeParse(null).success),
          e
        )
      ),
      up = e1('_ZodString', (e, t) => {
        (nK.init(e, t), uf.init(e, t));
        let r = e._zod.bag;
        ((e.format = r.format ?? null),
          (e.minLength = r.minimum ?? null),
          (e.maxLength = r.maximum ?? null),
          (e.regex = (...t) => e.check(si(...t))),
          (e.includes = (...t) => e.check(ss(...t))),
          (e.startsWith = (...t) => e.check(su(...t))),
          (e.endsWith = (...t) => e.check(sl(...t))),
          (e.min = (...t) => e.check(sr(...t))),
          (e.max = (...t) => e.check(st(...t))),
          (e.length = (...t) => e.check(sn(...t))),
          (e.nonempty = (...t) => e.check(sr(1, ...t))),
          (e.lowercase = (t) => e.check(sa(t))),
          (e.uppercase = (t) => e.check(so(t))),
          (e.trim = () => e.check(sm())),
          (e.normalize = (...t) => e.check(sp(...t))),
          (e.toLowerCase = () => e.check(sg())),
          (e.toUpperCase = () => e.check(sh())));
      }),
      um = e1('ZodString', (e, t) => {
        (nK.init(e, t),
          up.init(e, t),
          (e.email = (t) => e.check(on(uv, t))),
          (e.url = (t) => e.check(ol(uE, t))),
          (e.jwt = (t) => e.check(oS(u6, t))),
          (e.emoji = (t) => e.check(oc(uP, t))),
          (e.guid = (t) => e.check(oi(u_, t))),
          (e.uuid = (t) => e.check(oa(ux, t))),
          (e.uuidv4 = (t) => e.check(oo(ux, t))),
          (e.uuidv6 = (t) => e.check(os(ux, t))),
          (e.uuidv7 = (t) => e.check(ou(ux, t))),
          (e.nanoid = (t) => e.check(od(uR, t))),
          (e.guid = (t) => e.check(oi(u_, t))),
          (e.cuid = (t) => e.check(of(uj, t))),
          (e.cuid2 = (t) => e.check(op(uD, t))),
          (e.ulid = (t) => e.check(om(uz, t))),
          (e.base64 = (t) => e.check(ox(uK, t))),
          (e.base64url = (t) => e.check(o$(uQ, t))),
          (e.xid = (t) => e.check(og(uZ, t))),
          (e.ksuid = (t) => e.check(oh(uM, t))),
          (e.ipv4 = (t) => e.check(ov(uF, t))),
          (e.ipv6 = (t) => e.check(ob(uV, t))),
          (e.cidrv4 = (t) => e.check(o_(uq, t))),
          (e.cidrv6 = (t) => e.check(oy(uH, t))),
          (e.e164 = (t) => e.check(ow(u1, t))),
          (e.datetime = (t) => e.check(s0(t))),
          (e.date = (t) => e.check(s4(t))),
          (e.time = (t) => e.check(s2(t))),
          (e.duration = (t) => e.check(s3(t))));
      });
    function ug(e) {
      return ot(um, e);
    }
    let uh = e1('ZodStringFormat', (e, t) => {
        (nY.init(e, t), up.init(e, t));
      }),
      uv = e1('ZodEmail', (e, t) => {
        (n1.init(e, t), uh.init(e, t));
      });
    function ub(e) {
      return on(uv, e);
    }
    let u_ = e1('ZodGUID', (e, t) => {
      (nQ.init(e, t), uh.init(e, t));
    });
    function uy(e) {
      return oi(u_, e);
    }
    let ux = e1('ZodUUID', (e, t) => {
      (n0.init(e, t), uh.init(e, t));
    });
    function u$(e) {
      return oa(ux, e);
    }
    function uw(e) {
      return oo(ux, e);
    }
    function uS(e) {
      return os(ux, e);
    }
    function uO(e) {
      return ou(ux, e);
    }
    let uE = e1('ZodURL', (e, t) => {
      (n4.init(e, t), uh.init(e, t));
    });
    function uk(e) {
      return ol(uE, e);
    }
    function uI(e) {
      return ol(uE, { protocol: /^https?$/, hostname: sK.domain, ...sY.normalizeParams(e) });
    }
    let uP = e1('ZodEmoji', (e, t) => {
      (n6.init(e, t), uh.init(e, t));
    });
    function uN(e) {
      return oc(uP, e);
    }
    let uR = e1('ZodNanoID', (e, t) => {
      (n2.init(e, t), uh.init(e, t));
    });
    function uT(e) {
      return od(uR, e);
    }
    let uj = e1('ZodCUID', (e, t) => {
      (n9.init(e, t), uh.init(e, t));
    });
    function uA(e) {
      return of(uj, e);
    }
    let uD = e1('ZodCUID2', (e, t) => {
      (n3.init(e, t), uh.init(e, t));
    });
    function uU(e) {
      return op(uD, e);
    }
    let uz = e1('ZodULID', (e, t) => {
      (n7.init(e, t), uh.init(e, t));
    });
    function uC(e) {
      return om(uz, e);
    }
    let uZ = e1('ZodXID', (e, t) => {
      (n5.init(e, t), uh.init(e, t));
    });
    function uL(e) {
      return og(uZ, e);
    }
    let uM = e1('ZodKSUID', (e, t) => {
      (n8.init(e, t), uh.init(e, t));
    });
    function uB(e) {
      return oh(uM, e);
    }
    let uF = e1('ZodIPv4', (e, t) => {
      (ia.init(e, t), uh.init(e, t));
    });
    function uG(e) {
      return ov(uF, e);
    }
    let uV = e1('ZodIPv6', (e, t) => {
      (io.init(e, t), uh.init(e, t));
    });
    function uX(e) {
      return ob(uV, e);
    }
    let uq = e1('ZodCIDRv4', (e, t) => {
      (is.init(e, t), uh.init(e, t));
    });
    function uW(e) {
      return o_(uq, e);
    }
    let uH = e1('ZodCIDRv6', (e, t) => {
      (iu.init(e, t), uh.init(e, t));
    });
    function uJ(e) {
      return oy(uH, e);
    }
    let uK = e1('ZodBase64', (e, t) => {
      (ic.init(e, t), uh.init(e, t));
    });
    function uY(e) {
      return ox(uK, e);
    }
    let uQ = e1('ZodBase64URL', (e, t) => {
      (ip.init(e, t), uh.init(e, t));
    });
    function u0(e) {
      return o$(uQ, e);
    }
    let u1 = e1('ZodE164', (e, t) => {
      (im.init(e, t), uh.init(e, t));
    });
    function u4(e) {
      return ow(u1, e);
    }
    let u6 = e1('ZodJWT', (e, t) => {
      (ih.init(e, t), uh.init(e, t));
    });
    function u2(e) {
      return oS(u6, e);
    }
    let u9 = e1('ZodCustomStringFormat', (e, t) => {
      (iv.init(e, t), uh.init(e, t));
    });
    function u3(e, t, r = {}) {
      return sX(u9, e, t, r);
    }
    function u7(e) {
      return sX(u9, 'hostname', sK.hostname, e);
    }
    function u5(e) {
      return sX(u9, 'hex', sK.hex, e);
    }
    function u8(e, t) {
      let r = t?.enc ?? 'hex',
        n = `${e}_${r}`,
        i = sK[n];
      if (!i) throw Error(`Unrecognized hash format: ${n}`);
      return sX(u9, n, i, t);
    }
    let le = e1('ZodNumber', (e, t) => {
      (ib.init(e, t),
        uf.init(e, t),
        (e.gt = (t, r) => e.check(o1(t, r))),
        (e.gte = (t, r) => e.check(o4(t, r))),
        (e.min = (t, r) => e.check(o4(t, r))),
        (e.lt = (t, r) => e.check(oQ(t, r))),
        (e.lte = (t, r) => e.check(o0(t, r))),
        (e.max = (t, r) => e.check(o0(t, r))),
        (e.int = (t) => e.check(ln(t))),
        (e.safe = (t) => e.check(ln(t))),
        (e.positive = (t) => e.check(o1(0, t))),
        (e.nonnegative = (t) => e.check(o4(0, t))),
        (e.negative = (t) => e.check(oQ(0, t))),
        (e.nonpositive = (t) => e.check(o0(0, t))),
        (e.multipleOf = (t, r) => e.check(o7(t, r))),
        (e.step = (t, r) => e.check(o7(t, r))),
        (e.finite = () => e));
      let r = e._zod.bag;
      ((e.minValue = Math.max(r.minimum ?? -1 / 0, r.exclusiveMinimum ?? -1 / 0) ?? null),
        (e.maxValue = Math.min(r.maximum ?? 1 / 0, r.exclusiveMaximum ?? 1 / 0) ?? null),
        (e.isInt = (r.format ?? '').includes('int') || Number.isSafeInteger(r.multipleOf ?? 0.5)),
        (e.isFinite = !0),
        (e.format = r.format ?? null));
    });
    function lt(e) {
      return oN(le, e);
    }
    let lr = e1('ZodNumberFormat', (e, t) => {
      (i_.init(e, t), le.init(e, t));
    });
    function ln(e) {
      return oT(lr, e);
    }
    function li(e) {
      return oj(lr, e);
    }
    function la(e) {
      return oA(lr, e);
    }
    function lo(e) {
      return oD(lr, e);
    }
    function ls(e) {
      return oU(lr, e);
    }
    let lu = e1('ZodBoolean', (e, t) => {
      (iy.init(e, t), uf.init(e, t));
    });
    function ll(e) {
      return oz(lu, e);
    }
    let lc = e1('ZodBigInt', (e, t) => {
      (ix.init(e, t),
        uf.init(e, t),
        (e.gte = (t, r) => e.check(o4(t, r))),
        (e.min = (t, r) => e.check(o4(t, r))),
        (e.gt = (t, r) => e.check(o1(t, r))),
        (e.gte = (t, r) => e.check(o4(t, r))),
        (e.min = (t, r) => e.check(o4(t, r))),
        (e.lt = (t, r) => e.check(oQ(t, r))),
        (e.lte = (t, r) => e.check(o0(t, r))),
        (e.max = (t, r) => e.check(o0(t, r))),
        (e.positive = (t) => e.check(o1(BigInt(0), t))),
        (e.negative = (t) => e.check(oQ(BigInt(0), t))),
        (e.nonpositive = (t) => e.check(o0(BigInt(0), t))),
        (e.nonnegative = (t) => e.check(o4(BigInt(0), t))),
        (e.multipleOf = (t, r) => e.check(o7(t, r))));
      let r = e._zod.bag;
      ((e.minValue = r.minimum ?? null),
        (e.maxValue = r.maximum ?? null),
        (e.format = r.format ?? null));
    });
    function ld(e) {
      return oZ(lc, e);
    }
    let lf = e1('ZodBigIntFormat', (e, t) => {
      (i$.init(e, t), lc.init(e, t));
    });
    function lp(e) {
      return oM(lf, e);
    }
    function lm(e) {
      return oB(lf, e);
    }
    let lg = e1('ZodSymbol', (e, t) => {
      (iw.init(e, t), uf.init(e, t));
    });
    function lh(e) {
      return oF(lg, e);
    }
    let lv = e1('ZodUndefined', (e, t) => {
      (iS.init(e, t), uf.init(e, t));
    });
    function lb(e) {
      return oG(lv, e);
    }
    let l_ = e1('ZodNull', (e, t) => {
      (iO.init(e, t), uf.init(e, t));
    });
    function ly(e) {
      return oV(l_, e);
    }
    let lx = e1('ZodAny', (e, t) => {
      (iE.init(e, t), uf.init(e, t));
    });
    function l$() {
      return oX(lx);
    }
    let lw = e1('ZodUnknown', (e, t) => {
      (ik.init(e, t), uf.init(e, t));
    });
    function lS() {
      return oq(lw);
    }
    let lO = e1('ZodNever', (e, t) => {
      (iI.init(e, t), uf.init(e, t));
    });
    function lE(e) {
      return oW(lO, e);
    }
    let lk = e1('ZodVoid', (e, t) => {
      (iP.init(e, t), uf.init(e, t));
    });
    function lI(e) {
      return oH(lk, e);
    }
    let lP = e1('ZodDate', (e, t) => {
      (iN.init(e, t),
        uf.init(e, t),
        (e.min = (t, r) => e.check(o4(t, r))),
        (e.max = (t, r) => e.check(o0(t, r))));
      let r = e._zod.bag;
      ((e.minDate = r.minimum ? new Date(r.minimum) : null),
        (e.maxDate = r.maximum ? new Date(r.maximum) : null));
    });
    function lN(e) {
      return oJ(lP, e);
    }
    let lR = e1('ZodArray', (e, t) => {
      (iT.init(e, t),
        uf.init(e, t),
        (e.element = t.element),
        (e.min = (t, r) => e.check(sr(t, r))),
        (e.nonempty = (t) => e.check(sr(1, t))),
        (e.max = (t, r) => e.check(st(t, r))),
        (e.length = (t, r) => e.check(sn(t, r))),
        (e.unwrap = () => e.element));
    });
    function lT(e, t) {
      return sv(lR, e, t);
    }
    function lj(e) {
      return l0(Object.keys(e._zod.def.shape));
    }
    let lA = e1('ZodObject', (e, t) => {
      (iz.init(e, t),
        uf.init(e, t),
        sY.defineLazy(e, 'shape', () => t.shape),
        (e.keyof = () => l0(Object.keys(e._zod.def.shape))),
        (e.catchall = (t) => e.clone({ ...e._zod.def, catchall: t })),
        (e.passthrough = () => e.clone({ ...e._zod.def, catchall: lS() })),
        (e.loose = () => e.clone({ ...e._zod.def, catchall: lS() })),
        (e.strict = () => e.clone({ ...e._zod.def, catchall: lE() })),
        (e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 })),
        (e.extend = (t) => sY.extend(e, t)),
        (e.safeExtend = (t) => sY.safeExtend(e, t)),
        (e.merge = (t) => sY.merge(e, t)),
        (e.pick = (t) => sY.pick(e, t)),
        (e.omit = (t) => sY.omit(e, t)),
        (e.partial = (...t) => sY.partial(l5, e, t[0])),
        (e.required = (...t) => sY.required(cs, e, t[0])));
    });
    function lD(e, t) {
      return new lA({
        type: 'object',
        get shape() {
          return (sY.assignProp(this, 'shape', e ? sY.objectClone(e) : {}), this.shape);
        },
        ...sY.normalizeParams(t),
      });
    }
    function lU(e, t) {
      return new lA({
        type: 'object',
        get shape() {
          return (sY.assignProp(this, 'shape', sY.objectClone(e)), this.shape);
        },
        catchall: lE(),
        ...sY.normalizeParams(t),
      });
    }
    function lz(e, t) {
      return new lA({
        type: 'object',
        get shape() {
          return (sY.assignProp(this, 'shape', sY.objectClone(e)), this.shape);
        },
        catchall: lS(),
        ...sY.normalizeParams(t),
      });
    }
    let lC = e1('ZodUnion', (e, t) => {
      (iZ.init(e, t), uf.init(e, t), (e.options = t.options));
    });
    function lZ(e, t) {
      return new lC({ type: 'union', options: e, ...sY.normalizeParams(t) });
    }
    let lL = e1('ZodDiscriminatedUnion', (e, t) => {
      (lC.init(e, t), iL.init(e, t));
    });
    function lM(e, t, r) {
      return new lL({ type: 'union', options: t, discriminator: e, ...sY.normalizeParams(r) });
    }
    let lB = e1('ZodIntersection', (e, t) => {
      (iM.init(e, t), uf.init(e, t));
    });
    function lF(e, t) {
      return new lB({ type: 'intersection', left: e, right: t });
    }
    let lG = e1('ZodTuple', (e, t) => {
      (iF.init(e, t), uf.init(e, t), (e.rest = (t) => e.clone({ ...e._zod.def, rest: t })));
    });
    function lV(e, t, r) {
      let n = t instanceof nJ,
        i = n ? r : t;
      return new lG({ type: 'tuple', items: e, rest: n ? t : null, ...sY.normalizeParams(i) });
    }
    let lX = e1('ZodRecord', (e, t) => {
      (iV.init(e, t), uf.init(e, t), (e.keyType = t.keyType), (e.valueType = t.valueType));
    });
    function lq(e, t, r) {
      return new lX({ type: 'record', keyType: e, valueType: t, ...sY.normalizeParams(r) });
    }
    function lW(e, t, r) {
      let n = tP(e);
      return (
        (n._zod.values = void 0),
        new lX({ type: 'record', keyType: n, valueType: t, ...sY.normalizeParams(r) })
      );
    }
    let lH = e1('ZodMap', (e, t) => {
      (iX.init(e, t), uf.init(e, t), (e.keyType = t.keyType), (e.valueType = t.valueType));
    });
    function lJ(e, t, r) {
      return new lH({ type: 'map', keyType: e, valueType: t, ...sY.normalizeParams(r) });
    }
    let lK = e1('ZodSet', (e, t) => {
      (iW.init(e, t),
        uf.init(e, t),
        (e.min = (...t) => e.check(o8(...t))),
        (e.nonempty = (t) => e.check(o8(1, t))),
        (e.max = (...t) => e.check(o5(...t))),
        (e.size = (...t) => e.check(se(...t))));
    });
    function lY(e, t) {
      return new lK({ type: 'set', valueType: e, ...sY.normalizeParams(t) });
    }
    let lQ = e1('ZodEnum', (e, t) => {
      (iJ.init(e, t), uf.init(e, t), (e.enum = t.entries), (e.options = Object.values(t.entries)));
      let r = new Set(Object.keys(t.entries));
      ((e.extract = (e, n) => {
        let i = {};
        for (let n of e)
          if (r.has(n)) i[n] = t.entries[n];
          else throw Error(`Key ${n} not found in enum`);
        return new lQ({ ...t, checks: [], ...sY.normalizeParams(n), entries: i });
      }),
        (e.exclude = (e, n) => {
          let i = { ...t.entries };
          for (let t of e)
            if (r.has(t)) delete i[t];
            else throw Error(`Key ${t} not found in enum`);
          return new lQ({ ...t, checks: [], ...sY.normalizeParams(n), entries: i });
        }));
    });
    function l0(e, t) {
      return new lQ({
        type: 'enum',
        entries: Array.isArray(e) ? Object.fromEntries(e.map((e) => [e, e])) : e,
        ...sY.normalizeParams(t),
      });
    }
    function l1(e, t) {
      return new lQ({ type: 'enum', entries: e, ...sY.normalizeParams(t) });
    }
    let l4 = e1('ZodLiteral', (e, t) => {
      (iK.init(e, t),
        uf.init(e, t),
        (e.values = new Set(t.values)),
        Object.defineProperty(e, 'value', {
          get() {
            if (t.values.length > 1)
              throw Error(
                'This schema contains multiple valid literal values. Use `.values` instead.'
              );
            return t.values[0];
          },
        }));
    });
    function l6(e, t) {
      return new l4({
        type: 'literal',
        values: Array.isArray(e) ? e : [e],
        ...sY.normalizeParams(t),
      });
    }
    let l2 = e1('ZodFile', (e, t) => {
      (iY.init(e, t),
        uf.init(e, t),
        (e.min = (t, r) => e.check(o8(t, r))),
        (e.max = (t, r) => e.check(o5(t, r))),
        (e.mime = (t, r) => e.check(sd(Array.isArray(t) ? t : [t], r))));
    });
    function l9(e) {
      return sI(l2, e);
    }
    let l3 = e1('ZodTransform', (e, t) => {
      (iQ.init(e, t),
        uf.init(e, t),
        (e._zod.parse = (r, n) => {
          if ('backward' === n.direction) throw new e2(e.constructor.name);
          r.addIssue = (n) => {
            'string' == typeof n
              ? r.issues.push(sY.issue(n, r.value, t))
              : (n.fatal && (n.continue = !1),
                n.code ?? (n.code = 'custom'),
                n.input ?? (n.input = r.value),
                n.inst ?? (n.inst = e),
                r.issues.push(sY.issue(n)));
          };
          let i = t.transform(r.value, r);
          return i instanceof Promise ? i.then((e) => ((r.value = e), r)) : ((r.value = i), r);
        }));
    });
    function l7(e) {
      return new l3({ type: 'transform', transform: e });
    }
    let l5 = e1('ZodOptional', (e, t) => {
      (i1.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function l8(e) {
      return new l5({ type: 'optional', innerType: e });
    }
    let ce = e1('ZodNullable', (e, t) => {
      (i4.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function ct(e) {
      return new ce({ type: 'nullable', innerType: e });
    }
    function cr(e) {
      return l8(ct(e));
    }
    let cn = e1('ZodDefault', (e, t) => {
      (i6.init(e, t),
        uf.init(e, t),
        (e.unwrap = () => e._zod.def.innerType),
        (e.removeDefault = e.unwrap));
    });
    function ci(e, t) {
      return new cn({
        type: 'default',
        innerType: e,
        get defaultValue() {
          return 'function' == typeof t ? t() : sY.shallowClone(t);
        },
      });
    }
    let ca = e1('ZodPrefault', (e, t) => {
      (i9.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function co(e, t) {
      return new ca({
        type: 'prefault',
        innerType: e,
        get defaultValue() {
          return 'function' == typeof t ? t() : sY.shallowClone(t);
        },
      });
    }
    let cs = e1('ZodNonOptional', (e, t) => {
      (i3.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function cu(e, t) {
      return new cs({ type: 'nonoptional', innerType: e, ...sY.normalizeParams(t) });
    }
    let cl = e1('ZodSuccess', (e, t) => {
      (i5.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function cc(e) {
      return new cl({ type: 'success', innerType: e });
    }
    let cd = e1('ZodCatch', (e, t) => {
      (i8.init(e, t),
        uf.init(e, t),
        (e.unwrap = () => e._zod.def.innerType),
        (e.removeCatch = e.unwrap));
    });
    function cf(e, t) {
      return new cd({
        type: 'catch',
        innerType: e,
        catchValue: 'function' == typeof t ? t : () => t,
      });
    }
    let cp = e1('ZodNaN', (e, t) => {
      (ae.init(e, t), uf.init(e, t));
    });
    function cm(e) {
      return oY(cp, e);
    }
    let cg = e1('ZodPipe', (e, t) => {
      (at.init(e, t), uf.init(e, t), (e.in = t.in), (e.out = t.out));
    });
    function ch(e, t) {
      return new cg({ type: 'pipe', in: e, out: t });
    }
    let cv = e1('ZodCodec', (e, t) => {
      (cg.init(e, t), an.init(e, t));
    });
    function cb(e, t, r) {
      return new cv({
        type: 'pipe',
        in: e,
        out: t,
        transform: r.decode,
        reverseTransform: r.encode,
      });
    }
    let c_ = e1('ZodReadonly', (e, t) => {
      (ao.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function cy(e) {
      return new c_({ type: 'readonly', innerType: e });
    }
    let cx = e1('ZodTemplateLiteral', (e, t) => {
      (au.init(e, t), uf.init(e, t));
    });
    function c$(e, t) {
      return new cx({ type: 'template_literal', parts: e, ...sY.normalizeParams(t) });
    }
    let cw = e1('ZodLazy', (e, t) => {
      (ad.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.getter()));
    });
    function cS(e) {
      return new cw({ type: 'lazy', getter: e });
    }
    let cO = e1('ZodPromise', (e, t) => {
      (ac.init(e, t), uf.init(e, t), (e.unwrap = () => e._zod.def.innerType));
    });
    function cE(e) {
      return new cO({ type: 'promise', innerType: e });
    }
    let ck = e1('ZodFunction', (e, t) => {
      (al.init(e, t), uf.init(e, t));
    });
    function cI(e) {
      return new ck({
        type: 'function',
        input: Array.isArray(e?.input) ? lV(e?.input) : (e?.input ?? lT(lS())),
        output: e?.output ?? lS(),
      });
    }
    let cP = e1('ZodCustom', (e, t) => {
      (af.init(e, t), uf.init(e, t));
    });
    function cN(e) {
      let t = new nS({ check: 'custom' });
      return ((t._zod.check = e), t);
    }
    function cR(e, t) {
      return sM(cP, e ?? (() => !0), t);
    }
    function cT(e, t = {}) {
      return sB(cP, e, t);
    }
    function cj(e) {
      return sF(e);
    }
    function cA(e, t = { error: `Input not instance of ${e.name}` }) {
      let r = new cP({
        type: 'custom',
        check: 'custom',
        fn: (t) => t instanceof e,
        abort: !0,
        ...sY.normalizeParams(t),
      });
      return ((r._zod.bag.Class = e), r);
    }
    let cD = (...e) => sV({ Codec: cv, Boolean: lu, String: um }, ...e);
    function cU(e) {
      let t = cS(() => lZ([ug(e), lt(), ll(), ly(), lT(t), lq(ug(), t)]));
      return t;
    }
    function cz(e, t) {
      return ch(l7(e), t);
    }
    (e.i(91871),
      e.s(
        [
          'endsWith',
          () => sl,
          'gt',
          () => o1,
          'gte',
          () => o4,
          'includes',
          () => ss,
          'length',
          () => sn,
          'lowercase',
          () => sa,
          'lt',
          () => oQ,
          'lte',
          () => o0,
          'maxLength',
          () => st,
          'maxSize',
          () => o5,
          'mime',
          () => sd,
          'minLength',
          () => sr,
          'minSize',
          () => o8,
          'multipleOf',
          () => o7,
          'negative',
          () => o2,
          'nonnegative',
          () => o3,
          'nonpositive',
          () => o9,
          'normalize',
          () => sp,
          'overwrite',
          () => sf,
          'positive',
          () => o6,
          'property',
          () => sc,
          'regex',
          () => si,
          'size',
          () => se,
          'startsWith',
          () => su,
          'toLowerCase',
          () => sg,
          'toUpperCase',
          () => sh,
          'trim',
          () => sm,
          'uppercase',
          () => so,
        ],
        10011
      ),
      e.s([], 86084),
      e.i(86084),
      e.i(10011),
      e.i(64911),
      e.i(52083),
      e.s(
        [
          '$brand',
          () => e4,
          'ZodFirstPartyTypeKind',
          () => i,
          'ZodIssueCode',
          () => cC,
          'config',
          () => e3,
          'getErrorMap',
          () => cL,
          'setErrorMap',
          () => cZ,
        ],
        68796
      ),
      e.s(
        [
          'ZodFirstPartyTypeKind',
          () => i,
          'ZodIssueCode',
          () => cC,
          'getErrorMap',
          () => cL,
          'setErrorMap',
          () => cZ,
        ],
        53174
      ));
    let cC = {
      invalid_type: 'invalid_type',
      too_big: 'too_big',
      too_small: 'too_small',
      invalid_format: 'invalid_format',
      not_multiple_of: 'not_multiple_of',
      unrecognized_keys: 'unrecognized_keys',
      invalid_union: 'invalid_union',
      invalid_key: 'invalid_key',
      invalid_element: 'invalid_element',
      invalid_value: 'invalid_value',
      custom: 'custom',
    };
    function cZ(e) {
      e3({ customError: e });
    }
    function cL() {
      return e3().customError;
    }
    (i || (i = {}), e.i(53174), e.i(68796));
    var sK = ag,
      sY = am,
      cM = a9,
      cB = e.i(73673);
    function cF(e) {
      return or(um, e);
    }
    function cG(e) {
      return oR(le, e);
    }
    function cV(e) {
      return oC(lu, e);
    }
    function cX(e) {
      return oL(lc, e);
    }
    function cq(e) {
      return oK(lP, e);
    }
    e.s(
      [
        'bigint',
        () => cX,
        'boolean',
        () => cV,
        'date',
        () => cq,
        'number',
        () => cG,
        'string',
        () => cF,
      ],
      24576
    );
    var cW = e.i(24576),
      cH = e.i(23629),
      cH = cH;
    let cJ = (function (e) {
        let t = 'object' == typeof e.client ? e.client : {},
          r = 'object' == typeof e.server ? e.server : {},
          n = e.shared,
          i = e.runtimeEnv ? e.runtimeEnv : { ...process.env, ...e.experimental__runtimeEnv };
        return (function (e) {
          let t = e.runtimeEnvStrict ?? e.runtimeEnv ?? process.env;
          if (e.emptyStringAsUndefined)
            for (let [e, r] of Object.entries(t)) '' === r && delete t[e];
          if (e.skipValidation) return t;
          let r = 'object' == typeof e.client ? e.client : {},
            n = 'object' == typeof e.server ? e.server : {},
            i = 'object' == typeof e.shared ? e.shared : {},
            a = e.isServer ?? !0,
            o = a ? { ...n, ...i, ...r } : { ...r, ...i },
            s =
              e.createFinalSchema?.(o, a)['~standard'].validate(t) ??
              (function (e, t) {
                let r = {},
                  n = [];
                for (let i in e) {
                  let a = e[i]['~standard'].validate(t[i]);
                  if (
                    (eQ(a, `Validation must be synchronous, but ${i} returned a Promise.`),
                    a.issues)
                  ) {
                    n.push(
                      ...a.issues.map((e) => ({
                        ...e,
                        message: e.message,
                        path: [i, ...(e.path ?? [])],
                      }))
                    );
                    continue;
                  }
                  r[i] = a.value;
                }
                return n.length ? { issues: n } : { value: r };
              })(o, t);
          eQ(s, 'Validation must be synchronous');
          let u =
              e.onValidationError ??
              ((e) => {
                throw (
                  console.error('❌ Invalid environment variables:', e),
                  Error('Invalid environment variables')
                );
              }),
            l =
              e.onInvalidAccess ??
              (() => {
                throw Error(
                  '❌ Attempted to access a server-side environment variable on the client'
                );
              });
          return s.issues
            ? u(s.issues)
            : new Proxy(
                Object.assign(
                  (e.extends ?? []).reduce((e, t) => Object.assign(e, t), {}),
                  s.value
                ),
                {
                  get(t, r) {
                    if ('string' == typeof r && '__esModule' !== r && '$$typeof' !== r)
                      return a || (e.clientPrefix && (r.startsWith(e.clientPrefix) || r in i))
                        ? Reflect.get(t, r)
                        : l(r);
                  },
                }
              );
        })({ ...e, shared: n, client: t, server: r, clientPrefix: 'NEXT_PUBLIC_', runtimeEnv: i });
      })({
        server: {
          NODE_ENV: cH.enum(['development', 'test', 'production']).default('development'),
          SENTRY_DSN: cH.string().url().optional(),
          SENTRY_ORG: cH.string().optional(),
          SENTRY_PROJECT: cH.string().optional(),
          DATABASE_URL: cH.string().url().optional(),
          SUPABASE_URL: cH.string().url().optional(),
          SUPABASE_ANON_KEY: cH.string().min(1).optional(),
          STRIPE_WEBHOOK_SECRET: cH.string().optional(),
        },
        client: {
          NEXT_PUBLIC_APP_NAME: cH.string().default('DL Starter'),
          NEXT_PUBLIC_POSTHOG_KEY: cH.string().optional(),
          NEXT_PUBLIC_SENTRY_DSN: cH.string().url().optional(),
        },
        runtimeEnv: {
          NODE_ENV: 'production',
          SENTRY_DSN: process.env.SENTRY_DSN,
          SENTRY_ORG: process.env.SENTRY_ORG,
          SENTRY_PROJECT: process.env.SENTRY_PROJECT,
          DATABASE_URL: process.env.DATABASE_URL,
          SUPABASE_URL: process.env.SUPABASE_URL,
          SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
          STRIPE_WEBHOOK_SECRET: process.env.STRIPE_WEBHOOK_SECRET,
          NEXT_PUBLIC_APP_NAME: process.env.NEXT_PUBLIC_APP_NAME,
          NEXT_PUBLIC_POSTHOG_KEY: process.env.NEXT_PUBLIC_POSTHOG_KEY,
          NEXT_PUBLIC_SENTRY_DSN: process.env.NEXT_PUBLIC_SENTRY_DSN,
        },
        emptyStringAsUndefined: !0,
      }),
      cK = 'force-dynamic';
    async function cY() {
      return eY.NextResponse.json({
        ok: !0,
        appName: cJ.NEXT_PUBLIC_APP_NAME,
        hasSupabase: !!(cJ.SUPABASE_URL && cJ.SUPABASE_ANON_KEY),
      });
    }
    var cQ = e.i(49345);
    let c0 = new a.AppRouteRouteModule({
        definition: {
          kind: o.APP_ROUTE,
          page: '/api/health/route',
          pathname: '/api/health',
          filename: 'route',
          bundlePath: '',
        },
        distDir: '.next',
        relativeProjectDir: '',
        resolvedPagePath: '[project]/apps/web/src/app/api/health/route.ts',
        nextConfigOutput: '',
        userland: cQ,
      }),
      { workAsyncStorage: c1, workUnitAsyncStorage: c4, serverHooks: c6 } = c0;
    function c2() {
      if (!0 === globalThis[eU]) return;
      let e = (function (e) {
        let t = z.cache((e) => []);
        return function (r, n) {
          let i, a;
          if (n && n.signal) return e(r, n);
          if ('string' != typeof r || n) {
            let t = 'string' == typeof r || r instanceof URL ? new Request(r, n) : r;
            if (('GET' !== t.method && 'HEAD' !== t.method) || t.keepalive) return e(r, n);
            ((a = JSON.stringify([
              t.method,
              Array.from(t.headers.entries()),
              t.mode,
              t.redirect,
              t.credentials,
              t.referrer,
              t.referrerPolicy,
              t.integrity,
            ])),
              (i = t.url));
          } else ((a = '["GET",[],null,"follow",null,null,null,null]'), (i = r));
          let o = t(i);
          for (let e = 0, t = o.length; e < t; e += 1) {
            let [t, r] = o[e];
            if (t === a)
              return r.then(() => {
                let t = o[e][2];
                if (!t)
                  throw Object.defineProperty(new V('No cached response'), '__NEXT_ERROR_CODE', {
                    value: 'E579',
                    enumerable: !1,
                    configurable: !0,
                  });
                let [r, n] = J(t);
                return ((o[e][2] = n), r);
              });
          }
          let s = e(r, n),
            u = [a, s, null];
          return (
            o.push(u),
            s.then((e) => {
              let [t, r] = J(e);
              return ((u[2] = r), t);
            })
          );
        };
      })(globalThis.fetch);
      globalThis.fetch = (function (e, { workAsyncStorage: t, workUnitAsyncStorage: r }) {
        let n = async function (n, i) {
          var a, o;
          let s;
          try {
            (((s = new URL(n instanceof Request ? n.url : n)).username = ''), (s.password = ''));
          } catch {
            s = void 0;
          }
          let u = (null == s ? void 0 : s.href) ?? '',
            l = (null == i || null == (a = i.method) ? void 0 : a.toUpperCase()) || 'GET',
            d = (null == i || null == (o = i.next) ? void 0 : o.internal) === !0,
            f = '1' === process.env.NEXT_OTEL_FETCH_DISABLED,
            m = d ? void 0 : performance.timeOrigin + performance.now(),
            g = t.getStore(),
            h = r.getStore(),
            v = h ? (0, L.getCacheSignal)(h) : null;
          v && v.beginRead();
          let b = A().trace(
            d ? c.internalFetch : p.fetch,
            {
              hideSpan: f,
              kind: O.CLIENT,
              spanName: ['fetch', l, u].filter(Boolean).join(' '),
              attributes: {
                'http.url': u,
                'http.method': l,
                'net.peer.name': null == s ? void 0 : s.hostname,
                'net.peer.port': (null == s ? void 0 : s.port) || void 0,
              },
            },
            async () => {
              var t;
              let r, a, o, s, l, c;
              if (d || !g || g.isDraftMode) return e(n, i);
              let f = n && 'object' == typeof n && 'string' == typeof n.method,
                p = (e) => (null == i ? void 0 : i[e]) || (f ? n[e] : null),
                b = (e) => {
                  var t, r, a;
                  return void 0 !== (null == i || null == (t = i.next) ? void 0 : t[e])
                    ? null == i || null == (r = i.next)
                      ? void 0
                      : r[e]
                    : f
                      ? null == (a = n.next)
                        ? void 0
                        : a[e]
                      : void 0;
                },
                _ = b('revalidate'),
                y = _,
                x = (function (e, t) {
                  let r = [],
                    n = [];
                  for (let i = 0; i < e.length; i++) {
                    let a = e[i];
                    if (
                      ('string' != typeof a
                        ? n.push({ tag: a, reason: 'invalid type, must be a string' })
                        : a.length > 256
                          ? n.push({ tag: a, reason: 'exceeded max length of 256' })
                          : r.push(a),
                      r.length > 128)
                    ) {
                      console.warn(
                        `Warning: exceeded max tag count for ${t}, dropped tags:`,
                        e.slice(i).join(', ')
                      );
                      break;
                    }
                  }
                  if (n.length > 0)
                    for (let { tag: e, reason: r } of (console.warn(
                      `Warning: invalid tags passed to ${t}: `
                    ),
                    n))
                      console.log(`tag: "${e}" ${r}`);
                  return r;
                })(b('tags') || [], `fetch ${n.toString()}`);
              if (h)
                switch (h.type) {
                  case 'prerender':
                  case 'prerender-runtime':
                  case 'prerender-client':
                  case 'prerender-ppr':
                  case 'prerender-legacy':
                  case 'cache':
                  case 'private-cache':
                    r = h;
                }
              if (r && Array.isArray(x)) {
                let e = r.tags ?? (r.tags = []);
                for (let t of x) e.includes(t) || e.push(t);
              }
              let $ = null == h ? void 0 : h.implicitTags,
                w = g.fetchCache;
              h && 'unstable-cache' === h.type && (w = 'force-no-store');
              let S = !!g.isUnstableNoStore,
                O = p('cache'),
                E = '';
              'string' == typeof O &&
                void 0 !== y &&
                (('force-cache' === O && 0 === y) || ('no-store' === O && (y > 0 || !1 === y))) &&
                ((a = `Specified "cache: ${O}" and "revalidate: ${y}", only one should be specified.`),
                (O = void 0),
                (y = void 0));
              let k =
                  'no-cache' === O ||
                  'no-store' === O ||
                  'force-no-store' === w ||
                  'only-no-store' === w,
                I = !w && !O && !y && g.forceDynamic;
              ('force-cache' === O && void 0 === y ? (y = !1) : (k || I) && (y = 0),
                ('no-cache' === O || 'no-store' === O) && (E = `cache: ${O}`),
                (c = (function (e, t) {
                  try {
                    let r;
                    if (!1 === e) r = 0xfffffffe;
                    else if ('number' == typeof e && !isNaN(e) && e > -1) r = e;
                    else if (void 0 !== e)
                      throw Object.defineProperty(
                        Error(
                          `Invalid revalidate value "${e}" on "${t}", must be a non-negative number or false`
                        ),
                        '__NEXT_ERROR_CODE',
                        { value: 'E179', enumerable: !1, configurable: !0 }
                      );
                    return r;
                  } catch (e) {
                    if (e instanceof Error && e.message.includes('Invalid revalidate')) throw e;
                    return;
                  }
                })(y, g.route)));
              let P = p('headers'),
                N = 'function' == typeof (null == P ? void 0 : P.get) ? P : new Headers(P || {}),
                R = N.get('authorization') || N.get('cookie'),
                T = !['get', 'head'].includes(
                  (null == (t = p('method')) ? void 0 : t.toLowerCase()) || 'get'
                ),
                j = void 0 == w && (void 0 == O || 'default' === O) && void 0 == y,
                A = !!((R || T) && (null == r ? void 0 : r.revalidate) === 0),
                D = !1;
              if ((!A && j && (g.isBuildTimePrerendering ? (D = !0) : (A = !0)), j && void 0 !== h))
                switch (h.type) {
                  case 'prerender':
                  case 'prerender-runtime':
                  case 'prerender-client':
                    return (v && (v.endRead(), (v = null)), F(h.renderSignal, g.route, 'fetch()'));
                }
              switch (w) {
                case 'force-no-store':
                  E = 'fetchCache = force-no-store';
                  break;
                case 'only-no-store':
                  if ('force-cache' === O || (void 0 !== c && c > 0))
                    throw Object.defineProperty(
                      Error(
                        `cache: 'force-cache' used on fetch for ${u} with 'export const fetchCache = 'only-no-store'`
                      ),
                      '__NEXT_ERROR_CODE',
                      { value: 'E448', enumerable: !1, configurable: !0 }
                    );
                  E = 'fetchCache = only-no-store';
                  break;
                case 'only-cache':
                  if ('no-store' === O)
                    throw Object.defineProperty(
                      Error(
                        `cache: 'no-store' used on fetch for ${u} with 'export const fetchCache = 'only-cache'`
                      ),
                      '__NEXT_ERROR_CODE',
                      { value: 'E521', enumerable: !1, configurable: !0 }
                    );
                  break;
                case 'force-cache':
                  (void 0 === y || 0 === y) && ((E = 'fetchCache = force-cache'), (c = 0xfffffffe));
              }
              if (
                (void 0 === c
                  ? 'default-cache' !== w || S
                    ? 'default-no-store' === w
                      ? ((c = 0), (E = 'fetchCache = default-no-store'))
                      : S
                        ? ((c = 0), (E = 'noStore call'))
                        : A
                          ? ((c = 0), (E = 'auto no cache'))
                          : ((E = 'auto cache'), (c = r ? r.revalidate : 0xfffffffe))
                    : ((c = 0xfffffffe), (E = 'fetchCache = default-cache'))
                  : E || (E = `revalidate: ${c}`),
                !(g.forceStatic && 0 === c) && !A && r && c < r.revalidate)
              ) {
                if (0 === c) {
                  if (h)
                    switch (h.type) {
                      case 'prerender':
                      case 'prerender-client':
                      case 'prerender-runtime':
                        return (
                          v && (v.endRead(), (v = null)),
                          F(h.renderSignal, g.route, 'fetch()')
                        );
                    }
                  q(g, h, `revalidate: 0 fetch ${n} ${g.route}`);
                }
                r && _ === c && (r.revalidate = c);
              }
              let U = 'number' == typeof c && c > 0,
                { incrementalCache: z } = g,
                C = !1;
              if (h)
                switch (h.type) {
                  case 'request':
                  case 'cache':
                  case 'private-cache':
                    ((C = h.isHmrRefresh ?? !1), (s = h.serverComponentsHmrCache));
                }
              if (z && (U || s))
                try {
                  o = await z.generateCacheKey(u, f ? n : i);
                } catch (e) {
                  console.error('Failed to generate cache key for', n);
                }
              let Z = g.nextFetchId ?? 1;
              g.nextFetchId = Z + 1;
              let L = () => {},
                M = async (t, r) => {
                  let l = [
                    'cache',
                    'credentials',
                    'headers',
                    'integrity',
                    'keepalive',
                    'method',
                    'mode',
                    'redirect',
                    'referrer',
                    'referrerPolicy',
                    'window',
                    'duplex',
                    ...(t ? [] : ['signal']),
                  ];
                  if (f) {
                    let e = n,
                      t = { body: e._ogBody || e.body };
                    for (let r of l) t[r] = e[r];
                    n = new Request(e.url, t);
                  } else if (i) {
                    let { _ogBody: e, body: r, signal: n, ...a } = i;
                    i = { ...a, body: e || r, signal: t ? void 0 : n };
                  }
                  let d = {
                    ...i,
                    next: { ...(null == i ? void 0 : i.next), fetchType: 'origin', fetchIdx: Z },
                  };
                  return e(n, d)
                    .then(async (e) => {
                      if (
                        (!t &&
                          m &&
                          ez(g, {
                            start: m,
                            url: u,
                            cacheReason: r || E,
                            cacheStatus: 0 === c || r ? 'skip' : 'miss',
                            cacheWarning: a,
                            status: e.status,
                            method: d.method || 'GET',
                          }),
                        200 === e.status && z && o && (U || s))
                      ) {
                        let t = c >= 0xfffffffe ? 31536e3 : c,
                          r = U
                            ? {
                                fetchCache: !0,
                                fetchUrl: u,
                                fetchIdx: Z,
                                tags: x,
                                isImplicitBuildTimeCache: D,
                              }
                            : void 0;
                        switch (null == h ? void 0 : h.type) {
                          case 'prerender':
                          case 'prerender-client':
                          case 'prerender-runtime':
                            return eC(e, o, r, z, t, L);
                          case 'prerender-ppr':
                          case 'prerender-legacy':
                          case 'request':
                          case 'cache':
                          case 'private-cache':
                          case 'unstable-cache':
                          case void 0:
                            return eZ(g, e, o, r, z, s, t, n, L);
                        }
                      }
                      return (await L(), e);
                    })
                    .catch((e) => {
                      throw (L(), e);
                    });
                },
                B = !1,
                G = !1;
              if (o && z) {
                let e;
                if ((C && s && ((e = s.get(o)), (G = !0)), U && !e)) {
                  L = await z.lock(o);
                  let t = g.isOnDemandRevalidate
                    ? null
                    : await z.get(o, {
                        kind: Q.FETCH,
                        revalidate: c,
                        fetchUrl: u,
                        fetchIdx: Z,
                        tags: x,
                        softTags: null == $ ? void 0 : $.tags,
                      });
                  if (j && h)
                    switch (h.type) {
                      case 'prerender':
                      case 'prerender-client':
                      case 'prerender-runtime':
                        await new Promise((e) => setImmediate(e));
                    }
                  if (
                    (t ? await L() : (l = 'cache-control: no-cache (hard refresh)'),
                    (null == t ? void 0 : t.value) && t.value.kind === Y.FETCH)
                  )
                    if (g.isRevalidate && t.isStale) B = !0;
                    else {
                      if (t.isStale && ((g.pendingRevalidates ??= {}), !g.pendingRevalidates[o])) {
                        let e = M(!0)
                          .then(async (e) => ({
                            body: await e.arrayBuffer(),
                            headers: e.headers,
                            status: e.status,
                            statusText: e.statusText,
                          }))
                          .finally(() => {
                            ((g.pendingRevalidates ??= {}), delete g.pendingRevalidates[o || '']);
                          });
                        (e.catch(console.error), (g.pendingRevalidates[o] = e));
                      }
                      e = t.value.data;
                    }
                }
                if (e) {
                  m &&
                    ez(g, {
                      start: m,
                      url: u,
                      cacheReason: E,
                      cacheStatus: G ? 'hmr' : 'hit',
                      cacheWarning: a,
                      status: e.status || 200,
                      method: (null == i ? void 0 : i.method) || 'GET',
                    });
                  let t = new Response(Buffer.from(e.body, 'base64'), {
                    headers: e.headers,
                    status: e.status,
                  });
                  return (Object.defineProperty(t, 'url', { value: e.url }), t);
                }
              }
              if (g.isStaticGeneration && i && 'object' == typeof i) {
                let { cache: e } = i;
                if ('no-store' === e) {
                  if (h)
                    switch (h.type) {
                      case 'prerender':
                      case 'prerender-client':
                      case 'prerender-runtime':
                        return (
                          v && (v.endRead(), (v = null)),
                          F(h.renderSignal, g.route, 'fetch()')
                        );
                    }
                  q(g, h, `no-store fetch ${n} ${g.route}`);
                }
                let t = 'next' in i,
                  { next: a = {} } = i;
                if ('number' == typeof a.revalidate && r && a.revalidate < r.revalidate) {
                  if (0 === a.revalidate) {
                    if (h)
                      switch (h.type) {
                        case 'prerender':
                        case 'prerender-client':
                        case 'prerender-runtime':
                          return F(h.renderSignal, g.route, 'fetch()');
                      }
                    q(g, h, `revalidate: 0 fetch ${n} ${g.route}`);
                  }
                  (g.forceStatic && 0 === a.revalidate) || (r.revalidate = a.revalidate);
                }
                t && delete i.next;
              }
              if (!o || !B) return M(!1, l);
              {
                let e = o;
                g.pendingRevalidates ??= {};
                let t = g.pendingRevalidates[e];
                if (t) {
                  let e = await t;
                  return new Response(e.body, {
                    headers: e.headers,
                    status: e.status,
                    statusText: e.statusText,
                  });
                }
                let r = M(!0, l).then(J);
                return (
                  (t = r
                    .then(async (e) => {
                      let t = e[0];
                      return {
                        body: await t.arrayBuffer(),
                        headers: t.headers,
                        status: t.status,
                        statusText: t.statusText,
                      };
                    })
                    .finally(() => {
                      var t;
                      (null == (t = g.pendingRevalidates) ? void 0 : t[e]) &&
                        delete g.pendingRevalidates[e];
                    })).catch(() => {}),
                  (g.pendingRevalidates[e] = t),
                  r.then((e) => e[1])
                );
              }
            }
          );
          if (v)
            try {
              return await b;
            } finally {
              v && v.endRead();
            }
          return b;
        };
        return (
          (n.__nextPatched = !0),
          (n.__nextGetStaticStore = () => t),
          (n._nextOriginalFetch = e),
          (globalThis[eU] = !0),
          Object.defineProperty(n, 'name', { value: 'fetch', writable: !1 }),
          n
        );
      })(e, { workAsyncStorage: c1, workUnitAsyncStorage: c4 });
    }
    async function c9(e, t, r) {
      var n, i;
      let a = '/api/health/route';
      a = a.replace(/\/index$/, '') || '/';
      let u = await c0.prepare(e, t, { srcPage: a, multiZoneDraftMode: !1 });
      if (!u)
        return (
          (t.statusCode = 400),
          t.end('Bad Request'),
          null == r.waitUntil || r.waitUntil.call(r, Promise.resolve()),
          null
        );
      let {
          buildId: l,
          params: c,
          nextConfig: d,
          isDraftMode: f,
          prerenderManifest: p,
          routerServerContext: m,
          isOnDemandRevalidate: g,
          revalidateOnlyGenerated: h,
          resolvedPathname: v,
        } = u,
        b = (i = a
          .split('/')
          .reduce(
            (e, t, r, n) =>
              t
                ? ('(' === t[0] && t.endsWith(')')) ||
                  '@' === t[0] ||
                  (('page' === t || 'route' === t) && r === n.length - 1)
                  ? e
                  : e + '/' + t
                : e,
            ''
          )).startsWith('/')
          ? i
          : '/' + i,
        _ = !!(p.dynamicRoutes[b] || p.routes[v]);
      if (_ && !f) {
        let e = !!p.routes[v],
          t = p.dynamicRoutes[b];
        if (t && !1 === t.fallback && !e) throw new eK.NoFallbackError();
      }
      let y = null;
      !_ || c0.isDev || f || (y = '/index' === (y = v) ? '/' : y);
      let x = !0 === c0.isDev || !_,
        $ = _ && !x,
        w = e.method || 'GET',
        S = A(),
        E = S.getActiveScopeSpan(),
        k = {
          params: c,
          prerenderManifest: p,
          renderOpts: {
            experimental: {
              cacheComponents: !!d.experimental.cacheComponents,
              authInterrupts: !!d.experimental.authInterrupts,
            },
            supportsDynamicResponse: x,
            incrementalCache: eo(e, 'incrementalCache'),
            cacheLifeProfiles: null == (n = d.experimental) ? void 0 : n.cacheLife,
            isRevalidate: $,
            waitUntil: r.waitUntil,
            onClose: (e) => {
              t.on('close', e);
            },
            onAfterTaskError: void 0,
            onInstrumentationRequestError: (t, r, n) => c0.onRequestError(e, t, n, m),
          },
          sharedContext: { buildId: l },
        },
        I = new eq(e),
        P = new eW(t),
        N = eP.fromNodeNextRequest(
          I,
          (function (e) {
            let { errored: t, destroyed: r } = e;
            if (t || r) return AbortSignal.abort(t ?? new ek());
            let { signal: n } = eI(e);
            return n;
          })(t)
        );
      try {
        let n = async (r) =>
            c0.handle(N, k).finally(() => {
              if (!r) return;
              r.setAttributes({ 'http.status_code': t.statusCode, 'next.rsc': !1 });
              let n = S.getRootSpanAttributes();
              if (!n) return;
              if (n.get('next.span_type') !== s.handleRequest)
                return void console.warn(
                  `Unexpected root span type '${n.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`
                );
              let i = n.get('next.route');
              if (i) {
                let e = `${w} ${i}`;
                (r.setAttributes({ 'next.route': i, 'http.route': i, 'next.span_name': e }),
                  r.updateName(e));
              } else r.updateName(`${w} ${e.url}`);
            }),
          i = async (i) => {
            var s, u;
            let l = async ({ previousCacheEntry: o }) => {
                try {
                  if (!eo(e, 'minimalMode') && g && h && !o)
                    return (
                      (t.statusCode = 404),
                      t.setHeader('x-nextjs-cache', 'REVALIDATED'),
                      t.end('This page could not be found'),
                      null
                    );
                  let a = await n(i);
                  e.fetchMetrics = k.renderOpts.fetchMetrics;
                  let s = k.renderOpts.pendingWaitUntil;
                  s && r.waitUntil && (r.waitUntil(s), (s = void 0));
                  let u = k.renderOpts.collectedTags;
                  if (!_) return (await eJ(I, P, a, k.renderOpts.pendingWaitUntil), null);
                  {
                    let e = await a.blob(),
                      t = el(a.headers);
                    (u && (t[D] = u), !t['content-type'] && e.type && (t['content-type'] = e.type));
                    let r =
                        void 0 !== k.renderOpts.collectedRevalidate &&
                        !(k.renderOpts.collectedRevalidate >= 0xfffffffe) &&
                        k.renderOpts.collectedRevalidate,
                      n =
                        void 0 === k.renderOpts.collectedExpire ||
                        k.renderOpts.collectedExpire >= 0xfffffffe
                          ? void 0
                          : k.renderOpts.collectedExpire;
                    return {
                      value: {
                        kind: Y.APP_ROUTE,
                        status: a.status,
                        body: Buffer.from(await e.arrayBuffer()),
                        headers: t,
                      },
                      cacheControl: { revalidate: r, expire: n },
                    };
                  }
                } catch (t) {
                  throw (
                    (null == o ? void 0 : o.isStale) &&
                      (await c0.onRequestError(
                        e,
                        t,
                        {
                          routerKind: 'App Router',
                          routePath: a,
                          routeType: 'route',
                          revalidateReason: eH({ isRevalidate: $, isOnDemandRevalidate: g }),
                        },
                        m
                      )),
                    t
                  );
                }
              },
              c = await c0.handleResponse({
                req: e,
                nextConfig: d,
                cacheKey: y,
                routeKind: o.APP_ROUTE,
                isFallback: !1,
                prerenderManifest: p,
                isRoutePPREnabled: !1,
                isOnDemandRevalidate: g,
                revalidateOnlyGenerated: h,
                responseGenerator: l,
                waitUntil: r.waitUntil,
              });
            if (!_) return null;
            if ((null == c || null == (s = c.value) ? void 0 : s.kind) !== Y.APP_ROUTE)
              throw Object.defineProperty(
                Error(
                  `Invariant: app-route received invalid cache entry ${null == c || null == (u = c.value) ? void 0 : u.kind}`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E701', enumerable: !1, configurable: !0 }
              );
            (eo(e, 'minimalMode') ||
              t.setHeader(
                'x-nextjs-cache',
                g ? 'REVALIDATED' : c.isMiss ? 'MISS' : c.isStale ? 'STALE' : 'HIT'
              ),
              f &&
                t.setHeader(
                  'Cache-Control',
                  'private, no-cache, no-store, max-age=0, must-revalidate'
                ));
            let v = es(c.value.headers);
            return (
              (eo(e, 'minimalMode') && _) || v.delete(D),
              !c.cacheControl ||
                t.getHeader('Cache-Control') ||
                v.get('Cache-Control') ||
                v.set(
                  'Cache-Control',
                  (function ({ revalidate: e, expire: t }) {
                    let r =
                      'number' == typeof e && void 0 !== t && e < t
                        ? `, stale-while-revalidate=${t - e}`
                        : '';
                    return 0 === e
                      ? 'private, no-cache, no-store, max-age=0, must-revalidate'
                      : 'number' == typeof e
                        ? `s-maxage=${e}${r}`
                        : `s-maxage=31536000${r}`;
                  })(c.cacheControl)
                ),
              await eJ(
                I,
                P,
                new Response(c.value.body, { headers: v, status: c.value.status || 200 })
              ),
              null
            );
          };
        E
          ? await i(E)
          : await S.withPropagatedContext(e.headers, () =>
              S.trace(
                s.handleRequest,
                {
                  spanName: `${w} ${e.url}`,
                  kind: O.SERVER,
                  attributes: { 'http.method': w, 'http.target': e.url },
                },
                i
              )
            );
      } catch (t) {
        if (
          (E ||
            t instanceof eK.NoFallbackError ||
            (await c0.onRequestError(e, t, {
              routerKind: 'App Router',
              routePath: b,
              routeType: 'route',
              revalidateReason: eH({ isRevalidate: $, isOnDemandRevalidate: g }),
            })),
          _)
        )
          throw t;
        return (await eJ(I, P, new Response(null, { status: 500 })), null);
      }
    }
  },
];

//# sourceMappingURL=node_modules__pnpm_a3cdb84f._.js.map
